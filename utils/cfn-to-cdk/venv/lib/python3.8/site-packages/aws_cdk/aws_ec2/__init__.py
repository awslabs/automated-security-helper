'''
# Amazon EC2 Construct Library

The `@aws-cdk/aws-ec2` package contains primitives for setting up networking and
instances.

```python
import aws_cdk.aws_ec2 as ec2
```

## VPC

Most projects need a Virtual Private Cloud to provide security by means of
network partitioning. This is achieved by creating an instance of
`Vpc`:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "VPC")
```

All default constructs require EC2 instances to be launched inside a VPC, so
you should generally start by defining a VPC whenever you need to launch
instances for your project.

### Subnet Types

A VPC consists of one or more subnets that instances can be placed into. CDK
distinguishes three different subnet types:

* **Public (`SubnetType.PUBLIC`)** - public subnets connect directly to the Internet using an
  Internet Gateway. If you want your instances to have a public IP address
  and be directly reachable from the Internet, you must place them in a
  public subnet.
* **Private with Internet Access (`SubnetType.PRIVATE_WITH_NAT`)** - instances in private subnets are not directly routable from the
  Internet, and connect out to the Internet via a NAT gateway. By default, a
  NAT gateway is created in every public subnet for maximum availability. Be
  aware that you will be charged for NAT gateways.
* **Isolated (`SubnetType.PRIVATE_ISOLATED`)** - isolated subnets do not route from or to the Internet, and
  as such do not require NAT gateways. They can only connect to or be
  connected to from other instances in the same VPC. A default VPC configuration
  will not include isolated subnets,

A default VPC configuration will create public and **private** subnets. However, if
`natGateways:0` **and** `subnetConfiguration` is undefined, default VPC configuration
will create public and **isolated** subnets. See [*Advanced Subnet Configuration*](#advanced-subnet-configuration)
below for information on how to change the default subnet configuration.

Constructs using the VPC will "launch instances" (or more accurately, create
Elastic Network Interfaces) into one or more of the subnets. They all accept
a property called `subnetSelection` (sometimes called `vpcSubnets`) to allow
you to select in what subnet to place the ENIs, usually defaulting to
*private* subnets if the property is omitted.

If you would like to save on the cost of NAT gateways, you can use
*isolated* subnets instead of *private* subnets (as described in Advanced
*Subnet Configuration*). If you need private instances to have
internet connectivity, another option is to reduce the number of NAT gateways
created by setting the `natGateways` property to a lower value (the default
is one NAT gateway per availability zone). Be aware that this may have
availability implications for your application.

[Read more about
subnets](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html).

### Control over availability zones

By default, a VPC will spread over at most 3 Availability Zones available to
it. To change the number of Availability Zones that the VPC will spread over,
specify the `maxAzs` property when defining it.

The number of Availability Zones that are available depends on the *region*
and *account* of the Stack containing the VPC. If the [region and account are
specified](https://docs.aws.amazon.com/cdk/latest/guide/environments.html) on
the Stack, the CLI will [look up the existing Availability
Zones](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#using-regions-availability-zones-describe)
and get an accurate count. If region and account are not specified, the stack
could be deployed anywhere and it will have to make a safe choice, limiting
itself to 2 Availability Zones.

Therefore, to get the VPC to spread over 3 or more availability zones, you
must specify the environment where the stack will be deployed.

You can gain full control over the availability zones selection strategy by overriding the Stack's [`get availabilityZones()`](https://github.com/aws/aws-cdk/blob/master/packages/@aws-cdk/core/lib/stack.ts) method:

```text
// This example is only available in TypeScript

class MyStack extends Stack {

  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // ...
  }

  get availabilityZones(): string[] {
    return ['us-west-2a', 'us-west-2b'];
  }

}
```

Note that overriding the `get availabilityZones()` method will override the default behavior for all constructs defined within the Stack.

### Choosing subnets for resources

When creating resources that create Elastic Network Interfaces (such as
databases or instances), there is an option to choose which subnets to place
them in. For example, a VPC endpoint by default is placed into a subnet in
every availability zone, but you can override which subnets to use. The property
is typically called one of `subnets`, `vpcSubnets` or `subnetSelection`.

The example below will place the endpoint into two AZs (`us-east-1a` and `us-east-1c`),
in Isolated subnets:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
    vpc=vpc,
    service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
    subnets=ec2.SubnetSelection(
        subnet_type=ec2.SubnetType.ISOLATED,
        availability_zones=["us-east-1a", "us-east-1c"]
    )
)
```

You can also specify specific subnet objects for granular control:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc
# subnet1: ec2.Subnet
# subnet2: ec2.Subnet


ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
    vpc=vpc,
    service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
    subnets=ec2.SubnetSelection(
        subnets=[subnet1, subnet2]
    )
)
```

Which subnets are selected is evaluated as follows:

* `subnets`: if specific subnet objects are supplied, these are selected, and no other
  logic is used.
* `subnetType`/`subnetGroupName`: otherwise, a set of subnets is selected by
  supplying either type or name:

  * `subnetType` will select all subnets of the given type.
  * `subnetGroupName` should be used to distinguish between multiple groups of subnets of
    the same type (for example, you may want to separate your application instances and your
    RDS instances into two distinct groups of Isolated subnets).
  * If neither are given, the first available subnet group of a given type that
    exists in the VPC will be used, in this order: Private, then Isolated, then Public.
    In short: by default ENIs will preferentially be placed in subnets not connected to
    the Internet.
* `availabilityZones`/`onePerAz`: finally, some availability-zone based filtering may be done.
  This filtering by availability zones will only be possible if the VPC has been created or
  looked up in a non-environment agnostic stack (so account and region have been set and
  availability zones have been looked up).

  * `availabilityZones`: only the specific subnets from the selected subnet groups that are
    in the given availability zones will be returned.
  * `onePerAz`: per availability zone, a maximum of one subnet will be returned (Useful for resource
    types that do not allow creating two ENIs in the same availability zone).
* `subnetFilters`: additional filtering on subnets using any number of user-provided filters which
  extend `SubnetFilter`.  The following methods on the `SubnetFilter` class can be used to create
  a filter:

  * `byIds`: chooses subnets from a list of ids
  * `availabilityZones`: chooses subnets in the provided list of availability zones
  * `onePerAz`: chooses at most one subnet per availability zone
  * `containsIpAddresses`: chooses a subnet which contains *any* of the listed ip addresses
  * `byCidrMask`: chooses subnets that have the provided CIDR netmask

### Using NAT instances

By default, the `Vpc` construct will create NAT *gateways* for you, which
are managed by AWS. If you would prefer to use your own managed NAT
*instances* instead, specify a different value for the `natGatewayProvider`
property, as follows:

```python
# Configure the `natGatewayProvider` when defining a Vpc
nat_gateway_provider = ec2.NatProvider.instance(
    instance_type=ec2.InstanceType("t3.small")
)

vpc = ec2.Vpc(self, "MyVpc",
    nat_gateway_provider=nat_gateway_provider,

    # The 'natGateways' parameter now controls the number of NAT instances
    nat_gateways=2
)
```

The construct will automatically search for the most recent NAT gateway AMI.
If you prefer to use a custom AMI, use `machineImage: MachineImage.genericLinux({ ... })` and configure the right AMI ID for the
regions you want to deploy to.

By default, the NAT instances will route all traffic. To control what traffic
gets routed, pass `allowAllTraffic: false` and access the
`NatInstanceProvider.connections` member after having passed it to the VPC:

```python
# Example automatically generated from non-compiling source. May contain errors.
# instance_type: ec2.InstanceType


provider = ec2.NatProvider.instance(
    instance_type=instance_type,
    allow_all_traffic=False
)
ec2.Vpc(self, "TheVPC",
    nat_gateway_provider=provider
)
provider.connections.allow_from(ec2.Peer.ipv4("1.2.3.4/8"), ec2.Port.tcp(80))
```

### Advanced Subnet Configuration

If the default VPC configuration (public and private subnets spanning the
size of the VPC) don't suffice for you, you can configure what subnets to
create by specifying the `subnetConfiguration` property. It allows you
to configure the number and size of all subnets. Specifying an advanced
subnet configuration could look like this:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "TheVPC",
    # 'cidr' configures the IP range and size of the entire VPC.
    # The IP space will be divided over the configured subnets.
    cidr="10.0.0.0/21",

    # 'maxAzs' configures the maximum number of availability zones to use
    max_azs=3,

    # 'subnetConfiguration' specifies the "subnet groups" to create.
    # Every subnet group will have a subnet for each AZ, so this
    # configuration will create `3 groups Ã— 3 AZs = 9` subnets.
    subnet_configuration=[ec2.SubnetConfiguration(
        # 'subnetType' controls Internet access, as described above.
        subnet_type=ec2.SubnetType.PUBLIC,

        # 'name' is used to name this particular subnet group. You will have to
        # use the name for subnet selection if you have more than one subnet
        # group of the same type.
        name="Ingress",

        # 'cidrMask' specifies the IP addresses in the range of of individual
        # subnets in the group. Each of the subnets in this group will contain
        # `2^(32 address bits - 24 subnet bits) - 2 reserved addresses = 254`
        # usable IP addresses.
        #
        # If 'cidrMask' is left out the available address space is evenly
        # divided across the remaining subnet groups.
        cidr_mask=24
    ), ec2.SubnetConfiguration(
        cidr_mask=24,
        name="Application",
        subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
    ), ec2.SubnetConfiguration(
        cidr_mask=28,
        name="Database",
        subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,

        # 'reserved' can be used to reserve IP address space. No resources will
        # be created for this subnet, but the IP range will be kept available for
        # future creation of this subnet, or even for future subdivision.
        reserved=True
    )
    ]
)
```

The example above is one possible configuration, but the user can use the
constructs above to implement many other network configurations.

The `Vpc` from the above configuration in a Region with three
availability zones will be the following:

Subnet Name       |Type      |IP Block      |AZ|Features
------------------|----------|--------------|--|--------
IngressSubnet1    |`PUBLIC`  |`10.0.0.0/24` |#1|NAT Gateway
IngressSubnet2    |`PUBLIC`  |`10.0.1.0/24` |#2|NAT Gateway
IngressSubnet3    |`PUBLIC`  |`10.0.2.0/24` |#3|NAT Gateway
ApplicationSubnet1|`PRIVATE` |`10.0.3.0/24` |#1|Route to NAT in IngressSubnet1
ApplicationSubnet2|`PRIVATE` |`10.0.4.0/24` |#2|Route to NAT in IngressSubnet2
ApplicationSubnet3|`PRIVATE` |`10.0.5.0/24` |#3|Route to NAT in IngressSubnet3
DatabaseSubnet1   |`ISOLATED`|`10.0.6.0/28` |#1|Only routes within the VPC
DatabaseSubnet2   |`ISOLATED`|`10.0.6.16/28`|#2|Only routes within the VPC
DatabaseSubnet3   |`ISOLATED`|`10.0.6.32/28`|#3|Only routes within the VPC

### Accessing the Internet Gateway

If you need access to the internet gateway, you can get its ID like so:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


igw_id = vpc.internet_gateway_id
```

For a VPC with only `ISOLATED` subnets, this value will be undefined.

This is only supported for VPCs created in the stack - currently you're
unable to get the ID for imported VPCs. To do that you'd have to specifically
look up the Internet Gateway by name, which would require knowing the name
beforehand.

This can be useful for configuring routing using a combination of gateways:
for more information see [Routing](#routing) below.

#### Routing

It's possible to add routes to any subnets using the `addRoute()` method. If for
example you want an isolated subnet to have a static route via the default
Internet Gateway created for the public subnet - perhaps for routing a VPN
connection - you can do so like this:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "VPC",
    subnet_configuration=[ec2.SubnetConfiguration(
        subnet_type=ec2.SubnetType.PUBLIC,
        name="Public"
    ), ec2.SubnetConfiguration(
        subnet_type=ec2.SubnetType.ISOLATED,
        name="Isolated"
    )]
)

(vpc.isolated_subnets[0]).add_route("StaticRoute",
    router_id=vpc.internet_gateway_id,
    router_type=ec2.RouterType.GATEWAY,
    destination_cidr_block="8.8.8.8/32"
)
```

*Note that we cast to `Subnet` here because the list of subnets only returns an
`ISubnet`.*

### Reserving subnet IP space

There are situations where the IP space for a subnet or number of subnets
will need to be reserved. This is useful in situations where subnets would
need to be added after the vpc is originally deployed, without causing IP
renumbering for existing subnets. The IP space for a subnet may be reserved
by setting the `reserved` subnetConfiguration property to true, as shown
below:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "TheVPC",
    nat_gateways=1,
    subnet_configuration=[ec2.SubnetConfiguration(
        cidr_mask=26,
        name="Public",
        subnet_type=ec2.SubnetType.PUBLIC
    ), ec2.SubnetConfiguration(
        cidr_mask=26,
        name="Application1",
        subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
    ), ec2.SubnetConfiguration(
        cidr_mask=26,
        name="Application2",
        subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT,
        reserved=True
    ), ec2.SubnetConfiguration(
        cidr_mask=27,
        name="Database",
        subnet_type=ec2.SubnetType.ISOLATED
    )
    ]
)
```

In the example above, the subnet for Application2 is not actually provisioned
but its IP space is still reserved. If in the future this subnet needs to be
provisioned, then the `reserved: true` property should be removed. Reserving
parts of the IP space prevents the other subnets from getting renumbered.

### Sharing VPCs between stacks

If you are creating multiple `Stack`s inside the same CDK application, you
can reuse a VPC defined in one Stack in another by simply passing the VPC
instance around:

```python
#
# Stack1 creates the VPC
#
class Stack1(cdk.Stack):

    def __init__(self, scope, id, *, description=None, env=None, stackName=None, tags=None, synthesizer=None, terminationProtection=None, analyticsReporting=None):
        super().__init__(scope, id, description=description, env=env, stackName=stackName, tags=tags, synthesizer=synthesizer, terminationProtection=terminationProtection, analyticsReporting=analyticsReporting)

        self.vpc = ec2.Vpc(self, "VPC")

#
# Stack2 consumes the VPC
#
class Stack2(cdk.Stack):
    def __init__(self, scope, id, *, vpc, description=None, env=None, stackName=None, tags=None, synthesizer=None, terminationProtection=None, analyticsReporting=None):
        super().__init__(scope, id, vpc=vpc, description=description, env=env, stackName=stackName, tags=tags, synthesizer=synthesizer, terminationProtection=terminationProtection, analyticsReporting=analyticsReporting)

        # Pass the VPC to a construct that needs it
        ConstructThatTakesAVpc(self, "Construct",
            vpc=vpc
        )

stack1 = Stack1(app, "Stack1")
stack2 = Stack2(app, "Stack2",
    vpc=stack1.vpc
)
```

### Importing an existing VPC

If your VPC is created outside your CDK app, you can use `Vpc.fromLookup()`.
The CDK CLI will search for the specified VPC in the the stack's region and
account, and import the subnet configuration. Looking up can be done by VPC
ID, but more flexibly by searching for a specific tag on the VPC.

Subnet types will be determined from the `aws-cdk:subnet-type` tag on the
subnet if it exists, or the presence of a route to an Internet Gateway
otherwise. Subnet names will be determined from the `aws-cdk:subnet-name` tag
on the subnet if it exists, or will mirror the subnet type otherwise (i.e.
a public subnet will have the name `"Public"`).

The result of the `Vpc.fromLookup()` operation will be written to a file
called `cdk.context.json`. You must commit this file to source control so
that the lookup values are available in non-privileged environments such
as CI build steps, and to ensure your template builds are repeatable.

Here's how `Vpc.fromLookup()` can be used:

```python
vpc = ec2.Vpc.from_lookup(stack, "VPC",
    # This imports the default VPC but you can also
    # specify a 'vpcName' or 'tags'.
    is_default=True
)
```

`Vpc.fromLookup` is the recommended way to import VPCs. If for whatever
reason you do not want to use the context mechanism to look up a VPC at
synthesis time, you can also use `Vpc.fromVpcAttributes`. This has the
following limitations:

* Every subnet group in the VPC must have a subnet in each availability zone
  (for example, each AZ must have both a public and private subnet). Asymmetric
  VPCs are not supported.
* All VpcId, SubnetId, RouteTableId, ... parameters must either be known at
  synthesis time, or they must come from deploy-time list parameters whose
  deploy-time lengths are known at synthesis time.

Using `Vpc.fromVpcAttributes()` looks like this:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc.from_vpc_attributes(self, "VPC",
    vpc_id="vpc-1234",
    availability_zones=["us-east-1a", "us-east-1b"],

    # Either pass literals for all IDs
    public_subnet_ids=["s-12345", "s-67890"],

    # OR: import a list of known length
    private_subnet_ids=Fn.import_list_value("PrivateSubnetIds", 2),

    # OR: split an imported string to a list of known length
    isolated_subnet_ids=Fn.split(",", ssm.StringParameter.value_for_string_parameter(self, "MyParameter"), 2)
)
```

## Allowing Connections

In AWS, all network traffic in and out of **Elastic Network Interfaces** (ENIs)
is controlled by **Security Groups**. You can think of Security Groups as a
firewall with a set of rules. By default, Security Groups allow no incoming
(ingress) traffic and all outgoing (egress) traffic. You can add ingress rules
to them to allow incoming traffic streams. To exert fine-grained control over
egress traffic, set `allowAllOutbound: false` on the `SecurityGroup`, after
which you can add egress traffic rules.

You can manipulate Security Groups directly:

```python
my_security_group = ec2.SecurityGroup(self, "SecurityGroup",
    vpc=vpc,
    description="Allow ssh access to ec2 instances",
    allow_all_outbound=True
)
my_security_group.add_ingress_rule(ec2.Peer.any_ipv4(), ec2.Port.tcp(22), "allow ssh access from the world")
```

All constructs that create ENIs on your behalf (typically constructs that create
EC2 instances or other VPC-connected resources) will all have security groups
automatically assigned. Those constructs have an attribute called
**connections**, which is an object that makes it convenient to update the
security groups. If you want to allow connections between two constructs that
have security groups, you have to add an **Egress** rule to one Security Group,
and an **Ingress** rule to the other. The connections object will automatically
take care of this for you:

```python
# Example automatically generated from non-compiling source. May contain errors.
# load_balancer: elbv2.ApplicationLoadBalancer
# app_fleet: autoscaling.AutoScalingGroup
# db_fleet: autoscaling.AutoScalingGroup


# Allow connections from anywhere
load_balancer.connections.allow_from_any_ipv4(ec2.Port.tcp(443), "Allow inbound HTTPS")

# The same, but an explicit IP address
load_balancer.connections.allow_from(ec2.Peer.ipv4("1.2.3.4/32"), ec2.Port.tcp(443), "Allow inbound HTTPS")

# Allow connection between AutoScalingGroups
app_fleet.connections.allow_to(db_fleet, ec2.Port.tcp(443), "App can call database")
```

### Connection Peers

There are various classes that implement the connection peer part:

```python
# Example automatically generated from non-compiling source. May contain errors.
# app_fleet: autoscaling.AutoScalingGroup
# db_fleet: autoscaling.AutoScalingGroup


# Simple connection peers
peer = ec2.Peer.ipv4("10.0.0.0/16")
peer = ec2.Peer.any_ipv4()
peer = ec2.Peer.ipv6("::0/0")
peer = ec2.Peer.any_ipv6()
peer = ec2.Peer.prefix_list("pl-12345")
app_fleet.connections.allow_to(peer, ec2.Port.tcp(443), "Allow outbound HTTPS")
```

Any object that has a security group can itself be used as a connection peer:

```python
# Example automatically generated from non-compiling source. May contain errors.
# fleet1: autoscaling.AutoScalingGroup
# fleet2: autoscaling.AutoScalingGroup
# app_fleet: autoscaling.AutoScalingGroup


# These automatically create appropriate ingress and egress rules in both security groups
fleet1.connections.allow_to(fleet2, ec2.Port.tcp(80), "Allow between fleets")

app_fleet.connections.allow_from_any_ipv4(ec2.Port.tcp(80), "Allow from load balancer")
```

### Port Ranges

The connections that are allowed are specified by port ranges. A number of classes provide
the connection specifier:

```python
# Example automatically generated from non-compiling source. May contain errors.
ec2.Port.tcp(80)
ec2.Port.tcp_range(60000, 65535)
ec2.Port.all_tcp()
ec2.Port.all_traffic()
```

> NOTE: This set is not complete yet; for example, there is no library support for ICMP at the moment.
> However, you can write your own classes to implement those.

### Default Ports

Some Constructs have default ports associated with them. For example, the
listener of a load balancer does (it's the public port), or instances of an
RDS database (it's the port the database is accepting connections on).

If the object you're calling the peering method on has a default port associated with it, you can call
`allowDefaultPortFrom()` and omit the port specifier. If the argument has an associated default port, call
`allowDefaultPortTo()`.

For example:

```python
# Example automatically generated from non-compiling source. May contain errors.
# listener: elbv2.ApplicationListener
# app_fleet: autoscaling.AutoScalingGroup
# rds_database: rds.DatabaseCluster


# Port implicit in listener
listener.connections.allow_default_port_from_any_ipv4("Allow public")

# Port implicit in peer
app_fleet.connections.allow_default_port_to(rds_database, "Fleet can access database")
```

### Security group rules

By default, security group wills be added inline to the security group in the output cloud formation
template, if applicable.  This includes any static rules by ip address and port range.  This
optimization helps to minimize the size of the template.

In some environments this is not desirable, for example if your security group access is controlled
via tags. You can disable inline rules per security group or globally via the context key
`@aws-cdk/aws-ec2.securityGroupDisableInlineRules`.

```python
my_security_group_without_inline_rules = ec2.SecurityGroup(self, "SecurityGroup",
    vpc=vpc,
    description="Allow ssh access to ec2 instances",
    allow_all_outbound=True,
    disable_inline_rules=True
)
# This will add the rule as an external cloud formation construct
my_security_group_without_inline_rules.add_ingress_rule(ec2.Peer.any_ipv4(), ec2.Port.tcp(22), "allow ssh access from the world")
```

### Importing an existing security group

If you know the ID and the configuration of the security group to import, you can use `SecurityGroup.fromSecurityGroupId`:

```python
# Example automatically generated from non-compiling source. May contain errors.
sg = ec2.SecurityGroup.from_security_group_id(self, "SecurityGroupImport", "sg-1234",
    allow_all_outbound=True
)
```

Alternatively, use lookup methods to import security groups if you do not know the ID or the configuration details. Method `SecurityGroup.fromLookupByName` looks up a security group if the secruity group ID is unknown.

```python
sg = ec2.SecurityGroup.from_lookup_by_name(self, "SecurityGroupLookup", "security-group-name", vpc)
```

If the security group ID is known and configuration details are unknown, use method `SecurityGroup.fromLookupById` instead. This method will lookup property `allowAllOutbound` from the current configuration of the security group.

```python
# Example automatically generated from non-compiling source. May contain errors.
sg = ec2.SecurityGroup.from_lookup_by_id(self, "SecurityGroupLookup", "sg-1234")
```

The result of `SecurityGroup.fromLookupByName` and `SecurityGroup.fromLookupById` operations will be written to a file called `cdk.context.json`. You must commit this file to source control so that the lookup values are available in non-privileged environments such as CI build steps, and to ensure your template builds are repeatable.

## Machine Images (AMIs)

AMIs control the OS that gets launched when you start your EC2 instance. The EC2
library contains constructs to select the AMI you want to use.

Depending on the type of AMI, you select it a different way. Here are some
examples of things you might want to use:

```python
# Pick the right Amazon Linux edition. All arguments shown are optional
# and will default to these values when omitted.
amzn_linux = ec2.MachineImage.latest_amazon_linux(
    generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
    edition=ec2.AmazonLinuxEdition.STANDARD,
    virtualization=ec2.AmazonLinuxVirt.HVM,
    storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
    cpu_type=ec2.AmazonLinuxCpuType.X86_64
)

# Pick a Windows edition to use
windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)

# Read AMI id from SSM parameter store
ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)

# Look up the most recent image matching a set of AMI filters.
# In this case, look up the NAT instance AMI, by using a wildcard
# in the 'name' field:
nat_ami = ec2.MachineImage.lookup(
    name="amzn-ami-vpc-nat-*",
    owners=["amazon"]
)

# For other custom (Linux) images, instantiate a `GenericLinuxImage` with
# a map giving the AMI to in for each region:
linux = ec2.MachineImage.generic_linux({
    "us-east-1": "ami-97785bed",
    "eu-west-1": "ami-12345678"
})

# For other custom (Windows) images, instantiate a `GenericWindowsImage` with
# a map giving the AMI to in for each region:
generic_windows = ec2.MachineImage.generic_windows({
    "us-east-1": "ami-97785bed",
    "eu-west-1": "ami-12345678"
})
```

> NOTE: The AMIs selected by `MachineImage.lookup()` will be cached in
> `cdk.context.json`, so that your AutoScalingGroup instances aren't replaced while
> you are making unrelated changes to your CDK app.
>
> To query for the latest AMI again, remove the relevant cache entry from
> `cdk.context.json`, or use the `cdk context` command. For more information, see
> [Runtime Context](https://docs.aws.amazon.com/cdk/latest/guide/context.html) in the CDK
> developer guide.
>
> `MachineImage.genericLinux()`, `MachineImage.genericWindows()` will use `CfnMapping` in
> an agnostic stack.

## Special VPC configurations

### VPN connections to a VPC

Create your VPC with VPN connections by specifying the `vpnConnections` props (keys are construct `id`s):

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "MyVpc",
    vpn_connections={
        "dynamic": ec2.VpnConnectionOptions( # Dynamic routing (BGP)
            ip="1.2.3.4"),
        "static": ec2.VpnConnectionOptions( # Static routing
            ip="4.5.6.7",
            static_routes=["192.168.10.0/24", "192.168.20.0/24"
            ])
    }
)
```

To create a VPC that can accept VPN connections, set `vpnGateway` to `true`:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "MyVpc",
    vpn_gateway=True
)
```

VPN connections can then be added:

```python
vpc.add_vpn_connection("Dynamic",
    ip="1.2.3.4"
)
```

By default, routes will be propagated on the route tables associated with the private subnets. If no
private subnets exist, isolated subnets are used. If no isolated subnets exist, public subnets are
used. Use the `Vpc` property `vpnRoutePropagation` to customize this behavior.

VPN connections expose [metrics (cloudwatch.Metric)](https://github.com/aws/aws-cdk/blob/master/packages/%40aws-cdk/aws-cloudwatch/README.md) across all tunnels in the account/region and per connection:

```python
# Across all tunnels in the account/region
all_data_out = ec2.VpnConnection.metric_all_tunnel_data_out()

# For a specific vpn connection
vpn_connection = vpc.add_vpn_connection("Dynamic",
    ip="1.2.3.4"
)
state = vpn_connection.metric_tunnel_state()
```

### VPC endpoints

A VPC endpoint enables you to privately connect your VPC to supported AWS services and VPC endpoint services powered by PrivateLink without requiring an internet gateway, NAT device, VPN connection, or AWS Direct Connect connection. Instances in your VPC do not require public IP addresses to communicate with resources in the service. Traffic between your VPC and the other service does not leave the Amazon network.

Endpoints are virtual devices. They are horizontally scaled, redundant, and highly available VPC components that allow communication between instances in your VPC and services without imposing availability risks or bandwidth constraints on your network traffic.

```python
# Add gateway endpoints when creating the VPC
vpc = ec2.Vpc(self, "MyVpc",
    gateway_endpoints={
        "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(
            service=ec2.GatewayVpcEndpointAwsService.S3
        )
    }
)

# Alternatively gateway endpoints can be added on the VPC
dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",
    service=ec2.GatewayVpcEndpointAwsService.DYNAMODB
)

# This allows to customize the endpoint policy
dynamo_db_endpoint.add_to_policy(
    iam.PolicyStatement( # Restrict to listing and describing tables
        principals=[iam.AnyPrincipal()],
        actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],
        resources=["*"]))

# Add an interface endpoint
vpc.add_interface_endpoint("EcrDockerEndpoint",
    service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER
)
```

By default, CDK will place a VPC endpoint in one subnet per AZ. If you wish to override the AZs CDK places the VPC endpoint in,
use the `subnets` parameter as follows:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
    vpc=vpc,
    service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
    # Choose which availability zones to place the VPC endpoint in, based on
    # available AZs
    subnets=ec2.SubnetSelection(
        availability_zones=["us-east-1a", "us-east-1c"]
    )
)
```

Per the [AWS documentation](https://aws.amazon.com/premiumsupport/knowledge-center/interface-endpoint-availability-zone/), not all
VPC endpoint services are available in all AZs. If you specify the parameter `lookupSupportedAzs`, CDK attempts to discover which
AZs an endpoint service is available in, and will ensure the VPC endpoint is not placed in a subnet that doesn't match those AZs.
These AZs will be stored in cdk.context.json.

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
    vpc=vpc,
    service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
    # Choose which availability zones to place the VPC endpoint in, based on
    # available AZs
    lookup_supported_azs=True
)
```

Pre-defined AWS services are defined in the [InterfaceVpcEndpointAwsService](lib/vpc-endpoint.ts) class, and can be used to
create VPC endpoints without having to configure name, ports, etc. For example, a Keyspaces endpoint can be created for
use in your VPC:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
    vpc=vpc,
    service=ec2.InterfaceVpcEndpointAwsService.KEYSPACES
)
```

#### Security groups for interface VPC endpoints

By default, interface VPC endpoints create a new security group and traffic is **not**
automatically allowed from the VPC CIDR.

Use the `connections` object to allow traffic to flow to the endpoint:

```python
# Example automatically generated from non-compiling source. May contain errors.
# my_endpoint: ec2.InterfaceVpcEndpoint


my_endpoint.connections.allow_default_port_from_any_ipv4()
```

Alternatively, existing security groups can be used by specifying the `securityGroups` prop.

### VPC endpoint services

A VPC endpoint service enables you to expose a Network Load Balancer(s) as a provider service to consumers, who connect to your service over a VPC endpoint. You can restrict access to your service via allowed principals (anything that extends ArnPrincipal), and require that new connections be manually accepted.

```python
# Example automatically generated from non-compiling source. May contain errors.
# network_load_balancer1: elbv2.NetworkLoadBalancer
# network_load_balancer2: elbv2.NetworkLoadBalancer


ec2.VpcEndpointService(self, "EndpointService",
    vpc_endpoint_service_load_balancers=[network_load_balancer1, network_load_balancer2],
    acceptance_required=True,
    allowed_principals=[iam.ArnPrincipal("arn:aws:iam::123456789012:root")]
)
```

Endpoint services support private DNS, which makes it easier for clients to connect to your service by automatically setting up DNS in their VPC.
You can enable private DNS on an endpoint service like so:

```python
# Example automatically generated from non-compiling source. May contain errors.
from aws_cdk.aws_route53 import HostedZone, VpcEndpointServiceDomainName
# zone: HostedZone
# vpces: ec2.VpcEndpointService


VpcEndpointServiceDomainName(self, "EndpointDomain",
    endpoint_service=vpces,
    domain_name="my-stuff.aws-cdk.dev",
    public_hosted_zone=zone
)
```

Note: The domain name must be owned (registered through Route53) by the account the endpoint service is in, or delegated to the account.
The VpcEndpointServiceDomainName will handle the AWS side of domain verification, the process for which can be found
[here](https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-services-dns-validation.html)

### Client VPN endpoint

AWS Client VPN is a managed client-based VPN service that enables you to securely access your AWS
resources and resources in your on-premises network. With Client VPN, you can access your resources
from any location using an OpenVPN-based VPN client.

Use the `addClientVpnEndpoint()` method to add a client VPN endpoint to a VPC:

```python
vpc.add_client_vpn_endpoint("Endpoint",
    cidr="10.100.0.0/16",
    server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
    # Mutual authentication
    client_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/client-certificate-id",
    # User-based authentication
    user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider)
)
```

The endpoint must use at least one [authentication method](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/client-authentication.html):

* Mutual authentication with a client certificate
* User-based authentication (directory or federated)

If user-based authentication is used, the [self-service portal URL](https://docs.aws.amazon.com/vpn/latest/clientvpn-user/self-service-portal.html)
is made available via a CloudFormation output.

By default, a new security group is created, and logging is enabled. Moreover, a rule to
authorize all users to the VPC CIDR is created.

To customize authorization rules, set the `authorizeAllUsersToVpcCidr` prop to `false`
and use `addAuthorizationRule()`:

```python
endpoint = vpc.add_client_vpn_endpoint("Endpoint",
    cidr="10.100.0.0/16",
    server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
    user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),
    authorize_all_users_to_vpc_cidr=False
)

endpoint.add_authorization_rule("Rule",
    cidr="10.0.10.0/32",
    group_id="group-id"
)
```

Use `addRoute()` to configure network routes:

```python
endpoint = vpc.add_client_vpn_endpoint("Endpoint",
    cidr="10.100.0.0/16",
    server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
    user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider)
)

# Client-to-client access
endpoint.add_route("Route",
    cidr="10.100.0.0/16",
    target=ec2.ClientVpnRouteTarget.local()
)
```

Use the `connections` object of the endpoint to allow traffic to other security groups.

## Instances

You can use the `Instance` class to start up a single EC2 instance. For production setups, we recommend
you use an `AutoScalingGroup` from the `aws-autoscaling` module instead, as AutoScalingGroups will take
care of restarting your instance if it ever fails.

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc
# instance_type: ec2.InstanceType


# AWS Linux
ec2.Instance(self, "Instance1",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=ec2.AmazonLinuxImage()
)

# AWS Linux 2
ec2.Instance(self, "Instance2",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=ec2.AmazonLinuxImage(
        generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2
    )
)

# AWS Linux 2 with kernel 5.x
ec2.Instance(self, "Instance3",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=ec2.AmazonLinuxImage(
        generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,
        kernel=ec2.AmazonLinuxKernel.KERNEL5_X
    )
)

# AWS Linux 2022
ec2.Instance(self, "Instance4",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=ec2.AmazonLinuxImage(
        generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2022
    )
)
```

### Configuring Instances using CloudFormation Init (cfn-init)

CloudFormation Init allows you to configure your instances by writing files to them, installing software
packages, starting services and running arbitrary commands. By default, if any of the instance setup
commands throw an error; the deployment will fail and roll back to the previously known good state.
The following documentation also applies to `AutoScalingGroup`s.

For the full set of capabilities of this system, see the documentation for
[`AWS::CloudFormation::Init`](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-init.html).
Here is an example of applying some configuration to an instance:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc
# instance_type: ec2.InstanceType
# machine_image: ec2.IMachineImage


ec2.Instance(self, "Instance",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=machine_image,

    # Showing the most complex setup, if you have simpler requirements
    # you can use `CloudFormationInit.fromElements()`.
    init=ec2.CloudFormationInit.from_config_sets(
        config_sets={
            # Applies the configs below in this order
            "default": ["yumPreinstall", "config"]
        },
        configs={
            "yum_preinstall": ec2.InitConfig([
                # Install an Amazon Linux package using yum
                ec2.InitPackage.yum("git")
            ]),
            "config": ec2.InitConfig([
                # Create a JSON file from tokens (can also create other files)
                ec2.InitFile.from_object("/etc/stack.json", {
                    "stack_id": Stack.of(self).stack_id,
                    "stack_name": Stack.of(self).stack_name,
                    "region": Stack.of(self).region
                }),

                # Create a group and user
                ec2.InitGroup.from_name("my-group"),
                ec2.InitUser.from_name("my-user"),

                # Install an RPM from the internet
                ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
            ])
        }
    ),
    init_options=ec2.ApplyCloudFormationInitOptions(
        # Optional, which configsets to activate (['default'] by default)
        config_sets=["default"],

        # Optional, how long the installation is expected to take (5 minutes by default)
        timeout=Duration.minutes(30),

        # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
        include_url=True,

        # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
        include_role=True
    )
)
```

You can have services restarted after the init process has made changes to the system.
To do that, instantiate an `InitServiceRestartHandle` and pass it to the config elements
that need to trigger the restart and the service itself. For example, the following
config writes a config file for nginx, extracts an archive to the root directory, and then
restarts nginx so that it picks up the new config and files:

```python
# Example automatically generated from non-compiling source. May contain errors.
# my_bucket: s3.Bucket


handle = ec2.InitServiceRestartHandle()

ec2.CloudFormationInit.from_elements(
    ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
    ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
    ec2.InitService.enable("nginx",
        service_restart_handle=handle
    ))
```

### Bastion Hosts

A bastion host functions as an instance used to access servers and resources in a VPC without open up the complete VPC on a network level.
You can use bastion hosts using a standard SSH connection targeting port 22 on the host. As an alternative, you can connect the SSH connection
feature of AWS Systems Manager Session Manager, which does not need an opened security group. (https://aws.amazon.com/about-aws/whats-new/2019/07/session-manager-launches-tunneling-support-for-ssh-and-scp/)

A default bastion host for use via SSM can be configured like:

```python
host = ec2.BastionHostLinux(self, "BastionHost", vpc=vpc)
```

If you want to connect from the internet using SSH, you need to place the host into a public subnet. You can then configure allowed source hosts.

```python
host = ec2.BastionHostLinux(self, "BastionHost",
    vpc=vpc,
    subnet_selection=ec2.SubnetSelection(subnet_type=ec2.SubnetType.PUBLIC)
)
host.allow_ssh_access_from(ec2.Peer.ipv4("1.2.3.4/32"))
```

As there are no SSH public keys deployed on this machine, you need to use [EC2 Instance Connect](https://aws.amazon.com/de/blogs/compute/new-using-amazon-ec2-instance-connect-for-ssh-access-to-your-ec2-instances/)
with the command `aws ec2-instance-connect send-ssh-public-key` to provide your SSH public key.

EBS volume for the bastion host can be encrypted like:

```python
host = ec2.BastionHostLinux(self, "BastionHost",
    vpc=vpc,
    block_devices=[ec2.BlockDevice(
        device_name="EBSBastionHost",
        volume=ec2.BlockDeviceVolume.ebs(10,
            encrypted=True
        )
    )]
)
```

### Block Devices

To add EBS block device mappings, specify the `blockDevices` property. The following example sets the EBS-backed
root device (`/dev/sda1`) size to 50 GiB, and adds another EBS-backed device mapped to `/dev/sdm` that is 100 GiB in
size:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc
# instance_type: ec2.InstanceType
# machine_image: ec2.IMachineImage


ec2.Instance(self, "Instance",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=machine_image,

    # ...

    block_devices=[ec2.BlockDevice(
        device_name="/dev/sda1",
        volume=ec2.BlockDeviceVolume.ebs(50)
    ), ec2.BlockDevice(
        device_name="/dev/sdm",
        volume=ec2.BlockDeviceVolume.ebs(100)
    )
    ]
)
```

It is also possible to encrypt the block devices. In this example we will create an customer managed key encrypted EBS-backed root device:

```python
# Example automatically generated from non-compiling source. May contain errors.
from aws_cdk.aws_kms import Key

# vpc: ec2.Vpc
# instance_type: ec2.InstanceType
# machine_image: ec2.IMachineImage


kms_key = Key(self, "KmsKey")

ec2.Instance(self, "Instance",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=machine_image,

    # ...

    block_devices=[ec2.BlockDevice(
        device_name="/dev/sda1",
        volume=ec2.BlockDeviceVolume.ebs(50,
            encrypted=True,
            kms_key=kms_key
        )
    )
    ]
)
```

### Volumes

Whereas a `BlockDeviceVolume` is an EBS volume that is created and destroyed as part of the creation and destruction of a specific instance. A `Volume` is for when you want an EBS volume separate from any particular instance. A `Volume` is an EBS block device that can be attached to, or detached from, any instance at any time. Some types of `Volume`s can also be attached to multiple instances at the same time to allow you to have shared storage between those instances.

A notable restriction is that a Volume can only be attached to instances in the same availability zone as the Volume itself.

The following demonstrates how to create a 500 GiB encrypted Volume in the `us-west-2a` availability zone, and give a role the ability to attach that Volume to a specific instance:

```python
# Example automatically generated from non-compiling source. May contain errors.
# instance: ec2.Instance
# role: iam.Role


volume = ec2.Volume(self, "Volume",
    availability_zone="us-west-2a",
    size=Size.gibibytes(500),
    encrypted=True
)

volume.grant_attach_volume(role, [instance])
```

#### Instances Attaching Volumes to Themselves

If you need to grant an instance the ability to attach/detach an EBS volume to/from itself, then using `grantAttachVolume` and `grantDetachVolume` as outlined above
will lead to an unresolvable circular reference between the instance role and the instance. In this case, use `grantAttachVolumeByResourceTag` and `grantDetachVolumeByResourceTag` as follows:

```python
# Example automatically generated from non-compiling source. May contain errors.
# instance: ec2.Instance
# volume: ec2.Volume


attach_grant = volume.grant_attach_volume_by_resource_tag(instance.grant_principal, [instance])
detach_grant = volume.grant_detach_volume_by_resource_tag(instance.grant_principal, [instance])
```

#### Attaching Volumes

The Amazon EC2 documentation for
[Linux Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html) and
[Windows Instances](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ebs-volumes.html) contains information on how
to attach and detach your Volumes to/from instances, and how to format them for use.

The following is a sample skeleton of EC2 UserData that can be used to attach a Volume to the Linux instance that it is running on:

```python
# Example automatically generated from non-compiling source. May contain errors.
# instance: ec2.Instance
# volume: ec2.Volume


volume.grant_attach_volume_by_resource_tag(instance.grant_principal, [instance])
target_device = "/dev/xvdz"
instance.user_data.add_commands("TOKEN=$(curl -SsfX PUT \"http://169.254.169.254/latest/api/token\" -H \"X-aws-ec2-metadata-token-ttl-seconds: 21600\")", "INSTANCE_ID=$(curl -SsfH \"X-aws-ec2-metadata-token: $TOKEN\" http://169.254.169.254/latest/meta-data/instance-id)", f"aws --region {Stack.of(this).region} ec2 attach-volume --volume-id {volume.volumeId} --instance-id $INSTANCE_ID --device {targetDevice}", f"while ! test -e {targetDevice}; do sleep 1; done")
```

#### Tagging Volumes

You can configure [tag propagation on volume creation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation).

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc
# instance_type: ec2.InstanceType
# machine_image: ec2.IMachineImage


ec2.Instance(self, "Instance",
    vpc=vpc,
    machine_image=machine_image,
    instance_type=instance_type,
    propagate_tags_to_volume_on_creation=True
)
```

### Configuring Instance Metadata Service (IMDS)

#### Toggling IMDSv1

You can configure [EC2 Instance Metadata Service](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) options to either
allow both IMDSv1 and IMDSv2 or enforce IMDSv2 when interacting with the IMDS.

To do this for a single `Instance`, you can use the `requireImdsv2` property.
The example below demonstrates IMDSv2 being required on a single `Instance`:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc
# instance_type: ec2.InstanceType
# machine_image: ec2.IMachineImage


ec2.Instance(self, "Instance",
    vpc=vpc,
    instance_type=instance_type,
    machine_image=machine_image,

    # ...

    require_imdsv2=True
)
```

You can also use the either the `InstanceRequireImdsv2Aspect` for EC2 instances or the `LaunchTemplateRequireImdsv2Aspect` for EC2 launch templates
to apply the operation to multiple instances or launch templates, respectively.

The following example demonstrates how to use the `InstanceRequireImdsv2Aspect` to require IMDSv2 for all EC2 instances in a stack:

```python
# Example automatically generated from non-compiling source. May contain errors.
aspect = ec2.InstanceRequireImdsv2Aspect()
Aspects.of(self).add(aspect)
```

## VPC Flow Logs

VPC Flow Logs is a feature that enables you to capture information about the IP traffic going to and from network interfaces in your VPC. Flow log data can be published to Amazon CloudWatch Logs and Amazon S3. After you've created a flow log, you can retrieve and view its data in the chosen destination. ([https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)).

By default, a flow log will be created with CloudWatch Logs as the destination.

You can create a flow log like this:

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


ec2.FlowLog(self, "FlowLog",
    resource_type=ec2.FlowLogResourceType.from_vpc(vpc)
)
```

Or you can add a Flow Log to a VPC by using the addFlowLog method like this:

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "Vpc")

vpc.add_flow_log("FlowLog")
```

You can also add multiple flow logs with different destinations.

```python
# Example automatically generated from non-compiling source. May contain errors.
vpc = ec2.Vpc(self, "Vpc")

vpc.add_flow_log("FlowLogS3",
    destination=ec2.FlowLogDestination.to_s3()
)

vpc.add_flow_log("FlowLogCloudWatch",
    traffic_type=ec2.FlowLogTrafficType.REJECT
)
```

By default, the CDK will create the necessary resources for the destination. For the CloudWatch Logs destination
it will create a CloudWatch Logs Log Group as well as the IAM role with the necessary permissions to publish to
the log group. In the case of an S3 destination, it will create the S3 bucket.

If you want to customize any of the destination resources you can provide your own as part of the `destination`.

*CloudWatch Logs*

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


log_group = logs.LogGroup(self, "MyCustomLogGroup")

role = iam.Role(self, "MyCustomRole",
    assumed_by=iam.ServicePrincipal("vpc-flow-logs.amazonaws.com")
)

ec2.FlowLog(self, "FlowLog",
    resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
    destination=ec2.FlowLogDestination.to_cloud_watch_logs(log_group, role)
)
```

*S3*

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


bucket = s3.Bucket(self, "MyCustomBucket")

ec2.FlowLog(self, "FlowLog",
    resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
    destination=ec2.FlowLogDestination.to_s3(bucket)
)

ec2.FlowLog(self, "FlowLogWithKeyPrefix",
    resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
    destination=ec2.FlowLogDestination.to_s3(bucket, "prefix/")
)
```

## User Data

User data enables you to run a script when your instances start up.  In order to configure these scripts you can add commands directly to the script
or you can use the UserData's convenience functions to aid in the creation of your script.

A user data could be configured to run a script found in an asset through the following:

```python
# Example automatically generated from non-compiling source. May contain errors.
from aws_cdk.aws_s3_assets import Asset

# instance: ec2.Instance


asset = Asset(self, "Asset",
    path="./configure.sh"
)

local_path = instance.user_data.add_s3_download_command(
    bucket=asset.bucket,
    bucket_key=asset.s3_object_key,
    region="us-east-1"
)
instance.user_data.add_execute_file_command(
    file_path=local_path,
    arguments="--verbose -y"
)
asset.grant_read(instance.role)
```

### Multipart user data

In addition, to above the `MultipartUserData` can be used to change instance startup behavior. Multipart user data are composed
from separate parts forming archive. The most common parts are scripts executed during instance set-up. However, there are other
kinds, too.

The advantage of multipart archive is in flexibility when it's needed to add additional parts or to use specialized parts to
fine tune instance startup. Some services (like AWS Batch) support only `MultipartUserData`.

The parts can be executed at different moment of instance start-up and can serve a different purpose. This is controlled by `contentType` property.
For common scripts, `text/x-shellscript; charset="utf-8"` can be used as content type.

In order to create archive the `MultipartUserData` has to be instantiated. Than, user can add parts to multipart archive using `addPart`. The `MultipartBody` contains methods supporting creation of body parts.

If the very custom part is required, it can be created using `MultipartUserData.fromRawBody`, in this case full control over content type,
transfer encoding, and body properties is given to the user.

Below is an example for creating multipart user data with single body part responsible for installing `awscli` and configuring maximum size
of storage used by Docker containers:

```python
# Example automatically generated from non-compiling source. May contain errors.
boot_hook_conf = ec2.UserData.for_linux()
boot_hook_conf.add_commands("cloud-init-per once docker_options echo 'OPTIONS=\"${OPTIONS} --storage-opt dm.basesize=40G\"' >> /etc/sysconfig/docker")

setup_commands = ec2.UserData.for_linux()
setup_commands.add_commands("sudo yum install awscli && echo Packages installed ã‚‰ã¨ > /var/tmp/setup")

multipart_user_data = ec2.MultipartUserData()
# The docker has to be configured at early stage, so content type is overridden to boothook
multipart_user_data.add_part(ec2.MultipartBody.from_user_data(boot_hook_conf, "text/cloud-boothook; charset=\"us-ascii\""))
# Execute the rest of setup
multipart_user_data.add_part(ec2.MultipartBody.from_user_data(setup_commands))

ec2.LaunchTemplate(self, "",
    user_data=multipart_user_data,
    block_devices=[]
)
```

For more information see
[Specifying Multiple User Data Blocks Using a MIME Multi Part Archive](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/bootstrap_container_instance.html#multi-part_user_data)

#### Using add*Command on MultipartUserData

To use the `add*Command` methods, that are inherited from the `UserData` interface, on `MultipartUserData` you must add a part
to the `MultipartUserData` and designate it as the reciever for these methods. This is accomplished by using the `addUserDataPart()`
method on `MultipartUserData` with the `makeDefault` argument set to `true`:

```python
# Example automatically generated from non-compiling source. May contain errors.
multipart_user_data = ec2.MultipartUserData()
commands_user_data = ec2.UserData.for_linux()
multipart_user_data.add_user_data_part(commands_user_data, ec2.MultipartBody.SHELL_SCRIPT, True)

# Adding commands to the multipartUserData adds them to commandsUserData, and vice-versa.
multipart_user_data.add_commands("touch /root/multi.txt")
commands_user_data.add_commands("touch /root/userdata.txt")
```

When used on an EC2 instance, the above `multipartUserData` will create both `multi.txt` and `userdata.txt` in `/root`.

## Importing existing subnet

To import an existing Subnet, call `Subnet.fromSubnetAttributes()` or
`Subnet.fromSubnetId()`. Only if you supply the subnet's Availability Zone
and Route Table Ids when calling `Subnet.fromSubnetAttributes()` will you be
able to use the CDK features that use these values (such as selecting one
subnet per AZ).

Importing an existing subnet looks like this:

```python
# Example automatically generated from non-compiling source. May contain errors.
# Supply all properties
subnet1 = ec2.Subnet.from_subnet_attributes(self, "SubnetFromAttributes",
    subnet_id="s-1234",
    availability_zone="pub-az-4465",
    route_table_id="rt-145"
)

# Supply only subnet id
subnet2 = ec2.Subnet.from_subnet_id(self, "SubnetFromId", "s-1234")
```

## Launch Templates

A Launch Template is a standardized template that contains the configuration information to launch an instance.
They can be used when launching instances on their own, through Amazon EC2 Auto Scaling, EC2 Fleet, and Spot Fleet.
Launch templates enable you to store launch parameters so that you do not have to specify them every time you launch
an instance. For information on Launch Templates please see the
[official documentation](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html).

The following demonstrates how to create a launch template with an Amazon Machine Image, and security group.

```python
# Example automatically generated from non-compiling source. May contain errors.
# vpc: ec2.Vpc


template = ec2.LaunchTemplate(self, "LaunchTemplate",
    machine_image=ec2.MachineImage.latest_amazon_linux(),
    security_group=ec2.SecurityGroup(self, "LaunchTemplateSG",
        vpc=vpc
    )
)
```
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from .._jsii import *

import constructs
from .. import (
    AssetHashType as _AssetHashType_05b67f2d,
    BundlingOptions as _BundlingOptions_588cc936,
    CfnResource as _CfnResource_9df397a6,
    CfnTag as _CfnTag_f6864754,
    Duration as _Duration_4839e8c3,
    Expiration as _Expiration_059d47d0,
    IAspect as _IAspect_118c810a,
    IInspectable as _IInspectable_c2943556,
    IResolvable as _IResolvable_da3f097b,
    IResource as _IResource_c80c4260,
    IgnoreMode as _IgnoreMode_655a98e8,
    RemovalPolicy as _RemovalPolicy_9f93c814,
    Resource as _Resource_45bc6135,
    ResourceProps as _ResourceProps_15a65b4e,
    Size as _Size_7b441c34,
    Stack as _Stack_2866e57f,
    SymlinkFollowMode as _SymlinkFollowMode_047ec1f6,
    TagManager as _TagManager_0a598cb3,
    TreeInspector as _TreeInspector_488e0dd5,
)
from ..aws_cloudwatch import (
    Metric as _Metric_e396a4dc,
    MetricOptions as _MetricOptions_1788b62f,
    Unit as _Unit_61bc6f70,
)
from ..aws_iam import (
    ArnPrincipal as _ArnPrincipal_d31ca6bc,
    Grant as _Grant_a7ae64f8,
    IGrantable as _IGrantable_71c4f5de,
    IPrincipal as _IPrincipal_539bb2fd,
    IRole as _IRole_235f5d8e,
    ISamlProvider as _ISamlProvider_63f03582,
    PolicyDocument as _PolicyDocument_3ac34393,
    PolicyStatement as _PolicyStatement_0fe33853,
)
from ..aws_kms import IKey as _IKey_5f11635f
from ..aws_logs import (
    ILogGroup as _ILogGroup_3c4fa718, ILogStream as _ILogStream_dcfca8c2
)
from ..aws_s3 import IBucket as _IBucket_42e086fd
from ..aws_s3_assets import (
    Asset as _Asset_ac2a7e61, AssetOptions as _AssetOptions_2aa69621
)


class AclCidr(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.AclCidr",
):
    '''Either an IPv4 or an IPv6 CIDR.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        acl_cidr = ec2.AclCidr.any_ipv4()
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="anyIpv4") # type: ignore[misc]
    @builtins.classmethod
    def any_ipv4(cls) -> "AclCidr":
        '''The CIDR containing all IPv4 addresses (i.e., 0.0.0.0/0).'''
        return typing.cast("AclCidr", jsii.sinvoke(cls, "anyIpv4", []))

    @jsii.member(jsii_name="anyIpv6") # type: ignore[misc]
    @builtins.classmethod
    def any_ipv6(cls) -> "AclCidr":
        '''The CIDR containing all IPv6 addresses (i.e., ::/0).'''
        return typing.cast("AclCidr", jsii.sinvoke(cls, "anyIpv6", []))

    @jsii.member(jsii_name="ipv4") # type: ignore[misc]
    @builtins.classmethod
    def ipv4(cls, ipv4_cidr: builtins.str) -> "AclCidr":
        '''An IP network range in CIDR notation (for example, 172.16.0.0/24).

        :param ipv4_cidr: -
        '''
        return typing.cast("AclCidr", jsii.sinvoke(cls, "ipv4", [ipv4_cidr]))

    @jsii.member(jsii_name="ipv6") # type: ignore[misc]
    @builtins.classmethod
    def ipv6(cls, ipv6_cidr: builtins.str) -> "AclCidr":
        '''An IPv6 network range in CIDR notation (for example, 2001:db8::/48).

        :param ipv6_cidr: -
        '''
        return typing.cast("AclCidr", jsii.sinvoke(cls, "ipv6", [ipv6_cidr]))

    @jsii.member(jsii_name="toCidrConfig") # type: ignore[misc]
    @abc.abstractmethod
    def to_cidr_config(self) -> "AclCidrConfig":
        ...


class _AclCidrProxy(AclCidr):
    @jsii.member(jsii_name="toCidrConfig")
    def to_cidr_config(self) -> "AclCidrConfig":
        return typing.cast("AclCidrConfig", jsii.invoke(self, "toCidrConfig", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AclCidr).__jsii_proxy_class__ = lambda : _AclCidrProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AclCidrConfig",
    jsii_struct_bases=[],
    name_mapping={"cidr_block": "cidrBlock", "ipv6_cidr_block": "ipv6CidrBlock"},
)
class AclCidrConfig:
    def __init__(
        self,
        *,
        cidr_block: typing.Optional[builtins.str] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Acl Configuration for CIDR.

        :param cidr_block: Ipv4 CIDR.
        :param ipv6_cidr_block: Ipv6 CIDR.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            acl_cidr_config = ec2.AclCidrConfig(
                cidr_block="cidrBlock",
                ipv6_cidr_block="ipv6CidrBlock"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''Ipv4 CIDR.'''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''Ipv6 CIDR.'''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AclCidrConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AclIcmp",
    jsii_struct_bases=[],
    name_mapping={"code": "code", "type": "type"},
)
class AclIcmp:
    def __init__(
        self,
        *,
        code: typing.Optional[jsii.Number] = None,
        type: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties to create Icmp.

        :param code: The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.
        :param type: The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            acl_icmp = ec2.AclIcmp(
                code=123,
                type=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if code is not None:
            self._values["code"] = code
        if type is not None:
            self._values["type"] = type

    @builtins.property
    def code(self) -> typing.Optional[jsii.Number]:
        '''The Internet Control Message Protocol (ICMP) code.

        You can use -1 to specify all ICMP
        codes for the given ICMP type. Requirement is conditional: Required if you
        specify 1 (ICMP) for the protocol parameter.
        '''
        result = self._values.get("code")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def type(self) -> typing.Optional[jsii.Number]:
        '''The Internet Control Message Protocol (ICMP) type.

        You can use -1 to specify all ICMP types.
        Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AclIcmp(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AclPortRange",
    jsii_struct_bases=[],
    name_mapping={"from_": "from", "to": "to"},
)
class AclPortRange:
    def __init__(
        self,
        *,
        from_: typing.Optional[jsii.Number] = None,
        to: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties to create PortRange.

        :param from_: The first port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
        :param to: The last port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            acl_port_range = ec2.AclPortRange(
                from=123,
                to=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if from_ is not None:
            self._values["from_"] = from_
        if to is not None:
            self._values["to"] = to

    @builtins.property
    def from_(self) -> typing.Optional[jsii.Number]:
        '''The first port in the range.

        Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
        '''
        result = self._values.get("from_")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def to(self) -> typing.Optional[jsii.Number]:
        '''The last port in the range.

        Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
        '''
        result = self._values.get("to")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AclPortRange(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AclTraffic(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.AclTraffic",
):
    '''The traffic that is configured using a Network ACL entry.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        acl_traffic = ec2.AclTraffic.all_traffic()
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="allTraffic") # type: ignore[misc]
    @builtins.classmethod
    def all_traffic(cls) -> "AclTraffic":
        '''Apply the ACL entry to all traffic.'''
        return typing.cast("AclTraffic", jsii.sinvoke(cls, "allTraffic", []))

    @jsii.member(jsii_name="icmp") # type: ignore[misc]
    @builtins.classmethod
    def icmp(
        cls,
        *,
        code: typing.Optional[jsii.Number] = None,
        type: typing.Optional[jsii.Number] = None,
    ) -> "AclTraffic":
        '''Apply the ACL entry to ICMP traffic of given type and code.

        :param code: The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.
        :param type: The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.
        '''
        props = AclIcmp(code=code, type=type)

        return typing.cast("AclTraffic", jsii.sinvoke(cls, "icmp", [props]))

    @jsii.member(jsii_name="icmpv6") # type: ignore[misc]
    @builtins.classmethod
    def icmpv6(
        cls,
        *,
        code: typing.Optional[jsii.Number] = None,
        type: typing.Optional[jsii.Number] = None,
    ) -> "AclTraffic":
        '''Apply the ACL entry to ICMPv6 traffic of given type and code.

        Requires an IPv6 CIDR block.

        :param code: The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.
        :param type: The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the CreateNetworkAclEntry protocol parameter.
        '''
        props = AclIcmp(code=code, type=type)

        return typing.cast("AclTraffic", jsii.sinvoke(cls, "icmpv6", [props]))

    @jsii.member(jsii_name="tcpPort") # type: ignore[misc]
    @builtins.classmethod
    def tcp_port(cls, port: jsii.Number) -> "AclTraffic":
        '''Apply the ACL entry to TCP traffic on a given port.

        :param port: -
        '''
        return typing.cast("AclTraffic", jsii.sinvoke(cls, "tcpPort", [port]))

    @jsii.member(jsii_name="tcpPortRange") # type: ignore[misc]
    @builtins.classmethod
    def tcp_port_range(
        cls,
        start_port: jsii.Number,
        end_port: jsii.Number,
    ) -> "AclTraffic":
        '''Apply the ACL entry to TCP traffic on a given port range.

        :param start_port: -
        :param end_port: -
        '''
        return typing.cast("AclTraffic", jsii.sinvoke(cls, "tcpPortRange", [start_port, end_port]))

    @jsii.member(jsii_name="udpPort") # type: ignore[misc]
    @builtins.classmethod
    def udp_port(cls, port: jsii.Number) -> "AclTraffic":
        '''Apply the ACL entry to UDP traffic on a given port.

        :param port: -
        '''
        return typing.cast("AclTraffic", jsii.sinvoke(cls, "udpPort", [port]))

    @jsii.member(jsii_name="udpPortRange") # type: ignore[misc]
    @builtins.classmethod
    def udp_port_range(
        cls,
        start_port: jsii.Number,
        end_port: jsii.Number,
    ) -> "AclTraffic":
        '''Apply the ACL entry to UDP traffic on a given port range.

        :param start_port: -
        :param end_port: -
        '''
        return typing.cast("AclTraffic", jsii.sinvoke(cls, "udpPortRange", [start_port, end_port]))

    @jsii.member(jsii_name="toTrafficConfig") # type: ignore[misc]
    @abc.abstractmethod
    def to_traffic_config(self) -> "AclTrafficConfig":
        ...


class _AclTrafficProxy(AclTraffic):
    @jsii.member(jsii_name="toTrafficConfig")
    def to_traffic_config(self) -> "AclTrafficConfig":
        return typing.cast("AclTrafficConfig", jsii.invoke(self, "toTrafficConfig", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, AclTraffic).__jsii_proxy_class__ = lambda : _AclTrafficProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AclTrafficConfig",
    jsii_struct_bases=[],
    name_mapping={"protocol": "protocol", "icmp": "icmp", "port_range": "portRange"},
)
class AclTrafficConfig:
    def __init__(
        self,
        *,
        protocol: jsii.Number,
        icmp: typing.Optional[AclIcmp] = None,
        port_range: typing.Optional[AclPortRange] = None,
    ) -> None:
        '''Acl Configuration for traffic.

        :param protocol: The protocol number. A value of "-1" means all protocols. If you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or "1" (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types or codes that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code. Default: 17
        :param icmp: The Internet Control Message Protocol (ICMP) code and type. Default: - Required if specifying 1 (ICMP) for the protocol parameter.
        :param port_range: The range of port numbers for the UDP/TCP protocol. Default: - Required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            acl_traffic_config = ec2.AclTrafficConfig(
                protocol=123,
            
                # the properties below are optional
                icmp=ec2.AclIcmp(
                    code=123,
                    type=123
                ),
                port_range=ec2.AclPortRange(
                    from=123,
                    to=123
                )
            )
        '''
        if isinstance(icmp, dict):
            icmp = AclIcmp(**icmp)
        if isinstance(port_range, dict):
            port_range = AclPortRange(**port_range)
        self._values: typing.Dict[str, typing.Any] = {
            "protocol": protocol,
        }
        if icmp is not None:
            self._values["icmp"] = icmp
        if port_range is not None:
            self._values["port_range"] = port_range

    @builtins.property
    def protocol(self) -> jsii.Number:
        '''The protocol number.

        A value of "-1" means all protocols.

        If you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP),
        or "1" (ICMP), traffic on all ports is allowed, regardless of any ports or
        ICMP types or codes that you specify.

        If you specify protocol "58" (ICMPv6) and specify an IPv4 CIDR
        block, traffic for all ICMP types and codes allowed, regardless of any that
        you specify. If you specify protocol "58" (ICMPv6) and specify an IPv6 CIDR
        block, you must specify an ICMP type and code.

        :default: 17
        '''
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def icmp(self) -> typing.Optional[AclIcmp]:
        '''The Internet Control Message Protocol (ICMP) code and type.

        :default: - Required if specifying 1 (ICMP) for the protocol parameter.
        '''
        result = self._values.get("icmp")
        return typing.cast(typing.Optional[AclIcmp], result)

    @builtins.property
    def port_range(self) -> typing.Optional[AclPortRange]:
        '''The range of port numbers for the UDP/TCP protocol.

        :default: - Required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter
        '''
        result = self._values.get("port_range")
        return typing.cast(typing.Optional[AclPortRange], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AclTrafficConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.Action")
class Action(enum.Enum):
    '''What action to apply to traffic matching the ACL.'''

    ALLOW = "ALLOW"
    '''Allow the traffic.'''
    DENY = "DENY"
    '''Deny the traffic.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AddRouteOptions",
    jsii_struct_bases=[],
    name_mapping={
        "router_id": "routerId",
        "router_type": "routerType",
        "destination_cidr_block": "destinationCidrBlock",
        "destination_ipv6_cidr_block": "destinationIpv6CidrBlock",
        "enables_internet_connectivity": "enablesInternetConnectivity",
    },
)
class AddRouteOptions:
    def __init__(
        self,
        *,
        router_id: builtins.str,
        router_type: "RouterType",
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_ipv6_cidr_block: typing.Optional[builtins.str] = None,
        enables_internet_connectivity: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Options for adding a new route to a subnet.

        :param router_id: The ID of the router. Can be an instance ID, gateway ID, etc, depending on the router type.
        :param router_type: What type of router to route this traffic to.
        :param destination_cidr_block: IPv4 range this route applies to. Default: '0.0.0.0/0'
        :param destination_ipv6_cidr_block: IPv6 range this route applies to. Default: - Uses IPv6
        :param enables_internet_connectivity: Whether this route will enable internet connectivity. If true, this route will be added before any AWS resources that depend on internet connectivity in the VPC will be created. Default: false

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            vpc = ec2.Vpc(self, "VPC",
                subnet_configuration=[ec2.SubnetConfiguration(
                    subnet_type=ec2.SubnetType.PUBLIC,
                    name="Public"
                ), ec2.SubnetConfiguration(
                    subnet_type=ec2.SubnetType.ISOLATED,
                    name="Isolated"
                )]
            )
            
            (vpc.isolated_subnets[0]).add_route("StaticRoute",
                router_id=vpc.internet_gateway_id,
                router_type=ec2.RouterType.GATEWAY,
                destination_cidr_block="8.8.8.8/32"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "router_id": router_id,
            "router_type": router_type,
        }
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if destination_ipv6_cidr_block is not None:
            self._values["destination_ipv6_cidr_block"] = destination_ipv6_cidr_block
        if enables_internet_connectivity is not None:
            self._values["enables_internet_connectivity"] = enables_internet_connectivity

    @builtins.property
    def router_id(self) -> builtins.str:
        '''The ID of the router.

        Can be an instance ID, gateway ID, etc, depending on the router type.
        '''
        result = self._values.get("router_id")
        assert result is not None, "Required property 'router_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def router_type(self) -> "RouterType":
        '''What type of router to route this traffic to.'''
        result = self._values.get("router_type")
        assert result is not None, "Required property 'router_type' is missing"
        return typing.cast("RouterType", result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''IPv4 range this route applies to.

        :default: '0.0.0.0/0'
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''IPv6 range this route applies to.

        :default: - Uses IPv6
        '''
        result = self._values.get("destination_ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enables_internet_connectivity(self) -> typing.Optional[builtins.bool]:
        '''Whether this route will enable internet connectivity.

        If true, this route will be added before any AWS resources that depend
        on internet connectivity in the VPC will be created.

        :default: false
        '''
        result = self._values.get("enables_internet_connectivity")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddRouteOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxCpuType")
class AmazonLinuxCpuType(enum.Enum):
    '''CPU type.

    :exampleMetadata: lit=aws-ec2/test/example.images.lit.ts infused

    Example::

        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.MachineImage.latest_amazon_linux(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
            cpu_type=ec2.AmazonLinuxCpuType.X86_64
        )
        
        # Pick a Windows edition to use
        windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Read AMI id from SSM parameter store
        ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)
        
        # Look up the most recent image matching a set of AMI filters.
        # In this case, look up the NAT instance AMI, by using a wildcard
        # in the 'name' field:
        nat_ami = ec2.MachineImage.lookup(
            name="amzn-ami-vpc-nat-*",
            owners=["amazon"]
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        linux = ec2.MachineImage.generic_linux({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
        
        # For other custom (Windows) images, instantiate a `GenericWindowsImage` with
        # a map giving the AMI to in for each region:
        generic_windows = ec2.MachineImage.generic_windows({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    ARM_64 = "ARM_64"
    '''arm64 CPU type.'''
    X86_64 = "X86_64"
    '''x86_64 CPU type.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxEdition")
class AmazonLinuxEdition(enum.Enum):
    '''Amazon Linux edition.

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    STANDARD = "STANDARD"
    '''Standard edition.'''
    MINIMAL = "MINIMAL"
    '''Minimal edition.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxGeneration")
class AmazonLinuxGeneration(enum.Enum):
    '''What generation of Amazon Linux to use.

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    AMAZON_LINUX = "AMAZON_LINUX"
    '''Amazon Linux.'''
    AMAZON_LINUX_2 = "AMAZON_LINUX_2"
    '''Amazon Linux 2.'''
    AMAZON_LINUX_2022 = "AMAZON_LINUX_2022"
    '''Amazon Linux 2022.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "cached_in_context": "cachedInContext",
        "cpu_type": "cpuType",
        "edition": "edition",
        "generation": "generation",
        "kernel": "kernel",
        "storage": "storage",
        "user_data": "userData",
        "virtualization": "virtualization",
    },
)
class AmazonLinuxImageProps:
    def __init__(
        self,
        *,
        cached_in_context: typing.Optional[builtins.bool] = None,
        cpu_type: typing.Optional[AmazonLinuxCpuType] = None,
        edition: typing.Optional[AmazonLinuxEdition] = None,
        generation: typing.Optional[AmazonLinuxGeneration] = None,
        kernel: typing.Optional["AmazonLinuxKernel"] = None,
        storage: typing.Optional["AmazonLinuxStorage"] = None,
        user_data: typing.Optional["UserData"] = None,
        virtualization: typing.Optional["AmazonLinuxVirt"] = None,
    ) -> None:
        '''Amazon Linux image properties.

        :param cached_in_context: Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false
        :param cpu_type: CPU Type. Default: X86_64
        :param edition: What edition of Amazon Linux to use. Default: Standard
        :param generation: What generation of Amazon Linux to use. Default: AmazonLinux
        :param kernel: What kernel version of Amazon Linux to use. Default: -
        :param storage: What storage backed image to use. Default: GeneralPurpose
        :param user_data: Initial user data. Default: - Empty UserData for Linux machines
        :param virtualization: Virtualization type. Default: HVM

        :exampleMetadata: infused

        Example::

            sg = ec2.SecurityGroup.from_security_group_id(self, "FsxSecurityGroup", "{SECURITY-GROUP-ID}")
            fs = fsx.LustreFileSystem.from_lustre_file_system_attributes(self, "FsxLustreFileSystem",
                dns_name="{FILE-SYSTEM-DNS-NAME}",
                file_system_id="{FILE-SYSTEM-ID}",
                security_group=sg
            )
            
            vpc = ec2.Vpc.from_vpc_attributes(self, "Vpc",
                availability_zones=["us-west-2a", "us-west-2b"],
                public_subnet_ids=["{US-WEST-2A-SUBNET-ID}", "{US-WEST-2B-SUBNET-ID}"],
                vpc_id="{VPC-ID}"
            )
            
            inst = ec2.Instance(self, "inst",
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.T2, ec2.InstanceSize.LARGE),
                machine_image=ec2.AmazonLinuxImage(
                    generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2
                ),
                vpc=vpc,
                vpc_subnets=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PUBLIC
                )
            )
            
            fs.connections.allow_default_port_from(inst)
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if cached_in_context is not None:
            self._values["cached_in_context"] = cached_in_context
        if cpu_type is not None:
            self._values["cpu_type"] = cpu_type
        if edition is not None:
            self._values["edition"] = edition
        if generation is not None:
            self._values["generation"] = generation
        if kernel is not None:
            self._values["kernel"] = kernel
        if storage is not None:
            self._values["storage"] = storage
        if user_data is not None:
            self._values["user_data"] = user_data
        if virtualization is not None:
            self._values["virtualization"] = virtualization

    @builtins.property
    def cached_in_context(self) -> typing.Optional[builtins.bool]:
        '''Whether the AMI ID is cached to be stable between deployments.

        By default, the newest image is used on each deployment. This will cause
        instances to be replaced whenever a new version is released, and may cause
        downtime if there aren't enough running instances in the AutoScalingGroup
        to reschedule the tasks on.

        If set to true, the AMI ID will be cached in ``cdk.context.json`` and the
        same value will be used on future runs. Your instances will not be replaced
        but your AMI version will grow old over time. To refresh the AMI lookup,
        you will have to evict the value from the cache using the ``cdk context``
        command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for
        more information.

        Can not be set to ``true`` in environment-agnostic stacks.

        :default: false
        '''
        result = self._values.get("cached_in_context")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def cpu_type(self) -> typing.Optional[AmazonLinuxCpuType]:
        '''CPU Type.

        :default: X86_64
        '''
        result = self._values.get("cpu_type")
        return typing.cast(typing.Optional[AmazonLinuxCpuType], result)

    @builtins.property
    def edition(self) -> typing.Optional[AmazonLinuxEdition]:
        '''What edition of Amazon Linux to use.

        :default: Standard
        '''
        result = self._values.get("edition")
        return typing.cast(typing.Optional[AmazonLinuxEdition], result)

    @builtins.property
    def generation(self) -> typing.Optional[AmazonLinuxGeneration]:
        '''What generation of Amazon Linux to use.

        :default: AmazonLinux
        '''
        result = self._values.get("generation")
        return typing.cast(typing.Optional[AmazonLinuxGeneration], result)

    @builtins.property
    def kernel(self) -> typing.Optional["AmazonLinuxKernel"]:
        '''What kernel version of Amazon Linux to use.

        :default: -
        '''
        result = self._values.get("kernel")
        return typing.cast(typing.Optional["AmazonLinuxKernel"], result)

    @builtins.property
    def storage(self) -> typing.Optional["AmazonLinuxStorage"]:
        '''What storage backed image to use.

        :default: GeneralPurpose
        '''
        result = self._values.get("storage")
        return typing.cast(typing.Optional["AmazonLinuxStorage"], result)

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''Initial user data.

        :default: - Empty UserData for Linux machines
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    @builtins.property
    def virtualization(self) -> typing.Optional["AmazonLinuxVirt"]:
        '''Virtualization type.

        :default: HVM
        '''
        result = self._values.get("virtualization")
        return typing.cast(typing.Optional["AmazonLinuxVirt"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AmazonLinuxImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxKernel")
class AmazonLinuxKernel(enum.Enum):
    '''Amazon Linux Kernel.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        
        
        # AWS Linux
        ec2.Instance(self, "Instance1",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=ec2.AmazonLinuxImage()
        )
        
        # AWS Linux 2
        ec2.Instance(self, "Instance2",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=ec2.AmazonLinuxImage(
                generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2
            )
        )
        
        # AWS Linux 2 with kernel 5.x
        ec2.Instance(self, "Instance3",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=ec2.AmazonLinuxImage(
                generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,
                kernel=ec2.AmazonLinuxKernel.KERNEL5_X
            )
        )
        
        # AWS Linux 2022
        ec2.Instance(self, "Instance4",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=ec2.AmazonLinuxImage(
                generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2022
            )
        )
    '''

    KERNEL5_X = "KERNEL5_X"
    '''Standard edition.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxStorage")
class AmazonLinuxStorage(enum.Enum):
    '''
    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    EBS = "EBS"
    '''EBS-backed storage.'''
    S3 = "S3"
    '''S3-backed storage.'''
    GENERAL_PURPOSE = "GENERAL_PURPOSE"
    '''General Purpose-based storage (recommended).'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxVirt")
class AmazonLinuxVirt(enum.Enum):
    '''Virtualization type for Amazon Linux.

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    HVM = "HVM"
    '''HVM virtualization (recommended).'''
    PV = "PV"
    '''PV virtualization.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ApplyCloudFormationInitOptions",
    jsii_struct_bases=[],
    name_mapping={
        "config_sets": "configSets",
        "embed_fingerprint": "embedFingerprint",
        "ignore_failures": "ignoreFailures",
        "include_role": "includeRole",
        "include_url": "includeUrl",
        "print_log": "printLog",
        "timeout": "timeout",
    },
)
class ApplyCloudFormationInitOptions:
    def __init__(
        self,
        *,
        config_sets: typing.Optional[typing.Sequence[builtins.str]] = None,
        embed_fingerprint: typing.Optional[builtins.bool] = None,
        ignore_failures: typing.Optional[builtins.bool] = None,
        include_role: typing.Optional[builtins.bool] = None,
        include_url: typing.Optional[builtins.bool] = None,
        print_log: typing.Optional[builtins.bool] = None,
        timeout: typing.Optional[_Duration_4839e8c3] = None,
    ) -> None:
        '''Options for applying CloudFormation init to an instance or instance group.

        :param config_sets: ConfigSet to activate. Default: ['default']
        :param embed_fingerprint: Force instance replacement by embedding a config fingerprint. If ``true`` (the default), a hash of the config will be embedded into the UserData, so that if the config changes, the UserData changes. - If the EC2 instance is instance-store backed or ``userDataCausesReplacement`` is set, this will cause the instance to be replaced and the new configuration to be applied. - If the instance is EBS-backed and ``userDataCausesReplacement`` is not set, the change of UserData will make the instance restart but not be replaced, and the configuration will not be applied automatically. If ``false``, no hash will be embedded, and if the CloudFormation Init config changes nothing will happen to the running instance. If a config update introduces errors, you will not notice until after the CloudFormation deployment successfully finishes and the next instance fails to launch. Default: true
        :param ignore_failures: Don't fail the instance creation when cfn-init fails. You can use this to prevent CloudFormation from rolling back when instances fail to start up, to help in debugging. Default: false
        :param include_role: Include --role argument when running cfn-init and cfn-signal commands. This will be the IAM instance profile attached to the EC2 instance Default: false
        :param include_url: Include --url argument when running cfn-init and cfn-signal commands. This will be the cloudformation endpoint in the deployed region e.g. https://cloudformation.us-east-1.amazonaws.com Default: false
        :param print_log: Print the results of running cfn-init to the Instance System Log. By default, the output of running cfn-init is written to a log file on the instance. Set this to ``true`` to print it to the System Log (visible from the EC2 Console), ``false`` to not print it. (Be aware that the system log is refreshed at certain points in time of the instance life cycle, and successful execution may not always show up). Default: true
        :param timeout: Timeout waiting for the configuration to be applied. Default: Duration.minutes(5)

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            # instance_type: ec2.InstanceType
            # machine_image: ec2.IMachineImage
            
            
            ec2.Instance(self, "Instance",
                vpc=vpc,
                instance_type=instance_type,
                machine_image=machine_image,
            
                # Showing the most complex setup, if you have simpler requirements
                # you can use `CloudFormationInit.fromElements()`.
                init=ec2.CloudFormationInit.from_config_sets(
                    config_sets={
                        # Applies the configs below in this order
                        "default": ["yumPreinstall", "config"]
                    },
                    configs={
                        "yum_preinstall": ec2.InitConfig([
                            # Install an Amazon Linux package using yum
                            ec2.InitPackage.yum("git")
                        ]),
                        "config": ec2.InitConfig([
                            # Create a JSON file from tokens (can also create other files)
                            ec2.InitFile.from_object("/etc/stack.json", {
                                "stack_id": Stack.of(self).stack_id,
                                "stack_name": Stack.of(self).stack_name,
                                "region": Stack.of(self).region
                            }),
            
                            # Create a group and user
                            ec2.InitGroup.from_name("my-group"),
                            ec2.InitUser.from_name("my-user"),
            
                            # Install an RPM from the internet
                            ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
                        ])
                    }
                ),
                init_options=ec2.ApplyCloudFormationInitOptions(
                    # Optional, which configsets to activate (['default'] by default)
                    config_sets=["default"],
            
                    # Optional, how long the installation is expected to take (5 minutes by default)
                    timeout=Duration.minutes(30),
            
                    # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
                    include_url=True,
            
                    # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
                    include_role=True
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if config_sets is not None:
            self._values["config_sets"] = config_sets
        if embed_fingerprint is not None:
            self._values["embed_fingerprint"] = embed_fingerprint
        if ignore_failures is not None:
            self._values["ignore_failures"] = ignore_failures
        if include_role is not None:
            self._values["include_role"] = include_role
        if include_url is not None:
            self._values["include_url"] = include_url
        if print_log is not None:
            self._values["print_log"] = print_log
        if timeout is not None:
            self._values["timeout"] = timeout

    @builtins.property
    def config_sets(self) -> typing.Optional[typing.List[builtins.str]]:
        '''ConfigSet to activate.

        :default: ['default']
        '''
        result = self._values.get("config_sets")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def embed_fingerprint(self) -> typing.Optional[builtins.bool]:
        '''Force instance replacement by embedding a config fingerprint.

        If ``true`` (the default), a hash of the config will be embedded into the
        UserData, so that if the config changes, the UserData changes.

        - If the EC2 instance is instance-store backed or
          ``userDataCausesReplacement`` is set, this will cause the instance to be
          replaced and the new configuration to be applied.
        - If the instance is EBS-backed and ``userDataCausesReplacement`` is not
          set, the change of UserData will make the instance restart but not be
          replaced, and the configuration will not be applied automatically.

        If ``false``, no hash will be embedded, and if the CloudFormation Init
        config changes nothing will happen to the running instance. If a
        config update introduces errors, you will not notice until after the
        CloudFormation deployment successfully finishes and the next instance
        fails to launch.

        :default: true
        '''
        result = self._values.get("embed_fingerprint")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ignore_failures(self) -> typing.Optional[builtins.bool]:
        '''Don't fail the instance creation when cfn-init fails.

        You can use this to prevent CloudFormation from rolling back when
        instances fail to start up, to help in debugging.

        :default: false
        '''
        result = self._values.get("ignore_failures")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def include_role(self) -> typing.Optional[builtins.bool]:
        '''Include --role argument when running cfn-init and cfn-signal commands.

        This will be the IAM instance profile attached to the EC2 instance

        :default: false
        '''
        result = self._values.get("include_role")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def include_url(self) -> typing.Optional[builtins.bool]:
        '''Include --url argument when running cfn-init and cfn-signal commands.

        This will be the cloudformation endpoint in the deployed region
        e.g. https://cloudformation.us-east-1.amazonaws.com

        :default: false
        '''
        result = self._values.get("include_url")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def print_log(self) -> typing.Optional[builtins.bool]:
        '''Print the results of running cfn-init to the Instance System Log.

        By default, the output of running cfn-init is written to a log file
        on the instance. Set this to ``true`` to print it to the System Log
        (visible from the EC2 Console), ``false`` to not print it.

        (Be aware that the system log is refreshed at certain points in
        time of the instance life cycle, and successful execution may
        not always show up).

        :default: true
        '''
        result = self._values.get("print_log")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def timeout(self) -> typing.Optional[_Duration_4839e8c3]:
        '''Timeout waiting for the configuration to be applied.

        :default: Duration.minutes(5)
        '''
        result = self._values.get("timeout")
        return typing.cast(typing.Optional[_Duration_4839e8c3], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplyCloudFormationInitOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.AttachInitOptions",
    jsii_struct_bases=[],
    name_mapping={
        "instance_role": "instanceRole",
        "platform": "platform",
        "user_data": "userData",
        "config_sets": "configSets",
        "embed_fingerprint": "embedFingerprint",
        "ignore_failures": "ignoreFailures",
        "include_role": "includeRole",
        "include_url": "includeUrl",
        "print_log": "printLog",
        "signal_resource": "signalResource",
    },
)
class AttachInitOptions:
    def __init__(
        self,
        *,
        instance_role: _IRole_235f5d8e,
        platform: "OperatingSystemType",
        user_data: "UserData",
        config_sets: typing.Optional[typing.Sequence[builtins.str]] = None,
        embed_fingerprint: typing.Optional[builtins.bool] = None,
        ignore_failures: typing.Optional[builtins.bool] = None,
        include_role: typing.Optional[builtins.bool] = None,
        include_url: typing.Optional[builtins.bool] = None,
        print_log: typing.Optional[builtins.bool] = None,
        signal_resource: typing.Optional[_CfnResource_9df397a6] = None,
    ) -> None:
        '''Options for attaching a CloudFormationInit to a resource.

        :param instance_role: Instance role of the consuming instance or fleet.
        :param platform: OS Platform the init config will be used for.
        :param user_data: UserData to add commands to.
        :param config_sets: ConfigSet to activate. Default: ['default']
        :param embed_fingerprint: Whether to embed a hash into the userData. If ``true`` (the default), a hash of the config will be embedded into the UserData, so that if the config changes, the UserData changes and the instance will be replaced. If ``false``, no such hash will be embedded, and if the CloudFormation Init config changes nothing will happen to the running instance. Default: true
        :param ignore_failures: Don't fail the instance creation when cfn-init fails. You can use this to prevent CloudFormation from rolling back when instances fail to start up, to help in debugging. Default: false
        :param include_role: Include --role argument when running cfn-init and cfn-signal commands. This will be the IAM instance profile attached to the EC2 instance Default: false
        :param include_url: Include --url argument when running cfn-init and cfn-signal commands. This will be the cloudformation endpoint in the deployed region e.g. https://cloudformation.us-east-1.amazonaws.com Default: false
        :param print_log: Print the results of running cfn-init to the Instance System Log. By default, the output of running cfn-init is written to a log file on the instance. Set this to ``true`` to print it to the System Log (visible from the EC2 Console), ``false`` to not print it. (Be aware that the system log is refreshed at certain points in time of the instance life cycle, and successful execution may not always show up). Default: true
        :param signal_resource: When provided, signals this resource instead of the attached resource. You can use this to support signaling LaunchTemplate while attaching AutoScalingGroup Default: - if this property is undefined cfn-signal signals the attached resource

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import aws_cdk as cdk
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_iam as iam
            
            # cfn_resource: cdk.CfnResource
            # role: iam.Role
            # user_data: ec2.UserData
            
            attach_init_options = ec2.AttachInitOptions(
                instance_role=role,
                platform=ec2.OperatingSystemType.LINUX,
                user_data=user_data,
            
                # the properties below are optional
                config_sets=["configSets"],
                embed_fingerprint=False,
                ignore_failures=False,
                include_role=False,
                include_url=False,
                print_log=False,
                signal_resource=cfn_resource
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "instance_role": instance_role,
            "platform": platform,
            "user_data": user_data,
        }
        if config_sets is not None:
            self._values["config_sets"] = config_sets
        if embed_fingerprint is not None:
            self._values["embed_fingerprint"] = embed_fingerprint
        if ignore_failures is not None:
            self._values["ignore_failures"] = ignore_failures
        if include_role is not None:
            self._values["include_role"] = include_role
        if include_url is not None:
            self._values["include_url"] = include_url
        if print_log is not None:
            self._values["print_log"] = print_log
        if signal_resource is not None:
            self._values["signal_resource"] = signal_resource

    @builtins.property
    def instance_role(self) -> _IRole_235f5d8e:
        '''Instance role of the consuming instance or fleet.'''
        result = self._values.get("instance_role")
        assert result is not None, "Required property 'instance_role' is missing"
        return typing.cast(_IRole_235f5d8e, result)

    @builtins.property
    def platform(self) -> "OperatingSystemType":
        '''OS Platform the init config will be used for.'''
        result = self._values.get("platform")
        assert result is not None, "Required property 'platform' is missing"
        return typing.cast("OperatingSystemType", result)

    @builtins.property
    def user_data(self) -> "UserData":
        '''UserData to add commands to.'''
        result = self._values.get("user_data")
        assert result is not None, "Required property 'user_data' is missing"
        return typing.cast("UserData", result)

    @builtins.property
    def config_sets(self) -> typing.Optional[typing.List[builtins.str]]:
        '''ConfigSet to activate.

        :default: ['default']
        '''
        result = self._values.get("config_sets")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def embed_fingerprint(self) -> typing.Optional[builtins.bool]:
        '''Whether to embed a hash into the userData.

        If ``true`` (the default), a hash of the config will be embedded into the
        UserData, so that if the config changes, the UserData changes and
        the instance will be replaced.

        If ``false``, no such hash will be embedded, and if the CloudFormation Init
        config changes nothing will happen to the running instance.

        :default: true
        '''
        result = self._values.get("embed_fingerprint")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ignore_failures(self) -> typing.Optional[builtins.bool]:
        '''Don't fail the instance creation when cfn-init fails.

        You can use this to prevent CloudFormation from rolling back when
        instances fail to start up, to help in debugging.

        :default: false
        '''
        result = self._values.get("ignore_failures")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def include_role(self) -> typing.Optional[builtins.bool]:
        '''Include --role argument when running cfn-init and cfn-signal commands.

        This will be the IAM instance profile attached to the EC2 instance

        :default: false
        '''
        result = self._values.get("include_role")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def include_url(self) -> typing.Optional[builtins.bool]:
        '''Include --url argument when running cfn-init and cfn-signal commands.

        This will be the cloudformation endpoint in the deployed region
        e.g. https://cloudformation.us-east-1.amazonaws.com

        :default: false
        '''
        result = self._values.get("include_url")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def print_log(self) -> typing.Optional[builtins.bool]:
        '''Print the results of running cfn-init to the Instance System Log.

        By default, the output of running cfn-init is written to a log file
        on the instance. Set this to ``true`` to print it to the System Log
        (visible from the EC2 Console), ``false`` to not print it.

        (Be aware that the system log is refreshed at certain points in
        time of the instance life cycle, and successful execution may
        not always show up).

        :default: true
        '''
        result = self._values.get("print_log")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def signal_resource(self) -> typing.Optional[_CfnResource_9df397a6]:
        '''When provided, signals this resource instead of the attached resource.

        You can use this to support signaling LaunchTemplate while attaching AutoScalingGroup

        :default: - if this property is undefined cfn-signal signals the attached resource
        '''
        result = self._values.get("signal_resource")
        return typing.cast(typing.Optional[_CfnResource_9df397a6], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AttachInitOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.BastionHostLinuxProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc": "vpc",
        "availability_zone": "availabilityZone",
        "block_devices": "blockDevices",
        "init": "init",
        "init_options": "initOptions",
        "instance_name": "instanceName",
        "instance_type": "instanceType",
        "machine_image": "machineImage",
        "require_imdsv2": "requireImdsv2",
        "security_group": "securityGroup",
        "subnet_selection": "subnetSelection",
    },
)
class BastionHostLinuxProps:
    def __init__(
        self,
        *,
        vpc: "IVpc",
        availability_zone: typing.Optional[builtins.str] = None,
        block_devices: typing.Optional[typing.Sequence["BlockDevice"]] = None,
        init: typing.Optional["CloudFormationInit"] = None,
        init_options: typing.Optional[ApplyCloudFormationInitOptions] = None,
        instance_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional["InstanceType"] = None,
        machine_image: typing.Optional["IMachineImage"] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        security_group: typing.Optional["ISecurityGroup"] = None,
        subnet_selection: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''Properties of the bastion host.

        :param vpc: VPC to launch the instance in.
        :param availability_zone: In which AZ to place the instance within the VPC. Default: - Random zone.
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param init: Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init
        :param init_options: Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options
        :param instance_name: The name of the instance. Default: 'BastionHost'
        :param instance_type: Type of instance to launch. Default: 't3.nano'
        :param machine_image: The machine image to use, assumed to have SSM Agent preinstalled. Default: - An Amazon Linux 2 image which is kept up-to-date automatically (the instance may be replaced on every deployment) and already has SSM Agent installed.
        :param require_imdsv2: Whether IMDSv2 should be required on this instance. Default: - false
        :param security_group: Security Group to assign to this instance. Default: - create new security group with no inbound and all outbound traffic allowed
        :param subnet_selection: Select the subnets to run the bastion host in. Set this to PUBLIC if you need to connect to this instance via the internet and cannot use SSM. You have to allow port 22 manually by using the connections field Default: - private subnets of the supplied VPC

        :exampleMetadata: fixture=with-vpc infused

        Example::

            host = ec2.BastionHostLinux(self, "BastionHost",
                vpc=vpc,
                block_devices=[ec2.BlockDevice(
                    device_name="EBSBastionHost",
                    volume=ec2.BlockDeviceVolume.ebs(10,
                        encrypted=True
                    )
                )]
            )
        '''
        if isinstance(init_options, dict):
            init_options = ApplyCloudFormationInitOptions(**init_options)
        if isinstance(subnet_selection, dict):
            subnet_selection = SubnetSelection(**subnet_selection)
        self._values: typing.Dict[str, typing.Any] = {
            "vpc": vpc,
        }
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if block_devices is not None:
            self._values["block_devices"] = block_devices
        if init is not None:
            self._values["init"] = init
        if init_options is not None:
            self._values["init_options"] = init_options
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if machine_image is not None:
            self._values["machine_image"] = machine_image
        if require_imdsv2 is not None:
            self._values["require_imdsv2"] = require_imdsv2
        if security_group is not None:
            self._values["security_group"] = security_group
        if subnet_selection is not None:
            self._values["subnet_selection"] = subnet_selection

    @builtins.property
    def vpc(self) -> "IVpc":
        '''VPC to launch the instance in.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast("IVpc", result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''In which AZ to place the instance within the VPC.

        :default: - Random zone.
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def block_devices(self) -> typing.Optional[typing.List["BlockDevice"]]:
        '''Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes.

        Each instance that is launched has an associated root device volume,
        either an Amazon EBS volume or an instance store volume.
        You can use block device mappings to specify additional EBS volumes or
        instance store volumes to attach to an instance when it is launched.

        :default: - Uses the block device mapping of the AMI

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html
        '''
        result = self._values.get("block_devices")
        return typing.cast(typing.Optional[typing.List["BlockDevice"]], result)

    @builtins.property
    def init(self) -> typing.Optional["CloudFormationInit"]:
        '''Apply the given CloudFormation Init configuration to the instance at startup.

        :default: - no CloudFormation init
        '''
        result = self._values.get("init")
        return typing.cast(typing.Optional["CloudFormationInit"], result)

    @builtins.property
    def init_options(self) -> typing.Optional[ApplyCloudFormationInitOptions]:
        '''Use the given options for applying CloudFormation Init.

        Describes the configsets to use and the timeout to wait

        :default: - default options
        '''
        result = self._values.get("init_options")
        return typing.cast(typing.Optional[ApplyCloudFormationInitOptions], result)

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        '''The name of the instance.

        :default: 'BastionHost'
        '''
        result = self._values.get("instance_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional["InstanceType"]:
        '''Type of instance to launch.

        :default: 't3.nano'
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional["InstanceType"], result)

    @builtins.property
    def machine_image(self) -> typing.Optional["IMachineImage"]:
        '''The machine image to use, assumed to have SSM Agent preinstalled.

        :default:

        - An Amazon Linux 2 image which is kept up-to-date automatically (the instance
        may be replaced on every deployment) and already has SSM Agent installed.
        '''
        result = self._values.get("machine_image")
        return typing.cast(typing.Optional["IMachineImage"], result)

    @builtins.property
    def require_imdsv2(self) -> typing.Optional[builtins.bool]:
        '''Whether IMDSv2 should be required on this instance.

        :default: - false
        '''
        result = self._values.get("require_imdsv2")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def security_group(self) -> typing.Optional["ISecurityGroup"]:
        '''Security Group to assign to this instance.

        :default: - create new security group with no inbound and all outbound traffic allowed
        '''
        result = self._values.get("security_group")
        return typing.cast(typing.Optional["ISecurityGroup"], result)

    @builtins.property
    def subnet_selection(self) -> typing.Optional["SubnetSelection"]:
        '''Select the subnets to run the bastion host in.

        Set this to PUBLIC if you need to connect to this instance via the internet and cannot use SSM.
        You have to allow port 22 manually by using the connections field

        :default: - private subnets of the supplied VPC
        '''
        result = self._values.get("subnet_selection")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BastionHostLinuxProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.BlockDevice",
    jsii_struct_bases=[],
    name_mapping={
        "device_name": "deviceName",
        "volume": "volume",
        "mapping_enabled": "mappingEnabled",
    },
)
class BlockDevice:
    def __init__(
        self,
        *,
        device_name: builtins.str,
        volume: "BlockDeviceVolume",
        mapping_enabled: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Block device.

        :param device_name: The device name exposed to the EC2 instance. For example, a value like ``/dev/sdh``, ``xvdh``.
        :param volume: Defines the block device volume, to be either an Amazon EBS volume or an ephemeral instance store volume. For example, a value like ``BlockDeviceVolume.ebs(15)``, ``BlockDeviceVolume.ephemeral(0)``.
        :param mapping_enabled: If false, the device mapping will be suppressed. If set to false for the root device, the instance might fail the Amazon EC2 health check. Amazon EC2 Auto Scaling launches a replacement instance if the instance fails the health check. Default: true - device mapping is left untouched

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # block_device_volume: ec2.BlockDeviceVolume
            
            block_device = ec2.BlockDevice(
                device_name="deviceName",
                volume=block_device_volume,
            
                # the properties below are optional
                mapping_enabled=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "device_name": device_name,
            "volume": volume,
        }
        if mapping_enabled is not None:
            self._values["mapping_enabled"] = mapping_enabled

    @builtins.property
    def device_name(self) -> builtins.str:
        '''The device name exposed to the EC2 instance.

        For example, a value like ``/dev/sdh``, ``xvdh``.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html
        '''
        result = self._values.get("device_name")
        assert result is not None, "Required property 'device_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def volume(self) -> "BlockDeviceVolume":
        '''Defines the block device volume, to be either an Amazon EBS volume or an ephemeral instance store volume.

        For example, a value like ``BlockDeviceVolume.ebs(15)``, ``BlockDeviceVolume.ephemeral(0)``.
        '''
        result = self._values.get("volume")
        assert result is not None, "Required property 'volume' is missing"
        return typing.cast("BlockDeviceVolume", result)

    @builtins.property
    def mapping_enabled(self) -> typing.Optional[builtins.bool]:
        '''If false, the device mapping will be suppressed.

        If set to false for the root device, the instance might fail the Amazon EC2 health check.
        Amazon EC2 Auto Scaling launches a replacement instance if the instance fails the health check.

        :default: true - device mapping is left untouched
        '''
        result = self._values.get("mapping_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BlockDevice(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BlockDeviceVolume(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.BlockDeviceVolume",
):
    '''Describes a block device mapping for an EC2 instance or Auto Scaling group.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        ec2.Instance(self, "Instance",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # ...
        
            block_devices=[ec2.BlockDevice(
                device_name="/dev/sda1",
                volume=ec2.BlockDeviceVolume.ebs(50)
            ), ec2.BlockDevice(
                device_name="/dev/sdm",
                volume=ec2.BlockDeviceVolume.ebs(100)
            )
            ]
        )
    '''

    def __init__(
        self,
        ebs_device: typing.Optional["EbsDeviceProps"] = None,
        virtual_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param ebs_device: EBS device info.
        :param virtual_name: Virtual device name.
        '''
        jsii.create(self.__class__, self, [ebs_device, virtual_name])

    @jsii.member(jsii_name="ebs") # type: ignore[misc]
    @builtins.classmethod
    def ebs(
        cls,
        volume_size: jsii.Number,
        *,
        encrypted: typing.Optional[builtins.bool] = None,
        kms_key: typing.Optional[_IKey_5f11635f] = None,
        delete_on_termination: typing.Optional[builtins.bool] = None,
        iops: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional["EbsDeviceVolumeType"] = None,
    ) -> "BlockDeviceVolume":
        '''Creates a new Elastic Block Storage device.

        :param volume_size: The volume size, in Gibibytes (GiB).
        :param encrypted: Specifies whether the EBS volume is encrypted. Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption Default: false
        :param kms_key: The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption. You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances. Default: - If encrypted is true, the default aws/ebs KMS key will be used.
        :param delete_on_termination: Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1} The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for {@link EbsDeviceVolumeType.IO1}
        :param volume_type: The EBS volume type. Default: {@link EbsDeviceVolumeType.GP2}
        '''
        options = EbsDeviceOptions(
            encrypted=encrypted,
            kms_key=kms_key,
            delete_on_termination=delete_on_termination,
            iops=iops,
            volume_type=volume_type,
        )

        return typing.cast("BlockDeviceVolume", jsii.sinvoke(cls, "ebs", [volume_size, options]))

    @jsii.member(jsii_name="ebsFromSnapshot") # type: ignore[misc]
    @builtins.classmethod
    def ebs_from_snapshot(
        cls,
        snapshot_id: builtins.str,
        *,
        volume_size: typing.Optional[jsii.Number] = None,
        delete_on_termination: typing.Optional[builtins.bool] = None,
        iops: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional["EbsDeviceVolumeType"] = None,
    ) -> "BlockDeviceVolume":
        '''Creates a new Elastic Block Storage device from an existing snapshot.

        :param snapshot_id: The snapshot ID of the volume to use.
        :param volume_size: The volume size, in Gibibytes (GiB). If you specify volumeSize, it must be equal or greater than the size of the snapshot. Default: - The snapshot size
        :param delete_on_termination: Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1} The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for {@link EbsDeviceVolumeType.IO1}
        :param volume_type: The EBS volume type. Default: {@link EbsDeviceVolumeType.GP2}
        '''
        options = EbsDeviceSnapshotOptions(
            volume_size=volume_size,
            delete_on_termination=delete_on_termination,
            iops=iops,
            volume_type=volume_type,
        )

        return typing.cast("BlockDeviceVolume", jsii.sinvoke(cls, "ebsFromSnapshot", [snapshot_id, options]))

    @jsii.member(jsii_name="ephemeral") # type: ignore[misc]
    @builtins.classmethod
    def ephemeral(cls, volume_index: jsii.Number) -> "BlockDeviceVolume":
        '''Creates a virtual, ephemeral device.

        The name will be in the form ephemeral{volumeIndex}.

        :param volume_index: the volume index. Must be equal or greater than 0
        '''
        return typing.cast("BlockDeviceVolume", jsii.sinvoke(cls, "ephemeral", [volume_index]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ebsDevice")
    def ebs_device(self) -> typing.Optional["EbsDeviceProps"]:
        '''EBS device info.'''
        return typing.cast(typing.Optional["EbsDeviceProps"], jsii.get(self, "ebsDevice"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="virtualName")
    def virtual_name(self) -> typing.Optional[builtins.str]:
        '''Virtual device name.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "virtualName"))


@jsii.implements(_IInspectable_c2943556)
class CfnCapacityReservation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservation",
):
    '''A CloudFormation ``AWS::EC2::CapacityReservation``.

    Creates a new Capacity Reservation with the specified attributes. For more information, see `Capacity Reservations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html>`_ in the *Amazon EC2 User Guide* .

    :cloudformationResource: AWS::EC2::CapacityReservation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_capacity_reservation = ec2.CfnCapacityReservation(self, "MyCfnCapacityReservation",
            availability_zone="availabilityZone",
            instance_count=123,
            instance_platform="instancePlatform",
            instance_type="instanceType",
        
            # the properties below are optional
            ebs_optimized=False,
            end_date="endDate",
            end_date_type="endDateType",
            ephemeral_storage=False,
            instance_match_criteria="instanceMatchCriteria",
            out_post_arn="outPostArn",
            placement_group_arn="placementGroupArn",
            tag_specifications=[ec2.CfnCapacityReservation.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            tenancy="tenancy"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        instance_count: jsii.Number,
        instance_platform: builtins.str,
        instance_type: builtins.str,
        ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        end_date: typing.Optional[builtins.str] = None,
        end_date_type: typing.Optional[builtins.str] = None,
        ephemeral_storage: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        instance_match_criteria: typing.Optional[builtins.str] = None,
        out_post_arn: typing.Optional[builtins.str] = None,
        placement_group_arn: typing.Optional[builtins.str] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnCapacityReservation.TagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::CapacityReservation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param availability_zone: The Availability Zone in which to create the Capacity Reservation.
        :param instance_count: The number of instances for which to reserve capacity. Valid range: 1 - 1000
        :param instance_platform: The type of operating system for which to reserve capacity.
        :param instance_type: The instance type for which to reserve capacity. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .
        :param ebs_optimized: Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
        :param end_date: The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time. You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` . If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.
        :param end_date_type: Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types: - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` . - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .
        :param ephemeral_storage: Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.
        :param instance_match_criteria: Indicates the type of instance launches that the Capacity Reservation accepts. The options include:. - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters. - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. Default: ``open``
        :param out_post_arn: The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
        :param placement_group_arn: The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation. For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .
        :param tag_specifications: The tags to apply to the Capacity Reservation during launch.
        :param tenancy: Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:. - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .
        '''
        props = CfnCapacityReservationProps(
            availability_zone=availability_zone,
            instance_count=instance_count,
            instance_platform=instance_platform,
            instance_type=instance_type,
            ebs_optimized=ebs_optimized,
            end_date=end_date,
            end_date_type=end_date_type,
            ephemeral_storage=ephemeral_storage,
            instance_match_criteria=instance_match_criteria,
            out_post_arn=out_post_arn,
            placement_group_arn=placement_group_arn,
            tag_specifications=tag_specifications,
            tenancy=tenancy,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAvailabilityZone")
    def attr_availability_zone(self) -> builtins.str:
        '''Returns the Availability Zone in which the capacity is reserved.

        For example: ``us-east-1a`` .

        :cloudformationAttribute: AvailabilityZone
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAvailableInstanceCount")
    def attr_available_instance_count(self) -> jsii.Number:
        '''Returns the remaining capacity, which indicates the number of instances that can be launched in the Capacity Reservation.

        For example: ``9`` .

        :cloudformationAttribute: AvailableInstanceCount
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrAvailableInstanceCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrInstanceType")
    def attr_instance_type(self) -> builtins.str:
        '''Returns the type of instance for which the capacity is reserved.

        For example: ``m4.large`` .

        :cloudformationAttribute: InstanceType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrInstanceType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTenancy")
    def attr_tenancy(self) -> builtins.str:
        '''Returns the tenancy of the Capacity Reservation.

        For example: ``dedicated`` .

        :cloudformationAttribute: Tenancy
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTenancy"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTotalInstanceCount")
    def attr_total_instance_count(self) -> jsii.Number:
        '''Returns the total number of instances for which the Capacity Reservation reserves capacity.

        For example: ``15`` .

        :cloudformationAttribute: TotalInstanceCount
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrTotalInstanceCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to create the Capacity Reservation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
        '''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @availability_zone.setter
    def availability_zone(self, value: builtins.str) -> None:
        jsii.set(self, "availabilityZone", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceCount")
    def instance_count(self) -> jsii.Number:
        '''The number of instances for which to reserve capacity.

        Valid range: 1 - 1000

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
        '''
        return typing.cast(jsii.Number, jsii.get(self, "instanceCount"))

    @instance_count.setter
    def instance_count(self, value: jsii.Number) -> None:
        jsii.set(self, "instanceCount", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePlatform")
    def instance_platform(self) -> builtins.str:
        '''The type of operating system for which to reserve capacity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePlatform"))

    @instance_platform.setter
    def instance_platform(self, value: builtins.str) -> None:
        jsii.set(self, "instancePlatform", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> builtins.str:
        '''The instance type for which to reserve capacity.

        For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceType"))

    @instance_type.setter
    def instance_type(self, value: builtins.str) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ebsOptimized")
    def ebs_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the Capacity Reservation supports EBS-optimized instances.

        This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "ebsOptimized"))

    @ebs_optimized.setter
    def ebs_optimized(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "ebsOptimized", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endDate")
    def end_date(self) -> typing.Optional[builtins.str]:
        '''The date and time at which the Capacity Reservation expires.

        When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time.

        You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` .

        If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endDate"))

    @end_date.setter
    def end_date(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "endDate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endDateType")
    def end_date_type(self) -> typing.Optional[builtins.str]:
        '''Indicates the way in which the Capacity Reservation ends.

        A Capacity Reservation can have one of the following end types:

        - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` .
        - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endDateType"))

    @end_date_type.setter
    def end_date_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "endDateType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ephemeralStorage")
    def ephemeral_storage(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "ephemeralStorage"))

    @ephemeral_storage.setter
    def ephemeral_storage(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "ephemeralStorage", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceMatchCriteria")
    def instance_match_criteria(self) -> typing.Optional[builtins.str]:
        '''Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.

        - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
        - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.

        Default: ``open``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceMatchCriteria"))

    @instance_match_criteria.setter
    def instance_match_criteria(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceMatchCriteria", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="outPostArn")
    def out_post_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "outPostArn"))

    @out_post_arn.setter
    def out_post_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "outPostArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="placementGroupArn")
    def placement_group_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.

        For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "placementGroupArn"))

    @placement_group_arn.setter
    def placement_group_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "placementGroupArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagSpecifications")
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservation.TagSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The tags to apply to the Capacity Reservation during launch.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservation.TagSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "tagSpecifications"))

    @tag_specifications.setter
    def tag_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservation.TagSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "tagSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tenancy")
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.

        - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
        - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tenancy"))

    @tenancy.setter
    def tenancy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "tenancy", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservation.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        ) -> None:
            '''An array of key-value pairs to apply to this resource.

            For more information, see `Tag <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html>`_ .

            :param resource_type: The type of resource to tag. Specify ``capacity-reservation`` .
            :param tags: The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                tag_specification_property = ec2.CfnCapacityReservation.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            Specify ``capacity-reservation`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
            '''The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservation-tagspecification.html#cfn-ec2-capacityreservation-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_c2943556)
class CfnCapacityReservationFleet(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservationFleet",
):
    '''A CloudFormation ``AWS::EC2::CapacityReservationFleet``.

    Creates a new Capacity Reservation Fleet with the specified attributes. For more information, see `Capacity Reservation Fleets <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-fleets.html>`_ in the *Amazon EC2 User Guide* .

    :cloudformationResource: AWS::EC2::CapacityReservationFleet
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_capacity_reservation_fleet = ec2.CfnCapacityReservationFleet(self, "MyCfnCapacityReservationFleet",
            allocation_strategy="allocationStrategy",
            end_date="endDate",
            instance_match_criteria="instanceMatchCriteria",
            instance_type_specifications=[ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty(
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId",
                ebs_optimized=False,
                instance_platform="instancePlatform",
                instance_type="instanceType",
                priority=123,
                weight=123
            )],
            no_remove_end_date=False,
            remove_end_date=False,
            tag_specifications=[ec2.CfnCapacityReservationFleet.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            tenancy="tenancy",
            total_target_capacity=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        allocation_strategy: typing.Optional[builtins.str] = None,
        end_date: typing.Optional[builtins.str] = None,
        instance_match_criteria: typing.Optional[builtins.str] = None,
        instance_type_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnCapacityReservationFleet.InstanceTypeSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        no_remove_end_date: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        remove_end_date: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnCapacityReservationFleet.TagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        total_target_capacity: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::CapacityReservationFleet``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param allocation_strategy: The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use. Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the Amazon EC2 User Guide. Valid values: ``prioritized``
        :param end_date: The date and time at which the Capacity Reservation Fleet expires. When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire. The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .
        :param instance_match_criteria: Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria. Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
        :param instance_type_specifications: Information about the instance types for which to reserve the capacity.
        :param no_remove_end_date: ``AWS::EC2::CapacityReservationFleet.NoRemoveEndDate``.
        :param remove_end_date: ``AWS::EC2::CapacityReservationFleet.RemoveEndDate``.
        :param tag_specifications: The tags to assign to the Capacity Reservation Fleet. The tags are automatically assigned to the Capacity Reservations in the Fleet.
        :param tenancy: Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings: - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
        :param total_target_capacity: The total number of capacity units to be reserved by the Capacity Reservation Fleet. This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.
        '''
        props = CfnCapacityReservationFleetProps(
            allocation_strategy=allocation_strategy,
            end_date=end_date,
            instance_match_criteria=instance_match_criteria,
            instance_type_specifications=instance_type_specifications,
            no_remove_end_date=no_remove_end_date,
            remove_end_date=remove_end_date,
            tag_specifications=tag_specifications,
            tenancy=tenancy,
            total_target_capacity=total_target_capacity,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCapacityReservationFleetId")
    def attr_capacity_reservation_fleet_id(self) -> builtins.str:
        '''The ID of the Capacity Reservation Fleet.

        :cloudformationAttribute: CapacityReservationFleetId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCapacityReservationFleetId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationStrategy")
    def allocation_strategy(self) -> typing.Optional[builtins.str]:
        '''The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.

        Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the Amazon EC2 User Guide.

        Valid values: ``prioritized``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "allocationStrategy"))

    @allocation_strategy.setter
    def allocation_strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "allocationStrategy", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endDate")
    def end_date(self) -> typing.Optional[builtins.str]:
        '''The date and time at which the Capacity Reservation Fleet expires.

        When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire.

        The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "endDate"))

    @end_date.setter
    def end_date(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "endDate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceMatchCriteria")
    def instance_match_criteria(self) -> typing.Optional[builtins.str]:
        '''Indicates the type of instance launches that the Capacity Reservation Fleet accepts.

        All Capacity Reservations in the Fleet inherit this instance matching criteria.

        Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceMatchCriteria"))

    @instance_match_criteria.setter
    def instance_match_criteria(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceMatchCriteria", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceTypeSpecifications")
    def instance_type_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservationFleet.InstanceTypeSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''Information about the instance types for which to reserve the capacity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservationFleet.InstanceTypeSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "instanceTypeSpecifications"))

    @instance_type_specifications.setter
    def instance_type_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservationFleet.InstanceTypeSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "instanceTypeSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="noRemoveEndDate")
    def no_remove_end_date(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''``AWS::EC2::CapacityReservationFleet.NoRemoveEndDate``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "noRemoveEndDate"))

    @no_remove_end_date.setter
    def no_remove_end_date(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "noRemoveEndDate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="removeEndDate")
    def remove_end_date(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''``AWS::EC2::CapacityReservationFleet.RemoveEndDate``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "removeEndDate"))

    @remove_end_date.setter
    def remove_end_date(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "removeEndDate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagSpecifications")
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservationFleet.TagSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The tags to assign to the Capacity Reservation Fleet.

        The tags are automatically assigned to the Capacity Reservations in the Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservationFleet.TagSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "tagSpecifications"))

    @tag_specifications.setter
    def tag_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnCapacityReservationFleet.TagSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "tagSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tenancy")
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''Indicates the tenancy of the Capacity Reservation Fleet.

        All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:

        - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
        - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tenancy"))

    @tenancy.setter
    def tenancy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "tenancy", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="totalTargetCapacity")
    def total_target_capacity(self) -> typing.Optional[jsii.Number]:
        '''The total number of capacity units to be reserved by the Capacity Reservation Fleet.

        This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "totalTargetCapacity"))

    @total_target_capacity.setter
    def total_target_capacity(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "totalTargetCapacity", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "availability_zone_id": "availabilityZoneId",
            "ebs_optimized": "ebsOptimized",
            "instance_platform": "instancePlatform",
            "instance_type": "instanceType",
            "priority": "priority",
            "weight": "weight",
        },
    )
    class InstanceTypeSpecificationProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            availability_zone_id: typing.Optional[builtins.str] = None,
            ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            instance_platform: typing.Optional[builtins.str] = None,
            instance_type: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            weight: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies information about an instance type to use in a Capacity Reservation Fleet.

            ``InstanceTypeSpecification`` is a property of the `AWS::EC2::CapacityReservationFleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html>`_ resource.

            :param availability_zone: The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
            :param availability_zone_id: The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
            :param ebs_optimized: Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
            :param instance_platform: The type of operating system for which the Capacity Reservation Fleet reserves capacity.
            :param instance_type: The instance type for which the Capacity Reservation Fleet reserves capacity.
            :param priority: The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see `Instance type priority <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority>`_ in the Amazon EC2 User Guide.
            :param weight: The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide. Valid Range: Minimum value of ``0.001`` . Maximum value of ``99.999`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_type_specification_property = ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    ebs_optimized=False,
                    instance_platform="instancePlatform",
                    instance_type="instanceType",
                    priority=123,
                    weight=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if availability_zone_id is not None:
                self._values["availability_zone_id"] = availability_zone_id
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized
            if instance_platform is not None:
                self._values["instance_platform"] = instance_platform
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if priority is not None:
                self._values["priority"] = priority
            if weight is not None:
                self._values["weight"] = weight

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone in which the Capacity Reservation Fleet reserves the capacity.

            A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity.

            A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-availabilityzoneid
            '''
            result = self._values.get("availability_zone_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs_optimized(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types.

            This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-ebsoptimized
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_platform(self) -> typing.Optional[builtins.str]:
            '''The type of operating system for which the Capacity Reservation Fleet reserves capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instanceplatform
            '''
            result = self._values.get("instance_platform")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type for which the Capacity Reservation Fleet reserves capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            '''The priority to assign to the instance type.

            This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see `Instance type priority <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority>`_ in the Amazon EC2 User Guide.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-priority
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def weight(self) -> typing.Optional[jsii.Number]:
            '''The number of capacity units provided by the specified instance type.

            This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.

            Valid Range: Minimum value of ``0.001`` . Maximum value of ``99.999`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-instancetypespecification.html#cfn-ec2-capacityreservationfleet-instancetypespecification-weight
            '''
            result = self._values.get("weight")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceTypeSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservationFleet.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        ) -> None:
            '''The tags to apply to a resource when the resource is being created.

            :param resource_type: The type of resource to tag on creation. Specify ``capacity-reservation-fleet`` . To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .
            :param tags: The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                tag_specification_property = ec2.CfnCapacityReservationFleet.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag on creation. Specify ``capacity-reservation-fleet`` .

            To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
            '''The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-capacityreservationfleet-tagspecification.html#cfn-ec2-capacityreservationfleet-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservationFleetProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_strategy": "allocationStrategy",
        "end_date": "endDate",
        "instance_match_criteria": "instanceMatchCriteria",
        "instance_type_specifications": "instanceTypeSpecifications",
        "no_remove_end_date": "noRemoveEndDate",
        "remove_end_date": "removeEndDate",
        "tag_specifications": "tagSpecifications",
        "tenancy": "tenancy",
        "total_target_capacity": "totalTargetCapacity",
    },
)
class CfnCapacityReservationFleetProps:
    def __init__(
        self,
        *,
        allocation_strategy: typing.Optional[builtins.str] = None,
        end_date: typing.Optional[builtins.str] = None,
        instance_match_criteria: typing.Optional[builtins.str] = None,
        instance_type_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnCapacityReservationFleet.InstanceTypeSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        no_remove_end_date: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        remove_end_date: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnCapacityReservationFleet.TagSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        total_target_capacity: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for defining a ``CfnCapacityReservationFleet``.

        :param allocation_strategy: The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use. Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the Amazon EC2 User Guide. Valid values: ``prioritized``
        :param end_date: The date and time at which the Capacity Reservation Fleet expires. When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire. The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .
        :param instance_match_criteria: Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria. Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
        :param instance_type_specifications: Information about the instance types for which to reserve the capacity.
        :param no_remove_end_date: ``AWS::EC2::CapacityReservationFleet.NoRemoveEndDate``.
        :param remove_end_date: ``AWS::EC2::CapacityReservationFleet.RemoveEndDate``.
        :param tag_specifications: The tags to assign to the Capacity Reservation Fleet. The tags are automatically assigned to the Capacity Reservations in the Fleet.
        :param tenancy: Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings: - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
        :param total_target_capacity: The total number of capacity units to be reserved by the Capacity Reservation Fleet. This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_capacity_reservation_fleet_props = ec2.CfnCapacityReservationFleetProps(
                allocation_strategy="allocationStrategy",
                end_date="endDate",
                instance_match_criteria="instanceMatchCriteria",
                instance_type_specifications=[ec2.CfnCapacityReservationFleet.InstanceTypeSpecificationProperty(
                    availability_zone="availabilityZone",
                    availability_zone_id="availabilityZoneId",
                    ebs_optimized=False,
                    instance_platform="instancePlatform",
                    instance_type="instanceType",
                    priority=123,
                    weight=123
                )],
                no_remove_end_date=False,
                remove_end_date=False,
                tag_specifications=[ec2.CfnCapacityReservationFleet.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                tenancy="tenancy",
                total_target_capacity=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if allocation_strategy is not None:
            self._values["allocation_strategy"] = allocation_strategy
        if end_date is not None:
            self._values["end_date"] = end_date
        if instance_match_criteria is not None:
            self._values["instance_match_criteria"] = instance_match_criteria
        if instance_type_specifications is not None:
            self._values["instance_type_specifications"] = instance_type_specifications
        if no_remove_end_date is not None:
            self._values["no_remove_end_date"] = no_remove_end_date
        if remove_end_date is not None:
            self._values["remove_end_date"] = remove_end_date
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if total_target_capacity is not None:
            self._values["total_target_capacity"] = total_target_capacity

    @builtins.property
    def allocation_strategy(self) -> typing.Optional[builtins.str]:
        '''The strategy used by the Capacity Reservation Fleet to determine which of the specified instance types to use.

        Currently, only the ``prioritized`` allocation strategy is supported. For more information, see `Allocation strategy <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#allocation-strategy>`_ in the Amazon EC2 User Guide.

        Valid values: ``prioritized``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-allocationstrategy
        '''
        result = self._values.get("allocation_strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def end_date(self) -> typing.Optional[builtins.str]:
        '''The date and time at which the Capacity Reservation Fleet expires.

        When the Capacity Reservation Fleet expires, its state changes to ``expired`` and all of the Capacity Reservations in the Fleet expire.

        The Capacity Reservation Fleet expires within an hour after the specified time. For example, if you specify ``5/31/2019`` , ``13:30:55`` , the Capacity Reservation Fleet is guaranteed to expire between ``13:30:55`` and ``14:30:55`` on ``5/31/2019`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-enddate
        '''
        result = self._values.get("end_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_match_criteria(self) -> typing.Optional[builtins.str]:
        '''Indicates the type of instance launches that the Capacity Reservation Fleet accepts.

        All Capacity Reservations in the Fleet inherit this instance matching criteria.

        Currently, Capacity Reservation Fleets support ``open`` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancematchcriteria
        '''
        result = self._values.get("instance_match_criteria")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnCapacityReservationFleet.InstanceTypeSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''Information about the instance types for which to reserve the capacity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-instancetypespecifications
        '''
        result = self._values.get("instance_type_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnCapacityReservationFleet.InstanceTypeSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def no_remove_end_date(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''``AWS::EC2::CapacityReservationFleet.NoRemoveEndDate``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-noremoveenddate
        '''
        result = self._values.get("no_remove_end_date")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def remove_end_date(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''``AWS::EC2::CapacityReservationFleet.RemoveEndDate``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-removeenddate
        '''
        result = self._values.get("remove_end_date")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnCapacityReservationFleet.TagSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The tags to assign to the Capacity Reservation Fleet.

        The tags are automatically assigned to the Capacity Reservations in the Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnCapacityReservationFleet.TagSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''Indicates the tenancy of the Capacity Reservation Fleet.

        All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:

        - ``default`` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
        - ``dedicated`` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-tenancy
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def total_target_capacity(self) -> typing.Optional[jsii.Number]:
        '''The total number of capacity units to be reserved by the Capacity Reservation Fleet.

        This value, together with the instance type weights that you assign to each instance type used by the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see `Total target capacity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity>`_ in the Amazon EC2 User Guide.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservationfleet.html#cfn-ec2-capacityreservationfleet-totaltargetcapacity
        '''
        result = self._values.get("total_target_capacity")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCapacityReservationFleetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnCapacityReservationProps",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "instance_count": "instanceCount",
        "instance_platform": "instancePlatform",
        "instance_type": "instanceType",
        "ebs_optimized": "ebsOptimized",
        "end_date": "endDate",
        "end_date_type": "endDateType",
        "ephemeral_storage": "ephemeralStorage",
        "instance_match_criteria": "instanceMatchCriteria",
        "out_post_arn": "outPostArn",
        "placement_group_arn": "placementGroupArn",
        "tag_specifications": "tagSpecifications",
        "tenancy": "tenancy",
    },
)
class CfnCapacityReservationProps:
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        instance_count: jsii.Number,
        instance_platform: builtins.str,
        instance_type: builtins.str,
        ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        end_date: typing.Optional[builtins.str] = None,
        end_date_type: typing.Optional[builtins.str] = None,
        ephemeral_storage: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        instance_match_criteria: typing.Optional[builtins.str] = None,
        out_post_arn: typing.Optional[builtins.str] = None,
        placement_group_arn: typing.Optional[builtins.str] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnCapacityReservation.TagSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        tenancy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnCapacityReservation``.

        :param availability_zone: The Availability Zone in which to create the Capacity Reservation.
        :param instance_count: The number of instances for which to reserve capacity. Valid range: 1 - 1000
        :param instance_platform: The type of operating system for which to reserve capacity.
        :param instance_type: The instance type for which to reserve capacity. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .
        :param ebs_optimized: Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.
        :param end_date: The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time. You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` . If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.
        :param end_date_type: Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types: - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` . - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .
        :param ephemeral_storage: Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.
        :param instance_match_criteria: Indicates the type of instance launches that the Capacity Reservation accepts. The options include:. - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters. - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. Default: ``open``
        :param out_post_arn: The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.
        :param placement_group_arn: The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation. For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .
        :param tag_specifications: The tags to apply to the Capacity Reservation during launch.
        :param tenancy: Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:. - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts . - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_capacity_reservation_props = ec2.CfnCapacityReservationProps(
                availability_zone="availabilityZone",
                instance_count=123,
                instance_platform="instancePlatform",
                instance_type="instanceType",
            
                # the properties below are optional
                ebs_optimized=False,
                end_date="endDate",
                end_date_type="endDateType",
                ephemeral_storage=False,
                instance_match_criteria="instanceMatchCriteria",
                out_post_arn="outPostArn",
                placement_group_arn="placementGroupArn",
                tag_specifications=[ec2.CfnCapacityReservation.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                tenancy="tenancy"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
            "instance_count": instance_count,
            "instance_platform": instance_platform,
            "instance_type": instance_type,
        }
        if ebs_optimized is not None:
            self._values["ebs_optimized"] = ebs_optimized
        if end_date is not None:
            self._values["end_date"] = end_date
        if end_date_type is not None:
            self._values["end_date_type"] = end_date_type
        if ephemeral_storage is not None:
            self._values["ephemeral_storage"] = ephemeral_storage
        if instance_match_criteria is not None:
            self._values["instance_match_criteria"] = instance_match_criteria
        if out_post_arn is not None:
            self._values["out_post_arn"] = out_post_arn
        if placement_group_arn is not None:
            self._values["placement_group_arn"] = placement_group_arn
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if tenancy is not None:
            self._values["tenancy"] = tenancy

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to create the Capacity Reservation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-availabilityzone
        '''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_count(self) -> jsii.Number:
        '''The number of instances for which to reserve capacity.

        Valid range: 1 - 1000

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancecount
        '''
        result = self._values.get("instance_count")
        assert result is not None, "Required property 'instance_count' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def instance_platform(self) -> builtins.str:
        '''The type of operating system for which to reserve capacity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instanceplatform
        '''
        result = self._values.get("instance_platform")
        assert result is not None, "Required property 'instance_platform' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_type(self) -> builtins.str:
        '''The instance type for which to reserve capacity.

        For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancetype
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ebs_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the Capacity Reservation supports EBS-optimized instances.

        This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ebsoptimized
        '''
        result = self._values.get("ebs_optimized")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def end_date(self) -> typing.Optional[builtins.str]:
        '''The date and time at which the Capacity Reservation expires.

        When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to ``expired`` when it reaches its end date and time.

        You must provide an ``EndDate`` value if ``EndDateType`` is ``limited`` . Omit ``EndDate`` if ``EndDateType`` is ``unlimited`` .

        If the ``EndDateType`` is ``limited`` , the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddate
        '''
        result = self._values.get("end_date")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def end_date_type(self) -> typing.Optional[builtins.str]:
        '''Indicates the way in which the Capacity Reservation ends.

        A Capacity Reservation can have one of the following end types:

        - ``unlimited`` - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an ``EndDate`` if the ``EndDateType`` is ``unlimited`` .
        - ``limited`` - The Capacity Reservation expires automatically at a specified date and time. You must provide an ``EndDate`` value if the ``EndDateType`` value is ``limited`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-enddatetype
        '''
        result = self._values.get("end_date_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ephemeral_storage(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-ephemeralstorage
        '''
        result = self._values.get("ephemeral_storage")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def instance_match_criteria(self) -> typing.Optional[builtins.str]:
        '''Indicates the type of instance launches that the Capacity Reservation accepts. The options include:.

        - ``open`` - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.
        - ``targeted`` - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity.

        Default: ``open``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-instancematchcriteria
        '''
        result = self._values.get("instance_match_criteria")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def out_post_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost on which to create the Capacity Reservation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-outpostarn
        '''
        result = self._values.get("out_post_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def placement_group_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the cluster placement group in which to create the Capacity Reservation.

        For more information, see `Capacity Reservations for cluster placement groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/cr-cpg.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-placementgrouparn
        '''
        result = self._values.get("placement_group_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnCapacityReservation.TagSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The tags to apply to the Capacity Reservation during launch.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnCapacityReservation.TagSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:.

        - ``default`` - The Capacity Reservation is created on hardware that is shared with other AWS accounts .
        - ``dedicated`` - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-capacityreservation.html#cfn-ec2-capacityreservation-tenancy
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCapacityReservationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnCarrierGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnCarrierGateway",
):
    '''A CloudFormation ``AWS::EC2::CarrierGateway``.

    Creates a carrier gateway. For more information about carrier gateways, see `Carrier gateways <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#wavelength-carrier-gateway>`_ in the *AWS Wavelength Developer Guide* .

    :cloudformationResource: AWS::EC2::CarrierGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_carrier_gateway = ec2.CfnCarrierGateway(self, "MyCfnCarrierGateway",
            vpc_id="vpcId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::CarrierGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param vpc_id: The ID of the VPC associated with the carrier gateway.
        :param tags: The tags assigned to the carrier gateway.
        '''
        props = CfnCarrierGatewayProps(vpc_id=vpc_id, tags=tags)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCarrierGatewayId")
    def attr_carrier_gateway_id(self) -> builtins.str:
        '''The ID of the carrier gateway.

        :cloudformationAttribute: CarrierGatewayId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCarrierGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrOwnerId")
    def attr_owner_id(self) -> builtins.str:
        '''The AWS account ID of the owner of the carrier gateway.

        :cloudformationAttribute: OwnerId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrOwnerId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the carrier gateway.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags assigned to the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC associated with the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnCarrierGatewayProps",
    jsii_struct_bases=[],
    name_mapping={"vpc_id": "vpcId", "tags": "tags"},
)
class CfnCarrierGatewayProps:
    def __init__(
        self,
        *,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnCarrierGateway``.

        :param vpc_id: The ID of the VPC associated with the carrier gateway.
        :param tags: The tags assigned to the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_carrier_gateway_props = ec2.CfnCarrierGatewayProps(
                vpc_id="vpcId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC associated with the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags assigned to the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-carriergateway.html#cfn-ec2-carriergateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCarrierGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnClientVpnAuthorizationRule(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnAuthorizationRule",
):
    '''A CloudFormation ``AWS::EC2::ClientVpnAuthorizationRule``.

    Specifies an ingress authorization rule to add to a Client VPN endpoint. Ingress authorization rules act as firewall rules that grant access to networks. You must configure ingress authorization rules to enable clients to access resources in AWS or on-premises networks.

    :cloudformationResource: AWS::EC2::ClientVpnAuthorizationRule
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_client_vpn_authorization_rule = ec2.CfnClientVpnAuthorizationRule(self, "MyCfnClientVpnAuthorizationRule",
            client_vpn_endpoint_id="clientVpnEndpointId",
            target_network_cidr="targetNetworkCidr",
        
            # the properties below are optional
            access_group_id="accessGroupId",
            authorize_all_groups=False,
            description="description"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_vpn_endpoint_id: builtins.str,
        target_network_cidr: builtins.str,
        access_group_id: typing.Optional[builtins.str] = None,
        authorize_all_groups: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::ClientVpnAuthorizationRule``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint.
        :param target_network_cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
        :param access_group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Required if ``AuthorizeAllGroups`` is ``false`` or not specified.
        :param authorize_all_groups: Indicates whether to grant access to all clients. Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.
        :param description: A brief description of the authorization rule.
        '''
        props = CfnClientVpnAuthorizationRuleProps(
            client_vpn_endpoint_id=client_vpn_endpoint_id,
            target_network_cidr=target_network_cidr,
            access_group_id=access_group_id,
            authorize_all_groups=authorize_all_groups,
            description=description,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientVpnEndpointId")
    def client_vpn_endpoint_id(self) -> builtins.str:
        '''The ID of the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
        '''
        return typing.cast(builtins.str, jsii.get(self, "clientVpnEndpointId"))

    @client_vpn_endpoint_id.setter
    def client_vpn_endpoint_id(self, value: builtins.str) -> None:
        jsii.set(self, "clientVpnEndpointId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="targetNetworkCidr")
    def target_network_cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the network for which access is being authorized.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
        '''
        return typing.cast(builtins.str, jsii.get(self, "targetNetworkCidr"))

    @target_network_cidr.setter
    def target_network_cidr(self, value: builtins.str) -> None:
        jsii.set(self, "targetNetworkCidr", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="accessGroupId")
    def access_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.

        Required if ``AuthorizeAllGroups`` is ``false`` or not specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "accessGroupId"))

    @access_group_id.setter
    def access_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "accessGroupId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="authorizeAllGroups")
    def authorize_all_groups(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether to grant access to all clients.

        Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "authorizeAllGroups"))

    @authorize_all_groups.setter
    def authorize_all_groups(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "authorizeAllGroups", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnAuthorizationRuleProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_vpn_endpoint_id": "clientVpnEndpointId",
        "target_network_cidr": "targetNetworkCidr",
        "access_group_id": "accessGroupId",
        "authorize_all_groups": "authorizeAllGroups",
        "description": "description",
    },
)
class CfnClientVpnAuthorizationRuleProps:
    def __init__(
        self,
        *,
        client_vpn_endpoint_id: builtins.str,
        target_network_cidr: builtins.str,
        access_group_id: typing.Optional[builtins.str] = None,
        authorize_all_groups: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnClientVpnAuthorizationRule``.

        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint.
        :param target_network_cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
        :param access_group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Required if ``AuthorizeAllGroups`` is ``false`` or not specified.
        :param authorize_all_groups: Indicates whether to grant access to all clients. Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.
        :param description: A brief description of the authorization rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_client_vpn_authorization_rule_props = ec2.CfnClientVpnAuthorizationRuleProps(
                client_vpn_endpoint_id="clientVpnEndpointId",
                target_network_cidr="targetNetworkCidr",
            
                # the properties below are optional
                access_group_id="accessGroupId",
                authorize_all_groups=False,
                description="description"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "client_vpn_endpoint_id": client_vpn_endpoint_id,
            "target_network_cidr": target_network_cidr,
        }
        if access_group_id is not None:
            self._values["access_group_id"] = access_group_id
        if authorize_all_groups is not None:
            self._values["authorize_all_groups"] = authorize_all_groups
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def client_vpn_endpoint_id(self) -> builtins.str:
        '''The ID of the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-clientvpnendpointid
        '''
        result = self._values.get("client_vpn_endpoint_id")
        assert result is not None, "Required property 'client_vpn_endpoint_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_network_cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the network for which access is being authorized.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-targetnetworkcidr
        '''
        result = self._values.get("target_network_cidr")
        assert result is not None, "Required property 'target_network_cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def access_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.

        Required if ``AuthorizeAllGroups`` is ``false`` or not specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-accessgroupid
        '''
        result = self._values.get("access_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def authorize_all_groups(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether to grant access to all clients.

        Specify ``true`` to grant all clients who successfully establish a VPN connection access to the network. Must be set to ``true`` if ``AccessGroupId`` is not specified.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-authorizeallgroups
        '''
        result = self._values.get("authorize_all_groups")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnauthorizationrule.html#cfn-ec2-clientvpnauthorizationrule-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnAuthorizationRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnClientVpnEndpoint(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint",
):
    '''A CloudFormation ``AWS::EC2::ClientVpnEndpoint``.

    Specifies a Client VPN endpoint. A Client VPN endpoint is the resource you create and configure to enable and manage client VPN sessions. It is the destination endpoint at which all client VPN sessions are terminated.

    :cloudformationResource: AWS::EC2::ClientVpnEndpoint
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_client_vpn_endpoint = ec2.CfnClientVpnEndpoint(self, "MyCfnClientVpnEndpoint",
            authentication_options=[ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty(
                type="type",
        
                # the properties below are optional
                active_directory=ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(
                    directory_id="directoryId"
                ),
                federated_authentication=ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(
                    saml_provider_arn="samlProviderArn",
        
                    # the properties below are optional
                    self_service_saml_provider_arn="selfServiceSamlProviderArn"
                ),
                mutual_authentication=ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(
                    client_root_certificate_chain_arn="clientRootCertificateChainArn"
                )
            )],
            client_cidr_block="clientCidrBlock",
            connection_log_options=ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty(
                enabled=False,
        
                # the properties below are optional
                cloudwatch_log_group="cloudwatchLogGroup",
                cloudwatch_log_stream="cloudwatchLogStream"
            ),
            server_certificate_arn="serverCertificateArn",
        
            # the properties below are optional
            client_connect_options=ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty(
                enabled=False,
        
                # the properties below are optional
                lambda_function_arn="lambdaFunctionArn"
            ),
            client_login_banner_options=ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty(
                enabled=False,
        
                # the properties below are optional
                banner_text="bannerText"
            ),
            description="description",
            dns_servers=["dnsServers"],
            security_group_ids=["securityGroupIds"],
            self_service_portal="selfServicePortal",
            session_timeout_hours=123,
            split_tunnel=False,
            tag_specifications=[ec2.CfnClientVpnEndpoint.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            transport_protocol="transportProtocol",
            vpc_id="vpcId",
            vpn_port=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        authentication_options: typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnClientVpnEndpoint.ClientAuthenticationRequestProperty", _IResolvable_da3f097b]]],
        client_cidr_block: builtins.str,
        connection_log_options: typing.Union["CfnClientVpnEndpoint.ConnectionLogOptionsProperty", _IResolvable_da3f097b],
        server_certificate_arn: builtins.str,
        client_connect_options: typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientConnectOptionsProperty", _IResolvable_da3f097b]] = None,
        client_login_banner_options: typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty", _IResolvable_da3f097b]] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        self_service_portal: typing.Optional[builtins.str] = None,
        session_timeout_hours: typing.Optional[jsii.Number] = None,
        split_tunnel: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnClientVpnEndpoint.TagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        transport_protocol: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpn_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::ClientVpnEndpoint``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param authentication_options: Information about the authentication method to be used to authenticate clients.
        :param client_cidr_block: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. The CIDR block should be /22 or greater.
        :param connection_log_options: Information about the client connection logging options. If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged: - Client connection requests - Client connection results (successful and unsuccessful) - Reasons for unsuccessful client connection requests - Client connection termination time
        :param server_certificate_arn: The ARN of the server certificate. For more information, see the `AWS Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .
        :param client_connect_options: The options for managing connection authorization for new client connections.
        :param client_login_banner_options: Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
        :param description: A brief description of the Client VPN endpoint.
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
        :param security_group_ids: The IDs of one or more security groups to apply to the target network. You must also specify the ID of the VPC that contains the security groups.
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default Value: ``enabled``
        :param session_timeout_hours: The maximum VPN session duration time in hours. Valid values: ``8 | 10 | 12 | 24`` Default value: ``24``
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. By default, split-tunnel on a VPN endpoint is disabled. For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .
        :param tag_specifications: The tags to apply to the Client VPN endpoint during creation.
        :param transport_protocol: The transport protocol to be used by the VPN session. Default value: ``udp``
        :param vpc_id: The ID of the VPC to associate with the Client VPN endpoint. If no security group IDs are specified in the request, the default security group for the VPC is applied.
        :param vpn_port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Valid Values: ``443`` | ``1194`` Default Value: ``443``
        '''
        props = CfnClientVpnEndpointProps(
            authentication_options=authentication_options,
            client_cidr_block=client_cidr_block,
            connection_log_options=connection_log_options,
            server_certificate_arn=server_certificate_arn,
            client_connect_options=client_connect_options,
            client_login_banner_options=client_login_banner_options,
            description=description,
            dns_servers=dns_servers,
            security_group_ids=security_group_ids,
            self_service_portal=self_service_portal,
            session_timeout_hours=session_timeout_hours,
            split_tunnel=split_tunnel,
            tag_specifications=tag_specifications,
            transport_protocol=transport_protocol,
            vpc_id=vpc_id,
            vpn_port=vpn_port,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="authenticationOptions")
    def authentication_options(
        self,
    ) -> typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnClientVpnEndpoint.ClientAuthenticationRequestProperty", _IResolvable_da3f097b]]]:
        '''Information about the authentication method to be used to authenticate clients.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
        '''
        return typing.cast(typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnClientVpnEndpoint.ClientAuthenticationRequestProperty", _IResolvable_da3f097b]]], jsii.get(self, "authenticationOptions"))

    @authentication_options.setter
    def authentication_options(
        self,
        value: typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnClientVpnEndpoint.ClientAuthenticationRequestProperty", _IResolvable_da3f097b]]],
    ) -> None:
        jsii.set(self, "authenticationOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientCidrBlock")
    def client_cidr_block(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, from which to assign client IP addresses.

        The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. The CIDR block should be /22 or greater.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "clientCidrBlock"))

    @client_cidr_block.setter
    def client_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "clientCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connectionLogOptions")
    def connection_log_options(
        self,
    ) -> typing.Union["CfnClientVpnEndpoint.ConnectionLogOptionsProperty", _IResolvable_da3f097b]:
        '''Information about the client connection logging options.

        If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:

        - Client connection requests
        - Client connection results (successful and unsuccessful)
        - Reasons for unsuccessful client connection requests
        - Client connection termination time

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
        '''
        return typing.cast(typing.Union["CfnClientVpnEndpoint.ConnectionLogOptionsProperty", _IResolvable_da3f097b], jsii.get(self, "connectionLogOptions"))

    @connection_log_options.setter
    def connection_log_options(
        self,
        value: typing.Union["CfnClientVpnEndpoint.ConnectionLogOptionsProperty", _IResolvable_da3f097b],
    ) -> None:
        jsii.set(self, "connectionLogOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serverCertificateArn")
    def server_certificate_arn(self) -> builtins.str:
        '''The ARN of the server certificate.

        For more information, see the `AWS Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
        '''
        return typing.cast(builtins.str, jsii.get(self, "serverCertificateArn"))

    @server_certificate_arn.setter
    def server_certificate_arn(self, value: builtins.str) -> None:
        jsii.set(self, "serverCertificateArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientConnectOptions")
    def client_connect_options(
        self,
    ) -> typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientConnectOptionsProperty", _IResolvable_da3f097b]]:
        '''The options for managing connection authorization for new client connections.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientConnectOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "clientConnectOptions"))

    @client_connect_options.setter
    def client_connect_options(
        self,
        value: typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientConnectOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "clientConnectOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientLoginBannerOptions")
    def client_login_banner_options(
        self,
    ) -> typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty", _IResolvable_da3f097b]]:
        '''Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "clientLoginBannerOptions"))

    @client_login_banner_options.setter
    def client_login_banner_options(
        self,
        value: typing.Optional[typing.Union["CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "clientLoginBannerOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dnsServers")
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Information about the DNS servers to be used for DNS resolution.

        A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "dnsServers"))

    @dns_servers.setter
    def dns_servers(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "dnsServers", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more security groups to apply to the target network.

        You must also specify the ID of the VPC that contains the security groups.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "securityGroupIds"))

    @security_group_ids.setter
    def security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="selfServicePortal")
    def self_service_portal(self) -> typing.Optional[builtins.str]:
        '''Specify whether to enable the self-service portal for the Client VPN endpoint.

        Default Value: ``enabled``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "selfServicePortal"))

    @self_service_portal.setter
    def self_service_portal(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "selfServicePortal", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sessionTimeoutHours")
    def session_timeout_hours(self) -> typing.Optional[jsii.Number]:
        '''The maximum VPN session duration time in hours.

        Valid values: ``8 | 10 | 12 | 24``

        Default value: ``24``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "sessionTimeoutHours"))

    @session_timeout_hours.setter
    def session_timeout_hours(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "sessionTimeoutHours", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="splitTunnel")
    def split_tunnel(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.

        By default, split-tunnel on a VPN endpoint is disabled.

        For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "splitTunnel"))

    @split_tunnel.setter
    def split_tunnel(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "splitTunnel", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagSpecifications")
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnClientVpnEndpoint.TagSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The tags to apply to the Client VPN endpoint during creation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnClientVpnEndpoint.TagSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "tagSpecifications"))

    @tag_specifications.setter
    def tag_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnClientVpnEndpoint.TagSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "tagSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transportProtocol")
    def transport_protocol(self) -> typing.Optional[builtins.str]:
        '''The transport protocol to be used by the VPN session.

        Default value: ``udp``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transportProtocol"))

    @transport_protocol.setter
    def transport_protocol(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "transportProtocol", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC to associate with the Client VPN endpoint.

        If no security group IDs are specified in the request, the default security group for the VPC is applied.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnPort")
    def vpn_port(self) -> typing.Optional[jsii.Number]:
        '''The port number to assign to the Client VPN endpoint for TCP and UDP traffic.

        Valid Values: ``443`` | ``1194``

        Default Value: ``443``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "vpnPort"))

    @vpn_port.setter
    def vpn_port(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "vpnPort", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "client_root_certificate_chain_arn": "clientRootCertificateChainArn",
        },
    )
    class CertificateAuthenticationRequestProperty:
        def __init__(self, *, client_root_certificate_chain_arn: builtins.str) -> None:
            '''Information about the client certificate to be used for authentication.

            :param client_root_certificate_chain_arn: The ARN of the client certificate. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                certificate_authentication_request_property = ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(
                    client_root_certificate_chain_arn="clientRootCertificateChainArn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "client_root_certificate_chain_arn": client_root_certificate_chain_arn,
            }

        @builtins.property
        def client_root_certificate_chain_arn(self) -> builtins.str:
            '''The ARN of the client certificate.

            The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-certificateauthenticationrequest.html#cfn-ec2-clientvpnendpoint-certificateauthenticationrequest-clientrootcertificatechainarn
            '''
            result = self._values.get("client_root_certificate_chain_arn")
            assert result is not None, "Required property 'client_root_certificate_chain_arn' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CertificateAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "type": "type",
            "active_directory": "activeDirectory",
            "federated_authentication": "federatedAuthentication",
            "mutual_authentication": "mutualAuthentication",
        },
    )
    class ClientAuthenticationRequestProperty:
        def __init__(
            self,
            *,
            type: builtins.str,
            active_directory: typing.Optional[typing.Union["CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty", _IResolvable_da3f097b]] = None,
            federated_authentication: typing.Optional[typing.Union["CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty", _IResolvable_da3f097b]] = None,
            mutual_authentication: typing.Optional[typing.Union["CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes the authentication method to be used by a Client VPN endpoint.

            For more information, see `Authentication <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication>`_ in the *AWS Client VPN Administrator Guide* .

            :param type: The type of client authentication to be used.
            :param active_directory: Information about the Active Directory to be used, if applicable. You must provide this information if *Type* is ``directory-service-authentication`` .
            :param federated_authentication: Information about the IAM SAML identity provider, if applicable.
            :param mutual_authentication: Information about the authentication certificates to be used, if applicable. You must provide this information if *Type* is ``certificate-authentication`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                client_authentication_request_property = ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty(
                    type="type",
                
                    # the properties below are optional
                    active_directory=ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(
                        directory_id="directoryId"
                    ),
                    federated_authentication=ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(
                        saml_provider_arn="samlProviderArn",
                
                        # the properties below are optional
                        self_service_saml_provider_arn="selfServiceSamlProviderArn"
                    ),
                    mutual_authentication=ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(
                        client_root_certificate_chain_arn="clientRootCertificateChainArn"
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "type": type,
            }
            if active_directory is not None:
                self._values["active_directory"] = active_directory
            if federated_authentication is not None:
                self._values["federated_authentication"] = federated_authentication
            if mutual_authentication is not None:
                self._values["mutual_authentication"] = mutual_authentication

        @builtins.property
        def type(self) -> builtins.str:
            '''The type of client authentication to be used.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-type
            '''
            result = self._values.get("type")
            assert result is not None, "Required property 'type' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def active_directory(
            self,
        ) -> typing.Optional[typing.Union["CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty", _IResolvable_da3f097b]]:
            '''Information about the Active Directory to be used, if applicable.

            You must provide this information if *Type* is ``directory-service-authentication`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-activedirectory
            '''
            result = self._values.get("active_directory")
            return typing.cast(typing.Optional[typing.Union["CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def federated_authentication(
            self,
        ) -> typing.Optional[typing.Union["CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty", _IResolvable_da3f097b]]:
            '''Information about the IAM SAML identity provider, if applicable.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-federatedauthentication
            '''
            result = self._values.get("federated_authentication")
            return typing.cast(typing.Optional[typing.Union["CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def mutual_authentication(
            self,
        ) -> typing.Optional[typing.Union["CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty", _IResolvable_da3f097b]]:
            '''Information about the authentication certificates to be used, if applicable.

            You must provide this information if *Type* is ``certificate-authentication`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientauthenticationrequest.html#cfn-ec2-clientvpnendpoint-clientauthenticationrequest-mutualauthentication
            '''
            result = self._values.get("mutual_authentication")
            return typing.cast(typing.Optional[typing.Union["CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enabled": "enabled",
            "lambda_function_arn": "lambdaFunctionArn",
        },
    )
    class ClientConnectOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Union[builtins.bool, _IResolvable_da3f097b],
            lambda_function_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Indicates whether client connect options are enabled.

            The default is ``false`` (not enabled).

            :param enabled: Indicates whether client connect options are enabled. The default is ``false`` (not enabled).
            :param lambda_function_arn: The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                client_connect_options_property = ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty(
                    enabled=False,
                
                    # the properties below are optional
                    lambda_function_arn="lambdaFunctionArn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "enabled": enabled,
            }
            if lambda_function_arn is not None:
                self._values["lambda_function_arn"] = lambda_function_arn

        @builtins.property
        def enabled(self) -> typing.Union[builtins.bool, _IResolvable_da3f097b]:
            '''Indicates whether client connect options are enabled.

            The default is ``false`` (not enabled).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-enabled
            '''
            result = self._values.get("enabled")
            assert result is not None, "Required property 'enabled' is missing"
            return typing.cast(typing.Union[builtins.bool, _IResolvable_da3f097b], result)

        @builtins.property
        def lambda_function_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the AWS Lambda function used for connection authorization.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientconnectoptions.html#cfn-ec2-clientvpnendpoint-clientconnectoptions-lambdafunctionarn
            '''
            result = self._values.get("lambda_function_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientConnectOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled", "banner_text": "bannerText"},
    )
    class ClientLoginBannerOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Union[builtins.bool, _IResolvable_da3f097b],
            banner_text: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

            :param enabled: Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established. Valid values: ``true | false`` Default value: ``false``
            :param banner_text: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                client_login_banner_options_property = ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty(
                    enabled=False,
                
                    # the properties below are optional
                    banner_text="bannerText"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "enabled": enabled,
            }
            if banner_text is not None:
                self._values["banner_text"] = banner_text

        @builtins.property
        def enabled(self) -> typing.Union[builtins.bool, _IResolvable_da3f097b]:
            '''Enable or disable a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

            Valid values: ``true | false``

            Default value: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-enabled
            '''
            result = self._values.get("enabled")
            assert result is not None, "Required property 'enabled' is missing"
            return typing.cast(typing.Union[builtins.bool, _IResolvable_da3f097b], result)

        @builtins.property
        def banner_text(self) -> typing.Optional[builtins.str]:
            '''Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established.

            UTF-8 encoded characters only. Maximum of 1400 characters.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-clientloginbanneroptions.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions-bannertext
            '''
            result = self._values.get("banner_text")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClientLoginBannerOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enabled": "enabled",
            "cloudwatch_log_group": "cloudwatchLogGroup",
            "cloudwatch_log_stream": "cloudwatchLogStream",
        },
    )
    class ConnectionLogOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Union[builtins.bool, _IResolvable_da3f097b],
            cloudwatch_log_group: typing.Optional[builtins.str] = None,
            cloudwatch_log_stream: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the client connection logging options for the Client VPN endpoint.

            :param enabled: Indicates whether connection logging is enabled.
            :param cloudwatch_log_group: The name of the CloudWatch Logs log group. Required if connection logging is enabled.
            :param cloudwatch_log_stream: The name of the CloudWatch Logs log stream to which the connection data is published.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                connection_log_options_property = ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty(
                    enabled=False,
                
                    # the properties below are optional
                    cloudwatch_log_group="cloudwatchLogGroup",
                    cloudwatch_log_stream="cloudwatchLogStream"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "enabled": enabled,
            }
            if cloudwatch_log_group is not None:
                self._values["cloudwatch_log_group"] = cloudwatch_log_group
            if cloudwatch_log_stream is not None:
                self._values["cloudwatch_log_stream"] = cloudwatch_log_stream

        @builtins.property
        def enabled(self) -> typing.Union[builtins.bool, _IResolvable_da3f097b]:
            '''Indicates whether connection logging is enabled.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-enabled
            '''
            result = self._values.get("enabled")
            assert result is not None, "Required property 'enabled' is missing"
            return typing.cast(typing.Union[builtins.bool, _IResolvable_da3f097b], result)

        @builtins.property
        def cloudwatch_log_group(self) -> typing.Optional[builtins.str]:
            '''The name of the CloudWatch Logs log group.

            Required if connection logging is enabled.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchloggroup
            '''
            result = self._values.get("cloudwatch_log_group")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cloudwatch_log_stream(self) -> typing.Optional[builtins.str]:
            '''The name of the CloudWatch Logs log stream to which the connection data is published.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-connectionlogoptions.html#cfn-ec2-clientvpnendpoint-connectionlogoptions-cloudwatchlogstream
            '''
            result = self._values.get("cloudwatch_log_stream")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ConnectionLogOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"directory_id": "directoryId"},
    )
    class DirectoryServiceAuthenticationRequestProperty:
        def __init__(self, *, directory_id: builtins.str) -> None:
            '''Describes the Active Directory to be used for client authentication.

            :param directory_id: The ID of the Active Directory to be used for authentication.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                directory_service_authentication_request_property = ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(
                    directory_id="directoryId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "directory_id": directory_id,
            }

        @builtins.property
        def directory_id(self) -> builtins.str:
            '''The ID of the Active Directory to be used for authentication.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-directoryserviceauthenticationrequest.html#cfn-ec2-clientvpnendpoint-directoryserviceauthenticationrequest-directoryid
            '''
            result = self._values.get("directory_id")
            assert result is not None, "Required property 'directory_id' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "DirectoryServiceAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "saml_provider_arn": "samlProviderArn",
            "self_service_saml_provider_arn": "selfServiceSamlProviderArn",
        },
    )
    class FederatedAuthenticationRequestProperty:
        def __init__(
            self,
            *,
            saml_provider_arn: builtins.str,
            self_service_saml_provider_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The IAM SAML identity provider used for federated authentication.

            :param saml_provider_arn: The Amazon Resource Name (ARN) of the IAM SAML identity provider.
            :param self_service_saml_provider_arn: The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                federated_authentication_request_property = ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(
                    saml_provider_arn="samlProviderArn",
                
                    # the properties below are optional
                    self_service_saml_provider_arn="selfServiceSamlProviderArn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "saml_provider_arn": saml_provider_arn,
            }
            if self_service_saml_provider_arn is not None:
                self._values["self_service_saml_provider_arn"] = self_service_saml_provider_arn

        @builtins.property
        def saml_provider_arn(self) -> builtins.str:
            '''The Amazon Resource Name (ARN) of the IAM SAML identity provider.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-samlproviderarn
            '''
            result = self._values.get("saml_provider_arn")
            assert result is not None, "Required property 'saml_provider_arn' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def self_service_saml_provider_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-federatedauthenticationrequest.html#cfn-ec2-clientvpnendpoint-federatedauthenticationrequest-selfservicesamlproviderarn
            '''
            result = self._values.get("self_service_saml_provider_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FederatedAuthenticationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpoint.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: builtins.str,
            tags: typing.Sequence[_CfnTag_f6864754],
        ) -> None:
            '''The tags to apply to a resource when the resource is being created.

            :param resource_type: The type of resource to tag.
            :param tags: The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                tag_specification_property = ec2.CfnClientVpnEndpoint.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "resource_type": resource_type,
                "tags": tags,
            }

        @builtins.property
        def resource_type(self) -> builtins.str:
            '''The type of resource to tag.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            assert result is not None, "Required property 'resource_type' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def tags(self) -> typing.List[_CfnTag_f6864754]:
            '''The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-clientvpnendpoint-tagspecification.html#cfn-ec2-clientvpnendpoint-tagspecification-tags
            '''
            result = self._values.get("tags")
            assert result is not None, "Required property 'tags' is missing"
            return typing.cast(typing.List[_CfnTag_f6864754], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnEndpointProps",
    jsii_struct_bases=[],
    name_mapping={
        "authentication_options": "authenticationOptions",
        "client_cidr_block": "clientCidrBlock",
        "connection_log_options": "connectionLogOptions",
        "server_certificate_arn": "serverCertificateArn",
        "client_connect_options": "clientConnectOptions",
        "client_login_banner_options": "clientLoginBannerOptions",
        "description": "description",
        "dns_servers": "dnsServers",
        "security_group_ids": "securityGroupIds",
        "self_service_portal": "selfServicePortal",
        "session_timeout_hours": "sessionTimeoutHours",
        "split_tunnel": "splitTunnel",
        "tag_specifications": "tagSpecifications",
        "transport_protocol": "transportProtocol",
        "vpc_id": "vpcId",
        "vpn_port": "vpnPort",
    },
)
class CfnClientVpnEndpointProps:
    def __init__(
        self,
        *,
        authentication_options: typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnClientVpnEndpoint.ClientAuthenticationRequestProperty, _IResolvable_da3f097b]]],
        client_cidr_block: builtins.str,
        connection_log_options: typing.Union[CfnClientVpnEndpoint.ConnectionLogOptionsProperty, _IResolvable_da3f097b],
        server_certificate_arn: builtins.str,
        client_connect_options: typing.Optional[typing.Union[CfnClientVpnEndpoint.ClientConnectOptionsProperty, _IResolvable_da3f097b]] = None,
        client_login_banner_options: typing.Optional[typing.Union[CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty, _IResolvable_da3f097b]] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        self_service_portal: typing.Optional[builtins.str] = None,
        session_timeout_hours: typing.Optional[jsii.Number] = None,
        split_tunnel: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnClientVpnEndpoint.TagSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        transport_protocol: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpn_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for defining a ``CfnClientVpnEndpoint``.

        :param authentication_options: Information about the authentication method to be used to authenticate clients.
        :param client_cidr_block: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. The CIDR block should be /22 or greater.
        :param connection_log_options: Information about the client connection logging options. If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged: - Client connection requests - Client connection results (successful and unsuccessful) - Reasons for unsuccessful client connection requests - Client connection termination time
        :param server_certificate_arn: The ARN of the server certificate. For more information, see the `AWS Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .
        :param client_connect_options: The options for managing connection authorization for new client connections.
        :param client_login_banner_options: Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.
        :param description: A brief description of the Client VPN endpoint.
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.
        :param security_group_ids: The IDs of one or more security groups to apply to the target network. You must also specify the ID of the VPC that contains the security groups.
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default Value: ``enabled``
        :param session_timeout_hours: The maximum VPN session duration time in hours. Valid values: ``8 | 10 | 12 | 24`` Default value: ``24``
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. By default, split-tunnel on a VPN endpoint is disabled. For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .
        :param tag_specifications: The tags to apply to the Client VPN endpoint during creation.
        :param transport_protocol: The transport protocol to be used by the VPN session. Default value: ``udp``
        :param vpc_id: The ID of the VPC to associate with the Client VPN endpoint. If no security group IDs are specified in the request, the default security group for the VPC is applied.
        :param vpn_port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Valid Values: ``443`` | ``1194`` Default Value: ``443``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_client_vpn_endpoint_props = ec2.CfnClientVpnEndpointProps(
                authentication_options=[ec2.CfnClientVpnEndpoint.ClientAuthenticationRequestProperty(
                    type="type",
            
                    # the properties below are optional
                    active_directory=ec2.CfnClientVpnEndpoint.DirectoryServiceAuthenticationRequestProperty(
                        directory_id="directoryId"
                    ),
                    federated_authentication=ec2.CfnClientVpnEndpoint.FederatedAuthenticationRequestProperty(
                        saml_provider_arn="samlProviderArn",
            
                        # the properties below are optional
                        self_service_saml_provider_arn="selfServiceSamlProviderArn"
                    ),
                    mutual_authentication=ec2.CfnClientVpnEndpoint.CertificateAuthenticationRequestProperty(
                        client_root_certificate_chain_arn="clientRootCertificateChainArn"
                    )
                )],
                client_cidr_block="clientCidrBlock",
                connection_log_options=ec2.CfnClientVpnEndpoint.ConnectionLogOptionsProperty(
                    enabled=False,
            
                    # the properties below are optional
                    cloudwatch_log_group="cloudwatchLogGroup",
                    cloudwatch_log_stream="cloudwatchLogStream"
                ),
                server_certificate_arn="serverCertificateArn",
            
                # the properties below are optional
                client_connect_options=ec2.CfnClientVpnEndpoint.ClientConnectOptionsProperty(
                    enabled=False,
            
                    # the properties below are optional
                    lambda_function_arn="lambdaFunctionArn"
                ),
                client_login_banner_options=ec2.CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty(
                    enabled=False,
            
                    # the properties below are optional
                    banner_text="bannerText"
                ),
                description="description",
                dns_servers=["dnsServers"],
                security_group_ids=["securityGroupIds"],
                self_service_portal="selfServicePortal",
                session_timeout_hours=123,
                split_tunnel=False,
                tag_specifications=[ec2.CfnClientVpnEndpoint.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                transport_protocol="transportProtocol",
                vpc_id="vpcId",
                vpn_port=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "authentication_options": authentication_options,
            "client_cidr_block": client_cidr_block,
            "connection_log_options": connection_log_options,
            "server_certificate_arn": server_certificate_arn,
        }
        if client_connect_options is not None:
            self._values["client_connect_options"] = client_connect_options
        if client_login_banner_options is not None:
            self._values["client_login_banner_options"] = client_login_banner_options
        if description is not None:
            self._values["description"] = description
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if self_service_portal is not None:
            self._values["self_service_portal"] = self_service_portal
        if session_timeout_hours is not None:
            self._values["session_timeout_hours"] = session_timeout_hours
        if split_tunnel is not None:
            self._values["split_tunnel"] = split_tunnel
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if transport_protocol is not None:
            self._values["transport_protocol"] = transport_protocol
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if vpn_port is not None:
            self._values["vpn_port"] = vpn_port

    @builtins.property
    def authentication_options(
        self,
    ) -> typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnClientVpnEndpoint.ClientAuthenticationRequestProperty, _IResolvable_da3f097b]]]:
        '''Information about the authentication method to be used to authenticate clients.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-authenticationoptions
        '''
        result = self._values.get("authentication_options")
        assert result is not None, "Required property 'authentication_options' is missing"
        return typing.cast(typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnClientVpnEndpoint.ClientAuthenticationRequestProperty, _IResolvable_da3f097b]]], result)

    @builtins.property
    def client_cidr_block(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, from which to assign client IP addresses.

        The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. The address range cannot be changed after the Client VPN endpoint has been created. The CIDR block should be /22 or greater.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientcidrblock
        '''
        result = self._values.get("client_cidr_block")
        assert result is not None, "Required property 'client_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def connection_log_options(
        self,
    ) -> typing.Union[CfnClientVpnEndpoint.ConnectionLogOptionsProperty, _IResolvable_da3f097b]:
        '''Information about the client connection logging options.

        If you enable client connection logging, data about client connections is sent to a Cloudwatch Logs log stream. The following information is logged:

        - Client connection requests
        - Client connection results (successful and unsuccessful)
        - Reasons for unsuccessful client connection requests
        - Client connection termination time

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-connectionlogoptions
        '''
        result = self._values.get("connection_log_options")
        assert result is not None, "Required property 'connection_log_options' is missing"
        return typing.cast(typing.Union[CfnClientVpnEndpoint.ConnectionLogOptionsProperty, _IResolvable_da3f097b], result)

    @builtins.property
    def server_certificate_arn(self) -> builtins.str:
        '''The ARN of the server certificate.

        For more information, see the `AWS Certificate Manager User Guide <https://docs.aws.amazon.com/acm/latest/userguide/>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-servercertificatearn
        '''
        result = self._values.get("server_certificate_arn")
        assert result is not None, "Required property 'server_certificate_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def client_connect_options(
        self,
    ) -> typing.Optional[typing.Union[CfnClientVpnEndpoint.ClientConnectOptionsProperty, _IResolvable_da3f097b]]:
        '''The options for managing connection authorization for new client connections.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientconnectoptions
        '''
        result = self._values.get("client_connect_options")
        return typing.cast(typing.Optional[typing.Union[CfnClientVpnEndpoint.ClientConnectOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def client_login_banner_options(
        self,
    ) -> typing.Optional[typing.Union[CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty, _IResolvable_da3f097b]]:
        '''Options for enabling a customizable text banner that will be displayed on AWS provided clients when a VPN session is established.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-clientloginbanneroptions
        '''
        result = self._values.get("client_login_banner_options")
        return typing.cast(typing.Optional[typing.Union[CfnClientVpnEndpoint.ClientLoginBannerOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Information about the DNS servers to be used for DNS resolution.

        A Client VPN endpoint can have up to two DNS servers. If no DNS server is specified, the DNS address configured on the device is used for the DNS server.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-dnsservers
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more security groups to apply to the target network.

        You must also specify the ID of the VPC that contains the security groups.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def self_service_portal(self) -> typing.Optional[builtins.str]:
        '''Specify whether to enable the self-service portal for the Client VPN endpoint.

        Default Value: ``enabled``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-selfserviceportal
        '''
        result = self._values.get("self_service_portal")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def session_timeout_hours(self) -> typing.Optional[jsii.Number]:
        '''The maximum VPN session duration time in hours.

        Valid values: ``8 | 10 | 12 | 24``

        Default value: ``24``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-sessiontimeouthours
        '''
        result = self._values.get("session_timeout_hours")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def split_tunnel(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.

        By default, split-tunnel on a VPN endpoint is disabled.

        For information about split-tunnel VPN endpoints, see `Split-tunnel AWS Client VPN endpoint <https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html>`_ in the *AWS Client VPN Administrator Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-splittunnel
        '''
        result = self._values.get("split_tunnel")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnClientVpnEndpoint.TagSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The tags to apply to the Client VPN endpoint during creation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnClientVpnEndpoint.TagSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def transport_protocol(self) -> typing.Optional[builtins.str]:
        '''The transport protocol to be used by the VPN session.

        Default value: ``udp``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-transportprotocol
        '''
        result = self._values.get("transport_protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC to associate with the Client VPN endpoint.

        If no security group IDs are specified in the request, the default security group for the VPC is applied.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_port(self) -> typing.Optional[jsii.Number]:
        '''The port number to assign to the Client VPN endpoint for TCP and UDP traffic.

        Valid Values: ``443`` | ``1194``

        Default Value: ``443``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnendpoint.html#cfn-ec2-clientvpnendpoint-vpnport
        '''
        result = self._values.get("vpn_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnClientVpnRoute(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnRoute",
):
    '''A CloudFormation ``AWS::EC2::ClientVpnRoute``.

    Specifies a network route to add to a Client VPN endpoint. Each Client VPN endpoint has a route table that describes the available destination network routes. Each route in the route table specifies the path for traffic to specific resources or networks.

    A target network association must be created before you can specify a route. If you're setting up all the components of a Client VPN endpoint at the same time, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the ``AWS::EC2::ClientVpnTargetNetworkAssociation`` resource.

    :cloudformationResource: AWS::EC2::ClientVpnRoute
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_client_vpn_route = ec2.CfnClientVpnRoute(self, "MyCfnClientVpnRoute",
            client_vpn_endpoint_id="clientVpnEndpointId",
            destination_cidr_block="destinationCidrBlock",
            target_vpc_subnet_id="targetVpcSubnetId",
        
            # the properties below are optional
            description="description"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_vpn_endpoint_id: builtins.str,
        destination_cidr_block: builtins.str,
        target_vpc_subnet_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::ClientVpnRoute``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint to which to add the route.
        :param destination_cidr_block: The IPv4 address range, in CIDR notation, of the route destination. For example:. - To add a route for Internet access, enter ``0.0.0.0/0`` - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target_vpc_subnet_id: The ID of the subnet through which you want to route traffic. The specified subnet must be an existing target network of the Client VPN endpoint. Alternatively, if you're adding a route for the local network, specify ``local`` .
        :param description: A brief description of the route.
        '''
        props = CfnClientVpnRouteProps(
            client_vpn_endpoint_id=client_vpn_endpoint_id,
            destination_cidr_block=destination_cidr_block,
            target_vpc_subnet_id=target_vpc_subnet_id,
            description=description,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientVpnEndpointId")
    def client_vpn_endpoint_id(self) -> builtins.str:
        '''The ID of the Client VPN endpoint to which to add the route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
        '''
        return typing.cast(builtins.str, jsii.get(self, "clientVpnEndpointId"))

    @client_vpn_endpoint_id.setter
    def client_vpn_endpoint_id(self, value: builtins.str) -> None:
        jsii.set(self, "clientVpnEndpointId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the route destination. For example:.

        - To add a route for Internet access, enter ``0.0.0.0/0``
        - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
        - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range
        - To add a route for the local network, enter the client CIDR range

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "destinationCidrBlock"))

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="targetVpcSubnetId")
    def target_vpc_subnet_id(self) -> builtins.str:
        '''The ID of the subnet through which you want to route traffic.

        The specified subnet must be an existing target network of the Client VPN endpoint.

        Alternatively, if you're adding a route for the local network, specify ``local`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "targetVpcSubnetId"))

    @target_vpc_subnet_id.setter
    def target_vpc_subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "targetVpcSubnetId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_vpn_endpoint_id": "clientVpnEndpointId",
        "destination_cidr_block": "destinationCidrBlock",
        "target_vpc_subnet_id": "targetVpcSubnetId",
        "description": "description",
    },
)
class CfnClientVpnRouteProps:
    def __init__(
        self,
        *,
        client_vpn_endpoint_id: builtins.str,
        destination_cidr_block: builtins.str,
        target_vpc_subnet_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnClientVpnRoute``.

        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint to which to add the route.
        :param destination_cidr_block: The IPv4 address range, in CIDR notation, of the route destination. For example:. - To add a route for Internet access, enter ``0.0.0.0/0`` - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target_vpc_subnet_id: The ID of the subnet through which you want to route traffic. The specified subnet must be an existing target network of the Client VPN endpoint. Alternatively, if you're adding a route for the local network, specify ``local`` .
        :param description: A brief description of the route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_client_vpn_route_props = ec2.CfnClientVpnRouteProps(
                client_vpn_endpoint_id="clientVpnEndpointId",
                destination_cidr_block="destinationCidrBlock",
                target_vpc_subnet_id="targetVpcSubnetId",
            
                # the properties below are optional
                description="description"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "client_vpn_endpoint_id": client_vpn_endpoint_id,
            "destination_cidr_block": destination_cidr_block,
            "target_vpc_subnet_id": target_vpc_subnet_id,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def client_vpn_endpoint_id(self) -> builtins.str:
        '''The ID of the Client VPN endpoint to which to add the route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-clientvpnendpointid
        '''
        result = self._values.get("client_vpn_endpoint_id")
        assert result is not None, "Required property 'client_vpn_endpoint_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destination_cidr_block(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the route destination. For example:.

        - To add a route for Internet access, enter ``0.0.0.0/0``
        - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
        - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range
        - To add a route for the local network, enter the client CIDR range

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        assert result is not None, "Required property 'destination_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_vpc_subnet_id(self) -> builtins.str:
        '''The ID of the subnet through which you want to route traffic.

        The specified subnet must be an existing target network of the Client VPN endpoint.

        Alternatively, if you're adding a route for the local network, specify ``local`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-targetvpcsubnetid
        '''
        result = self._values.get("target_vpc_subnet_id")
        assert result is not None, "Required property 'target_vpc_subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpnroute.html#cfn-ec2-clientvpnroute-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnClientVpnTargetNetworkAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnTargetNetworkAssociation",
):
    '''A CloudFormation ``AWS::EC2::ClientVpnTargetNetworkAssociation``.

    Specifies a target network to associate with a Client VPN endpoint. A target network is a subnet in a VPC. You can associate multiple subnets from the same VPC with a Client VPN endpoint. You can associate only one subnet in each Availability Zone. We recommend that you associate at least two subnets to provide Availability Zone redundancy.

    :cloudformationResource: AWS::EC2::ClientVpnTargetNetworkAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_client_vpn_target_network_association = ec2.CfnClientVpnTargetNetworkAssociation(self, "MyCfnClientVpnTargetNetworkAssociation",
            client_vpn_endpoint_id="clientVpnEndpointId",
            subnet_id="subnetId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_vpn_endpoint_id: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::ClientVpnTargetNetworkAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint.
        :param subnet_id: The ID of the subnet to associate with the Client VPN endpoint.
        '''
        props = CfnClientVpnTargetNetworkAssociationProps(
            client_vpn_endpoint_id=client_vpn_endpoint_id, subnet_id=subnet_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="clientVpnEndpointId")
    def client_vpn_endpoint_id(self) -> builtins.str:
        '''The ID of the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
        '''
        return typing.cast(builtins.str, jsii.get(self, "clientVpnEndpointId"))

    @client_vpn_endpoint_id.setter
    def client_vpn_endpoint_id(self, value: builtins.str) -> None:
        jsii.set(self, "clientVpnEndpointId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet to associate with the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnClientVpnTargetNetworkAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "client_vpn_endpoint_id": "clientVpnEndpointId",
        "subnet_id": "subnetId",
    },
)
class CfnClientVpnTargetNetworkAssociationProps:
    def __init__(
        self,
        *,
        client_vpn_endpoint_id: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnClientVpnTargetNetworkAssociation``.

        :param client_vpn_endpoint_id: The ID of the Client VPN endpoint.
        :param subnet_id: The ID of the subnet to associate with the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_client_vpn_target_network_association_props = ec2.CfnClientVpnTargetNetworkAssociationProps(
                client_vpn_endpoint_id="clientVpnEndpointId",
                subnet_id="subnetId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "client_vpn_endpoint_id": client_vpn_endpoint_id,
            "subnet_id": subnet_id,
        }

    @builtins.property
    def client_vpn_endpoint_id(self) -> builtins.str:
        '''The ID of the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-clientvpnendpointid
        '''
        result = self._values.get("client_vpn_endpoint_id")
        assert result is not None, "Required property 'client_vpn_endpoint_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet to associate with the Client VPN endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-clientvpntargetnetworkassociation.html#cfn-ec2-clientvpntargetnetworkassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnClientVpnTargetNetworkAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnCustomerGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnCustomerGateway",
):
    '''A CloudFormation ``AWS::EC2::CustomerGateway``.

    Specifies a customer gateway.

    :cloudformationResource: AWS::EC2::CustomerGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_customer_gateway = ec2.CfnCustomerGateway(self, "MyCfnCustomerGateway",
            bgp_asn=123,
            ip_address="ipAddress",
            type="type",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        bgp_asn: jsii.Number,
        ip_address: builtins.str,
        type: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::CustomerGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN. Default: 65000
        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
        :param type: The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).
        :param tags: One or more tags for the customer gateway.
        '''
        props = CfnCustomerGatewayProps(
            bgp_asn=bgp_asn, ip_address=ip_address, type=type, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''One or more tags for the customer gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="bgpAsn")
    def bgp_asn(self) -> jsii.Number:
        '''For devices that support BGP, the customer gateway's BGP ASN.

        Default: 65000

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-bgpasn
        '''
        return typing.cast(jsii.Number, jsii.get(self, "bgpAsn"))

    @bgp_asn.setter
    def bgp_asn(self, value: jsii.Number) -> None:
        jsii.set(self, "bgpAsn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipAddress")
    def ip_address(self) -> builtins.str:
        '''The Internet-routable IP address for the customer gateway's outside interface.

        The address must be static.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-ipaddress
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipAddress"))

    @ip_address.setter
    def ip_address(self, value: builtins.str) -> None:
        jsii.set(self, "ipAddress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        '''The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-type
        '''
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnCustomerGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "bgp_asn": "bgpAsn",
        "ip_address": "ipAddress",
        "type": "type",
        "tags": "tags",
    },
)
class CfnCustomerGatewayProps:
    def __init__(
        self,
        *,
        bgp_asn: jsii.Number,
        ip_address: builtins.str,
        type: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnCustomerGateway``.

        :param bgp_asn: For devices that support BGP, the customer gateway's BGP ASN. Default: 65000
        :param ip_address: The Internet-routable IP address for the customer gateway's outside interface. The address must be static.
        :param type: The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).
        :param tags: One or more tags for the customer gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_customer_gateway_props = ec2.CfnCustomerGatewayProps(
                bgp_asn=123,
                ip_address="ipAddress",
                type="type",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "bgp_asn": bgp_asn,
            "ip_address": ip_address,
            "type": type,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def bgp_asn(self) -> jsii.Number:
        '''For devices that support BGP, the customer gateway's BGP ASN.

        Default: 65000

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-bgpasn
        '''
        result = self._values.get("bgp_asn")
        assert result is not None, "Required property 'bgp_asn' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def ip_address(self) -> builtins.str:
        '''The Internet-routable IP address for the customer gateway's outside interface.

        The address must be static.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-ipaddress
        '''
        result = self._values.get("ip_address")
        assert result is not None, "Required property 'ip_address' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of VPN connection that this customer gateway supports ( ``ipsec.1`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''One or more tags for the customer gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html#cfn-ec2-customergateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnCustomerGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnDHCPOptions(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnDHCPOptions",
):
    '''A CloudFormation ``AWS::EC2::DHCPOptions``.

    Specifies a set of DHCP options for your VPC.

    You must specify at least one of the following properties: ``DomainNameServers`` , ``NetbiosNameServers`` , ``NtpServers`` . If you specify ``NetbiosNameServers`` , you must specify ``NetbiosNodeType`` .

    :cloudformationResource: AWS::EC2::DHCPOptions
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_dHCPOptions = ec2.CfnDHCPOptions(self, "MyCfnDHCPOptions",
            domain_name="domainName",
            domain_name_servers=["domainNameServers"],
            netbios_name_servers=["netbiosNameServers"],
            netbios_node_type=123,
            ntp_servers=["ntpServers"],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        domain_name: typing.Optional[builtins.str] = None,
        domain_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        netbios_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        netbios_node_type: typing.Optional[jsii.Number] = None,
        ntp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::DHCPOptions``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param domain_name: This value is used to complete unqualified DNS hostnames. If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
        :param domain_name_servers: The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` . The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.
        :param netbios_name_servers: The IPv4 addresses of up to four NetBIOS name servers.
        :param netbios_node_type: The NetBIOS node type (1, 2, 4, or 8). We recommend that you specify 2 (broadcast and multicast are not currently supported).
        :param ntp_servers: The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
        :param tags: Any tags assigned to the DHCP options set.
        '''
        props = CfnDHCPOptionsProps(
            domain_name=domain_name,
            domain_name_servers=domain_name_servers,
            netbios_name_servers=netbios_name_servers,
            netbios_node_type=netbios_node_type,
            ntp_servers=ntp_servers,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrDhcpOptionsId")
    def attr_dhcp_options_id(self) -> builtins.str:
        '''The ID of the DHCP options set.

        :cloudformationAttribute: DhcpOptionsId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDhcpOptionsId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the DHCP options set.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="domainName")
    def domain_name(self) -> typing.Optional[builtins.str]:
        '''This value is used to complete unqualified DNS hostnames.

        If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "domainName"))

    @domain_name.setter
    def domain_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "domainName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="domainNameServers")
    def domain_name_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` .

        The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "domainNameServers"))

    @domain_name_servers.setter
    def domain_name_servers(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "domainNameServers", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="netbiosNameServers")
    def netbios_name_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four NetBIOS name servers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "netbiosNameServers"))

    @netbios_name_servers.setter
    def netbios_name_servers(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "netbiosNameServers", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="netbiosNodeType")
    def netbios_node_type(self) -> typing.Optional[jsii.Number]:
        '''The NetBIOS node type (1, 2, 4, or 8).

        We recommend that you specify 2 (broadcast and multicast are not currently supported).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "netbiosNodeType"))

    @netbios_node_type.setter
    def netbios_node_type(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "netbiosNodeType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ntpServers")
    def ntp_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four Network Time Protocol (NTP) servers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "ntpServers"))

    @ntp_servers.setter
    def ntp_servers(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "ntpServers", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnDHCPOptionsProps",
    jsii_struct_bases=[],
    name_mapping={
        "domain_name": "domainName",
        "domain_name_servers": "domainNameServers",
        "netbios_name_servers": "netbiosNameServers",
        "netbios_node_type": "netbiosNodeType",
        "ntp_servers": "ntpServers",
        "tags": "tags",
    },
)
class CfnDHCPOptionsProps:
    def __init__(
        self,
        *,
        domain_name: typing.Optional[builtins.str] = None,
        domain_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        netbios_name_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        netbios_node_type: typing.Optional[jsii.Number] = None,
        ntp_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnDHCPOptions``.

        :param domain_name: This value is used to complete unqualified DNS hostnames. If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).
        :param domain_name_servers: The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` . The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.
        :param netbios_name_servers: The IPv4 addresses of up to four NetBIOS name servers.
        :param netbios_node_type: The NetBIOS node type (1, 2, 4, or 8). We recommend that you specify 2 (broadcast and multicast are not currently supported).
        :param ntp_servers: The IPv4 addresses of up to four Network Time Protocol (NTP) servers.
        :param tags: Any tags assigned to the DHCP options set.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_dHCPOptions_props = ec2.CfnDHCPOptionsProps(
                domain_name="domainName",
                domain_name_servers=["domainNameServers"],
                netbios_name_servers=["netbiosNameServers"],
                netbios_node_type=123,
                ntp_servers=["ntpServers"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if domain_name is not None:
            self._values["domain_name"] = domain_name
        if domain_name_servers is not None:
            self._values["domain_name_servers"] = domain_name_servers
        if netbios_name_servers is not None:
            self._values["netbios_name_servers"] = netbios_name_servers
        if netbios_node_type is not None:
            self._values["netbios_node_type"] = netbios_node_type
        if ntp_servers is not None:
            self._values["ntp_servers"] = ntp_servers
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def domain_name(self) -> typing.Optional[builtins.str]:
        '''This value is used to complete unqualified DNS hostnames.

        If you're using AmazonProvidedDNS in ``us-east-1`` , specify ``ec2.internal`` . If you're using AmazonProvidedDNS in another Region, specify *region* . ``compute.internal`` (for example, ``ap-northeast-1.compute.internal`` ). Otherwise, specify a domain name (for example, *MyCompany.com* ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainname
        '''
        result = self._values.get("domain_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_name_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four domain name servers, or ``AmazonProvidedDNS`` .

        The default is ``AmazonProvidedDNS`` . To have your instance receive a custom DNS hostname as specified in ``DomainName`` , you must set this property to a custom DNS server.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-domainnameservers
        '''
        result = self._values.get("domain_name_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def netbios_name_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four NetBIOS name servers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnameservers
        '''
        result = self._values.get("netbios_name_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def netbios_node_type(self) -> typing.Optional[jsii.Number]:
        '''The NetBIOS node type (1, 2, 4, or 8).

        We recommend that you specify 2 (broadcast and multicast are not currently supported).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-netbiosnodetype
        '''
        result = self._values.get("netbios_node_type")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ntp_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IPv4 addresses of up to four Network Time Protocol (NTP) servers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-ntpservers
        '''
        result = self._values.get("ntp_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the DHCP options set.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-dhcpoptions.html#cfn-ec2-dhcpoptions-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnDHCPOptionsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnEC2Fleet(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet",
):
    '''A CloudFormation ``AWS::EC2::EC2Fleet``.

    Specifies the configuration information to launch a fleet--or group--of instances. An EC2 Fleet can launch multiple instance types across multiple Availability Zones, using the On-Demand Instance, Reserved Instance, and Spot Instance purchasing models together. Using EC2 Fleet, you can define separate On-Demand and Spot capacity targets, specify the instance types that work best for your applications, and specify how Amazon EC2 should distribute your fleet capacity within each purchasing model. For more information, see `Launching an EC2 Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

    :cloudformationResource: AWS::EC2::EC2Fleet
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_eC2_fleet = ec2.CfnEC2Fleet(self, "MyCfnEC2Fleet",
            launch_template_configs=[ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty(
                launch_template_specification=ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                ),
                overrides=[ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(
                    availability_zone="availabilityZone",
                    instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    max_price="maxPrice",
                    placement=ec2.CfnEC2Fleet.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    priority=123,
                    subnet_id="subnetId",
                    weighted_capacity=123
                )]
            )],
            target_capacity_specification=ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty(
                total_target_capacity=123,
        
                # the properties below are optional
                default_target_capacity_type="defaultTargetCapacityType",
                on_demand_target_capacity=123,
                spot_target_capacity=123,
                target_capacity_unit_type="targetCapacityUnitType"
            ),
        
            # the properties below are optional
            context="context",
            excess_capacity_termination_policy="excessCapacityTerminationPolicy",
            on_demand_options=ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty(
                allocation_strategy="allocationStrategy",
                capacity_reservation_options=ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(
                    usage_strategy="usageStrategy"
                ),
                max_total_price="maxTotalPrice",
                min_target_capacity=123,
                single_availability_zone=False,
                single_instance_type=False
            ),
            replace_unhealthy_instances=False,
            spot_options=ec2.CfnEC2Fleet.SpotOptionsRequestProperty(
                allocation_strategy="allocationStrategy",
                instance_interruption_behavior="instanceInterruptionBehavior",
                instance_pools_to_use_count=123,
                maintenance_strategies=ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(
                    capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                ),
                max_total_price="maxTotalPrice",
                min_target_capacity=123,
                single_availability_zone=False,
                single_instance_type=False
            ),
            tag_specifications=[ec2.CfnEC2Fleet.TagSpecificationProperty(
                resource_type="resourceType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )],
            terminate_instances_with_expiration=False,
            type="type",
            valid_from="validFrom",
            valid_until="validUntil"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        launch_template_configs: typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty", _IResolvable_da3f097b]]],
        target_capacity_specification: typing.Union["CfnEC2Fleet.TargetCapacitySpecificationRequestProperty", _IResolvable_da3f097b],
        context: typing.Optional[builtins.str] = None,
        excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
        on_demand_options: typing.Optional[typing.Union["CfnEC2Fleet.OnDemandOptionsRequestProperty", _IResolvable_da3f097b]] = None,
        replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        spot_options: typing.Optional[typing.Union["CfnEC2Fleet.SpotOptionsRequestProperty", _IResolvable_da3f097b]] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnEC2Fleet.TagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        type: typing.Optional[builtins.str] = None,
        valid_from: typing.Optional[builtins.str] = None,
        valid_until: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::EC2Fleet``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param launch_template_configs: The configuration for the EC2 Fleet.
        :param target_capacity_specification: The number of units to request.
        :param context: Reserved.
        :param excess_capacity_termination_policy: Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
        :param on_demand_options: Describes the configuration of On-Demand Instances in an EC2 Fleet.
        :param replace_unhealthy_instances: Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .
        :param spot_options: Describes the configuration of Spot Instances in an EC2 Fleet.
        :param tag_specifications: The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tagging your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ . If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch. If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .
        :param terminate_instances_with_expiration: Indicates whether running instances should be terminated when the EC2 Fleet expires.
        :param type: The fleet type. The default value is ``maintain`` . - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances. - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted. - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched. For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .
        :param valid_from: The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). The default is to start fulfilling the request immediately.
        :param valid_until: The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.
        '''
        props = CfnEC2FleetProps(
            launch_template_configs=launch_template_configs,
            target_capacity_specification=target_capacity_specification,
            context=context,
            excess_capacity_termination_policy=excess_capacity_termination_policy,
            on_demand_options=on_demand_options,
            replace_unhealthy_instances=replace_unhealthy_instances,
            spot_options=spot_options,
            tag_specifications=tag_specifications,
            terminate_instances_with_expiration=terminate_instances_with_expiration,
            type=type,
            valid_from=valid_from,
            valid_until=valid_until,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrFleetId")
    def attr_fleet_id(self) -> builtins.str:
        '''The ID of the EC2 Fleet.

        :cloudformationAttribute: FleetId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrFleetId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateConfigs")
    def launch_template_configs(
        self,
    ) -> typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty", _IResolvable_da3f097b]]]:
        '''The configuration for the EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
        '''
        return typing.cast(typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty", _IResolvable_da3f097b]]], jsii.get(self, "launchTemplateConfigs"))

    @launch_template_configs.setter
    def launch_template_configs(
        self,
        value: typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty", _IResolvable_da3f097b]]],
    ) -> None:
        jsii.set(self, "launchTemplateConfigs", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="targetCapacitySpecification")
    def target_capacity_specification(
        self,
    ) -> typing.Union["CfnEC2Fleet.TargetCapacitySpecificationRequestProperty", _IResolvable_da3f097b]:
        '''The number of units to request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
        '''
        return typing.cast(typing.Union["CfnEC2Fleet.TargetCapacitySpecificationRequestProperty", _IResolvable_da3f097b], jsii.get(self, "targetCapacitySpecification"))

    @target_capacity_specification.setter
    def target_capacity_specification(
        self,
        value: typing.Union["CfnEC2Fleet.TargetCapacitySpecificationRequestProperty", _IResolvable_da3f097b],
    ) -> None:
        jsii.set(self, "targetCapacitySpecification", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="context")
    def context(self) -> typing.Optional[builtins.str]:
        '''Reserved.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "context"))

    @context.setter
    def context(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "context", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="excessCapacityTerminationPolicy")
    def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
        '''Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "excessCapacityTerminationPolicy"))

    @excess_capacity_termination_policy.setter
    def excess_capacity_termination_policy(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "excessCapacityTerminationPolicy", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="onDemandOptions")
    def on_demand_options(
        self,
    ) -> typing.Optional[typing.Union["CfnEC2Fleet.OnDemandOptionsRequestProperty", _IResolvable_da3f097b]]:
        '''Describes the configuration of On-Demand Instances in an EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.OnDemandOptionsRequestProperty", _IResolvable_da3f097b]], jsii.get(self, "onDemandOptions"))

    @on_demand_options.setter
    def on_demand_options(
        self,
        value: typing.Optional[typing.Union["CfnEC2Fleet.OnDemandOptionsRequestProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "onDemandOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="replaceUnhealthyInstances")
    def replace_unhealthy_instances(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether EC2 Fleet should replace unhealthy Spot Instances.

        Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "replaceUnhealthyInstances"))

    @replace_unhealthy_instances.setter
    def replace_unhealthy_instances(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "replaceUnhealthyInstances", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="spotOptions")
    def spot_options(
        self,
    ) -> typing.Optional[typing.Union["CfnEC2Fleet.SpotOptionsRequestProperty", _IResolvable_da3f097b]]:
        '''Describes the configuration of Spot Instances in an EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.SpotOptionsRequestProperty", _IResolvable_da3f097b]], jsii.get(self, "spotOptions"))

    @spot_options.setter
    def spot_options(
        self,
        value: typing.Optional[typing.Union["CfnEC2Fleet.SpotOptionsRequestProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "spotOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagSpecifications")
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.TagSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tagging your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ .

        If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch.

        If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.TagSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "tagSpecifications"))

    @tag_specifications.setter
    def tag_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.TagSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "tagSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="terminateInstancesWithExpiration")
    def terminate_instances_with_expiration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether running instances should be terminated when the EC2 Fleet expires.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "terminateInstancesWithExpiration"))

    @terminate_instances_with_expiration.setter
    def terminate_instances_with_expiration(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "terminateInstancesWithExpiration", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> typing.Optional[builtins.str]:
        '''The fleet type. The default value is ``maintain`` .

        - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
        - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
        - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.

        For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "type"))

    @type.setter
    def type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validFrom")
    def valid_from(self) -> typing.Optional[builtins.str]:
        '''The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

        The default is to start fulfilling the request immediately.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "validFrom"))

    @valid_from.setter
    def valid_from(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "validFrom", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="validUntil")
    def valid_until(self) -> typing.Optional[builtins.str]:
        '''The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

        At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "validUntil"))

    @valid_until.setter
    def valid_until(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "validUntil", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.AcceleratorCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :param max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .
            :param min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                accelerator_count_request_property = ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of accelerators.

            To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of accelerators.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratorcountrequest.html#cfn-ec2-ec2fleet-acceleratorcountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorTotalMemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            :param max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                accelerator_total_memory_mi_bRequest_property = ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of accelerator memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of accelerator memory, in MiB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-acceleratortotalmemorymibrequest.html#cfn-ec2-ec2fleet-acceleratortotalmemorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorTotalMemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class BaselineEbsBandwidthMbpsRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                baseline_ebs_bandwidth_mbps_request_property = ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum baseline bandwidth, in Mbps.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum baseline bandwidth, in Mbps.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-ec2fleet-baselineebsbandwidthmbpsrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselineEbsBandwidthMbpsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.CapacityRebalanceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "replacement_strategy": "replacementStrategy",
            "termination_delay": "terminationDelay",
        },
    )
    class CapacityRebalanceProperty:
        def __init__(
            self,
            *,
            replacement_strategy: typing.Optional[builtins.str] = None,
            termination_delay: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The Spot Instance replacement strategy to use when Amazon EC2 emits a rebalance notification signal that your Spot Instance is at an elevated risk of being interrupted.

            For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide* .

            :param replacement_strategy: The replacement strategy to use. Only available for fleets of type ``maintain`` . ``launch`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running. ``launch-before-terminate`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.
            :param termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance. Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` . Not valid when ``ReplacementStrategy`` is set to ``launch`` . Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                capacity_rebalance_property = ec2.CfnEC2Fleet.CapacityRebalanceProperty(
                    replacement_strategy="replacementStrategy",
                    termination_delay=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if replacement_strategy is not None:
                self._values["replacement_strategy"] = replacement_strategy
            if termination_delay is not None:
                self._values["termination_delay"] = termination_delay

        @builtins.property
        def replacement_strategy(self) -> typing.Optional[builtins.str]:
            '''The replacement strategy to use. Only available for fleets of type ``maintain`` .

            ``launch`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

            ``launch-before-terminate`` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-replacementstrategy
            '''
            result = self._values.get("replacement_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def termination_delay(self) -> typing.Optional[jsii.Number]:
            '''The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

            Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` .

            Not valid when ``ReplacementStrategy`` is set to ``launch`` .

            Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityrebalance.html#cfn-ec2-ec2fleet-capacityrebalance-terminationdelay
            '''
            result = self._values.get("termination_delay")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityRebalanceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"usage_strategy": "usageStrategy"},
    )
    class CapacityReservationOptionsRequestProperty:
        def __init__(
            self,
            *,
            usage_strategy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

            .. epigraph::

               This strategy can only be used if the EC2 Fleet is of type ``instant`` .

            For more information about Capacity Reservations, see `On-Demand Capacity Reservations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html>`_ in the *Amazon EC2 User Guide* . For examples of using Capacity Reservations in an EC2 Fleet, see `EC2 Fleet example configurations <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html>`_ in the *Amazon EC2 User Guide* .

            :param usage_strategy: Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity. If you specify ``use-capacity-reservations-first`` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ). If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                capacity_reservation_options_request_property = ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(
                    usage_strategy="usageStrategy"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if usage_strategy is not None:
                self._values["usage_strategy"] = usage_strategy

        @builtins.property
        def usage_strategy(self) -> typing.Optional[builtins.str]:
            '''Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.

            If you specify ``use-capacity-reservations-first`` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( ``lowest-price`` or ``prioritized`` ).

            If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-capacityreservationoptionsrequest.html#cfn-ec2-ec2fleet-capacityreservationoptionsrequest-usagestrategy
            '''
            result = self._values.get("usage_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityReservationOptionsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_specification": "launchTemplateSpecification",
            "overrides": "overrides",
        },
    )
    class FleetLaunchTemplateConfigRequestProperty:
        def __init__(
            self,
            *,
            launch_template_specification: typing.Optional[typing.Union["CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty", _IResolvable_da3f097b]] = None,
            overrides: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty", _IResolvable_da3f097b]]]] = None,
        ) -> None:
            '''Specifies a launch template and overrides for an EC2 Fleet.

            ``FleetLaunchTemplateConfigRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param launch_template_specification: The launch template to use. You must specify either the launch template ID or launch template name in the request.
            :param overrides: Any parameters that you specify override the same parameters in the launch template. For fleets of type ``request`` and ``maintain`` , a maximum of 300 items is allowed across all launch templates.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                fleet_launch_template_config_request_property = ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty(
                    launch_template_specification=ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName",
                        version="version"
                    ),
                    overrides=[ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(
                        availability_zone="availabilityZone",
                        instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        max_price="maxPrice",
                        placement=ec2.CfnEC2Fleet.PlacementProperty(
                            affinity="affinity",
                            availability_zone="availabilityZone",
                            group_name="groupName",
                            host_id="hostId",
                            host_resource_group_arn="hostResourceGroupArn",
                            partition_number=123,
                            spread_domain="spreadDomain",
                            tenancy="tenancy"
                        ),
                        priority=123,
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if launch_template_specification is not None:
                self._values["launch_template_specification"] = launch_template_specification
            if overrides is not None:
                self._values["overrides"] = overrides

        @builtins.property
        def launch_template_specification(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty", _IResolvable_da3f097b]]:
            '''The launch template to use.

            You must specify either the launch template ID or launch template name in the request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-launchtemplatespecification
            '''
            result = self._values.get("launch_template_specification")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def overrides(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty", _IResolvable_da3f097b]]]]:
            '''Any parameters that you specify override the same parameters in the launch template.

            For fleets of type ``request`` and ``maintain`` , a maximum of 300 items is allowed across all launch templates.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateconfigrequest-overrides
            '''
            result = self._values.get("overrides")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty", _IResolvable_da3f097b]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateConfigRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "max_price": "maxPrice",
            "placement": "placement",
            "priority": "priority",
            "subnet_id": "subnetId",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class FleetLaunchTemplateOverridesRequestProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            instance_requirements: typing.Optional[typing.Union["CfnEC2Fleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            max_price: typing.Optional[builtins.str] = None,
            placement: typing.Optional[typing.Union["CfnEC2Fleet.PlacementProperty", _IResolvable_da3f097b]] = None,
            priority: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies overrides for a launch template for an EC2 Fleet.

            ``FleetLaunchTemplateOverridesRequest`` is a property of the `FleetLaunchTemplateConfigRequest <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html>`_ property type.

            :param availability_zone: The Availability Zone in which to launch the instances.
            :param instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceTypes`` .
            :param instance_type: The instance type. .. epigraph:: If you specify ``InstanceTypes`` , you can't specify ``InstanceRequirements`` .
            :param max_price: The maximum price per unit hour that you are willing to pay for a Spot Instance.
            :param placement: The location where the instance launched, if applicable.
            :param priority: The priority for the launch template override. The highest priority is launched first. If the On-Demand ``AllocationStrategy`` is set to ``prioritized`` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. If the Spot ``AllocationStrategy`` is set to ``capacity-optimized-prioritized`` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first. Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
            :param subnet_id: The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, ``subnet-1234abcdeexample1, subnet-0987cdef6example2`` ). A request of type ``instant`` can have only one subnet ID.
            :param weighted_capacity: The number of units provided by the specified instance type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                fleet_launch_template_overrides_request_property = ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(
                    availability_zone="availabilityZone",
                    instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    max_price="maxPrice",
                    placement=ec2.CfnEC2Fleet.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    priority=123,
                    subnet_id="subnetId",
                    weighted_capacity=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if max_price is not None:
                self._values["max_price"] = max_price
            if placement is not None:
                self._values["placement"] = placement
            if priority is not None:
                self._values["priority"] = priority
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone in which to launch the instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]]:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceTypes`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type.

            .. epigraph::

               If you specify ``InstanceTypes`` , you can't specify ``InstanceRequirements`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def max_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-maxprice
            '''
            result = self._values.get("max_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.PlacementProperty", _IResolvable_da3f097b]]:
            '''The location where the instance launched, if applicable.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-placement
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.PlacementProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            '''The priority for the launch template override. The highest priority is launched first.

            If the On-Demand ``AllocationStrategy`` is set to ``prioritized`` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

            If the Spot ``AllocationStrategy`` is set to ``capacity-optimized-prioritized`` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

            Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-priority
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The IDs of the subnets in which to launch the instances.

            Separate multiple subnet IDs using commas (for example, ``subnet-1234abcdeexample1, subnet-0987cdef6example2`` ). A request of type ``instant`` can have only one subnet ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units provided by the specified instance type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplateoverridesrequest-weightedcapacity
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateOverridesRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_id": "launchTemplateId",
            "launch_template_name": "launchTemplateName",
            "version": "version",
        },
    )
    class FleetLaunchTemplateSpecificationRequestProperty:
        def __init__(
            self,
            *,
            launch_template_id: typing.Optional[builtins.str] = None,
            launch_template_name: typing.Optional[builtins.str] = None,
            version: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the launch template to use for an EC2 Fleet.

            You must specify either the launch template ID or launch template name in the request.

            ``FleetLaunchTemplateSpecificationRequest`` is a property of the `FleetLaunchTemplateConfigRequest <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplateconfigrequest.html>`_ property type.

            :param launch_template_id: The ID of the launch template. If you specify the template ID, you can't specify the template name.
            :param launch_template_name: The name of the launch template. If you specify the template name, you can't specify the template ID.
            :param version: The launch template version number, ``$Latest`` , or ``$Default`` . You must specify a value, otherwise the request fails. If the value is ``$Latest`` , Amazon EC2 uses the latest version of the launch template. If the value is ``$Default`` , Amazon EC2 uses the default version of the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                fleet_launch_template_specification_request_property = ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName",
                    version="version"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if launch_template_id is not None:
                self._values["launch_template_id"] = launch_template_id
            if launch_template_name is not None:
                self._values["launch_template_name"] = launch_template_name
            if version is not None:
                self._values["version"] = version

        @builtins.property
        def launch_template_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the launch template.

            If you specify the template ID, you can't specify the template name.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplateid
            '''
            result = self._values.get("launch_template_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def launch_template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the launch template.

            If you specify the template name, you can't specify the template ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-launchtemplatename
            '''
            result = self._values.get("launch_template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def version(self) -> typing.Optional[builtins.str]:
            '''The launch template version number, ``$Latest`` , or ``$Default`` . You must specify a value, otherwise the request fails.

            If the value is ``$Latest`` , Amazon EC2 uses the latest version of the launch template.

            If the value is ``$Default`` , Amazon EC2 uses the default version of the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest.html#cfn-ec2-ec2fleet-fleetlaunchtemplatespecificationrequest-version
            '''
            result = self._values.get("version")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateSpecificationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "accelerator_count": "acceleratorCount",
            "accelerator_manufacturers": "acceleratorManufacturers",
            "accelerator_names": "acceleratorNames",
            "accelerator_total_memory_mib": "acceleratorTotalMemoryMiB",
            "accelerator_types": "acceleratorTypes",
            "bare_metal": "bareMetal",
            "baseline_ebs_bandwidth_mbps": "baselineEbsBandwidthMbps",
            "burstable_performance": "burstablePerformance",
            "cpu_manufacturers": "cpuManufacturers",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_generations": "instanceGenerations",
            "local_storage": "localStorage",
            "local_storage_types": "localStorageTypes",
            "memory_gib_per_v_cpu": "memoryGiBPerVCpu",
            "memory_mib": "memoryMiB",
            "network_interface_count": "networkInterfaceCount",
            "on_demand_max_price_percentage_over_lowest_price": "onDemandMaxPricePercentageOverLowestPrice",
            "require_hibernate_support": "requireHibernateSupport",
            "spot_max_price_percentage_over_lowest_price": "spotMaxPricePercentageOverLowestPrice",
            "total_local_storage_gb": "totalLocalStorageGb",
            "v_cpu_count": "vCpuCount",
        },
    )
    class InstanceRequirementsRequestProperty:
        def __init__(
            self,
            *,
            accelerator_count: typing.Optional[typing.Union["CfnEC2Fleet.AcceleratorCountRequestProperty", _IResolvable_da3f097b]] = None,
            accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_total_memory_mib: typing.Optional[typing.Union["CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty", _IResolvable_da3f097b]] = None,
            accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            bare_metal: typing.Optional[builtins.str] = None,
            baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union["CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty", _IResolvable_da3f097b]] = None,
            burstable_performance: typing.Optional[builtins.str] = None,
            cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
            local_storage: typing.Optional[builtins.str] = None,
            local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            memory_gib_per_v_cpu: typing.Optional[typing.Union["CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty", _IResolvable_da3f097b]] = None,
            memory_mib: typing.Optional[typing.Union["CfnEC2Fleet.MemoryMiBRequestProperty", _IResolvable_da3f097b]] = None,
            network_interface_count: typing.Optional[typing.Union["CfnEC2Fleet.NetworkInterfaceCountRequestProperty", _IResolvable_da3f097b]] = None,
            on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            require_hibernate_support: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            total_local_storage_gb: typing.Optional[typing.Union["CfnEC2Fleet.TotalLocalStorageGBRequestProperty", _IResolvable_da3f097b]] = None,
            v_cpu_count: typing.Optional[typing.Union["CfnEC2Fleet.VCpuCountRangeRequestProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            When you specify multiple parameters, you get instance types that satisfy all of the specified parameters. If you specify multiple values for a parameter, you get instance types that satisfy any of the specified values.
            .. epigraph::

               You must specify ``VCpuCount`` and ``MemoryMiB`` . All other parameters are optional. Any unspecified optional parameter is set to its default.

            For more information, see `Attribute-based instance type selection for EC2 Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ , `Attribute-based instance type selection for Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html>`_ , and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :param accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits
            :param accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer
            :param accelerator_names: The accelerators that must be on the instance type. - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . Default: Any accelerator
            :param accelerator_total_memory_mib: The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits
            :param accelerator_types: The accelerator types that must be on the instance type. - To include instance types with GPU hardware, specify ``gpu`` . - To include instance types with FPGA hardware, specify ``fpga`` . - To include instance types with inference hardware, specify ``inference`` . Default: Any accelerator type
            :param bare_metal: Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``
            :param baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``
            :param cpu_manufacturers: The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer
            :param excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. Default: No excluded instance types
            :param instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types
            :param local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``
            :param local_storage_types: The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SDD) storage, specify ``sdd`` . Default: ``hdd`` and ``sdd``
            :param memory_gib_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits
            :param memory_mib: The minimum and maximum amount of memory, in MiB.
            :param network_interface_count: The minimum and maximum number of network interfaces. Default: No minimum or maximum limits
            :param on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum youâ€™ll pay for an On-Demand Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``
            :param require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``
            :param spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instance. This is the maximum youâ€™ll pay for an Spot Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``100``
            :param total_local_storage_gb: The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits
            :param v_cpu_count: The minimum and maximum number of vCPUs.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_requirements_request_property = ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(
                    accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(
                        max=123,
                        min=123
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(
                        max=123,
                        min=123
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if accelerator_count is not None:
                self._values["accelerator_count"] = accelerator_count
            if accelerator_manufacturers is not None:
                self._values["accelerator_manufacturers"] = accelerator_manufacturers
            if accelerator_names is not None:
                self._values["accelerator_names"] = accelerator_names
            if accelerator_total_memory_mib is not None:
                self._values["accelerator_total_memory_mib"] = accelerator_total_memory_mib
            if accelerator_types is not None:
                self._values["accelerator_types"] = accelerator_types
            if bare_metal is not None:
                self._values["bare_metal"] = bare_metal
            if baseline_ebs_bandwidth_mbps is not None:
                self._values["baseline_ebs_bandwidth_mbps"] = baseline_ebs_bandwidth_mbps
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cpu_manufacturers is not None:
                self._values["cpu_manufacturers"] = cpu_manufacturers
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_generations is not None:
                self._values["instance_generations"] = instance_generations
            if local_storage is not None:
                self._values["local_storage"] = local_storage
            if local_storage_types is not None:
                self._values["local_storage_types"] = local_storage_types
            if memory_gib_per_v_cpu is not None:
                self._values["memory_gib_per_v_cpu"] = memory_gib_per_v_cpu
            if memory_mib is not None:
                self._values["memory_mib"] = memory_mib
            if network_interface_count is not None:
                self._values["network_interface_count"] = network_interface_count
            if on_demand_max_price_percentage_over_lowest_price is not None:
                self._values["on_demand_max_price_percentage_over_lowest_price"] = on_demand_max_price_percentage_over_lowest_price
            if require_hibernate_support is not None:
                self._values["require_hibernate_support"] = require_hibernate_support
            if spot_max_price_percentage_over_lowest_price is not None:
                self._values["spot_max_price_percentage_over_lowest_price"] = spot_max_price_percentage_over_lowest_price
            if total_local_storage_gb is not None:
                self._values["total_local_storage_gb"] = total_local_storage_gb
            if v_cpu_count is not None:
                self._values["v_cpu_count"] = v_cpu_count

        @builtins.property
        def accelerator_count(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.AcceleratorCountRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratorcount
            '''
            result = self._values.get("accelerator_count")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.AcceleratorCountRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def accelerator_manufacturers(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether instance types must have accelerators by specific manufacturers.

            - For instance types with NVIDIA devices, specify ``nvidia`` .
            - For instance types with AMD devices, specify ``amd`` .
            - For instance types with AWS devices, specify ``amazon-web-services`` .
            - For instance types with Xilinx devices, specify ``xilinx`` .

            Default: Any manufacturer

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratormanufacturers
            '''
            result = self._values.get("accelerator_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerators that must be on the instance type.

            - For instance types with NVIDIA A100 GPUs, specify ``a100`` .
            - For instance types with NVIDIA V100 GPUs, specify ``v100`` .
            - For instance types with NVIDIA K80 GPUs, specify ``k80`` .
            - For instance types with NVIDIA T4 GPUs, specify ``t4`` .
            - For instance types with NVIDIA M60 GPUs, specify ``m60`` .
            - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` .
            - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` .

            Default: Any accelerator

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratornames
            '''
            result = self._values.get("accelerator_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_total_memory_mib(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortotalmemorymib
            '''
            result = self._values.get("accelerator_total_memory_mib")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def accelerator_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerator types that must be on the instance type.

            - To include instance types with GPU hardware, specify ``gpu`` .
            - To include instance types with FPGA hardware, specify ``fpga`` .
            - To include instance types with inference hardware, specify ``inference`` .

            Default: Any accelerator type

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-acceleratortypes
            '''
            result = self._values.get("accelerator_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def bare_metal(self) -> typing.Optional[builtins.str]:
            '''Indicates whether bare metal instance types must be included, excluded, or required.

            - To include bare metal instance types, specify ``included`` .
            - To require only bare metal instance types, specify ``required`` .
            - To exclude bare metal instance types, specify ``excluded`` .

            Default: ``excluded``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baremetal
            '''
            result = self._values.get("bare_metal")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def baseline_ebs_bandwidth_mbps(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-baselineebsbandwidthmbps
            '''
            result = self._values.get("baseline_ebs_bandwidth_mbps")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def burstable_performance(self) -> typing.Optional[builtins.str]:
            '''Indicates whether burstable performance T instance types are included, excluded, or required.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ .

            - To include burstable performance instance types, specify ``included`` .
            - To require only burstable performance instance types, specify ``required`` .
            - To exclude burstable performance instance types, specify ``excluded`` .

            Default: ``excluded``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-burstableperformance
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cpu_manufacturers(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CPU manufacturers to include.

            - For instance types with Intel CPUs, specify ``intel`` .
            - For instance types with AMD CPUs, specify ``amd`` .
            - For instance types with AWS CPUs, specify ``amazon-web-services`` .

            .. epigraph::

               Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

            Default: Any manufacturer

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-cpumanufacturers
            '''
            result = self._values.get("cpu_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def excluded_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to exclude.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

            Default: No excluded instance types

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-excludedinstancetypes
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_generations(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether current or previous generation instance types are included.

            The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            For current generation instance types, specify ``current`` .

            For previous generation instance types, specify ``previous`` .

            Default: Current and previous generation instance types

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-instancegenerations
            '''
            result = self._values.get("instance_generations")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def local_storage(self) -> typing.Optional[builtins.str]:
            '''Indicates whether instance types with instance store volumes are included, excluded, or required.

            For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* .

            - To include instance types with instance store volumes, specify ``included`` .
            - To require only instance types with instance store volumes, specify ``required`` .
            - To exclude instance types with instance store volumes, specify ``excluded`` .

            Default: ``included``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstorage
            '''
            result = self._values.get("local_storage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def local_storage_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of local storage that is required.

            - For instance types with hard disk drive (HDD) storage, specify ``hdd`` .
            - For instance types with solid state drive (SDD) storage, specify ``sdd`` .

            Default: ``hdd`` and ``sdd``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-localstoragetypes
            '''
            result = self._values.get("local_storage_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def memory_gib_per_v_cpu(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorygibpervcpu
            '''
            result = self._values.get("memory_gib_per_v_cpu")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def memory_mib(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.MemoryMiBRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of memory, in MiB.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-memorymib
            '''
            result = self._values.get("memory_mib")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.MemoryMiBRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def network_interface_count(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.NetworkInterfaceCountRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of network interfaces.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-networkinterfacecount
            '''
            result = self._values.get("network_interface_count")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.NetworkInterfaceCountRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def on_demand_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''The price protection threshold for On-Demand Instances.

            This is the maximum youâ€™ll pay for an On-Demand Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``20``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("on_demand_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def require_hibernate_support(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether instance types must support hibernation for On-Demand Instances.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ .

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-requirehibernatesupport
            '''
            result = self._values.get("require_hibernate_support")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def spot_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''The price protection threshold for Spot Instance.

            This is the maximum youâ€™ll pay for an Spot Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``100``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("spot_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def total_local_storage_gb(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.TotalLocalStorageGBRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of total local storage, in GB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-totallocalstoragegb
            '''
            result = self._values.get("total_local_storage_gb")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.TotalLocalStorageGBRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def v_cpu_count(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.VCpuCountRangeRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of vCPUs.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-instancerequirementsrequest.html#cfn-ec2-ec2fleet-instancerequirementsrequest-vcpucount
            '''
            result = self._values.get("v_cpu_count")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.VCpuCountRangeRequestProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceRequirementsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.MaintenanceStrategiesProperty",
        jsii_struct_bases=[],
        name_mapping={"capacity_rebalance": "capacityRebalance"},
    )
    class MaintenanceStrategiesProperty:
        def __init__(
            self,
            *,
            capacity_rebalance: typing.Optional[typing.Union["CfnEC2Fleet.CapacityRebalanceProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :param capacity_rebalance: The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                maintenance_strategies_property = ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(
                    capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if capacity_rebalance is not None:
                self._values["capacity_rebalance"] = capacity_rebalance

        @builtins.property
        def capacity_rebalance(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.CapacityRebalanceProperty", _IResolvable_da3f097b]]:
            '''The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-maintenancestrategies.html#cfn-ec2-ec2fleet-maintenancestrategies-capacityrebalance
            '''
            result = self._values.get("capacity_rebalance")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.CapacityRebalanceProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MaintenanceStrategiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryGiBPerVCpuRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            :param max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                memory_gi_bPer_vCpu_request_property = ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory per vCPU, in GiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory per vCPU, in GiB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorygibpervcpurequest.html#cfn-ec2-ec2fleet-memorygibpervcpurequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryGiBPerVCpuRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.MemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory, in MiB.

            :param max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                memory_mi_bRequest_property = ec2.CfnEC2Fleet.MemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory, in MiB.

            To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-memorymibrequest.html#cfn-ec2-ec2fleet-memorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkInterfaceCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of network interfaces.

            :param max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                network_interface_count_request_property = ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of network interfaces.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of network interfaces.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-networkinterfacecountrequest.html#cfn-ec2-ec2fleet-networkinterfacecountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allocation_strategy": "allocationStrategy",
            "capacity_reservation_options": "capacityReservationOptions",
            "max_total_price": "maxTotalPrice",
            "min_target_capacity": "minTargetCapacity",
            "single_availability_zone": "singleAvailabilityZone",
            "single_instance_type": "singleInstanceType",
        },
    )
    class OnDemandOptionsRequestProperty:
        def __init__(
            self,
            *,
            allocation_strategy: typing.Optional[builtins.str] = None,
            capacity_reservation_options: typing.Optional[typing.Union["CfnEC2Fleet.CapacityReservationOptionsRequestProperty", _IResolvable_da3f097b]] = None,
            max_total_price: typing.Optional[builtins.str] = None,
            min_target_capacity: typing.Optional[jsii.Number] = None,
            single_availability_zone: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            single_instance_type: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies the allocation strategy of On-Demand Instances in an EC2 Fleet.

            ``OnDemandOptionsRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param allocation_strategy: The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity. ``lowest-price`` - EC2 Fleet uses price to determine the order, launching the lowest price first. ``prioritized`` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. Default: ``lowest-price``
            :param capacity_reservation_options: The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type ``instant`` .
            :param max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay.
            :param min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type ``instant`` . At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``
            :param single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type ``instant`` .
            :param single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                on_demand_options_request_property = ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    capacity_reservation_options=ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(
                        usage_strategy="usageStrategy"
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if capacity_reservation_options is not None:
                self._values["capacity_reservation_options"] = capacity_reservation_options
            if max_total_price is not None:
                self._values["max_total_price"] = max_total_price
            if min_target_capacity is not None:
                self._values["min_target_capacity"] = min_target_capacity
            if single_availability_zone is not None:
                self._values["single_availability_zone"] = single_availability_zone
            if single_instance_type is not None:
                self._values["single_instance_type"] = single_instance_type

        @builtins.property
        def allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.

            ``lowest-price`` - EC2 Fleet uses price to determine the order, launching the lowest price first.

            ``prioritized`` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.

            Default: ``lowest-price``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-allocationstrategy
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def capacity_reservation_options(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.CapacityReservationOptionsRequestProperty", _IResolvable_da3f097b]]:
            '''The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

            Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-capacityreservationoptions
            '''
            result = self._values.get("capacity_reservation_options")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.CapacityReservationOptionsRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for On-Demand Instances that you're willing to pay.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-maxtotalprice
            '''
            result = self._values.get("max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def min_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The minimum target capacity for On-Demand Instances in the fleet.

            If the minimum target capacity is not reached, the fleet launches no instances.

            Supported only for fleets of type ``instant`` .

            At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-mintargetcapacity
            '''
            result = self._values.get("min_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def single_availability_zone(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.

            Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleavailabilityzone
            '''
            result = self._values.get("single_availability_zone")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def single_instance_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.

            Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-ondemandoptionsrequest.html#cfn-ec2-ec2fleet-ondemandoptionsrequest-singleinstancetype
            '''
            result = self._values.get("single_instance_type")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "OnDemandOptionsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.PlacementProperty",
        jsii_struct_bases=[],
        name_mapping={
            "affinity": "affinity",
            "availability_zone": "availabilityZone",
            "group_name": "groupName",
            "host_id": "hostId",
            "host_resource_group_arn": "hostResourceGroupArn",
            "partition_number": "partitionNumber",
            "spread_domain": "spreadDomain",
            "tenancy": "tenancy",
        },
    )
    class PlacementProperty:
        def __init__(
            self,
            *,
            affinity: typing.Optional[builtins.str] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            group_name: typing.Optional[builtins.str] = None,
            host_id: typing.Optional[builtins.str] = None,
            host_resource_group_arn: typing.Optional[builtins.str] = None,
            partition_number: typing.Optional[jsii.Number] = None,
            spread_domain: typing.Optional[builtins.str] = None,
            tenancy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the placement of an instance.

            :param affinity: The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ command. This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param availability_zone: The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param group_name: The name of the placement group the instance is in.
            :param host_id: The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ command. This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` . This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param partition_number: The number of the partition that the instance is in. Valid only if the placement group strategy is set to ``partition`` . This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param spread_domain: Reserved for future use. This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .
            :param tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for the `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ command. This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ . T3 instances that use the ``unlimited`` CPU credit option do not support ``host`` tenancy.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                placement_property = ec2.CfnEC2Fleet.PlacementProperty(
                    affinity="affinity",
                    availability_zone="availabilityZone",
                    group_name="groupName",
                    host_id="hostId",
                    host_resource_group_arn="hostResourceGroupArn",
                    partition_number=123,
                    spread_domain="spreadDomain",
                    tenancy="tenancy"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if affinity is not None:
                self._values["affinity"] = affinity
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if group_name is not None:
                self._values["group_name"] = group_name
            if host_id is not None:
                self._values["host_id"] = host_id
            if host_resource_group_arn is not None:
                self._values["host_resource_group_arn"] = host_resource_group_arn
            if partition_number is not None:
                self._values["partition_number"] = partition_number
            if spread_domain is not None:
                self._values["spread_domain"] = spread_domain
            if tenancy is not None:
                self._values["tenancy"] = tenancy

        @builtins.property
        def affinity(self) -> typing.Optional[builtins.str]:
            '''The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ command.

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-affinity
            '''
            result = self._values.get("affinity")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone of the instance.

            If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the placement group the instance is in.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-groupname
            '''
            result = self._values.get("group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Dedicated Host on which the instance resides.

            This parameter is not supported for the `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ command.

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostid
            '''
            result = self._values.get("host_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the host resource group in which to launch the instances.

            If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-hostresourcegrouparn
            '''
            result = self._values.get("host_resource_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def partition_number(self) -> typing.Optional[jsii.Number]:
            '''The number of the partition that the instance is in.

            Valid only if the placement group strategy is set to ``partition`` .

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-partitionnumber
            '''
            result = self._values.get("partition_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spread_domain(self) -> typing.Optional[builtins.str]:
            '''Reserved for future use.

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-spreaddomain
            '''
            result = self._values.get("spread_domain")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenancy(self) -> typing.Optional[builtins.str]:
            '''The tenancy of the instance (if the instance is running in a VPC).

            An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for the `ImportInstance <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html>`_ command.

            This parameter is not supported by `CreateFleet <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet>`_ .

            T3 instances that use the ``unlimited`` CPU credit option do not support ``host`` tenancy.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-placement.html#cfn-ec2-ec2fleet-placement-tenancy
            '''
            result = self._values.get("tenancy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PlacementProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.SpotOptionsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "allocation_strategy": "allocationStrategy",
            "instance_interruption_behavior": "instanceInterruptionBehavior",
            "instance_pools_to_use_count": "instancePoolsToUseCount",
            "maintenance_strategies": "maintenanceStrategies",
            "max_total_price": "maxTotalPrice",
            "min_target_capacity": "minTargetCapacity",
            "single_availability_zone": "singleAvailabilityZone",
            "single_instance_type": "singleInstanceType",
        },
    )
    class SpotOptionsRequestProperty:
        def __init__(
            self,
            *,
            allocation_strategy: typing.Optional[builtins.str] = None,
            instance_interruption_behavior: typing.Optional[builtins.str] = None,
            instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
            maintenance_strategies: typing.Optional[typing.Union["CfnEC2Fleet.MaintenanceStrategiesProperty", _IResolvable_da3f097b]] = None,
            max_total_price: typing.Optional[builtins.str] = None,
            min_target_capacity: typing.Optional[jsii.Number] = None,
            single_availability_zone: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            single_instance_type: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies the configuration of Spot Instances for an EC2 Fleet.

            ``SpotOptionsRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com//AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param allocation_strategy: Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet. If the allocation strategy is ``lowestPrice`` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy. If the allocation strategy is ``diversified`` , EC2 Fleet launches instances from all the Spot Instance pools that you specify. If the allocation strategy is ``capacityOptimized`` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity. *Allowed Values* : ``lowestPrice`` | ``diversified`` | ``capacityOptimized`` | ``capacityOptimizedPrioritized``
            :param instance_interruption_behavior: The behavior when a Spot Instance is interrupted. Default: ``terminate``
            :param instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot ``AllocationStrategy`` is set to ``lowest-price`` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify. Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
            :param maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
            :param max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay.
            :param min_target_capacity: The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances. Supported only for fleets of type ``instant`` . At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``
            :param single_availability_zone: Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type ``instant`` .
            :param single_instance_type: Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_options_request_property = ec2.CfnEC2Fleet.SpotOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    maintenance_strategies=ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(
                        capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if instance_interruption_behavior is not None:
                self._values["instance_interruption_behavior"] = instance_interruption_behavior
            if instance_pools_to_use_count is not None:
                self._values["instance_pools_to_use_count"] = instance_pools_to_use_count
            if maintenance_strategies is not None:
                self._values["maintenance_strategies"] = maintenance_strategies
            if max_total_price is not None:
                self._values["max_total_price"] = max_total_price
            if min_target_capacity is not None:
                self._values["min_target_capacity"] = min_target_capacity
            if single_availability_zone is not None:
                self._values["single_availability_zone"] = single_availability_zone
            if single_instance_type is not None:
                self._values["single_instance_type"] = single_instance_type

        @builtins.property
        def allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.

            If the allocation strategy is ``lowestPrice`` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

            If the allocation strategy is ``diversified`` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.

            If the allocation strategy is ``capacityOptimized`` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.

            *Allowed Values* : ``lowestPrice`` | ``diversified`` | ``capacityOptimized`` | ``capacityOptimizedPrioritized``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-allocationstrategy
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
            '''The behavior when a Spot Instance is interrupted.

            Default: ``terminate``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instanceinterruptionbehavior
            '''
            result = self._values.get("instance_interruption_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
            '''The number of Spot pools across which to allocate your target Spot capacity.

            Supported only when Spot ``AllocationStrategy`` is set to ``lowest-price`` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

            Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-instancepoolstousecount
            '''
            result = self._values.get("instance_pools_to_use_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def maintenance_strategies(
            self,
        ) -> typing.Optional[typing.Union["CfnEC2Fleet.MaintenanceStrategiesProperty", _IResolvable_da3f097b]]:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maintenancestrategies
            '''
            result = self._values.get("maintenance_strategies")
            return typing.cast(typing.Optional[typing.Union["CfnEC2Fleet.MaintenanceStrategiesProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for Spot Instances that you're willing to pay.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-maxtotalprice
            '''
            result = self._values.get("max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def min_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The minimum target capacity for Spot Instances in the fleet.

            If the minimum target capacity is not reached, the fleet launches no instances.

            Supported only for fleets of type ``instant`` .

            At least one of the following must be specified: ``SingleAvailabilityZone`` | ``SingleInstanceType``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-mintargetcapacity
            '''
            result = self._values.get("min_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def single_availability_zone(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates that the fleet launches all Spot Instances into a single Availability Zone.

            Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleavailabilityzone
            '''
            result = self._values.get("single_availability_zone")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def single_instance_type(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.

            Supported only for fleets of type ``instant`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-spotoptionsrequest.html#cfn-ec2-ec2fleet-spotoptionsrequest-singleinstancetype
            '''
            result = self._values.get("single_instance_type")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotOptionsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        ) -> None:
            '''Specifies the tags to apply to a resource when the resource is being created for an EC2 Fleet.

            ``TagSpecification`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param resource_type: The type of resource to tag. ``ResourceType`` must be ``fleet`` .
            :param tags: The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                tag_specification_property = ec2.CfnEC2Fleet.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            ``ResourceType`` must be ``fleet`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
            '''The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-tagspecification.html#cfn-ec2-ec2fleet-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "total_target_capacity": "totalTargetCapacity",
            "default_target_capacity_type": "defaultTargetCapacityType",
            "on_demand_target_capacity": "onDemandTargetCapacity",
            "spot_target_capacity": "spotTargetCapacity",
            "target_capacity_unit_type": "targetCapacityUnitType",
        },
    )
    class TargetCapacitySpecificationRequestProperty:
        def __init__(
            self,
            *,
            total_target_capacity: jsii.Number,
            default_target_capacity_type: typing.Optional[builtins.str] = None,
            on_demand_target_capacity: typing.Optional[jsii.Number] = None,
            spot_target_capacity: typing.Optional[jsii.Number] = None,
            target_capacity_unit_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the number of units to request for an EC2 Fleet.

            You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of ``0`` and add capacity later.

            ``TargetCapacitySpecificationRequest`` is a property of the `AWS::EC2::EC2Fleet <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html>`_ resource.

            :param total_target_capacity: The number of units to request, filled using ``DefaultTargetCapacityType`` .
            :param default_target_capacity_type: The default ``TotalTargetCapacity`` , which is either ``Spot`` or ``On-Demand`` .
            :param on_demand_target_capacity: The number of On-Demand units to request.
            :param spot_target_capacity: The number of Spot units to request.
            :param target_capacity_unit_type: The unit for the target capacity. Default: ``units`` (translates to number of instances)

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                target_capacity_specification_request_property = ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty(
                    total_target_capacity=123,
                
                    # the properties below are optional
                    default_target_capacity_type="defaultTargetCapacityType",
                    on_demand_target_capacity=123,
                    spot_target_capacity=123,
                    target_capacity_unit_type="targetCapacityUnitType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "total_target_capacity": total_target_capacity,
            }
            if default_target_capacity_type is not None:
                self._values["default_target_capacity_type"] = default_target_capacity_type
            if on_demand_target_capacity is not None:
                self._values["on_demand_target_capacity"] = on_demand_target_capacity
            if spot_target_capacity is not None:
                self._values["spot_target_capacity"] = spot_target_capacity
            if target_capacity_unit_type is not None:
                self._values["target_capacity_unit_type"] = target_capacity_unit_type

        @builtins.property
        def total_target_capacity(self) -> jsii.Number:
            '''The number of units to request, filled using ``DefaultTargetCapacityType`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-totaltargetcapacity
            '''
            result = self._values.get("total_target_capacity")
            assert result is not None, "Required property 'total_target_capacity' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def default_target_capacity_type(self) -> typing.Optional[builtins.str]:
            '''The default ``TotalTargetCapacity`` , which is either ``Spot`` or ``On-Demand`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-defaulttargetcapacitytype
            '''
            result = self._values.get("default_target_capacity_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def on_demand_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of On-Demand units to request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-ondemandtargetcapacity
            '''
            result = self._values.get("on_demand_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spot_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of Spot units to request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-spottargetcapacity
            '''
            result = self._values.get("spot_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def target_capacity_unit_type(self) -> typing.Optional[builtins.str]:
            '''The unit for the target capacity.

            Default: ``units`` (translates to number of instances)

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-targetcapacityspecificationrequest.html#cfn-ec2-ec2fleet-targetcapacityspecificationrequest-targetcapacityunittype
            '''
            result = self._values.get("target_capacity_unit_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TargetCapacitySpecificationRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class TotalLocalStorageGBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total local storage, in GB.

            :param max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                total_local_storage_gBRequest_property = ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of total local storage, in GB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of total local storage, in GB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-totallocalstoragegbrequest.html#cfn-ec2-ec2fleet-totallocalstoragegbrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TotalLocalStorageGBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class VCpuCountRangeRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of vCPUs.

            :param max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                v_cpu_count_range_request_property = ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of vCPUs.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of vCPUs.

            To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ec2fleet-vcpucountrangerequest.html#cfn-ec2-ec2fleet-vcpucountrangerequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VCpuCountRangeRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnEC2FleetProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_configs": "launchTemplateConfigs",
        "target_capacity_specification": "targetCapacitySpecification",
        "context": "context",
        "excess_capacity_termination_policy": "excessCapacityTerminationPolicy",
        "on_demand_options": "onDemandOptions",
        "replace_unhealthy_instances": "replaceUnhealthyInstances",
        "spot_options": "spotOptions",
        "tag_specifications": "tagSpecifications",
        "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
        "type": "type",
        "valid_from": "validFrom",
        "valid_until": "validUntil",
    },
)
class CfnEC2FleetProps:
    def __init__(
        self,
        *,
        launch_template_configs: typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty, _IResolvable_da3f097b]]],
        target_capacity_specification: typing.Union[CfnEC2Fleet.TargetCapacitySpecificationRequestProperty, _IResolvable_da3f097b],
        context: typing.Optional[builtins.str] = None,
        excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
        on_demand_options: typing.Optional[typing.Union[CfnEC2Fleet.OnDemandOptionsRequestProperty, _IResolvable_da3f097b]] = None,
        replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        spot_options: typing.Optional[typing.Union[CfnEC2Fleet.SpotOptionsRequestProperty, _IResolvable_da3f097b]] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnEC2Fleet.TagSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        type: typing.Optional[builtins.str] = None,
        valid_from: typing.Optional[builtins.str] = None,
        valid_until: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnEC2Fleet``.

        :param launch_template_configs: The configuration for the EC2 Fleet.
        :param target_capacity_specification: The number of units to request.
        :param context: Reserved.
        :param excess_capacity_termination_policy: Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
        :param on_demand_options: Describes the configuration of On-Demand Instances in an EC2 Fleet.
        :param replace_unhealthy_instances: Indicates whether EC2 Fleet should replace unhealthy Spot Instances. Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .
        :param spot_options: Describes the configuration of Spot Instances in an EC2 Fleet.
        :param tag_specifications: The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tagging your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ . If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch. If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .
        :param terminate_instances_with_expiration: Indicates whether running instances should be terminated when the EC2 Fleet expires.
        :param type: The fleet type. The default value is ``maintain`` . - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances. - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted. - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched. For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .
        :param valid_from: The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). The default is to start fulfilling the request immediately.
        :param valid_until: The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_eC2_fleet_props = ec2.CfnEC2FleetProps(
                launch_template_configs=[ec2.CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty(
                    launch_template_specification=ec2.CfnEC2Fleet.FleetLaunchTemplateSpecificationRequestProperty(
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName",
                        version="version"
                    ),
                    overrides=[ec2.CfnEC2Fleet.FleetLaunchTemplateOverridesRequestProperty(
                        availability_zone="availabilityZone",
                        instance_requirements=ec2.CfnEC2Fleet.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2.CfnEC2Fleet.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2.CfnEC2Fleet.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2.CfnEC2Fleet.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            memory_gi_bPer_vCpu=ec2.CfnEC2Fleet.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2.CfnEC2Fleet.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2.CfnEC2Fleet.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2.CfnEC2Fleet.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2.CfnEC2Fleet.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        max_price="maxPrice",
                        placement=ec2.CfnEC2Fleet.PlacementProperty(
                            affinity="affinity",
                            availability_zone="availabilityZone",
                            group_name="groupName",
                            host_id="hostId",
                            host_resource_group_arn="hostResourceGroupArn",
                            partition_number=123,
                            spread_domain="spreadDomain",
                            tenancy="tenancy"
                        ),
                        priority=123,
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )],
                target_capacity_specification=ec2.CfnEC2Fleet.TargetCapacitySpecificationRequestProperty(
                    total_target_capacity=123,
            
                    # the properties below are optional
                    default_target_capacity_type="defaultTargetCapacityType",
                    on_demand_target_capacity=123,
                    spot_target_capacity=123,
                    target_capacity_unit_type="targetCapacityUnitType"
                ),
            
                # the properties below are optional
                context="context",
                excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                on_demand_options=ec2.CfnEC2Fleet.OnDemandOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    capacity_reservation_options=ec2.CfnEC2Fleet.CapacityReservationOptionsRequestProperty(
                        usage_strategy="usageStrategy"
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                ),
                replace_unhealthy_instances=False,
                spot_options=ec2.CfnEC2Fleet.SpotOptionsRequestProperty(
                    allocation_strategy="allocationStrategy",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    maintenance_strategies=ec2.CfnEC2Fleet.MaintenanceStrategiesProperty(
                        capacity_rebalance=ec2.CfnEC2Fleet.CapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    max_total_price="maxTotalPrice",
                    min_target_capacity=123,
                    single_availability_zone=False,
                    single_instance_type=False
                ),
                tag_specifications=[ec2.CfnEC2Fleet.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )],
                terminate_instances_with_expiration=False,
                type="type",
                valid_from="validFrom",
                valid_until="validUntil"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "launch_template_configs": launch_template_configs,
            "target_capacity_specification": target_capacity_specification,
        }
        if context is not None:
            self._values["context"] = context
        if excess_capacity_termination_policy is not None:
            self._values["excess_capacity_termination_policy"] = excess_capacity_termination_policy
        if on_demand_options is not None:
            self._values["on_demand_options"] = on_demand_options
        if replace_unhealthy_instances is not None:
            self._values["replace_unhealthy_instances"] = replace_unhealthy_instances
        if spot_options is not None:
            self._values["spot_options"] = spot_options
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications
        if terminate_instances_with_expiration is not None:
            self._values["terminate_instances_with_expiration"] = terminate_instances_with_expiration
        if type is not None:
            self._values["type"] = type
        if valid_from is not None:
            self._values["valid_from"] = valid_from
        if valid_until is not None:
            self._values["valid_until"] = valid_until

    @builtins.property
    def launch_template_configs(
        self,
    ) -> typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty, _IResolvable_da3f097b]]]:
        '''The configuration for the EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-launchtemplateconfigs
        '''
        result = self._values.get("launch_template_configs")
        assert result is not None, "Required property 'launch_template_configs' is missing"
        return typing.cast(typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnEC2Fleet.FleetLaunchTemplateConfigRequestProperty, _IResolvable_da3f097b]]], result)

    @builtins.property
    def target_capacity_specification(
        self,
    ) -> typing.Union[CfnEC2Fleet.TargetCapacitySpecificationRequestProperty, _IResolvable_da3f097b]:
        '''The number of units to request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-targetcapacityspecification
        '''
        result = self._values.get("target_capacity_specification")
        assert result is not None, "Required property 'target_capacity_specification' is missing"
        return typing.cast(typing.Union[CfnEC2Fleet.TargetCapacitySpecificationRequestProperty, _IResolvable_da3f097b], result)

    @builtins.property
    def context(self) -> typing.Optional[builtins.str]:
        '''Reserved.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-context
        '''
        result = self._values.get("context")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
        '''Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-excesscapacityterminationpolicy
        '''
        result = self._values.get("excess_capacity_termination_policy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def on_demand_options(
        self,
    ) -> typing.Optional[typing.Union[CfnEC2Fleet.OnDemandOptionsRequestProperty, _IResolvable_da3f097b]]:
        '''Describes the configuration of On-Demand Instances in an EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-ondemandoptions
        '''
        result = self._values.get("on_demand_options")
        return typing.cast(typing.Optional[typing.Union[CfnEC2Fleet.OnDemandOptionsRequestProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def replace_unhealthy_instances(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether EC2 Fleet should replace unhealthy Spot Instances.

        Supported only for fleets of type ``maintain`` . For more information, see `EC2 Fleet health checks <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/manage-ec2-fleet.html#ec2-fleet-health-checks>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-replaceunhealthyinstances
        '''
        result = self._values.get("replace_unhealthy_instances")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def spot_options(
        self,
    ) -> typing.Optional[typing.Union[CfnEC2Fleet.SpotOptionsRequestProperty, _IResolvable_da3f097b]]:
        '''Describes the configuration of Spot Instances in an EC2 Fleet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-spotoptions
        '''
        result = self._values.get("spot_options")
        return typing.cast(typing.Optional[typing.Union[CfnEC2Fleet.SpotOptionsRequestProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnEC2Fleet.TagSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The key-value pair for tagging the EC2 Fleet request on creation. For more information, see `Tagging your resources <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources>`_ .

        If the fleet type is ``instant`` , specify a resource type of ``fleet`` to tag the fleet or ``instance`` to tag the instances at launch.

        If the fleet type is ``maintain`` or ``request`` , specify a resource type of ``fleet`` to tag the fleet. You cannot specify a resource type of ``instance`` . To tag instances at launch, specify the tags in a `launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnEC2Fleet.TagSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def terminate_instances_with_expiration(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether running instances should be terminated when the EC2 Fleet expires.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-terminateinstanceswithexpiration
        '''
        result = self._values.get("terminate_instances_with_expiration")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def type(self) -> typing.Optional[builtins.str]:
        '''The fleet type. The default value is ``maintain`` .

        - ``maintain`` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
        - ``request`` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
        - ``instant`` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.

        For more information, see `EC2 Fleet request types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-type
        '''
        result = self._values.get("type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def valid_from(self) -> typing.Optional[builtins.str]:
        '''The start date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

        The default is to start fulfilling the request immediately.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validfrom
        '''
        result = self._values.get("valid_from")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def valid_until(self) -> typing.Optional[builtins.str]:
        '''The end date and time of the request, in UTC format (for example, *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

        At this point, no new EC2 Fleet requests are placed or able to fulfill the request. If no value is specified, the request remains until you cancel it.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ec2fleet.html#cfn-ec2-ec2fleet-validuntil
        '''
        result = self._values.get("valid_until")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEC2FleetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnEIP(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnEIP",
):
    '''A CloudFormation ``AWS::EC2::EIP``.

    Specifies an Elastic IP (EIP) address and can, optionally, associate it with an Amazon EC2 instance.

    You can allocate an Elastic IP address from an address pool owned by AWS or from an address pool created from a public IPv4 address range that you have brought to AWS for use with your AWS resources using bring your own IP addresses (BYOIP). For more information, see `Bring Your Own IP Addresses (BYOIP) <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html>`_ in the *Amazon EC2 User Guide* .

    [EC2-VPC] If you release an Elastic IP address, you might be able to recover it. You cannot recover an Elastic IP address that you released after it is allocated to another AWS account. You cannot recover an Elastic IP address for EC2-Classic. To attempt to recover an Elastic IP address that you released, specify it in this operation.

    An Elastic IP address is for use either in the EC2-Classic platform or in a VPC. By default, you can allocate 5 Elastic IP addresses for EC2-Classic per Region and 5 Elastic IP addresses for EC2-VPC per Region.

    For more information, see `Elastic IP Addresses <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html>`_ in the *Amazon EC2 User Guide* .

    :cloudformationResource: AWS::EC2::EIP
    :exampleMetadata: infused
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html

    Example::

        # listener: globalaccelerator.Listener
        # eip: ec2.CfnEIP
        
        
        listener.add_endpoint_group("Group",
            endpoints=[
                ga_endpoints.CfnEipEndpoint(eip,
                    weight=128
                )
            ]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        domain: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        public_ipv4_pool: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::EIP``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param domain: Indicates whether the Elastic IP address is for use with instances in a VPC or instance in EC2-Classic. Default: If the Region supports EC2-Classic, the default is ``standard`` . Otherwise, the default is ``vpc`` . Use when allocating an address for use with a VPC if the Region supports EC2-Classic. If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.
        :param instance_id: The ID of the instance. .. epigraph:: Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param public_ipv4_pool: The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. .. epigraph:: Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param tags: Any tags assigned to the Elastic IP address. .. epigraph:: Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        '''
        props = CfnEIPProps(
            domain=domain,
            instance_id=instance_id,
            public_ipv4_pool=public_ipv4_pool,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAllocationId")
    def attr_allocation_id(self) -> builtins.str:
        '''The ID that AWS assigns to represent the allocation of the address for use with Amazon VPC.

        This is returned only for VPC elastic IP addresses. For example, ``eipalloc-5723d13e`` .

        :cloudformationAttribute: AllocationId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrAllocationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the Elastic IP address.

        .. epigraph::

           Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="domain")
    def domain(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the Elastic IP address is for use with instances in a VPC or instance in EC2-Classic.

        Default: If the Region supports EC2-Classic, the default is ``standard`` . Otherwise, the default is ``vpc`` .

        Use when allocating an address for use with a VPC if the Region supports EC2-Classic.

        If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-domain
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "domain"))

    @domain.setter
    def domain(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "domain", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance.

        .. epigraph::

           Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-instanceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="publicIpv4Pool")
    def public_ipv4_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of an address pool that you own.

        Use this parameter to let Amazon EC2 select an address from the address pool.
        .. epigraph::

           Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-publicipv4pool
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "publicIpv4Pool"))

    @public_ipv4_pool.setter
    def public_ipv4_pool(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "publicIpv4Pool", value)


@jsii.implements(_IInspectable_c2943556)
class CfnEIPAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnEIPAssociation",
):
    '''A CloudFormation ``AWS::EC2::EIPAssociation``.

    Associates an Elastic IP address with an instance or a network interface. Before you can use an Elastic IP address, you must allocate it to your account.

    An Elastic IP address is for use in either the EC2-Classic platform or in a VPC. For more information, see `Elastic IP Addresses <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html>`_ in the *Amazon EC2 User Guide* .

    [EC2-Classic, VPC in an EC2-VPC-only account] If the Elastic IP address is already associated with a different instance, it is disassociated from that instance and associated with the specified instance. If you associate an Elastic IP address with an instance that has an existing Elastic IP address, the existing address is disassociated from the instance, but remains allocated to your account.

    [VPC in an EC2-Classic account] If you don't specify a private IP address, the Elastic IP address is associated with the primary IP address. If the Elastic IP address is already associated with a different instance or a network interface, you get an error unless you allow reassociation. You cannot associate an Elastic IP address with an instance or network interface that has an existing Elastic IP address.

    :cloudformationResource: AWS::EC2::EIPAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_eIPAssociation = ec2.CfnEIPAssociation(self, "MyCfnEIPAssociation",
            allocation_id="allocationId",
            eip="eip",
            instance_id="instanceId",
            network_interface_id="networkInterfaceId",
            private_ip_address="privateIpAddress"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        allocation_id: typing.Optional[builtins.str] = None,
        eip: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::EIPAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param allocation_id: [EC2-VPC] The allocation ID. This is required for EC2-VPC.
        :param eip: [EC2-Classic] The Elastic IP address to associate with the instance. This is required for EC2-Classic.
        :param instance_id: The ID of the instance. The instance must have exactly one attached network interface. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. For EC2-Classic, you must specify an instance ID and the instance must be in the running state.
        :param network_interface_id: [EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both.
        :param private_ip_address: [EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.
        '''
        props = CfnEIPAssociationProps(
            allocation_id=allocation_id,
            eip=eip,
            instance_id=instance_id,
            network_interface_id=network_interface_id,
            private_ip_address=private_ip_address,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationId")
    def allocation_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The allocation ID.

        This is required for EC2-VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-allocationid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "allocationId"))

    @allocation_id.setter
    def allocation_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "allocationId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="eip")
    def eip(self) -> typing.Optional[builtins.str]:
        '''[EC2-Classic] The Elastic IP address to associate with the instance.

        This is required for EC2-Classic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-eip
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "eip"))

    @eip.setter
    def eip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "eip", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance.

        The instance must have exactly one attached network interface. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. For EC2-Classic, you must specify an instance ID and the instance must be in the running state.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-instanceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The ID of the network interface.

        If the instance has more than one network interface, you must specify a network interface ID.

        For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-networkinterfaceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address.

        If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-PrivateIpAddress
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "privateIpAddress"))

    @private_ip_address.setter
    def private_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "privateIpAddress", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnEIPAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "allocation_id": "allocationId",
        "eip": "eip",
        "instance_id": "instanceId",
        "network_interface_id": "networkInterfaceId",
        "private_ip_address": "privateIpAddress",
    },
)
class CfnEIPAssociationProps:
    def __init__(
        self,
        *,
        allocation_id: typing.Optional[builtins.str] = None,
        eip: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnEIPAssociation``.

        :param allocation_id: [EC2-VPC] The allocation ID. This is required for EC2-VPC.
        :param eip: [EC2-Classic] The Elastic IP address to associate with the instance. This is required for EC2-Classic.
        :param instance_id: The ID of the instance. The instance must have exactly one attached network interface. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. For EC2-Classic, you must specify an instance ID and the instance must be in the running state.
        :param network_interface_id: [EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both.
        :param private_ip_address: [EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_eIPAssociation_props = ec2.CfnEIPAssociationProps(
                allocation_id="allocationId",
                eip="eip",
                instance_id="instanceId",
                network_interface_id="networkInterfaceId",
                private_ip_address="privateIpAddress"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if allocation_id is not None:
            self._values["allocation_id"] = allocation_id
        if eip is not None:
            self._values["eip"] = eip
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address

    @builtins.property
    def allocation_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The allocation ID.

        This is required for EC2-VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-allocationid
        '''
        result = self._values.get("allocation_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def eip(self) -> typing.Optional[builtins.str]:
        '''[EC2-Classic] The Elastic IP address to associate with the instance.

        This is required for EC2-Classic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-eip
        '''
        result = self._values.get("eip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance.

        The instance must have exactly one attached network interface. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. For EC2-Classic, you must specify an instance ID and the instance must be in the running state.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The ID of the network interface.

        If the instance has more than one network interface, you must specify a network interface ID.

        For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address.

        If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip-association.html#cfn-ec2-eipassociation-PrivateIpAddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEIPAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnEIPProps",
    jsii_struct_bases=[],
    name_mapping={
        "domain": "domain",
        "instance_id": "instanceId",
        "public_ipv4_pool": "publicIpv4Pool",
        "tags": "tags",
    },
)
class CfnEIPProps:
    def __init__(
        self,
        *,
        domain: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        public_ipv4_pool: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnEIP``.

        :param domain: Indicates whether the Elastic IP address is for use with instances in a VPC or instance in EC2-Classic. Default: If the Region supports EC2-Classic, the default is ``standard`` . Otherwise, the default is ``vpc`` . Use when allocating an address for use with a VPC if the Region supports EC2-Classic. If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.
        :param instance_id: The ID of the instance. .. epigraph:: Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param public_ipv4_pool: The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. .. epigraph:: Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.
        :param tags: Any tags assigned to the Elastic IP address. .. epigraph:: Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :exampleMetadata: infused
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html

        Example::

            # instance: ec2.Instance
            
            # my_zone: route53.HostedZone
            
            
            elastic_ip = ec2.CfnEIP(self, "EIP",
                domain="vpc",
                instance_id=instance.instance_id
            )
            route53.ARecord(self, "ARecord",
                zone=my_zone,
                target=route53.RecordTarget.from_ip_addresses(elastic_ip.ref)
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if domain is not None:
            self._values["domain"] = domain
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if public_ipv4_pool is not None:
            self._values["public_ipv4_pool"] = public_ipv4_pool
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def domain(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the Elastic IP address is for use with instances in a VPC or instance in EC2-Classic.

        Default: If the Region supports EC2-Classic, the default is ``standard`` . Otherwise, the default is ``vpc`` .

        Use when allocating an address for use with a VPC if the Region supports EC2-Classic.

        If you define an Elastic IP address and associate it with a VPC that is defined in the same template, you must declare a dependency on the VPC-gateway attachment by using the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ on this resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-domain
        '''
        result = self._values.get("domain")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the instance.

        .. epigraph::

           Updates to the ``InstanceId`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def public_ipv4_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of an address pool that you own.

        Use this parameter to let Amazon EC2 select an address from the address pool.
        .. epigraph::

           Updates to the ``PublicIpv4Pool`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-publicipv4pool
        '''
        result = self._values.get("public_ipv4_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the Elastic IP address.

        .. epigraph::

           Updates to the ``Tags`` property may require *some interruptions* . Updates on an EIP reassociates the address on its associated resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-eip.html#cfn-ec2-eip-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEIPProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnEgressOnlyInternetGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnEgressOnlyInternetGateway",
):
    '''A CloudFormation ``AWS::EC2::EgressOnlyInternetGateway``.

    [IPv6 only] Specifies an egress-only internet gateway for your VPC. An egress-only internet gateway is used to enable outbound communication over IPv6 from instances in your VPC to the internet, and prevents hosts outside of your VPC from initiating an IPv6 connection with your instance.

    :cloudformationResource: AWS::EC2::EgressOnlyInternetGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_egress_only_internet_gateway = ec2.CfnEgressOnlyInternetGateway(self, "MyCfnEgressOnlyInternetGateway",
            vpc_id="vpcId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::EgressOnlyInternetGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param vpc_id: The ID of the VPC for which to create the egress-only internet gateway.
        '''
        props = CfnEgressOnlyInternetGatewayProps(vpc_id=vpc_id)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the egress-only internet gateway.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC for which to create the egress-only internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnEgressOnlyInternetGatewayProps",
    jsii_struct_bases=[],
    name_mapping={"vpc_id": "vpcId"},
)
class CfnEgressOnlyInternetGatewayProps:
    def __init__(self, *, vpc_id: builtins.str) -> None:
        '''Properties for defining a ``CfnEgressOnlyInternetGateway``.

        :param vpc_id: The ID of the VPC for which to create the egress-only internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_egress_only_internet_gateway_props = ec2.CfnEgressOnlyInternetGatewayProps(
                vpc_id="vpcId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_id": vpc_id,
        }

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC for which to create the egress-only internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-egressonlyinternetgateway.html#cfn-ec2-egressonlyinternetgateway-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEgressOnlyInternetGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnEnclaveCertificateIamRoleAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnEnclaveCertificateIamRoleAssociation",
):
    '''A CloudFormation ``AWS::EC2::EnclaveCertificateIamRoleAssociation``.

    Associates an AWS Identity and Access Management (IAM) role with an AWS Certificate Manager (ACM) certificate. This enables the certificate to be used by the ACM for Nitro Enclaves application inside an enclave. For more information, see `AWS Certificate Manager for Nitro Enclaves <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html>`_ in the *AWS Nitro Enclaves User Guide* .

    When the IAM role is associated with the ACM certificate, the certificate, certificate chain, and encrypted private key are placed in an Amazon S3 bucket that only the associated IAM role can access. The private key of the certificate is encrypted with an AWS managed key that has an attached attestation-based key policy.

    To enable the IAM role to access the Amazon S3 object, you must grant it permission to call ``s3:GetObject`` on the Amazon S3 bucket returned by the command. To enable the IAM role to access the KMS key, you must grant it permission to call ``kms:Decrypt`` on the KMS key returned by the command. For more information, see `Grant the role permission to access the certificate and encryption key <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave-refapp.html#add-policy>`_ in the *AWS Nitro Enclaves User Guide* .

    :cloudformationResource: AWS::EC2::EnclaveCertificateIamRoleAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_enclave_certificate_iam_role_association = ec2.CfnEnclaveCertificateIamRoleAssociation(self, "MyCfnEnclaveCertificateIamRoleAssociation",
            certificate_arn="certificateArn",
            role_arn="roleArn"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        certificate_arn: builtins.str,
        role_arn: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::EnclaveCertificateIamRoleAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param certificate_arn: The ARN of the ACM certificate with which to associate the IAM role.
        :param role_arn: The ARN of the IAM role to associate with the ACM certificate. You can associate up to 16 IAM roles with an ACM certificate.
        '''
        props = CfnEnclaveCertificateIamRoleAssociationProps(
            certificate_arn=certificate_arn, role_arn=role_arn
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCertificateS3BucketName")
    def attr_certificate_s3_bucket_name(self) -> builtins.str:
        '''The name of the Amazon S3 bucket to which the certificate was uploaded.

        :cloudformationAttribute: CertificateS3BucketName
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCertificateS3BucketName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCertificateS3ObjectKey")
    def attr_certificate_s3_object_key(self) -> builtins.str:
        '''The Amazon S3 object key where the certificate, certificate chain, and encrypted private key bundle are stored.

        The object key is formatted as follows: ``role_arn`` / ``certificate_arn`` .

        :cloudformationAttribute: CertificateS3ObjectKey
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCertificateS3ObjectKey"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrEncryptionKmsKeyId")
    def attr_encryption_kms_key_id(self) -> builtins.str:
        '''The ID of the AWS KMS key used to encrypt the private key of the certificate.

        :cloudformationAttribute: EncryptionKmsKeyId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEncryptionKmsKeyId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="certificateArn")
    def certificate_arn(self) -> builtins.str:
        '''The ARN of the ACM certificate with which to associate the IAM role.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
        '''
        return typing.cast(builtins.str, jsii.get(self, "certificateArn"))

    @certificate_arn.setter
    def certificate_arn(self, value: builtins.str) -> None:
        jsii.set(self, "certificateArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="roleArn")
    def role_arn(self) -> builtins.str:
        '''The ARN of the IAM role to associate with the ACM certificate.

        You can associate up to 16 IAM roles with an ACM certificate.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
        '''
        return typing.cast(builtins.str, jsii.get(self, "roleArn"))

    @role_arn.setter
    def role_arn(self, value: builtins.str) -> None:
        jsii.set(self, "roleArn", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnEnclaveCertificateIamRoleAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"certificate_arn": "certificateArn", "role_arn": "roleArn"},
)
class CfnEnclaveCertificateIamRoleAssociationProps:
    def __init__(
        self,
        *,
        certificate_arn: builtins.str,
        role_arn: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnEnclaveCertificateIamRoleAssociation``.

        :param certificate_arn: The ARN of the ACM certificate with which to associate the IAM role.
        :param role_arn: The ARN of the IAM role to associate with the ACM certificate. You can associate up to 16 IAM roles with an ACM certificate.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_enclave_certificate_iam_role_association_props = ec2.CfnEnclaveCertificateIamRoleAssociationProps(
                certificate_arn="certificateArn",
                role_arn="roleArn"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "certificate_arn": certificate_arn,
            "role_arn": role_arn,
        }

    @builtins.property
    def certificate_arn(self) -> builtins.str:
        '''The ARN of the ACM certificate with which to associate the IAM role.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-certificatearn
        '''
        result = self._values.get("certificate_arn")
        assert result is not None, "Required property 'certificate_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def role_arn(self) -> builtins.str:
        '''The ARN of the IAM role to associate with the ACM certificate.

        You can associate up to 16 IAM roles with an ACM certificate.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-enclavecertificateiamroleassociation.html#cfn-ec2-enclavecertificateiamroleassociation-rolearn
        '''
        result = self._values.get("role_arn")
        assert result is not None, "Required property 'role_arn' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnEnclaveCertificateIamRoleAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnFlowLog(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnFlowLog",
):
    '''A CloudFormation ``AWS::EC2::FlowLog``.

    Specifies a VPC flow log that captures IP traffic for a specified network interface, subnet, or VPC. To view the log data, use Amazon CloudWatch Logs (CloudWatch Logs) to help troubleshoot connection issues. For example, you can use a flow log to investigate why certain traffic isn't reaching an instance, which can help you diagnose overly restrictive security group rules. For more information, see `VPC Flow Logs <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html>`_ in the *Amazon VPC User Guide* .

    :cloudformationResource: AWS::EC2::FlowLog
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # destination_options: Any
        
        cfn_flow_log = ec2.CfnFlowLog(self, "MyCfnFlowLog",
            resource_id="resourceId",
            resource_type="resourceType",
            traffic_type="trafficType",
        
            # the properties below are optional
            deliver_logs_permission_arn="deliverLogsPermissionArn",
            destination_options=destination_options,
            log_destination="logDestination",
            log_destination_type="logDestinationType",
            log_format="logFormat",
            log_group_name="logGroupName",
            max_aggregation_interval=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        resource_id: builtins.str,
        resource_type: builtins.str,
        traffic_type: builtins.str,
        deliver_logs_permission_arn: typing.Optional[builtins.str] = None,
        destination_options: typing.Any = None,
        log_destination: typing.Optional[builtins.str] = None,
        log_destination_type: typing.Optional[builtins.str] = None,
        log_format: typing.Optional[builtins.str] = None,
        log_group_name: typing.Optional[builtins.str] = None,
        max_aggregation_interval: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::FlowLog``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param resource_id: The ID of the subnet, network interface, or VPC for which you want to create a flow log.
        :param resource_type: The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ``ResourceId`` property, specify ``VPC`` for this property.
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
        :param deliver_logs_permission_arn: The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .
        :param destination_options: The destination options. The following options are supported:. - ``FileFormat`` - The format for the flow log ( ``plain-text`` | ``parquet`` ). The default is ``plain-text`` . - ``HiveCompatiblePartitions`` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( ``true`` | ``false`` ). The default is ``false`` . - ``PerHourPartition`` - Indicates whether to partition the flow log per hour ( ``true`` | ``false`` ). The default is ``false`` .
        :param log_destination: The destination to which the flow log data is to be published. Flow log data can be published to a CloudWatch Logs log group or an Amazon S3 bucket. The value specified for this parameter depends on the value specified for ``LogDestinationType`` . If ``LogDestinationType`` is not specified or ``cloud-watch-logs`` , specify the Amazon Resource Name (ARN) of the CloudWatch Logs log group. For example, to publish to a log group called ``my-logs`` , specify ``arn:aws:logs:us-east-1:123456789012:log-group:my-logs`` . Alternatively, use ``LogGroupName`` instead. If LogDestinationType is ``s3`` , specify the ARN of the Amazon S3 bucket. You can also specify a subfolder in the bucket. To specify a subfolder in the bucket, use the following ARN format: ``bucket_ARN/subfolder_name/`` . For example, to specify a subfolder named ``my-logs`` in a bucket named ``my-bucket`` , use the following ARN: ``arn:aws:s3:::my-bucket/my-logs/`` . You cannot use ``AWSLogs`` as a subfolder name. This is a reserved term.
        :param log_destination_type: The type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify ``cloud-watch-logs`` . To publish flow log data to Amazon S3, specify ``s3`` . If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` . Default: ``cloud-watch-logs``
        :param log_format: The fields to include in the flow log record, in the order in which they should appear. For a list of available fields, see `Flow Log Records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ . If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must specify at least one field. Specify the fields using the ``${field-id}`` format, separated by spaces.
        :param log_group_name: The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .
        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. You can specify 60 seconds (1 minute) or 600 seconds (10 minutes). When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify. Default: 600
        :param tags: The tags to apply to the flow logs.
        '''
        props = CfnFlowLogProps(
            resource_id=resource_id,
            resource_type=resource_type,
            traffic_type=traffic_type,
            deliver_logs_permission_arn=deliver_logs_permission_arn,
            destination_options=destination_options,
            log_destination=log_destination,
            log_destination_type=log_destination_type,
            log_format=log_format,
            log_group_name=log_group_name,
            max_aggregation_interval=max_aggregation_interval,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the flow log.

        For example, ``fl-123456abc123abc1`` .

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to apply to the flow logs.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationOptions")
    def destination_options(self) -> typing.Any:
        '''The destination options. The following options are supported:.

        - ``FileFormat`` - The format for the flow log ( ``plain-text`` | ``parquet`` ). The default is ``plain-text`` .
        - ``HiveCompatiblePartitions`` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( ``true`` | ``false`` ). The default is ``false`` .
        - ``PerHourPartition`` - Indicates whether to partition the flow log per hour ( ``true`` | ``false`` ). The default is ``false`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
        '''
        return typing.cast(typing.Any, jsii.get(self, "destinationOptions"))

    @destination_options.setter
    def destination_options(self, value: typing.Any) -> None:
        jsii.set(self, "destinationOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''The ID of the subnet, network interface, or VPC for which you want to create a flow log.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @resource_id.setter
    def resource_id(self, value: builtins.str) -> None:
        jsii.set(self, "resourceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="resourceType")
    def resource_type(self) -> builtins.str:
        '''The type of resource for which to create the flow log.

        For example, if you specified a VPC ID for the ``ResourceId`` property, specify ``VPC`` for this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
        '''
        return typing.cast(builtins.str, jsii.get(self, "resourceType"))

    @resource_type.setter
    def resource_type(self, value: builtins.str) -> None:
        jsii.set(self, "resourceType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="trafficType")
    def traffic_type(self) -> builtins.str:
        '''The type of traffic to log.

        You can log traffic that the resource accepts or rejects, or all traffic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
        '''
        return typing.cast(builtins.str, jsii.get(self, "trafficType"))

    @traffic_type.setter
    def traffic_type(self, value: builtins.str) -> None:
        jsii.set(self, "trafficType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="deliverLogsPermissionArn")
    def deliver_logs_permission_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.

        If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deliverLogsPermissionArn"))

    @deliver_logs_permission_arn.setter
    def deliver_logs_permission_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "deliverLogsPermissionArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logDestination")
    def log_destination(self) -> typing.Optional[builtins.str]:
        '''The destination to which the flow log data is to be published.

        Flow log data can be published to a CloudWatch Logs log group or an Amazon S3 bucket. The value specified for this parameter depends on the value specified for ``LogDestinationType`` .

        If ``LogDestinationType`` is not specified or ``cloud-watch-logs`` , specify the Amazon Resource Name (ARN) of the CloudWatch Logs log group. For example, to publish to a log group called ``my-logs`` , specify ``arn:aws:logs:us-east-1:123456789012:log-group:my-logs`` . Alternatively, use ``LogGroupName`` instead.

        If LogDestinationType is ``s3`` , specify the ARN of the Amazon S3 bucket. You can also specify a subfolder in the bucket. To specify a subfolder in the bucket, use the following ARN format: ``bucket_ARN/subfolder_name/`` . For example, to specify a subfolder named ``my-logs`` in a bucket named ``my-bucket`` , use the following ARN: ``arn:aws:s3:::my-bucket/my-logs/`` . You cannot use ``AWSLogs`` as a subfolder name. This is a reserved term.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logDestination"))

    @log_destination.setter
    def log_destination(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "logDestination", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logDestinationType")
    def log_destination_type(self) -> typing.Optional[builtins.str]:
        '''The type of destination to which the flow log data is to be published.

        Flow log data can be published to CloudWatch Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify ``cloud-watch-logs`` . To publish flow log data to Amazon S3, specify ``s3`` .

        If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .

        Default: ``cloud-watch-logs``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logDestinationType"))

    @log_destination_type.setter
    def log_destination_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "logDestinationType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logFormat")
    def log_format(self) -> typing.Optional[builtins.str]:
        '''The fields to include in the flow log record, in the order in which they should appear.

        For a list of available fields, see `Flow Log Records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ . If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must specify at least one field.

        Specify the fields using the ``${field-id}`` format, separated by spaces.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logFormat"))

    @log_format.setter
    def log_format(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "logFormat", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logGroupName")
    def log_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.

        If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logGroupName"))

    @log_group_name.setter
    def log_group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "logGroupName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="maxAggregationInterval")
    def max_aggregation_interval(self) -> typing.Optional[jsii.Number]:
        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.

        You can specify 60 seconds (1 minute) or 600 seconds (10 minutes).

        When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.

        Default: 600

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "maxAggregationInterval"))

    @max_aggregation_interval.setter
    def max_aggregation_interval(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "maxAggregationInterval", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnFlowLogProps",
    jsii_struct_bases=[],
    name_mapping={
        "resource_id": "resourceId",
        "resource_type": "resourceType",
        "traffic_type": "trafficType",
        "deliver_logs_permission_arn": "deliverLogsPermissionArn",
        "destination_options": "destinationOptions",
        "log_destination": "logDestination",
        "log_destination_type": "logDestinationType",
        "log_format": "logFormat",
        "log_group_name": "logGroupName",
        "max_aggregation_interval": "maxAggregationInterval",
        "tags": "tags",
    },
)
class CfnFlowLogProps:
    def __init__(
        self,
        *,
        resource_id: builtins.str,
        resource_type: builtins.str,
        traffic_type: builtins.str,
        deliver_logs_permission_arn: typing.Optional[builtins.str] = None,
        destination_options: typing.Any = None,
        log_destination: typing.Optional[builtins.str] = None,
        log_destination_type: typing.Optional[builtins.str] = None,
        log_format: typing.Optional[builtins.str] = None,
        log_group_name: typing.Optional[builtins.str] = None,
        max_aggregation_interval: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnFlowLog``.

        :param resource_id: The ID of the subnet, network interface, or VPC for which you want to create a flow log.
        :param resource_type: The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ``ResourceId`` property, specify ``VPC`` for this property.
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
        :param deliver_logs_permission_arn: The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account. If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .
        :param destination_options: The destination options. The following options are supported:. - ``FileFormat`` - The format for the flow log ( ``plain-text`` | ``parquet`` ). The default is ``plain-text`` . - ``HiveCompatiblePartitions`` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( ``true`` | ``false`` ). The default is ``false`` . - ``PerHourPartition`` - Indicates whether to partition the flow log per hour ( ``true`` | ``false`` ). The default is ``false`` .
        :param log_destination: The destination to which the flow log data is to be published. Flow log data can be published to a CloudWatch Logs log group or an Amazon S3 bucket. The value specified for this parameter depends on the value specified for ``LogDestinationType`` . If ``LogDestinationType`` is not specified or ``cloud-watch-logs`` , specify the Amazon Resource Name (ARN) of the CloudWatch Logs log group. For example, to publish to a log group called ``my-logs`` , specify ``arn:aws:logs:us-east-1:123456789012:log-group:my-logs`` . Alternatively, use ``LogGroupName`` instead. If LogDestinationType is ``s3`` , specify the ARN of the Amazon S3 bucket. You can also specify a subfolder in the bucket. To specify a subfolder in the bucket, use the following ARN format: ``bucket_ARN/subfolder_name/`` . For example, to specify a subfolder named ``my-logs`` in a bucket named ``my-bucket`` , use the following ARN: ``arn:aws:s3:::my-bucket/my-logs/`` . You cannot use ``AWSLogs`` as a subfolder name. This is a reserved term.
        :param log_destination_type: The type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify ``cloud-watch-logs`` . To publish flow log data to Amazon S3, specify ``s3`` . If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` . Default: ``cloud-watch-logs``
        :param log_format: The fields to include in the flow log record, in the order in which they should appear. For a list of available fields, see `Flow Log Records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ . If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must specify at least one field. Specify the fields using the ``${field-id}`` format, separated by spaces.
        :param log_group_name: The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs. If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .
        :param max_aggregation_interval: The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record. You can specify 60 seconds (1 minute) or 600 seconds (10 minutes). When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify. Default: 600
        :param tags: The tags to apply to the flow logs.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # destination_options: Any
            
            cfn_flow_log_props = ec2.CfnFlowLogProps(
                resource_id="resourceId",
                resource_type="resourceType",
                traffic_type="trafficType",
            
                # the properties below are optional
                deliver_logs_permission_arn="deliverLogsPermissionArn",
                destination_options=destination_options,
                log_destination="logDestination",
                log_destination_type="logDestinationType",
                log_format="logFormat",
                log_group_name="logGroupName",
                max_aggregation_interval=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "resource_id": resource_id,
            "resource_type": resource_type,
            "traffic_type": traffic_type,
        }
        if deliver_logs_permission_arn is not None:
            self._values["deliver_logs_permission_arn"] = deliver_logs_permission_arn
        if destination_options is not None:
            self._values["destination_options"] = destination_options
        if log_destination is not None:
            self._values["log_destination"] = log_destination
        if log_destination_type is not None:
            self._values["log_destination_type"] = log_destination_type
        if log_format is not None:
            self._values["log_format"] = log_format
        if log_group_name is not None:
            self._values["log_group_name"] = log_group_name
        if max_aggregation_interval is not None:
            self._values["max_aggregation_interval"] = max_aggregation_interval
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def resource_id(self) -> builtins.str:
        '''The ID of the subnet, network interface, or VPC for which you want to create a flow log.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourceid
        '''
        result = self._values.get("resource_id")
        assert result is not None, "Required property 'resource_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource_type(self) -> builtins.str:
        '''The type of resource for which to create the flow log.

        For example, if you specified a VPC ID for the ``ResourceId`` property, specify ``VPC`` for this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-resourcetype
        '''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def traffic_type(self) -> builtins.str:
        '''The type of traffic to log.

        You can log traffic that the resource accepts or rejects, or all traffic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-traffictype
        '''
        result = self._values.get("traffic_type")
        assert result is not None, "Required property 'traffic_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def deliver_logs_permission_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN for the IAM role that permits Amazon EC2 to publish flow logs to a CloudWatch Logs log group in your account.

        If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-deliverlogspermissionarn
        '''
        result = self._values.get("deliver_logs_permission_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_options(self) -> typing.Any:
        '''The destination options. The following options are supported:.

        - ``FileFormat`` - The format for the flow log ( ``plain-text`` | ``parquet`` ). The default is ``plain-text`` .
        - ``HiveCompatiblePartitions`` - Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3 ( ``true`` | ``false`` ). The default is ``false`` .
        - ``PerHourPartition`` - Indicates whether to partition the flow log per hour ( ``true`` | ``false`` ). The default is ``false`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-destinationoptions
        '''
        result = self._values.get("destination_options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def log_destination(self) -> typing.Optional[builtins.str]:
        '''The destination to which the flow log data is to be published.

        Flow log data can be published to a CloudWatch Logs log group or an Amazon S3 bucket. The value specified for this parameter depends on the value specified for ``LogDestinationType`` .

        If ``LogDestinationType`` is not specified or ``cloud-watch-logs`` , specify the Amazon Resource Name (ARN) of the CloudWatch Logs log group. For example, to publish to a log group called ``my-logs`` , specify ``arn:aws:logs:us-east-1:123456789012:log-group:my-logs`` . Alternatively, use ``LogGroupName`` instead.

        If LogDestinationType is ``s3`` , specify the ARN of the Amazon S3 bucket. You can also specify a subfolder in the bucket. To specify a subfolder in the bucket, use the following ARN format: ``bucket_ARN/subfolder_name/`` . For example, to specify a subfolder named ``my-logs`` in a bucket named ``my-bucket`` , use the following ARN: ``arn:aws:s3:::my-bucket/my-logs/`` . You cannot use ``AWSLogs`` as a subfolder name. This is a reserved term.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestination
        '''
        result = self._values.get("log_destination")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_destination_type(self) -> typing.Optional[builtins.str]:
        '''The type of destination to which the flow log data is to be published.

        Flow log data can be published to CloudWatch Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify ``cloud-watch-logs`` . To publish flow log data to Amazon S3, specify ``s3`` .

        If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .

        Default: ``cloud-watch-logs``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logdestinationtype
        '''
        result = self._values.get("log_destination_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_format(self) -> typing.Optional[builtins.str]:
        '''The fields to include in the flow log record, in the order in which they should appear.

        For a list of available fields, see `Flow Log Records <https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html#flow-log-records>`_ . If you omit this parameter, the flow log is created using the default format. If you specify this parameter, you must specify at least one field.

        Specify the fields using the ``${field-id}`` format, separated by spaces.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-logformat
        '''
        result = self._values.get("log_format")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of a new or existing CloudWatch Logs log group where Amazon EC2 publishes your flow logs.

        If you specify ``LogDestinationType`` as ``s3`` , do not specify ``DeliverLogsPermissionArn`` or ``LogGroupName`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-loggroupname
        '''
        result = self._values.get("log_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def max_aggregation_interval(self) -> typing.Optional[jsii.Number]:
        '''The maximum interval of time during which a flow of packets is captured and aggregated into a flow log record.

        You can specify 60 seconds (1 minute) or 600 seconds (10 minutes).

        When a network interface is attached to a `Nitro-based instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ , the aggregation interval is always 60 seconds or less, regardless of the value that you specify.

        Default: 600

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-maxaggregationinterval
        '''
        result = self._values.get("max_aggregation_interval")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to apply to the flow logs.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-flowlog.html#cfn-ec2-flowlog-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnFlowLogProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnGatewayRouteTableAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnGatewayRouteTableAssociation",
):
    '''A CloudFormation ``AWS::EC2::GatewayRouteTableAssociation``.

    Associates a virtual private gateway or internet gateway with a route table. The gateway and route table must be in the same VPC. This association causes the incoming traffic to the gateway to be routed according to the routes in the route table.

    :cloudformationResource: AWS::EC2::GatewayRouteTableAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_gateway_route_table_association = ec2.CfnGatewayRouteTableAssociation(self, "MyCfnGatewayRouteTableAssociation",
            gateway_id="gatewayId",
            route_table_id="routeTableId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        gateway_id: builtins.str,
        route_table_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::GatewayRouteTableAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param gateway_id: The ID of the gateway.
        :param route_table_id: The ID of the route table.
        '''
        props = CfnGatewayRouteTableAssociationProps(
            gateway_id=gateway_id, route_table_id=route_table_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAssociationId")
    def attr_association_id(self) -> builtins.str:
        '''The ID of the route table association.

        :cloudformationAttribute: AssociationId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrAssociationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gatewayId")
    def gateway_id(self) -> builtins.str:
        '''The ID of the gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "gatewayId"))

    @gateway_id.setter
    def gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "gatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "routeTableId"))

    @route_table_id.setter
    def route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "routeTableId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnGatewayRouteTableAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"gateway_id": "gatewayId", "route_table_id": "routeTableId"},
)
class CfnGatewayRouteTableAssociationProps:
    def __init__(
        self,
        *,
        gateway_id: builtins.str,
        route_table_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnGatewayRouteTableAssociation``.

        :param gateway_id: The ID of the gateway.
        :param route_table_id: The ID of the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_gateway_route_table_association_props = ec2.CfnGatewayRouteTableAssociationProps(
                gateway_id="gatewayId",
                route_table_id="routeTableId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "gateway_id": gateway_id,
            "route_table_id": route_table_id,
        }

    @builtins.property
    def gateway_id(self) -> builtins.str:
        '''The ID of the gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-gatewayid
        '''
        result = self._values.get("gateway_id")
        assert result is not None, "Required property 'gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-gatewayroutetableassociation.html#cfn-ec2-gatewayroutetableassociation-routetableid
        '''
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnGatewayRouteTableAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnHost(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnHost",
):
    '''A CloudFormation ``AWS::EC2::Host``.

    Allocates a fully dedicated physical server for launching EC2 instances. Because the host is fully dedicated for your use, it can help you address compliance requirements and reduce costs by allowing you to use your existing server-bound software licenses. For more information, see `Dedicated Hosts <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-overview.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

    :cloudformationResource: AWS::EC2::Host
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_host = ec2.CfnHost(self, "MyCfnHost",
            availability_zone="availabilityZone",
            instance_type="instanceType",
        
            # the properties below are optional
            auto_placement="autoPlacement",
            host_recovery="hostRecovery"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        instance_type: builtins.str,
        auto_placement: typing.Optional[builtins.str] = None,
        host_recovery: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::Host``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param availability_zone: The Availability Zone in which to allocate the Dedicated Host.
        :param instance_type: Specifies the instance type to be supported by the Dedicated Hosts. If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.
        :param auto_placement: Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID. For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* . Default: ``on``
        :param host_recovery: Indicates whether to enable or disable host recovery for the Dedicated Host. Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* . Default: ``off``
        '''
        props = CfnHostProps(
            availability_zone=availability_zone,
            instance_type=instance_type,
            auto_placement=auto_placement,
            host_recovery=host_recovery,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrHostId")
    def attr_host_id(self) -> builtins.str:
        '''The ID of the host.

        :cloudformationAttribute: HostId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrHostId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to allocate the Dedicated Host.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
        '''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @availability_zone.setter
    def availability_zone(self, value: builtins.str) -> None:
        jsii.set(self, "availabilityZone", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> builtins.str:
        '''Specifies the instance type to be supported by the Dedicated Hosts.

        If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceType"))

    @instance_type.setter
    def instance_type(self, value: builtins.str) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="autoPlacement")
    def auto_placement(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.

        For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* .

        Default: ``on``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "autoPlacement"))

    @auto_placement.setter
    def auto_placement(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "autoPlacement", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostRecovery")
    def host_recovery(self) -> typing.Optional[builtins.str]:
        '''Indicates whether to enable or disable host recovery for the Dedicated Host.

        Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``off``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostRecovery"))

    @host_recovery.setter
    def host_recovery(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostRecovery", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnHostProps",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "instance_type": "instanceType",
        "auto_placement": "autoPlacement",
        "host_recovery": "hostRecovery",
    },
)
class CfnHostProps:
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        instance_type: builtins.str,
        auto_placement: typing.Optional[builtins.str] = None,
        host_recovery: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnHost``.

        :param availability_zone: The Availability Zone in which to allocate the Dedicated Host.
        :param instance_type: Specifies the instance type to be supported by the Dedicated Hosts. If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.
        :param auto_placement: Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID. For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* . Default: ``on``
        :param host_recovery: Indicates whether to enable or disable host recovery for the Dedicated Host. Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* . Default: ``off``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_host_props = ec2.CfnHostProps(
                availability_zone="availabilityZone",
                instance_type="instanceType",
            
                # the properties below are optional
                auto_placement="autoPlacement",
                host_recovery="hostRecovery"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
            "instance_type": instance_type,
        }
        if auto_placement is not None:
            self._values["auto_placement"] = auto_placement
        if host_recovery is not None:
            self._values["host_recovery"] = host_recovery

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to allocate the Dedicated Host.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-availabilityzone
        '''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_type(self) -> builtins.str:
        '''Specifies the instance type to be supported by the Dedicated Hosts.

        If you specify an instance type, the Dedicated Hosts support instances of the specified instance type only.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-instancetype
        '''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auto_placement(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the host accepts any untargeted instance launches that match its instance type configuration, or if it only accepts Host tenancy instance launches that specify its unique host ID.

        For more information, see `Understanding auto-placement and affinity <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-dedicated-hosts-work.html#dedicated-hosts-understanding>`_ in the *Amazon EC2 User Guide* .

        Default: ``on``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-autoplacement
        '''
        result = self._values.get("auto_placement")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_recovery(self) -> typing.Optional[builtins.str]:
        '''Indicates whether to enable or disable host recovery for the Dedicated Host.

        Host recovery is disabled by default. For more information, see `Host recovery <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/dedicated-hosts-recovery.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``off``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-host.html#cfn-ec2-host-hostrecovery
        '''
        result = self._values.get("host_recovery")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnHostProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnIPAM(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAM",
):
    '''A CloudFormation ``AWS::EC2::IPAM``.

    IPAM is a VPC feature that you can use to automate your IP address management workflows including assigning, tracking, troubleshooting, and auditing IP addresses across AWS Regions and accounts throughout your AWS Organization. For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

    :cloudformationResource: AWS::EC2::IPAM
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_iPAM = ec2.CfnIPAM(self, "MyCfnIPAM",
            description="description",
            operating_regions=[ec2.CfnIPAM.IpamOperatingRegionProperty(
                region_name="regionName"
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        operating_regions: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnIPAM.IpamOperatingRegionProperty", _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::IPAM``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param description: The description for the IPAM.
        :param operating_regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions. For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.
        '''
        props = CfnIPAMProps(
            description=description, operating_regions=operating_regions, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrArn")
    def attr_arn(self) -> builtins.str:
        '''The ARN of the IPAM.

        :cloudformationAttribute: Arn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamId")
    def attr_ipam_id(self) -> builtins.str:
        '''The ID of the IPAM.

        :cloudformationAttribute: IpamId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPrivateDefaultScopeId")
    def attr_private_default_scope_id(self) -> builtins.str:
        '''The ID of the IPAM's default private scope.

        :cloudformationAttribute: PrivateDefaultScopeId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPrivateDefaultScopeId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPublicDefaultScopeId")
    def attr_public_default_scope_id(self) -> builtins.str:
        '''The ID of the IPAM's default public scope.

        :cloudformationAttribute: PublicDefaultScopeId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPublicDefaultScopeId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrScopeCount")
    def attr_scope_count(self) -> jsii.Number:
        '''The number of scopes in the IPAM.

        The scope quota is 5.

        :cloudformationAttribute: ScopeCount
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrScopeCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description for the IPAM.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="operatingRegions")
    def operating_regions(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnIPAM.IpamOperatingRegionProperty", _IResolvable_da3f097b]]]]:
        '''The operating Regions for an IPAM.

        Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

        For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnIPAM.IpamOperatingRegionProperty", _IResolvable_da3f097b]]]], jsii.get(self, "operatingRegions"))

    @operating_regions.setter
    def operating_regions(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnIPAM.IpamOperatingRegionProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "operatingRegions", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnIPAM.IpamOperatingRegionProperty",
        jsii_struct_bases=[],
        name_mapping={"region_name": "regionName"},
    )
    class IpamOperatingRegionProperty:
        def __init__(self, *, region_name: builtins.str) -> None:
            '''The operating Regions for an IPAM.

            Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

            For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

            :param region_name: The name of the operating Region.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ipam_operating_region_property = ec2.CfnIPAM.IpamOperatingRegionProperty(
                    region_name="regionName"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "region_name": region_name,
            }

        @builtins.property
        def region_name(self) -> builtins.str:
            '''The name of the operating Region.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipam-ipamoperatingregion.html#cfn-ec2-ipam-ipamoperatingregion-regionname
            '''
            result = self._values.get("region_name")
            assert result is not None, "Required property 'region_name' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IpamOperatingRegionProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_c2943556)
class CfnIPAMAllocation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMAllocation",
):
    '''A CloudFormation ``AWS::EC2::IPAMAllocation``.

    In IPAM, an allocation is a CIDR assignment from an IPAM pool to another resource or IPAM pool.

    :cloudformationResource: AWS::EC2::IPAMAllocation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_iPAMAllocation = ec2.CfnIPAMAllocation(self, "MyCfnIPAMAllocation",
            ipam_pool_id="ipamPoolId",
        
            # the properties below are optional
            cidr="cidr",
            description="description",
            netmask_length=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        ipam_pool_id: builtins.str,
        cidr: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        netmask_length: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::IPAMAllocation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param ipam_pool_id: The ID of the IPAM pool from which you would like to allocate a CIDR.
        :param cidr: The CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible values: Any available IPv4 or IPv6 CIDR.
        :param description: A description for the allocation.
        :param netmask_length: The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        '''
        props = CfnIPAMAllocationProps(
            ipam_pool_id=ipam_pool_id,
            cidr=cidr,
            description=description,
            netmask_length=netmask_length,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamPoolAllocationId")
    def attr_ipam_pool_allocation_id(self) -> builtins.str:
        '''The ID of an allocation.

        :cloudformationAttribute: IpamPoolAllocationId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamPoolAllocationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipamPoolId")
    def ipam_pool_id(self) -> builtins.str:
        '''The ID of the IPAM pool from which you would like to allocate a CIDR.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipamPoolId"))

    @ipam_pool_id.setter
    def ipam_pool_id(self, value: builtins.str) -> None:
        jsii.set(self, "ipamPoolId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidr")
    def cidr(self) -> typing.Optional[builtins.str]:
        '''The CIDR you would like to allocate from the IPAM pool. Note the following:.

        - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
        - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.

        Possible values: Any available IPv4 or IPv6 CIDR.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidr"))

    @cidr.setter
    def cidr(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidr", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the allocation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="netmaskLength")
    def netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.

        - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
        - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.

        Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "netmaskLength"))

    @netmask_length.setter
    def netmask_length(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "netmaskLength", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMAllocationProps",
    jsii_struct_bases=[],
    name_mapping={
        "ipam_pool_id": "ipamPoolId",
        "cidr": "cidr",
        "description": "description",
        "netmask_length": "netmaskLength",
    },
)
class CfnIPAMAllocationProps:
    def __init__(
        self,
        *,
        ipam_pool_id: builtins.str,
        cidr: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        netmask_length: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for defining a ``CfnIPAMAllocation``.

        :param ipam_pool_id: The ID of the IPAM pool from which you would like to allocate a CIDR.
        :param cidr: The CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible values: Any available IPv4 or IPv6 CIDR.
        :param description: A description for the allocation.
        :param netmask_length: The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:. - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR. - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_iPAMAllocation_props = ec2.CfnIPAMAllocationProps(
                ipam_pool_id="ipamPoolId",
            
                # the properties below are optional
                cidr="cidr",
                description="description",
                netmask_length=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "ipam_pool_id": ipam_pool_id,
        }
        if cidr is not None:
            self._values["cidr"] = cidr
        if description is not None:
            self._values["description"] = description
        if netmask_length is not None:
            self._values["netmask_length"] = netmask_length

    @builtins.property
    def ipam_pool_id(self) -> builtins.str:
        '''The ID of the IPAM pool from which you would like to allocate a CIDR.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-ipampoolid
        '''
        result = self._values.get("ipam_pool_id")
        assert result is not None, "Required property 'ipam_pool_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidr(self) -> typing.Optional[builtins.str]:
        '''The CIDR you would like to allocate from the IPAM pool. Note the following:.

        - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
        - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.

        Possible values: Any available IPv4 or IPv6 CIDR.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-cidr
        '''
        result = self._values.get("cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the allocation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the CIDR you would like to allocate from the IPAM pool. Note the following:.

        - If there is no DefaultNetmaskLength allocation rule set on the pool, you must specify either the NetmaskLength or the CIDR.
        - If the DefaultNetmaskLength allocation rule is set on the pool, you can specify either the NetmaskLength or the CIDR and the DefaultNetmaskLength allocation rule will be ignored.

        Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamallocation.html#cfn-ec2-ipamallocation-netmasklength
        '''
        result = self._values.get("netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMAllocationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnIPAMPool(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMPool",
):
    '''A CloudFormation ``AWS::EC2::IPAMPool``.

    In IPAM, a pool is a collection of contiguous IP addresses CIDRs. Pools enable you to organize your IP addresses according to your routing and security needs. For example, if you have separate routing and security needs for development and production applications, you can create a pool for each.

    :cloudformationResource: AWS::EC2::IPAMPool
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_iPAMPool = ec2.CfnIPAMPool(self, "MyCfnIPAMPool",
            address_family="addressFamily",
            ipam_scope_id="ipamScopeId",
        
            # the properties below are optional
            allocation_default_netmask_length=123,
            allocation_max_netmask_length=123,
            allocation_min_netmask_length=123,
            allocation_resource_tags=[CfnTag(
                key="key",
                value="value"
            )],
            auto_import=False,
            description="description",
            locale="locale",
            provisioned_cidrs=[ec2.CfnIPAMPool.ProvisionedCidrProperty(
                cidr="cidr"
            )],
            publicly_advertisable=False,
            source_ipam_pool_id="sourceIpamPoolId",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        address_family: builtins.str,
        ipam_scope_id: builtins.str,
        allocation_default_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_max_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_min_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_resource_tags: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]] = None,
        auto_import: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        description: typing.Optional[builtins.str] = None,
        locale: typing.Optional[builtins.str] = None,
        provisioned_cidrs: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnIPAMPool.ProvisionedCidrProperty", _IResolvable_da3f097b]]]] = None,
        publicly_advertisable: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        source_ipam_pool_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::IPAMPool``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param address_family: The address family of the pool.
        :param ipam_scope_id: The ID of the scope in which you would like to create the IPAM pool.
        :param allocation_default_netmask_length: The default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
        :param allocation_max_netmask_length: The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant. The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        :param allocation_min_netmask_length: The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant. The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        :param allocation_resource_tags: Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
        :param auto_import: If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM. The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only. A locale must be set on the pool for this feature to work.
        :param description: The description of the IPAM pool.
        :param locale: The locale of the IPAM pool. In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPCâ€™s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
        :param provisioned_cidrs: Information about the CIDRs provisioned to an IPAM pool.
        :param publicly_advertisable: Determines if a pool is publicly advertisable. This option is not available for pools with AddressFamily set to ``ipv4`` .
        :param source_ipam_pool_id: The ID of the source IPAM pool. You can use this option to create an IPAM pool within an existing source pool.
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.
        '''
        props = CfnIPAMPoolProps(
            address_family=address_family,
            ipam_scope_id=ipam_scope_id,
            allocation_default_netmask_length=allocation_default_netmask_length,
            allocation_max_netmask_length=allocation_max_netmask_length,
            allocation_min_netmask_length=allocation_min_netmask_length,
            allocation_resource_tags=allocation_resource_tags,
            auto_import=auto_import,
            description=description,
            locale=locale,
            provisioned_cidrs=provisioned_cidrs,
            publicly_advertisable=publicly_advertisable,
            source_ipam_pool_id=source_ipam_pool_id,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrArn")
    def attr_arn(self) -> builtins.str:
        '''The ARN of the IPAM pool.

        :cloudformationAttribute: Arn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamArn")
    def attr_ipam_arn(self) -> builtins.str:
        '''The ARN of the IPAM.

        :cloudformationAttribute: IpamArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamPoolId")
    def attr_ipam_pool_id(self) -> builtins.str:
        '''The ID of the IPAM pool.

        :cloudformationAttribute: IpamPoolId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamPoolId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamScopeArn")
    def attr_ipam_scope_arn(self) -> builtins.str:
        '''The ARN of the scope of the IPAM pool.

        :cloudformationAttribute: IpamScopeArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamScopeArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamScopeType")
    def attr_ipam_scope_type(self) -> builtins.str:
        '''The scope of the IPAM.

        :cloudformationAttribute: IpamScopeType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamScopeType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPoolDepth")
    def attr_pool_depth(self) -> jsii.Number:
        '''The depth of pools in your IPAM pool.

        The pool depth quota is 10.

        :cloudformationAttribute: PoolDepth
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrPoolDepth"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the IPAM pool.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStateMessage")
    def attr_state_message(self) -> builtins.str:
        '''A message related to the failed creation of an IPAM pool.

        :cloudformationAttribute: StateMessage
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStateMessage"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="addressFamily")
    def address_family(self) -> builtins.str:
        '''The address family of the pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
        '''
        return typing.cast(builtins.str, jsii.get(self, "addressFamily"))

    @address_family.setter
    def address_family(self, value: builtins.str) -> None:
        jsii.set(self, "addressFamily", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipamScopeId")
    def ipam_scope_id(self) -> builtins.str:
        '''The ID of the scope in which you would like to create the IPAM pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipamScopeId"))

    @ipam_scope_id.setter
    def ipam_scope_id(self, value: builtins.str) -> None:
        jsii.set(self, "ipamScopeId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationDefaultNetmaskLength")
    def allocation_default_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The default netmask length for allocations added to this pool.

        If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "allocationDefaultNetmaskLength"))

    @allocation_default_netmask_length.setter
    def allocation_default_netmask_length(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "allocationDefaultNetmaskLength", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationMaxNetmaskLength")
    def allocation_max_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.

        The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "allocationMaxNetmaskLength"))

    @allocation_max_netmask_length.setter
    def allocation_max_netmask_length(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "allocationMaxNetmaskLength", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationMinNetmaskLength")
    def allocation_min_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.

        The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "allocationMinNetmaskLength"))

    @allocation_min_netmask_length.setter
    def allocation_min_netmask_length(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "allocationMinNetmaskLength", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationResourceTags")
    def allocation_resource_tags(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]]:
        '''Tags that are required for resources that use CIDRs from this IPAM pool.

        Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]], jsii.get(self, "allocationResourceTags"))

    @allocation_resource_tags.setter
    def allocation_resource_tags(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]],
    ) -> None:
        jsii.set(self, "allocationResourceTags", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="autoImport")
    def auto_import(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.

        The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.

        A locale must be set on the pool for this feature to work.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "autoImport"))

    @auto_import.setter
    def auto_import(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "autoImport", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the IPAM pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="locale")
    def locale(self) -> typing.Optional[builtins.str]:
        '''The locale of the IPAM pool.

        In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPCâ€™s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "locale"))

    @locale.setter
    def locale(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "locale", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="provisionedCidrs")
    def provisioned_cidrs(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnIPAMPool.ProvisionedCidrProperty", _IResolvable_da3f097b]]]]:
        '''Information about the CIDRs provisioned to an IPAM pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnIPAMPool.ProvisionedCidrProperty", _IResolvable_da3f097b]]]], jsii.get(self, "provisionedCidrs"))

    @provisioned_cidrs.setter
    def provisioned_cidrs(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnIPAMPool.ProvisionedCidrProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "provisionedCidrs", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="publiclyAdvertisable")
    def publicly_advertisable(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Determines if a pool is publicly advertisable.

        This option is not available for pools with AddressFamily set to ``ipv4`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "publiclyAdvertisable"))

    @publicly_advertisable.setter
    def publicly_advertisable(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "publiclyAdvertisable", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceIpamPoolId")
    def source_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the source IPAM pool.

        You can use this option to create an IPAM pool within an existing source pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceIpamPoolId"))

    @source_ipam_pool_id.setter
    def source_ipam_pool_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceIpamPoolId", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMPool.ProvisionedCidrProperty",
        jsii_struct_bases=[],
        name_mapping={"cidr": "cidr"},
    )
    class ProvisionedCidrProperty:
        def __init__(self, *, cidr: builtins.str) -> None:
            '''The CIDR provisioned to the IPAM pool.

            A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .

            :param cidr: The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                provisioned_cidr_property = ec2.CfnIPAMPool.ProvisionedCidrProperty(
                    cidr="cidr"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "cidr": cidr,
            }

        @builtins.property
        def cidr(self) -> builtins.str:
            '''The CIDR provisioned to the IPAM pool.

            A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is ``10.24.34.0/23`` . An IPv6 CIDR example is ``2001:DB8::/32`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ipampool-provisionedcidr.html#cfn-ec2-ipampool-provisionedcidr-cidr
            '''
            result = self._values.get("cidr")
            assert result is not None, "Required property 'cidr' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ProvisionedCidrProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMPoolProps",
    jsii_struct_bases=[],
    name_mapping={
        "address_family": "addressFamily",
        "ipam_scope_id": "ipamScopeId",
        "allocation_default_netmask_length": "allocationDefaultNetmaskLength",
        "allocation_max_netmask_length": "allocationMaxNetmaskLength",
        "allocation_min_netmask_length": "allocationMinNetmaskLength",
        "allocation_resource_tags": "allocationResourceTags",
        "auto_import": "autoImport",
        "description": "description",
        "locale": "locale",
        "provisioned_cidrs": "provisionedCidrs",
        "publicly_advertisable": "publiclyAdvertisable",
        "source_ipam_pool_id": "sourceIpamPoolId",
        "tags": "tags",
    },
)
class CfnIPAMPoolProps:
    def __init__(
        self,
        *,
        address_family: builtins.str,
        ipam_scope_id: builtins.str,
        allocation_default_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_max_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_min_netmask_length: typing.Optional[jsii.Number] = None,
        allocation_resource_tags: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]] = None,
        auto_import: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        description: typing.Optional[builtins.str] = None,
        locale: typing.Optional[builtins.str] = None,
        provisioned_cidrs: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnIPAMPool.ProvisionedCidrProperty, _IResolvable_da3f097b]]]] = None,
        publicly_advertisable: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        source_ipam_pool_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnIPAMPool``.

        :param address_family: The address family of the pool.
        :param ipam_scope_id: The ID of the scope in which you would like to create the IPAM pool.
        :param allocation_default_netmask_length: The default netmask length for allocations added to this pool. If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.
        :param allocation_max_netmask_length: The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant. The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        :param allocation_min_netmask_length: The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant. The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.
        :param allocation_resource_tags: Tags that are required for resources that use CIDRs from this IPAM pool. Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.
        :param auto_import: If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM. The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only. A locale must be set on the pool for this feature to work.
        :param description: The description of the IPAM pool.
        :param locale: The locale of the IPAM pool. In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPCâ€™s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.
        :param provisioned_cidrs: Information about the CIDRs provisioned to an IPAM pool.
        :param publicly_advertisable: Determines if a pool is publicly advertisable. This option is not available for pools with AddressFamily set to ``ipv4`` .
        :param source_ipam_pool_id: The ID of the source IPAM pool. You can use this option to create an IPAM pool within an existing source pool.
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_iPAMPool_props = ec2.CfnIPAMPoolProps(
                address_family="addressFamily",
                ipam_scope_id="ipamScopeId",
            
                # the properties below are optional
                allocation_default_netmask_length=123,
                allocation_max_netmask_length=123,
                allocation_min_netmask_length=123,
                allocation_resource_tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                auto_import=False,
                description="description",
                locale="locale",
                provisioned_cidrs=[ec2.CfnIPAMPool.ProvisionedCidrProperty(
                    cidr="cidr"
                )],
                publicly_advertisable=False,
                source_ipam_pool_id="sourceIpamPoolId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "address_family": address_family,
            "ipam_scope_id": ipam_scope_id,
        }
        if allocation_default_netmask_length is not None:
            self._values["allocation_default_netmask_length"] = allocation_default_netmask_length
        if allocation_max_netmask_length is not None:
            self._values["allocation_max_netmask_length"] = allocation_max_netmask_length
        if allocation_min_netmask_length is not None:
            self._values["allocation_min_netmask_length"] = allocation_min_netmask_length
        if allocation_resource_tags is not None:
            self._values["allocation_resource_tags"] = allocation_resource_tags
        if auto_import is not None:
            self._values["auto_import"] = auto_import
        if description is not None:
            self._values["description"] = description
        if locale is not None:
            self._values["locale"] = locale
        if provisioned_cidrs is not None:
            self._values["provisioned_cidrs"] = provisioned_cidrs
        if publicly_advertisable is not None:
            self._values["publicly_advertisable"] = publicly_advertisable
        if source_ipam_pool_id is not None:
            self._values["source_ipam_pool_id"] = source_ipam_pool_id
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def address_family(self) -> builtins.str:
        '''The address family of the pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-addressfamily
        '''
        result = self._values.get("address_family")
        assert result is not None, "Required property 'address_family' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ipam_scope_id(self) -> builtins.str:
        '''The ID of the scope in which you would like to create the IPAM pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-ipamscopeid
        '''
        result = self._values.get("ipam_scope_id")
        assert result is not None, "Required property 'ipam_scope_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def allocation_default_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The default netmask length for allocations added to this pool.

        If, for example, the CIDR assigned to this pool is 10.0.0.0/8 and you enter 16 here, new allocations will default to 10.0.0.0/16.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationdefaultnetmasklength
        '''
        result = self._values.get("allocation_default_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allocation_max_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The maximum netmask length possible for CIDR allocations in this IPAM pool to be compliant.

        The maximum netmask length must be greater than the minimum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationmaxnetmasklength
        '''
        result = self._values.get("allocation_max_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allocation_min_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The minimum netmask length required for CIDR allocations in this IPAM pool to be compliant.

        The minimum netmask length must be less than the maximum netmask length. Possible netmask lengths for IPv4 addresses are 0 - 32. Possible netmask lengths for IPv6 addresses are 0 - 128.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationminnetmasklength
        '''
        result = self._values.get("allocation_min_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def allocation_resource_tags(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]]:
        '''Tags that are required for resources that use CIDRs from this IPAM pool.

        Resources that do not have these tags will not be allowed to allocate space from the pool. If the resources have their tags changed after they have allocated space or if the allocation tagging requirements are changed on the pool, the resource may be marked as noncompliant.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-allocationresourcetags
        '''
        result = self._values.get("allocation_resource_tags")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[_IResolvable_da3f097b, _CfnTag_f6864754]]]], result)

    @builtins.property
    def auto_import(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''If selected, IPAM will continuously look for resources within the CIDR range of this pool and automatically import them as allocations into your IPAM.

        The CIDRs that will be allocated for these resources must not already be allocated to other resources in order for the import to succeed. IPAM will import a CIDR regardless of its compliance with the pool's allocation rules, so a resource might be imported and subsequently marked as noncompliant. If IPAM discovers multiple CIDRs that overlap, IPAM will import the largest CIDR only. If IPAM discovers multiple CIDRs with matching CIDRs, IPAM will randomly import one of them only.

        A locale must be set on the pool for this feature to work.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-autoimport
        '''
        result = self._values.get("auto_import")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the IPAM pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def locale(self) -> typing.Optional[builtins.str]:
        '''The locale of the IPAM pool.

        In IPAM, the locale is the AWS Region where you want to make an IPAM pool available for allocations. Only resources in the same Region as the locale of the pool can get IP address allocations from the pool. You can only allocate a CIDR for a VPC, for example, from an IPAM pool that shares a locale with the VPCâ€™s Region. Note that once you choose a Locale for a pool, you cannot modify it. If you choose an AWS Region for locale that has not been configured as an operating Region for the IPAM, you'll get an error.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-locale
        '''
        result = self._values.get("locale")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def provisioned_cidrs(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnIPAMPool.ProvisionedCidrProperty, _IResolvable_da3f097b]]]]:
        '''Information about the CIDRs provisioned to an IPAM pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-provisionedcidrs
        '''
        result = self._values.get("provisioned_cidrs")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnIPAMPool.ProvisionedCidrProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def publicly_advertisable(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Determines if a pool is publicly advertisable.

        This option is not available for pools with AddressFamily set to ``ipv4`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-publiclyadvertisable
        '''
        result = self._values.get("publicly_advertisable")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def source_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the source IPAM pool.

        You can use this option to create an IPAM pool within an existing source pool.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-sourceipampoolid
        '''
        result = self._values.get("source_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipampool.html#cfn-ec2-ipampool-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMPoolProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "operating_regions": "operatingRegions",
        "tags": "tags",
    },
)
class CfnIPAMProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        operating_regions: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnIPAM.IpamOperatingRegionProperty, _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnIPAM``.

        :param description: The description for the IPAM.
        :param operating_regions: The operating Regions for an IPAM. Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions. For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_iPAMProps = ec2.CfnIPAMProps(
                description="description",
                operating_regions=[ec2.CfnIPAM.IpamOperatingRegionProperty(
                    region_name="regionName"
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if operating_regions is not None:
            self._values["operating_regions"] = operating_regions
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description for the IPAM.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def operating_regions(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnIPAM.IpamOperatingRegionProperty, _IResolvable_da3f097b]]]]:
        '''The operating Regions for an IPAM.

        Operating Regions are AWS Regions where the IPAM is allowed to manage IP address CIDRs. IPAM only discovers and monitors resources in the AWS Regions you select as operating Regions.

        For more information about operating Regions, see `Create an IPAM <https://docs.aws.amazon.com//vpc/latest/ipam/create-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-operatingregions
        '''
        result = self._values.get("operating_regions")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnIPAM.IpamOperatingRegionProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipam.html#cfn-ec2-ipam-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnIPAMScope(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMScope",
):
    '''A CloudFormation ``AWS::EC2::IPAMScope``.

    In IPAM, a scope is the highest-level container within IPAM. An IPAM contains two default scopes. Each scope represents the IP space for a single network. The private scope is intended for all private IP address space. The public scope is intended for all public IP address space. Scopes enable you to reuse IP addresses across multiple unconnected networks without causing IP address overlap or conflict.

    For more information, see `How IPAM works <https://docs.aws.amazon.com//vpc/latest/ipam/how-it-works-ipam.html>`_ in the *Amazon VPC IPAM User Guide*

    :cloudformationResource: AWS::EC2::IPAMScope
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_iPAMScope = ec2.CfnIPAMScope(self, "MyCfnIPAMScope",
            ipam_id="ipamId",
        
            # the properties below are optional
            description="description",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        ipam_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::IPAMScope``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param ipam_id: The ID of the IPAM for which you're creating this scope.
        :param description: The description of the scope.
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.
        '''
        props = CfnIPAMScopeProps(ipam_id=ipam_id, description=description, tags=tags)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrArn")
    def attr_arn(self) -> builtins.str:
        '''The ARN of the scope.

        :cloudformationAttribute: Arn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamArn")
    def attr_ipam_arn(self) -> builtins.str:
        '''The ARN of an IPAM.

        :cloudformationAttribute: IpamArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamScopeId")
    def attr_ipam_scope_id(self) -> builtins.str:
        '''The ID of an IPAM scope.

        :cloudformationAttribute: IpamScopeId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamScopeId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpamScopeType")
    def attr_ipam_scope_type(self) -> builtins.str:
        '''The type of the scope.

        :cloudformationAttribute: IpamScopeType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrIpamScopeType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIsDefault")
    def attr_is_default(self) -> _IResolvable_da3f097b:
        '''Defines if the scope is the default scope or not.

        :cloudformationAttribute: IsDefault
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrIsDefault"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPoolCount")
    def attr_pool_count(self) -> jsii.Number:
        '''The number of pools in a scope.

        :cloudformationAttribute: PoolCount
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrPoolCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipamId")
    def ipam_id(self) -> builtins.str:
        '''The ID of the IPAM for which you're creating this scope.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipamId"))

    @ipam_id.setter
    def ipam_id(self, value: builtins.str) -> None:
        jsii.set(self, "ipamId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the scope.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnIPAMScopeProps",
    jsii_struct_bases=[],
    name_mapping={"ipam_id": "ipamId", "description": "description", "tags": "tags"},
)
class CfnIPAMScopeProps:
    def __init__(
        self,
        *,
        ipam_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnIPAMScope``.

        :param ipam_id: The ID of the IPAM for which you're creating this scope.
        :param description: The description of the scope.
        :param tags: The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_iPAMScope_props = ec2.CfnIPAMScopeProps(
                ipam_id="ipamId",
            
                # the properties below are optional
                description="description",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "ipam_id": ipam_id,
        }
        if description is not None:
            self._values["description"] = description
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def ipam_id(self) -> builtins.str:
        '''The ID of the IPAM for which you're creating this scope.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-ipamid
        '''
        result = self._values.get("ipam_id")
        assert result is not None, "Required property 'ipam_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the scope.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The key/value combination of a tag assigned to the resource.

        Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key ``Owner`` and the value ``TeamA`` , specify ``tag:Owner`` for the filter name and ``TeamA`` for the filter value.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-ipamscope.html#cfn-ec2-ipamscope-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnIPAMScopeProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnInstance(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnInstance",
):
    '''A CloudFormation ``AWS::EC2::Instance``.

    Specifies an EC2 instance.

    If an Elastic IP address is attached to your instance, AWS CloudFormation reattaches the Elastic IP address after it updates the instance. For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .

    :cloudformationResource: AWS::EC2::Instance
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_instance = ec2.CfnInstance(self, "MyCfnInstance",
            additional_info="additionalInfo",
            affinity="affinity",
            availability_zone="availabilityZone",
            block_device_mappings=[ec2.CfnInstance.BlockDeviceMappingProperty(
                device_name="deviceName",
        
                # the properties below are optional
                ebs=ec2.CfnInstance.EbsProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                ),
                no_device=ec2.CfnInstance.NoDeviceProperty(),
                virtual_name="virtualName"
            )],
            cpu_options=ec2.CfnInstance.CpuOptionsProperty(
                core_count=123,
                threads_per_core=123
            ),
            credit_specification=ec2.CfnInstance.CreditSpecificationProperty(
                cpu_credits="cpuCredits"
            ),
            disable_api_termination=False,
            ebs_optimized=False,
            elastic_gpu_specifications=[ec2.CfnInstance.ElasticGpuSpecificationProperty(
                type="type"
            )],
            elastic_inference_accelerators=[ec2.CfnInstance.ElasticInferenceAcceleratorProperty(
                type="type",
        
                # the properties below are optional
                count=123
            )],
            enclave_options=ec2.CfnInstance.EnclaveOptionsProperty(
                enabled=False
            ),
            hibernation_options=ec2.CfnInstance.HibernationOptionsProperty(
                configured=False
            ),
            host_id="hostId",
            host_resource_group_arn="hostResourceGroupArn",
            iam_instance_profile="iamInstanceProfile",
            image_id="imageId",
            instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
            instance_type="instanceType",
            ipv6_address_count=123,
            ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(
                ipv6_address="ipv6Address"
            )],
            kernel_id="kernelId",
            key_name="keyName",
            launch_template=ec2.CfnInstance.LaunchTemplateSpecificationProperty(
                version="version",
        
                # the properties below are optional
                launch_template_id="launchTemplateId",
                launch_template_name="launchTemplateName"
            ),
            license_specifications=[ec2.CfnInstance.LicenseSpecificationProperty(
                license_configuration_arn="licenseConfigurationArn"
            )],
            monitoring=False,
            network_interfaces=[ec2.CfnInstance.NetworkInterfaceProperty(
                device_index="deviceIndex",
        
                # the properties below are optional
                associate_public_ip_address=False,
                delete_on_termination=False,
                description="description",
                group_set=["groupSet"],
                ipv6_address_count=123,
                ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )],
                network_interface_id="networkInterfaceId",
                private_ip_address="privateIpAddress",
                private_ip_addresses=[ec2.CfnInstance.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )],
                secondary_private_ip_address_count=123,
                subnet_id="subnetId"
            )],
            placement_group_name="placementGroupName",
            private_dns_name_options=ec2.CfnInstance.PrivateDnsNameOptionsProperty(
                enable_resource_name_dns_aaaa_record=False,
                enable_resource_name_dns_aRecord=False,
                hostname_type="hostnameType"
            ),
            private_ip_address="privateIpAddress",
            propagate_tags_to_volume_on_creation=False,
            ramdisk_id="ramdiskId",
            security_group_ids=["securityGroupIds"],
            security_groups=["securityGroups"],
            source_dest_check=False,
            ssm_associations=[ec2.CfnInstance.SsmAssociationProperty(
                document_name="documentName",
        
                # the properties below are optional
                association_parameters=[ec2.CfnInstance.AssociationParameterProperty(
                    key="key",
                    value=["value"]
                )]
            )],
            subnet_id="subnetId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            tenancy="tenancy",
            user_data="userData",
            volumes=[ec2.CfnInstance.VolumeProperty(
                device="device",
                volume_id="volumeId"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        additional_info: typing.Optional[builtins.str] = None,
        affinity: typing.Optional[builtins.str] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        block_device_mappings: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]] = None,
        cpu_options: typing.Optional[typing.Union["CfnInstance.CpuOptionsProperty", _IResolvable_da3f097b]] = None,
        credit_specification: typing.Optional[typing.Union["CfnInstance.CreditSpecificationProperty", _IResolvable_da3f097b]] = None,
        disable_api_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        elastic_gpu_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        elastic_inference_accelerators: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.ElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]] = None,
        enclave_options: typing.Optional[typing.Union["CfnInstance.EnclaveOptionsProperty", _IResolvable_da3f097b]] = None,
        hibernation_options: typing.Optional[typing.Union["CfnInstance.HibernationOptionsProperty", _IResolvable_da3f097b]] = None,
        host_id: typing.Optional[builtins.str] = None,
        host_resource_group_arn: typing.Optional[builtins.str] = None,
        iam_instance_profile: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]] = None,
        kernel_id: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        launch_template: typing.Optional[typing.Union["CfnInstance.LaunchTemplateSpecificationProperty", _IResolvable_da3f097b]] = None,
        license_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.LicenseSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        monitoring: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        network_interfaces: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.NetworkInterfaceProperty", _IResolvable_da3f097b]]]] = None,
        placement_group_name: typing.Optional[builtins.str] = None,
        private_dns_name_options: typing.Optional[typing.Union["CfnInstance.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        propagate_tags_to_volume_on_creation: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ramdisk_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_dest_check: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ssm_associations: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.SsmAssociationProperty", _IResolvable_da3f097b]]]] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        user_data: typing.Optional[builtins.str] = None,
        volumes: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.VolumeProperty", _IResolvable_da3f097b]]]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::Instance``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param additional_info: This property is reserved for internal use. If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .
        :param affinity: Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .
        :param availability_zone: The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .
        :param block_device_mappings: The block device mapping entries that defines the block devices to attach to the instance at launch. By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
        :param cpu_options: The CPU options for the instance. For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
        :param credit_specification: The credit option for CPU usage of the burstable performance instance. Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* . Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a instances) For T3 instances with ``host`` tenancy, only ``standard`` is supported.
        :param disable_api_termination: If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance. Default: ``false``
        :param ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: ``false``
        :param elastic_gpu_specifications: An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide* .
        :param elastic_inference_accelerators: An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. You cannot specify accelerators from different generations in the same request.
        :param enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param hibernation_options: Indicates whether an instance is enabled for hibernation. For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* . You can't enable hibernation and AWS Nitro Enclaves on the same instance.
        :param host_id: If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with. If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
        :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .
        :param iam_instance_profile: The name of an IAM instance profile. To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.
        :param image_id: The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template.
        :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``
        :param instance_type: The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . Default: ``m1.small``
        :param ipv6_address_count: [EC2-VPC] The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.
        :param ipv6_addresses: [EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.
        :param kernel_id: The ID of the kernel. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
        :param key_name: The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        :param launch_template: The launch template to use to launch the instances. Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
        :param license_specifications: The license configurations.
        :param monitoring: Specifies whether detailed monitoring is enabled for the instance.
        :param network_interfaces: The network interfaces to associate with the instance. .. epigraph:: If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed. If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.
        :param placement_group_name: The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
        :param private_dns_name_options: The options for the instance hostname.
        :param private_ip_address: [EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request. You cannot specify this option and the network interfaces option in the same request. If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
        :param propagate_tags_to_volume_on_creation: Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch. If you specify ``true`` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify ``false`` , those tags are not assigned to the attached volumes.
        :param ramdisk_id: The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
        :param security_group_ids: The IDs of the security groups. You can create a security group using `CreateSecurityGroup <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html>`_ . If you specify a network interface, you must specify any security groups as part of the network interface.
        :param security_groups: [EC2-Classic, default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead. You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template. Default: Amazon EC2 uses the default security group.
        :param source_dest_check: Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
        :param ssm_associations: The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an Instance Profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: You can currently associate only one document with an instance.
        :param subnet_id: [EC2-VPC] The ID of the subnet to launch the instance into. If you specify a network interface, you must specify any subnets as part of the network interface.
        :param tags: The tags to add to the instance. These tags are not applied to the EBS volumes, such as the root volume.
        :param tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.
        :param user_data: The user data to make available to the instance. For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ and `Run commands on your Windows instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html>`_ . If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text. User data is limited to 16 KB.
        :param volumes: The volumes to attach to the instance.
        '''
        props = CfnInstanceProps(
            additional_info=additional_info,
            affinity=affinity,
            availability_zone=availability_zone,
            block_device_mappings=block_device_mappings,
            cpu_options=cpu_options,
            credit_specification=credit_specification,
            disable_api_termination=disable_api_termination,
            ebs_optimized=ebs_optimized,
            elastic_gpu_specifications=elastic_gpu_specifications,
            elastic_inference_accelerators=elastic_inference_accelerators,
            enclave_options=enclave_options,
            hibernation_options=hibernation_options,
            host_id=host_id,
            host_resource_group_arn=host_resource_group_arn,
            iam_instance_profile=iam_instance_profile,
            image_id=image_id,
            instance_initiated_shutdown_behavior=instance_initiated_shutdown_behavior,
            instance_type=instance_type,
            ipv6_address_count=ipv6_address_count,
            ipv6_addresses=ipv6_addresses,
            kernel_id=kernel_id,
            key_name=key_name,
            launch_template=launch_template,
            license_specifications=license_specifications,
            monitoring=monitoring,
            network_interfaces=network_interfaces,
            placement_group_name=placement_group_name,
            private_dns_name_options=private_dns_name_options,
            private_ip_address=private_ip_address,
            propagate_tags_to_volume_on_creation=propagate_tags_to_volume_on_creation,
            ramdisk_id=ramdisk_id,
            security_group_ids=security_group_ids,
            security_groups=security_groups,
            source_dest_check=source_dest_check,
            ssm_associations=ssm_associations,
            subnet_id=subnet_id,
            tags=tags,
            tenancy=tenancy,
            user_data=user_data,
            volumes=volumes,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAvailabilityZone")
    def attr_availability_zone(self) -> builtins.str:
        '''The Availability Zone where the specified instance is launched. For example: ``us-east-1b`` .

        You can retrieve a list of all Availability Zones for a Region by using the `Fn::GetAZs <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getavailabilityzones.html>`_ intrinsic function.

        :cloudformationAttribute: AvailabilityZone
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPrivateDnsName")
    def attr_private_dns_name(self) -> builtins.str:
        '''The private DNS name of the specified instance.

        For example: ``ip-10-24-34-0.ec2.internal`` .

        :cloudformationAttribute: PrivateDnsName
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPrivateDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPrivateIp")
    def attr_private_ip(self) -> builtins.str:
        '''The private IP address of the specified instance.

        For example: ``10.24.34.0`` .

        :cloudformationAttribute: PrivateIp
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPrivateIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPublicDnsName")
    def attr_public_dns_name(self) -> builtins.str:
        '''The public DNS name of the specified instance.

        For example: ``ec2-107-20-50-45.compute-1.amazonaws.com`` .

        :cloudformationAttribute: PublicDnsName
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPublicDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPublicIp")
    def attr_public_ip(self) -> builtins.str:
        '''The public IP address of the specified instance.

        For example: ``192.0.2.0`` .

        :cloudformationAttribute: PublicIp
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPublicIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to add to the instance.

        These tags are not applied to the EBS volumes, such as the root volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="additionalInfo")
    def additional_info(self) -> typing.Optional[builtins.str]:
        '''This property is reserved for internal use.

        If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-additionalinfo
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "additionalInfo"))

    @additional_info.setter
    def additional_info(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "additionalInfo", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="affinity")
    def affinity(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the instance is associated with a dedicated host.

        If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-affinity
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "affinity"))

    @affinity.setter
    def affinity(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "affinity", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone of the instance.

        If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.

        This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-availabilityzone
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "availabilityZone"))

    @availability_zone.setter
    def availability_zone(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "availabilityZone", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="blockDeviceMappings")
    def block_device_mappings(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]]:
        '''The block device mapping entries that defines the block devices to attach to the instance at launch.

        By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting.
        .. epigraph::

           After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]], jsii.get(self, "blockDeviceMappings"))

    @block_device_mappings.setter
    def block_device_mappings(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "blockDeviceMappings", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cpuOptions")
    def cpu_options(
        self,
    ) -> typing.Optional[typing.Union["CfnInstance.CpuOptionsProperty", _IResolvable_da3f097b]]:
        '''The CPU options for the instance.

        For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-cpuoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnInstance.CpuOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "cpuOptions"))

    @cpu_options.setter
    def cpu_options(
        self,
        value: typing.Optional[typing.Union["CfnInstance.CpuOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "cpuOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="creditSpecification")
    def credit_specification(
        self,
    ) -> typing.Optional[typing.Union["CfnInstance.CreditSpecificationProperty", _IResolvable_da3f097b]]:
        '''The credit option for CPU usage of the burstable performance instance.

        Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a instances)

        For T3 instances with ``host`` tenancy, only ``standard`` is supported.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-creditspecification
        '''
        return typing.cast(typing.Optional[typing.Union["CfnInstance.CreditSpecificationProperty", _IResolvable_da3f097b]], jsii.get(self, "creditSpecification"))

    @credit_specification.setter
    def credit_specification(
        self,
        value: typing.Optional[typing.Union["CfnInstance.CreditSpecificationProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "creditSpecification", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="disableApiTermination")
    def disable_api_termination(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;

        otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance.

        Default: ``false``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-disableapitermination
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "disableApiTermination"))

    @disable_api_termination.setter
    def disable_api_termination(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "disableApiTermination", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ebsOptimized")
    def ebs_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the instance is optimized for Amazon EBS I/O.

        This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.

        Default: ``false``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ebsoptimized
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "ebsOptimized"))

    @ebs_optimized.setter
    def ebs_optimized(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "ebsOptimized", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elasticGpuSpecifications")
    def elastic_gpu_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''An elastic GPU to associate with the instance.

        An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "elasticGpuSpecifications"))

    @elastic_gpu_specifications.setter
    def elastic_gpu_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "elasticGpuSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elasticInferenceAccelerators")
    def elastic_inference_accelerators(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.ElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]]:
        '''An elastic inference accelerator to associate with the instance.

        Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.

        You cannot specify accelerators from different generations in the same request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.ElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]], jsii.get(self, "elasticInferenceAccelerators"))

    @elastic_inference_accelerators.setter
    def elastic_inference_accelerators(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.ElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "elasticInferenceAccelerators", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enclaveOptions")
    def enclave_options(
        self,
    ) -> typing.Optional[typing.Union["CfnInstance.EnclaveOptionsProperty", _IResolvable_da3f097b]]:
        '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-enclaveoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnInstance.EnclaveOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "enclaveOptions"))

    @enclave_options.setter
    def enclave_options(
        self,
        value: typing.Optional[typing.Union["CfnInstance.EnclaveOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "enclaveOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hibernationOptions")
    def hibernation_options(
        self,
    ) -> typing.Optional[typing.Union["CfnInstance.HibernationOptionsProperty", _IResolvable_da3f097b]]:
        '''Indicates whether an instance is enabled for hibernation.

        For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .

        You can't enable hibernation and AWS Nitro Enclaves on the same instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hibernationoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnInstance.HibernationOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "hibernationOptions"))

    @hibernation_options.setter
    def hibernation_options(
        self,
        value: typing.Optional[typing.Union["CfnInstance.HibernationOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "hibernationOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostId")
    def host_id(self) -> typing.Optional[builtins.str]:
        '''If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with.

        If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hostid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostId"))

    @host_id.setter
    def host_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the host resource group in which to launch the instances.

        If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "hostResourceGroupArn"))

    @host_resource_group_arn.setter
    def host_resource_group_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "hostResourceGroupArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="iamInstanceProfile")
    def iam_instance_profile(self) -> typing.Optional[builtins.str]:
        '''The name of an IAM instance profile.

        To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "iamInstanceProfile"))

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "iamInstanceProfile", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="imageId")
    def image_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AMI.

        An AMI ID is required to launch an instance and must be specified here or in a launch template.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-imageid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "imageId"))

    @image_id.setter
    def image_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "imageId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceInitiatedShutdownBehavior")
    def instance_initiated_shutdown_behavior(self) -> typing.Optional[builtins.str]:
        '''Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).

        Default: ``stop``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceInitiatedShutdownBehavior"))

    @instance_initiated_shutdown_behavior.setter
    def instance_initiated_shutdown_behavior(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "instanceInitiatedShutdownBehavior", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceType")
    def instance_type(self) -> typing.Optional[builtins.str]:
        '''The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``m1.small``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-instancetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceType"))

    @instance_type.setter
    def instance_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        '''[EC2-VPC] The number of IPv6 addresses to associate with the primary network interface.

        Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

        You cannot specify this option and the network interfaces option in the same request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "ipv6AddressCount"))

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6Addresses")
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]]:
        '''[EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface.

        You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

        You cannot specify this option and the network interfaces option in the same request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ipv6addresses
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]], jsii.get(self, "ipv6Addresses"))

    @ipv6_addresses.setter
    def ipv6_addresses(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "ipv6Addresses", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="kernelId")
    def kernel_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the kernel.

        .. epigraph::

           We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-kernelid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kernelId"))

    @kernel_id.setter
    def kernel_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "kernelId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="keyName")
    def key_name(self) -> typing.Optional[builtins.str]:
        '''The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ .

        .. epigraph::

           If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-keyname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyName"))

    @key_name.setter
    def key_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "keyName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplate")
    def launch_template(
        self,
    ) -> typing.Optional[typing.Union["CfnInstance.LaunchTemplateSpecificationProperty", _IResolvable_da3f097b]]:
        '''The launch template to use to launch the instances.

        Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-launchtemplate
        '''
        return typing.cast(typing.Optional[typing.Union["CfnInstance.LaunchTemplateSpecificationProperty", _IResolvable_da3f097b]], jsii.get(self, "launchTemplate"))

    @launch_template.setter
    def launch_template(
        self,
        value: typing.Optional[typing.Union["CfnInstance.LaunchTemplateSpecificationProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "launchTemplate", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="licenseSpecifications")
    def license_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.LicenseSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The license configurations.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-licensespecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.LicenseSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "licenseSpecifications"))

    @license_specifications.setter
    def license_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.LicenseSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "licenseSpecifications", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="monitoring")
    def monitoring(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Specifies whether detailed monitoring is enabled for the instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-monitoring
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "monitoring"))

    @monitoring.setter
    def monitoring(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "monitoring", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaces")
    def network_interfaces(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.NetworkInterfaceProperty", _IResolvable_da3f097b]]]]:
        '''The network interfaces to associate with the instance.

        .. epigraph::

           If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.

           If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-networkinterfaces
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.NetworkInterfaceProperty", _IResolvable_da3f097b]]]], jsii.get(self, "networkInterfaces"))

    @network_interfaces.setter
    def network_interfaces(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.NetworkInterfaceProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "networkInterfaces", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="placementGroupName")
    def placement_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-placementgroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "placementGroupName"))

    @placement_group_name.setter
    def placement_group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "placementGroupName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsNameOptions")
    def private_dns_name_options(
        self,
    ) -> typing.Optional[typing.Union["CfnInstance.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]]:
        '''The options for the instance hostname.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
        '''
        return typing.cast(typing.Optional[typing.Union["CfnInstance.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "privateDnsNameOptions"))

    @private_dns_name_options.setter
    def private_dns_name_options(
        self,
        value: typing.Optional[typing.Union["CfnInstance.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "privateDnsNameOptions", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.

        Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.

        You cannot specify this option and the network interfaces option in the same request.

        If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-privateipaddress
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "privateIpAddress"))

    @private_ip_address.setter
    def private_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "privateIpAddress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="propagateTagsToVolumeOnCreation")
    def propagate_tags_to_volume_on_creation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.

        If you specify ``true`` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify ``false`` , those tags are not assigned to the attached volumes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "propagateTagsToVolumeOnCreation"))

    @propagate_tags_to_volume_on_creation.setter
    def propagate_tags_to_volume_on_creation(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "propagateTagsToVolumeOnCreation", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ramdiskId")
    def ramdisk_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the RAM disk to select.

        Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
        .. epigraph::

           We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ramdiskid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ramdiskId"))

    @ramdisk_id.setter
    def ramdisk_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ramdiskId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups. You can create a security group using `CreateSecurityGroup <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html>`_ .

        If you specify a network interface, you must specify any security groups as part of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-securitygroupids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "securityGroupIds"))

    @security_group_ids.setter
    def security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroups")
    def security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''[EC2-Classic, default VPC] The names of the security groups.

        For a nondefault VPC, you must use security group IDs instead.

        You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.

        Default: Amazon EC2 uses the default security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-securitygroups
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "securityGroups"))

    @security_groups.setter
    def security_groups(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "securityGroups", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceDestCheck")
    def source_dest_check(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.

        If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "sourceDestCheck"))

    @source_dest_check.setter
    def source_dest_check(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "sourceDestCheck", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ssmAssociations")
    def ssm_associations(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.SsmAssociationProperty", _IResolvable_da3f097b]]]]:
        '''The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an Instance Profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* .

        .. epigraph::

           You can currently associate only one document with an instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ssmassociations
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.SsmAssociationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "ssmAssociations"))

    @ssm_associations.setter
    def ssm_associations(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.SsmAssociationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "ssmAssociations", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The ID of the subnet to launch the instance into.

        If you specify a network interface, you must specify any subnets as part of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-subnetid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "subnetId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tenancy")
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''The tenancy of the instance (if the instance is running in a VPC).

        An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-tenancy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tenancy"))

    @tenancy.setter
    def tenancy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "tenancy", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional[builtins.str]:
        '''The user data to make available to the instance.

        For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ and `Run commands on your Windows instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html>`_ . If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text. User data is limited to 16 KB.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-userdata
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "userData"))

    @user_data.setter
    def user_data(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "userData", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="volumes")
    def volumes(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.VolumeProperty", _IResolvable_da3f097b]]]]:
        '''The volumes to attach to the instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-volumes
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.VolumeProperty", _IResolvable_da3f097b]]]], jsii.get(self, "volumes"))

    @volumes.setter
    def volumes(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.VolumeProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "volumes", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.AssociationParameterProperty",
        jsii_struct_bases=[],
        name_mapping={"key": "key", "value": "value"},
    )
    class AssociationParameterProperty:
        def __init__(
            self,
            *,
            key: builtins.str,
            value: typing.Sequence[builtins.str],
        ) -> None:
            '''Specifies input parameter values for an SSM document in AWS Systems Manager .

            ``AssociationParameter`` is a property of the `Amazon EC2 Instance SsmAssociation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html>`_ property.

            :param key: The name of an input parameter that is in the associated SSM document.
            :param value: The value of an input parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                association_parameter_property = ec2.CfnInstance.AssociationParameterProperty(
                    key="key",
                    value=["value"]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "key": key,
                "value": value,
            }

        @builtins.property
        def key(self) -> builtins.str:
            '''The name of an input parameter that is in the associated SSM document.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html#cfn-ec2-instance-ssmassociations-associationparameters-key
            '''
            result = self._values.get("key")
            assert result is not None, "Required property 'key' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def value(self) -> typing.List[builtins.str]:
            '''The value of an input parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations-associationparameters.html#cfn-ec2-instance-ssmassociations-associationparameters-value
            '''
            result = self._values.get("value")
            assert result is not None, "Required property 'value' is missing"
            return typing.cast(typing.List[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AssociationParameterProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: builtins.str,
            ebs: typing.Optional[typing.Union["CfnInstance.EbsProperty", _IResolvable_da3f097b]] = None,
            no_device: typing.Optional[typing.Union["CfnInstance.NoDeviceProperty", _IResolvable_da3f097b]] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device mapping for an instance.

            You must specify exactly one of the following properties: ``VirtualName`` , ``Ebs`` , or ``NoDevice`` .

            ``BlockDeviceMapping`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.
            .. epigraph::

               After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :param device_name: The device name (for example, ``/dev/sdh`` or ``xvdh`` ). .. epigraph:: After the instance is running, this parameter is used to specify the device name of the block device mapping to update.
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_ .
            :param no_device: To omit the device from the block device mapping, specify an empty string. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param virtual_name: The virtual device name ( ``ephemeral`` N). The name must be in the form ``ephemeral`` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                block_device_mapping_property = ec2.CfnInstance.BlockDeviceMappingProperty(
                    device_name="deviceName",
                
                    # the properties below are optional
                    ebs=ec2.CfnInstance.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device=ec2.CfnInstance.NoDeviceProperty(),
                    virtual_name="virtualName"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "device_name": device_name,
            }
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> builtins.str:
            '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

            .. epigraph::

               After the instance is running, this parameter is used to specify the device name of the block device mapping to update.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-devicename
            '''
            result = self._values.get("device_name")
            assert result is not None, "Required property 'device_name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["CfnInstance.EbsProperty", _IResolvable_da3f097b]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            .. epigraph::

               After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-no-interrupt>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["CfnInstance.EbsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def no_device(
            self,
        ) -> typing.Optional[typing.Union["CfnInstance.NoDeviceProperty", _IResolvable_da3f097b]]:
            '''To omit the device from the block device mapping, specify an empty string.

            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[typing.Union["CfnInstance.NoDeviceProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name ( ``ephemeral`` N).

            The name must be in the form ``ephemeral`` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

            *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html#cfn-ec2-blockdev-mapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.CpuOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"core_count": "coreCount", "threads_per_core": "threadsPerCore"},
    )
    class CpuOptionsProperty:
        def __init__(
            self,
            *,
            core_count: typing.Optional[jsii.Number] = None,
            threads_per_core: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the CPU options for the instance.

            When you specify CPU options, you must specify both the number of CPU cores and threads per core.

            For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :param core_count: The number of CPU cores for the instance.
            :param threads_per_core: The number of threads per CPU core.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                cpu_options_property = ec2.CfnInstance.CpuOptionsProperty(
                    core_count=123,
                    threads_per_core=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if core_count is not None:
                self._values["core_count"] = core_count
            if threads_per_core is not None:
                self._values["threads_per_core"] = threads_per_core

        @builtins.property
        def core_count(self) -> typing.Optional[jsii.Number]:
            '''The number of CPU cores for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-corecount
            '''
            result = self._values.get("core_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def threads_per_core(self) -> typing.Optional[jsii.Number]:
            '''The number of threads per CPU core.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-cpuoptions.html#cfn-ec2-instance-cpuoptions-threadspercore
            '''
            result = self._values.get("threads_per_core")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.CreditSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu_credits": "cpuCredits"},
    )
    class CreditSpecificationProperty:
        def __init__(
            self,
            *,
            cpu_credits: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the credit option for CPU usage of a T2, T3, or T3a instance.

            ``CreditSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param cpu_credits: The credit option for CPU usage of the instance. Valid values are ``standard`` and ``unlimited`` . ``T3`` instances launch as ``unlimited`` by default. ``T2`` instances launch as ``standard`` by default.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                credit_specification_property = ec2.CfnInstance.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if cpu_credits is not None:
                self._values["cpu_credits"] = cpu_credits

        @builtins.property
        def cpu_credits(self) -> typing.Optional[builtins.str]:
            '''The credit option for CPU usage of the instance.

            Valid values are ``standard`` and ``unlimited`` . ``T3`` instances launch as ``unlimited`` by default. ``T2`` instances launch as ``standard`` by default.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-creditspecification.html#cfn-ec2-instance-creditspecification-cpucredits
            '''
            result = self._values.get("cpu_credits")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CreditSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.EbsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "kms_key_id": "kmsKeyId",
            "snapshot_id": "snapshotId",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            iops: typing.Optional[jsii.Number] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device for an EBS volume.

            ``Ebs`` is a property of the `Amazon EC2 BlockDeviceMapping <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html>`_ property.
            .. epigraph::

               After the instance is running, you can modify only the ``DeleteOnTermination`` parameters for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .
            :param encrypted: Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ . .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param kms_key_id: The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If the encrypted state is ``true`` but you do not specify ``KmsKeyId`` , your KMS key for EBS is used. You can specify the KMS key using any of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. For example, alias/ExampleAlias. - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param snapshot_id: The ID of the snapshot. If you specify both ``SnapshotId`` and ``VolumeSize`` , ``VolumeSize`` must be equal or greater than the size of the snapshot. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` :1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024 .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports. .. epigraph:: After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ebs_property = ec2.CfnInstance.EbsProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the volume should be encrypted.

            The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000-16,000 IOPS
            - ``io1`` : 100-64,000 IOPS
            - ``io2`` : 100-64,000 IOPS

            For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS.

            This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''The identifier of the AWS KMS key to use for Amazon EBS encryption.

            If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If the encrypted state is ``true`` but you do not specify ``KmsKeyId`` , your KMS key for EBS is used.

            You can specify the KMS key using any of the following:

            - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
            - Key alias. For example, alias/ExampleAlias.
            - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:1234abcd-12ab-34cd-56ef-1234567890ab.
            - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.

            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-instance-ebs-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            If you specify both ``SnapshotId`` and ``VolumeSize`` , ``VolumeSize`` must be equal or greater than the size of the snapshot.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

            The following are the supported volumes sizes for each volume type:

            - ``gp2`` and ``gp3`` :1-16,384
            - ``io1`` and ``io2`` : 4-16,384
            - ``st1`` and ``sc1`` : 125-16,384
            - ``standard`` : 1-1,024

            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports.
            .. epigraph::

               After the instance is running, modifying this parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-template.html#cfn-ec2-blockdev-template-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.ElasticGpuSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type"},
    )
    class ElasticGpuSpecificationProperty:
        def __init__(self, *, type: builtins.str) -> None:
            '''Specifies the type of Elastic GPU.

            An Elastic GPU is a GPU resource that you can attach to your Amazon EC2 instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide for Windows Instances* .

            ``ElasticGpuSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param type: The type of Elastic Graphics accelerator. For more information about the values to specify for ``Type`` , see `Elastic Graphics Basics <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics>`_ , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                elastic_gpu_specification_property = ec2.CfnInstance.ElasticGpuSpecificationProperty(
                    type="type"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "type": type,
            }

        @builtins.property
        def type(self) -> builtins.str:
            '''The type of Elastic Graphics accelerator.

            For more information about the values to specify for ``Type`` , see `Elastic Graphics Basics <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics>`_ , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticgpuspecification.html#cfn-ec2-instance-elasticgpuspecification-type
            '''
            result = self._values.get("type")
            assert result is not None, "Required property 'type' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticGpuSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.ElasticInferenceAcceleratorProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type", "count": "count"},
    )
    class ElasticInferenceAcceleratorProperty:
        def __init__(
            self,
            *,
            type: builtins.str,
            count: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the Elastic Inference Accelerator for the instance.

            ``ElasticInferenceAccelerator`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param type: The type of elastic inference accelerator. The possible values are ``eia1.medium`` , ``eia1.large`` , ``eia1.xlarge`` , ``eia2.medium`` , ``eia2.large`` , and ``eia2.xlarge`` .
            :param count: The number of elastic inference accelerators to attach to the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                elastic_inference_accelerator_property = ec2.CfnInstance.ElasticInferenceAcceleratorProperty(
                    type="type",
                
                    # the properties below are optional
                    count=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "type": type,
            }
            if count is not None:
                self._values["count"] = count

        @builtins.property
        def type(self) -> builtins.str:
            '''The type of elastic inference accelerator.

            The possible values are ``eia1.medium`` , ``eia1.large`` , ``eia1.xlarge`` , ``eia2.medium`` , ``eia2.large`` , and ``eia2.xlarge`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-type
            '''
            result = self._values.get("type")
            assert result is not None, "Required property 'type' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def count(self) -> typing.Optional[jsii.Number]:
            '''The number of elastic inference accelerators to attach to the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-elasticinferenceaccelerator.html#cfn-ec2-instance-elasticinferenceaccelerator-count
            '''
            result = self._values.get("count")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticInferenceAcceleratorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.EnclaveOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class EnclaveOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

            :param enabled: If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                enclave_options_property = ec2.CfnInstance.EnclaveOptionsProperty(
                    enabled=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves;

            otherwise, it is not enabled for AWS Nitro Enclaves.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-enclaveoptions.html#cfn-ec2-instance-enclaveoptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnclaveOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.HibernationOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"configured": "configured"},
    )
    class HibernationOptionsProperty:
        def __init__(
            self,
            *,
            configured: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies the hibernation options for the instance.

            ``HibernationOptions`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param configured: If you set this parameter to ``true`` , your instance is enabled for hibernation. Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                hibernation_options_property = ec2.CfnInstance.HibernationOptionsProperty(
                    configured=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if configured is not None:
                self._values["configured"] = configured

        @builtins.property
        def configured(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''If you set this parameter to ``true`` , your instance is enabled for hibernation.

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-hibernationoptions.html#cfn-ec2-instance-hibernationoptions-configured
            '''
            result = self._values.get("configured")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HibernationOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.InstanceIpv6AddressProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class InstanceIpv6AddressProperty:
        def __init__(self, *, ipv6_address: builtins.str) -> None:
            '''Specifies the IPv6 address for the instance.

            ``InstanceIpv6Address`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param ipv6_address: The IPv6 address.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_ipv6_address_property = ec2.CfnInstance.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "ipv6_address": ipv6_address,
            }

        @builtins.property
        def ipv6_address(self) -> builtins.str:
            '''The IPv6 address.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-instanceipv6address.html#cfn-ec2-instance-instanceipv6address-ipv6address
            '''
            result = self._values.get("ipv6_address")
            assert result is not None, "Required property 'ipv6_address' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceIpv6AddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.LaunchTemplateSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "version": "version",
            "launch_template_id": "launchTemplateId",
            "launch_template_name": "launchTemplateName",
        },
    )
    class LaunchTemplateSpecificationProperty:
        def __init__(
            self,
            *,
            version: builtins.str,
            launch_template_id: typing.Optional[builtins.str] = None,
            launch_template_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a launch template. You must specify either the launch template ID or launch template name.

            ``LaunchTemplateSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param version: The version number of the launch template. AWS CloudFormation does not support specifying ``$Latest`` , or ``$Default`` for the template version number.
            :param launch_template_id: The ID of the launch template.
            :param launch_template_name: The name of the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                launch_template_specification_property = ec2.CfnInstance.LaunchTemplateSpecificationProperty(
                    version="version",
                
                    # the properties below are optional
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "version": version,
            }
            if launch_template_id is not None:
                self._values["launch_template_id"] = launch_template_id
            if launch_template_name is not None:
                self._values["launch_template_name"] = launch_template_name

        @builtins.property
        def version(self) -> builtins.str:
            '''The version number of the launch template.

            AWS CloudFormation does not support specifying ``$Latest`` , or ``$Default`` for the template version number.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-version
            '''
            result = self._values.get("version")
            assert result is not None, "Required property 'version' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def launch_template_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplateid
            '''
            result = self._values.get("launch_template_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def launch_template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-launchtemplatespecification.html#cfn-ec2-instance-launchtemplatespecification-launchtemplatename
            '''
            result = self._values.get("launch_template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.LicenseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"license_configuration_arn": "licenseConfigurationArn"},
    )
    class LicenseSpecificationProperty:
        def __init__(self, *, license_configuration_arn: builtins.str) -> None:
            '''Specifies the license configuration to use.

            ``LicenseSpecification`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                license_specification_property = ec2.CfnInstance.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "license_configuration_arn": license_configuration_arn,
            }

        @builtins.property
        def license_configuration_arn(self) -> builtins.str:
            '''The Amazon Resource Name (ARN) of the license configuration.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-licensespecification.html#cfn-ec2-instance-licensespecification-licenseconfigurationarn
            '''
            result = self._values.get("license_configuration_arn")
            assert result is not None, "Required property 'license_configuration_arn' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LicenseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.NetworkInterfaceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_index": "deviceIndex",
            "associate_public_ip_address": "associatePublicIpAddress",
            "delete_on_termination": "deleteOnTermination",
            "description": "description",
            "group_set": "groupSet",
            "ipv6_address_count": "ipv6AddressCount",
            "ipv6_addresses": "ipv6Addresses",
            "network_interface_id": "networkInterfaceId",
            "private_ip_address": "privateIpAddress",
            "private_ip_addresses": "privateIpAddresses",
            "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
            "subnet_id": "subnetId",
        },
    )
    class NetworkInterfaceProperty:
        def __init__(
            self,
            *,
            device_index: builtins.str,
            associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            description: typing.Optional[builtins.str] = None,
            group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
            ipv6_address_count: typing.Optional[jsii.Number] = None,
            ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
            private_ip_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a network interface that is to be attached to an instance.

            You can create a network interface when launching an instance. For an example, see the `AWS::EC2::Instance examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#aws-properties-ec2-instance--examples--Automatically_assign_a_public_IP_address>`_ .

            Alternatively, you can attach an existing network interface when launching an instance. For an example, see the `AWS::EC2:NetworkInterface examples <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface.html#aws-resource-ec2-network-interface--examples--Basic_network_interface>`_ .

            :param device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you create a network interface when launching an instance, you must specify the device index.
            :param associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance. Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is ``true`` .
            :param delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated. Applies only if creating a network interface when launching an instance.
            :param description: The description of the network interface. Applies only if creating a network interface when launching an instance.
            :param group_set: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
            :param ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
            :param ipv6_addresses: One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
            :param network_interface_id: The ID of the network interface, when attaching an existing network interface.
            :param private_ip_address: The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance.
            :param private_ip_addresses: One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary.
            :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option.
            :param subnet_id: The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                network_interface_property = ec2.CfnInstance.NetworkInterfaceProperty(
                    device_index="deviceIndex",
                
                    # the properties below are optional
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    group_set=["groupSet"],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_interface_id="networkInterfaceId",
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2.CfnInstance.PrivateIpAddressSpecificationProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "device_index": device_index,
            }
            if associate_public_ip_address is not None:
                self._values["associate_public_ip_address"] = associate_public_ip_address
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if description is not None:
                self._values["description"] = description
            if group_set is not None:
                self._values["group_set"] = group_set
            if ipv6_address_count is not None:
                self._values["ipv6_address_count"] = ipv6_address_count
            if ipv6_addresses is not None:
                self._values["ipv6_addresses"] = ipv6_addresses
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address
            if private_ip_addresses is not None:
                self._values["private_ip_addresses"] = private_ip_addresses
            if secondary_private_ip_address_count is not None:
                self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id

        @builtins.property
        def device_index(self) -> builtins.str:
            '''The position of the network interface in the attachment order.

            A primary network interface has a device index of 0.

            If you create a network interface when launching an instance, you must specify the device index.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-deviceindex
            '''
            result = self._values.get("device_index")
            assert result is not None, "Required property 'device_index' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def associate_public_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to assign a public IPv4 address to an instance.

            Applies only if creating a network interface when launching an instance. The network interface must be the primary network interface. If launching into a default subnet, the default value is ``true`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-associatepubip
            '''
            result = self._values.get("associate_public_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the network interface is deleted when the instance is terminated.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-delete
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_set(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the security groups for the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-groupset
            '''
            result = self._values.get("group_set")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
            '''A number of IPv6 addresses to assign to the network interface.

            Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#cfn-ec2-instance-networkinterface-ipv6addresscount
            '''
            result = self._values.get("ipv6_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_addresses(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]]:
            '''One or more IPv6 addresses to assign to the network interface.

            You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#cfn-ec2-instance-networkinterface-ipv6addresses
            '''
            result = self._values.get("ipv6_addresses")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface, when attaching an existing network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-network-iface
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IPv4 address of the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_addresses(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''One or more private IPv4 addresses to assign to the network interface.

            Only one private IPv4 address can be designated as primary.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-privateipaddresses
            '''
            result = self._values.get("private_ip_addresses")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of secondary private IPv4 addresses.

            You can't specify this option and specify more than one private IP address using the private IP addresses option.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-secondprivateip
            '''
            result = self._values.get("secondary_private_ip_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet associated with the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-iface-embedded.html#aws-properties-ec2-network-iface-embedded-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.NoDeviceProperty",
        jsii_struct_bases=[],
        name_mapping={},
    )
    class NoDeviceProperty:
        def __init__(self) -> None:
            '''Suppresses the specified device included in the block device mapping of the AMI.

            To suppress a device, specify an empty string.

            ``NoDevice`` is a property of the `Amazon EC2 BlockDeviceMapping <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-blockdev-mapping.html>`_ property.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-nodevice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                no_device_property = ec2.CfnInstance.NoDeviceProperty()
            '''
            self._values: typing.Dict[str, typing.Any] = {}

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NoDeviceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.PrivateDnsNameOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_resource_name_dns_aaaa_record": "enableResourceNameDnsAaaaRecord",
            "enable_resource_name_dns_a_record": "enableResourceNameDnsARecord",
            "hostname_type": "hostnameType",
        },
    )
    class PrivateDnsNameOptionsProperty:
        def __init__(
            self,
            *,
            enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            hostname_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The type of hostnames to assign to instances in the subnet at launch.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :param enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param hostname_type: The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_dns_name_options_property = ec2.CfnInstance.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enable_resource_name_dns_aaaa_record is not None:
                self._values["enable_resource_name_dns_aaaa_record"] = enable_resource_name_dns_aaaa_record
            if enable_resource_name_dns_a_record is not None:
                self._values["enable_resource_name_dns_a_record"] = enable_resource_name_dns_a_record
            if hostname_type is not None:
                self._values["hostname_type"] = hostname_type

        @builtins.property
        def enable_resource_name_dns_aaaa_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.

            For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsaaaarecord
            '''
            result = self._values.get("enable_resource_name_dns_aaaa_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def enable_resource_name_dns_a_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS A records.

            For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-enableresourcenamednsarecord
            '''
            result = self._values.get("enable_resource_name_dns_a_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def hostname_type(self) -> typing.Optional[builtins.str]:
            '''The type of hostnames to assign to instances in the subnet at launch.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-privatednsnameoptions.html#cfn-ec2-instance-privatednsnameoptions-hostnametype
            '''
            result = self._values.get("hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateDnsNameOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.PrivateIpAddressSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddressSpecificationProperty:
        def __init__(
            self,
            *,
            primary: typing.Union[builtins.bool, _IResolvable_da3f097b],
            private_ip_address: builtins.str,
        ) -> None:
            '''Specifies a secondary private IPv4 address for a network interface.

            ``PrivateIpAddressSpecification`` is a property of the `AWS::EC2::NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface.html>`_ resource.

            :param primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
            :param private_ip_address: The private IPv4 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_ip_address_specification_property = ec2.CfnInstance.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "primary": primary,
                "private_ip_address": private_ip_address,
            }

        @builtins.property
        def primary(self) -> typing.Union[builtins.bool, _IResolvable_da3f097b]:
            '''Indicates whether the private IPv4 address is the primary private IPv4 address.

            Only one IPv4 address can be designated as primary.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html#cfn-ec2-networkinterface-privateipspecification-primary
            '''
            result = self._values.get("primary")
            assert result is not None, "Required property 'primary' is missing"
            return typing.cast(typing.Union[builtins.bool, _IResolvable_da3f097b], result)

        @builtins.property
        def private_ip_address(self) -> builtins.str:
            '''The private IPv4 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-network-interface-privateipspec.html#cfn-ec2-networkinterface-privateipspecification-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            assert result is not None, "Required property 'private_ip_address' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddressSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.SsmAssociationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "document_name": "documentName",
            "association_parameters": "associationParameters",
        },
    )
    class SsmAssociationProperty:
        def __init__(
            self,
            *,
            document_name: builtins.str,
            association_parameters: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnInstance.AssociationParameterProperty", _IResolvable_da3f097b]]]] = None,
        ) -> None:
            '''Specifies the SSM document and parameter values in AWS Systems Manager to associate with an instance.

            ``SsmAssociations`` is a property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param document_name: The name of an SSM document to associate with the instance.
            :param association_parameters: The input parameter values to use with the associated SSM document.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ssm_association_property = ec2.CfnInstance.SsmAssociationProperty(
                    document_name="documentName",
                
                    # the properties below are optional
                    association_parameters=[ec2.CfnInstance.AssociationParameterProperty(
                        key="key",
                        value=["value"]
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "document_name": document_name,
            }
            if association_parameters is not None:
                self._values["association_parameters"] = association_parameters

        @builtins.property
        def document_name(self) -> builtins.str:
            '''The name of an SSM document to associate with the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html#cfn-ec2-instance-ssmassociations-documentname
            '''
            result = self._values.get("document_name")
            assert result is not None, "Required property 'document_name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def association_parameters(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.AssociationParameterProperty", _IResolvable_da3f097b]]]]:
            '''The input parameter values to use with the associated SSM document.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance-ssmassociations.html#cfn-ec2-instance-ssmassociations-associationparameters
            '''
            result = self._values.get("association_parameters")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnInstance.AssociationParameterProperty", _IResolvable_da3f097b]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SsmAssociationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnInstance.VolumeProperty",
        jsii_struct_bases=[],
        name_mapping={"device": "device", "volume_id": "volumeId"},
    )
    class VolumeProperty:
        def __init__(self, *, device: builtins.str, volume_id: builtins.str) -> None:
            '''Specifies a volume to attach to an instance.

            ``Volume`` is an embedded property of the `AWS::EC2::Instance <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource.

            :param device: The device name (for example, ``/dev/sdh`` or ``xvdh`` ).
            :param volume_id: The ID of the EBS volume. The volume and instance must be within the same Availability Zone.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                volume_property = ec2.CfnInstance.VolumeProperty(
                    device="device",
                    volume_id="volumeId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "device": device,
                "volume_id": volume_id,
            }

        @builtins.property
        def device(self) -> builtins.str:
            '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html#cfn-ec2-mountpoint-device
            '''
            result = self._values.get("device")
            assert result is not None, "Required property 'device' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def volume_id(self) -> builtins.str:
            '''The ID of the EBS volume.

            The volume and instance must be within the same Availability Zone.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-mount-point.html#cfn-ec2-mountpoint-volumeid
            '''
            result = self._values.get("volume_id")
            assert result is not None, "Required property 'volume_id' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VolumeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnInstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "additional_info": "additionalInfo",
        "affinity": "affinity",
        "availability_zone": "availabilityZone",
        "block_device_mappings": "blockDeviceMappings",
        "cpu_options": "cpuOptions",
        "credit_specification": "creditSpecification",
        "disable_api_termination": "disableApiTermination",
        "ebs_optimized": "ebsOptimized",
        "elastic_gpu_specifications": "elasticGpuSpecifications",
        "elastic_inference_accelerators": "elasticInferenceAccelerators",
        "enclave_options": "enclaveOptions",
        "hibernation_options": "hibernationOptions",
        "host_id": "hostId",
        "host_resource_group_arn": "hostResourceGroupArn",
        "iam_instance_profile": "iamInstanceProfile",
        "image_id": "imageId",
        "instance_initiated_shutdown_behavior": "instanceInitiatedShutdownBehavior",
        "instance_type": "instanceType",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "kernel_id": "kernelId",
        "key_name": "keyName",
        "launch_template": "launchTemplate",
        "license_specifications": "licenseSpecifications",
        "monitoring": "monitoring",
        "network_interfaces": "networkInterfaces",
        "placement_group_name": "placementGroupName",
        "private_dns_name_options": "privateDnsNameOptions",
        "private_ip_address": "privateIpAddress",
        "propagate_tags_to_volume_on_creation": "propagateTagsToVolumeOnCreation",
        "ramdisk_id": "ramdiskId",
        "security_group_ids": "securityGroupIds",
        "security_groups": "securityGroups",
        "source_dest_check": "sourceDestCheck",
        "ssm_associations": "ssmAssociations",
        "subnet_id": "subnetId",
        "tags": "tags",
        "tenancy": "tenancy",
        "user_data": "userData",
        "volumes": "volumes",
    },
)
class CfnInstanceProps:
    def __init__(
        self,
        *,
        additional_info: typing.Optional[builtins.str] = None,
        affinity: typing.Optional[builtins.str] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        block_device_mappings: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.BlockDeviceMappingProperty, _IResolvable_da3f097b]]]] = None,
        cpu_options: typing.Optional[typing.Union[CfnInstance.CpuOptionsProperty, _IResolvable_da3f097b]] = None,
        credit_specification: typing.Optional[typing.Union[CfnInstance.CreditSpecificationProperty, _IResolvable_da3f097b]] = None,
        disable_api_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        elastic_gpu_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.ElasticGpuSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        elastic_inference_accelerators: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.ElasticInferenceAcceleratorProperty, _IResolvable_da3f097b]]]] = None,
        enclave_options: typing.Optional[typing.Union[CfnInstance.EnclaveOptionsProperty, _IResolvable_da3f097b]] = None,
        hibernation_options: typing.Optional[typing.Union[CfnInstance.HibernationOptionsProperty, _IResolvable_da3f097b]] = None,
        host_id: typing.Optional[builtins.str] = None,
        host_resource_group_arn: typing.Optional[builtins.str] = None,
        iam_instance_profile: typing.Optional[builtins.str] = None,
        image_id: typing.Optional[builtins.str] = None,
        instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.InstanceIpv6AddressProperty, _IResolvable_da3f097b]]]] = None,
        kernel_id: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        launch_template: typing.Optional[typing.Union[CfnInstance.LaunchTemplateSpecificationProperty, _IResolvable_da3f097b]] = None,
        license_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.LicenseSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        monitoring: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        network_interfaces: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.NetworkInterfaceProperty, _IResolvable_da3f097b]]]] = None,
        placement_group_name: typing.Optional[builtins.str] = None,
        private_dns_name_options: typing.Optional[typing.Union[CfnInstance.PrivateDnsNameOptionsProperty, _IResolvable_da3f097b]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        propagate_tags_to_volume_on_creation: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ramdisk_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        source_dest_check: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ssm_associations: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.SsmAssociationProperty, _IResolvable_da3f097b]]]] = None,
        subnet_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        tenancy: typing.Optional[builtins.str] = None,
        user_data: typing.Optional[builtins.str] = None,
        volumes: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnInstance.VolumeProperty, _IResolvable_da3f097b]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnInstance``.

        :param additional_info: This property is reserved for internal use. If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .
        :param affinity: Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .
        :param availability_zone: The Availability Zone of the instance. If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region. This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .
        :param block_device_mappings: The block device mapping entries that defines the block devices to attach to the instance at launch. By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting. .. epigraph:: After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
        :param cpu_options: The CPU options for the instance. For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
        :param credit_specification: The credit option for CPU usage of the burstable performance instance. Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* . Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a instances) For T3 instances with ``host`` tenancy, only ``standard`` is supported.
        :param disable_api_termination: If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance. Default: ``false``
        :param ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: ``false``
        :param elastic_gpu_specifications: An elastic GPU to associate with the instance. An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide* .
        :param elastic_inference_accelerators: An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads. You cannot specify accelerators from different generations in the same request.
        :param enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param hibernation_options: Indicates whether an instance is enabled for hibernation. For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* . You can't enable hibernation and AWS Nitro Enclaves on the same instance.
        :param host_id: If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with. If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.
        :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .
        :param iam_instance_profile: The name of an IAM instance profile. To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.
        :param image_id: The ID of the AMI. An AMI ID is required to launch an instance and must be specified here or in a launch template.
        :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``
        :param instance_type: The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . Default: ``m1.small``
        :param ipv6_address_count: [EC2-VPC] The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.
        :param ipv6_addresses: [EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch. You cannot specify this option and the network interfaces option in the same request.
        :param kernel_id: The ID of the kernel. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
        :param key_name: The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        :param launch_template: The launch template to use to launch the instances. Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.
        :param license_specifications: The license configurations.
        :param monitoring: Specifies whether detailed monitoring is enabled for the instance.
        :param network_interfaces: The network interfaces to associate with the instance. .. epigraph:: If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed. If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.
        :param placement_group_name: The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).
        :param private_dns_name_options: The options for the instance hostname.
        :param private_ip_address: [EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet. Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request. You cannot specify this option and the network interfaces option in the same request. If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.
        :param propagate_tags_to_volume_on_creation: Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch. If you specify ``true`` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify ``false`` , those tags are not assigned to the attached volumes.
        :param ramdisk_id: The ID of the RAM disk to select. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
        :param security_group_ids: The IDs of the security groups. You can create a security group using `CreateSecurityGroup <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html>`_ . If you specify a network interface, you must specify any security groups as part of the network interface.
        :param security_groups: [EC2-Classic, default VPC] The names of the security groups. For a nondefault VPC, you must use security group IDs instead. You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template. Default: Amazon EC2 uses the default security group.
        :param source_dest_check: Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
        :param ssm_associations: The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an Instance Profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* . .. epigraph:: You can currently associate only one document with an instance.
        :param subnet_id: [EC2-VPC] The ID of the subnet to launch the instance into. If you specify a network interface, you must specify any subnets as part of the network interface.
        :param tags: The tags to add to the instance. These tags are not applied to the EBS volumes, such as the root volume.
        :param tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.
        :param user_data: The user data to make available to the instance. For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ and `Run commands on your Windows instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html>`_ . If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text. User data is limited to 16 KB.
        :param volumes: The volumes to attach to the instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_instance_props = ec2.CfnInstanceProps(
                additional_info="additionalInfo",
                affinity="affinity",
                availability_zone="availabilityZone",
                block_device_mappings=[ec2.CfnInstance.BlockDeviceMappingProperty(
                    device_name="deviceName",
            
                    # the properties below are optional
                    ebs=ec2.CfnInstance.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device=ec2.CfnInstance.NoDeviceProperty(),
                    virtual_name="virtualName"
                )],
                cpu_options=ec2.CfnInstance.CpuOptionsProperty(
                    core_count=123,
                    threads_per_core=123
                ),
                credit_specification=ec2.CfnInstance.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                ),
                disable_api_termination=False,
                ebs_optimized=False,
                elastic_gpu_specifications=[ec2.CfnInstance.ElasticGpuSpecificationProperty(
                    type="type"
                )],
                elastic_inference_accelerators=[ec2.CfnInstance.ElasticInferenceAcceleratorProperty(
                    type="type",
            
                    # the properties below are optional
                    count=123
                )],
                enclave_options=ec2.CfnInstance.EnclaveOptionsProperty(
                    enabled=False
                ),
                hibernation_options=ec2.CfnInstance.HibernationOptionsProperty(
                    configured=False
                ),
                host_id="hostId",
                host_resource_group_arn="hostResourceGroupArn",
                iam_instance_profile="iamInstanceProfile",
                image_id="imageId",
                instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
                instance_type="instanceType",
                ipv6_address_count=123,
                ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )],
                kernel_id="kernelId",
                key_name="keyName",
                launch_template=ec2.CfnInstance.LaunchTemplateSpecificationProperty(
                    version="version",
            
                    # the properties below are optional
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName"
                ),
                license_specifications=[ec2.CfnInstance.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )],
                monitoring=False,
                network_interfaces=[ec2.CfnInstance.NetworkInterfaceProperty(
                    device_index="deviceIndex",
            
                    # the properties below are optional
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    group_set=["groupSet"],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2.CfnInstance.InstanceIpv6AddressProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_interface_id="networkInterfaceId",
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2.CfnInstance.PrivateIpAddressSpecificationProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )],
                placement_group_name="placementGroupName",
                private_dns_name_options=ec2.CfnInstance.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                ),
                private_ip_address="privateIpAddress",
                propagate_tags_to_volume_on_creation=False,
                ramdisk_id="ramdiskId",
                security_group_ids=["securityGroupIds"],
                security_groups=["securityGroups"],
                source_dest_check=False,
                ssm_associations=[ec2.CfnInstance.SsmAssociationProperty(
                    document_name="documentName",
            
                    # the properties below are optional
                    association_parameters=[ec2.CfnInstance.AssociationParameterProperty(
                        key="key",
                        value=["value"]
                    )]
                )],
                subnet_id="subnetId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                tenancy="tenancy",
                user_data="userData",
                volumes=[ec2.CfnInstance.VolumeProperty(
                    device="device",
                    volume_id="volumeId"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if additional_info is not None:
            self._values["additional_info"] = additional_info
        if affinity is not None:
            self._values["affinity"] = affinity
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if block_device_mappings is not None:
            self._values["block_device_mappings"] = block_device_mappings
        if cpu_options is not None:
            self._values["cpu_options"] = cpu_options
        if credit_specification is not None:
            self._values["credit_specification"] = credit_specification
        if disable_api_termination is not None:
            self._values["disable_api_termination"] = disable_api_termination
        if ebs_optimized is not None:
            self._values["ebs_optimized"] = ebs_optimized
        if elastic_gpu_specifications is not None:
            self._values["elastic_gpu_specifications"] = elastic_gpu_specifications
        if elastic_inference_accelerators is not None:
            self._values["elastic_inference_accelerators"] = elastic_inference_accelerators
        if enclave_options is not None:
            self._values["enclave_options"] = enclave_options
        if hibernation_options is not None:
            self._values["hibernation_options"] = hibernation_options
        if host_id is not None:
            self._values["host_id"] = host_id
        if host_resource_group_arn is not None:
            self._values["host_resource_group_arn"] = host_resource_group_arn
        if iam_instance_profile is not None:
            self._values["iam_instance_profile"] = iam_instance_profile
        if image_id is not None:
            self._values["image_id"] = image_id
        if instance_initiated_shutdown_behavior is not None:
            self._values["instance_initiated_shutdown_behavior"] = instance_initiated_shutdown_behavior
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if kernel_id is not None:
            self._values["kernel_id"] = kernel_id
        if key_name is not None:
            self._values["key_name"] = key_name
        if launch_template is not None:
            self._values["launch_template"] = launch_template
        if license_specifications is not None:
            self._values["license_specifications"] = license_specifications
        if monitoring is not None:
            self._values["monitoring"] = monitoring
        if network_interfaces is not None:
            self._values["network_interfaces"] = network_interfaces
        if placement_group_name is not None:
            self._values["placement_group_name"] = placement_group_name
        if private_dns_name_options is not None:
            self._values["private_dns_name_options"] = private_dns_name_options
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if propagate_tags_to_volume_on_creation is not None:
            self._values["propagate_tags_to_volume_on_creation"] = propagate_tags_to_volume_on_creation
        if ramdisk_id is not None:
            self._values["ramdisk_id"] = ramdisk_id
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if source_dest_check is not None:
            self._values["source_dest_check"] = source_dest_check
        if ssm_associations is not None:
            self._values["ssm_associations"] = ssm_associations
        if subnet_id is not None:
            self._values["subnet_id"] = subnet_id
        if tags is not None:
            self._values["tags"] = tags
        if tenancy is not None:
            self._values["tenancy"] = tenancy
        if user_data is not None:
            self._values["user_data"] = user_data
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def additional_info(self) -> typing.Optional[builtins.str]:
        '''This property is reserved for internal use.

        If you use it, the stack fails with this error: ``Bad property set: [Testing this property] (Service: AmazonEC2; Status Code: 400; Error Code: InvalidParameterCombination; Request ID: 0XXXXXX-49c7-4b40-8bcc-76885dcXXXXX)`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-additionalinfo
        '''
        result = self._values.get("additional_info")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def affinity(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the instance is associated with a dedicated host.

        If you want the instance to always restart on the same host on which it was launched, specify ``host`` . If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify ``default`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-affinity
        '''
        result = self._values.get("affinity")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone of the instance.

        If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.

        This parameter is not supported by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def block_device_mappings(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.BlockDeviceMappingProperty, _IResolvable_da3f097b]]]]:
        '''The block device mapping entries that defines the block devices to attach to the instance at launch.

        By default, the block devices specified in the block device mapping for the AMI are used. You can override the AMI block device mapping using the instance block device mapping. For the root volume, you can override only the volume size, volume type, volume encryption settings, and the ``DeleteOnTermination`` setting.
        .. epigraph::

           After the instance is running, you can modify only the ``DeleteOnTermination`` parameter for the attached volumes without interrupting the instance. Modifying any other parameter results in instance `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-blockdevicemappings
        '''
        result = self._values.get("block_device_mappings")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.BlockDeviceMappingProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def cpu_options(
        self,
    ) -> typing.Optional[typing.Union[CfnInstance.CpuOptionsProperty, _IResolvable_da3f097b]]:
        '''The CPU options for the instance.

        For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-cpuoptions
        '''
        result = self._values.get("cpu_options")
        return typing.cast(typing.Optional[typing.Union[CfnInstance.CpuOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def credit_specification(
        self,
    ) -> typing.Optional[typing.Union[CfnInstance.CreditSpecificationProperty, _IResolvable_da3f097b]]:
        '''The credit option for CPU usage of the burstable performance instance.

        Valid values are ``standard`` and ``unlimited`` . To change this attribute after launch, use `ModifyInstanceCreditSpecification <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceCreditSpecification.html>`_ . For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``standard`` (T2 instances) or ``unlimited`` (T3/T3a instances)

        For T3 instances with ``host`` tenancy, only ``standard`` is supported.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-creditspecification
        '''
        result = self._values.get("credit_specification")
        return typing.cast(typing.Optional[typing.Union[CfnInstance.CreditSpecificationProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def disable_api_termination(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;

        otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance.

        Default: ``false``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-disableapitermination
        '''
        result = self._values.get("disable_api_termination")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def ebs_optimized(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the instance is optimized for Amazon EBS I/O.

        This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.

        Default: ``false``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ebsoptimized
        '''
        result = self._values.get("ebs_optimized")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def elastic_gpu_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.ElasticGpuSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''An elastic GPU to associate with the instance.

        An Elastic GPU is a GPU resource that you can attach to your Windows instance to accelerate the graphics performance of your applications. For more information, see `Amazon EC2 Elastic GPUs <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-elasticgpuspecifications
        '''
        result = self._values.get("elastic_gpu_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.ElasticGpuSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def elastic_inference_accelerators(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.ElasticInferenceAcceleratorProperty, _IResolvable_da3f097b]]]]:
        '''An elastic inference accelerator to associate with the instance.

        Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.

        You cannot specify accelerators from different generations in the same request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-elasticinferenceaccelerators
        '''
        result = self._values.get("elastic_inference_accelerators")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.ElasticInferenceAcceleratorProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def enclave_options(
        self,
    ) -> typing.Optional[typing.Union[CfnInstance.EnclaveOptionsProperty, _IResolvable_da3f097b]]:
        '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-enclaveoptions
        '''
        result = self._values.get("enclave_options")
        return typing.cast(typing.Optional[typing.Union[CfnInstance.EnclaveOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def hibernation_options(
        self,
    ) -> typing.Optional[typing.Union[CfnInstance.HibernationOptionsProperty, _IResolvable_da3f097b]]:
        '''Indicates whether an instance is enabled for hibernation.

        For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .

        You can't enable hibernation and AWS Nitro Enclaves on the same instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hibernationoptions
        '''
        result = self._values.get("hibernation_options")
        return typing.cast(typing.Optional[typing.Union[CfnInstance.HibernationOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def host_id(self) -> typing.Optional[builtins.str]:
        '''If you specify host for the ``Affinity`` property, the ID of a dedicated host that the instance is associated with.

        If you don't specify an ID, Amazon EC2 launches the instance onto any available, compatible dedicated host in your account. This type of launch is called an untargeted launch. Note that for untargeted launches, you must have a compatible, dedicated host available to successfully launch instances.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hostid
        '''
        result = self._values.get("host_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the host resource group in which to launch the instances.

        If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-hostresourcegrouparn
        '''
        result = self._values.get("host_resource_group_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def iam_instance_profile(self) -> typing.Optional[builtins.str]:
        '''The name of an IAM instance profile.

        To create a new IAM instance profile, use the `AWS::IAM::InstanceProfile <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html>`_ resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-iaminstanceprofile
        '''
        result = self._values.get("iam_instance_profile")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the AMI.

        An AMI ID is required to launch an instance and must be specified here or in a launch template.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-imageid
        '''
        result = self._values.get("image_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_initiated_shutdown_behavior(self) -> typing.Optional[builtins.str]:
        '''Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).

        Default: ``stop``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-instanceinitiatedshutdownbehavior
        '''
        result = self._values.get("instance_initiated_shutdown_behavior")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[builtins.str]:
        '''The instance type. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

        Default: ``m1.small``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-instancetype
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        '''[EC2-VPC] The number of IPv6 addresses to associate with the primary network interface.

        Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

        You cannot specify this option and the network interfaces option in the same request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ipv6addresscount
        '''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.InstanceIpv6AddressProperty, _IResolvable_da3f097b]]]]:
        '''[EC2-VPC] The IPv6 addresses from the range of the subnet to associate with the primary network interface.

        You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

        You cannot specify this option and the network interfaces option in the same request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ipv6addresses
        '''
        result = self._values.get("ipv6_addresses")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.InstanceIpv6AddressProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def kernel_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the kernel.

        .. epigraph::

           We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-kernelid
        '''
        result = self._values.get("kernel_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ .

        .. epigraph::

           If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-keyname
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def launch_template(
        self,
    ) -> typing.Optional[typing.Union[CfnInstance.LaunchTemplateSpecificationProperty, _IResolvable_da3f097b]]:
        '''The launch template to use to launch the instances.

        Any parameters that you specify in the AWS CloudFormation template override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-launchtemplate
        '''
        result = self._values.get("launch_template")
        return typing.cast(typing.Optional[typing.Union[CfnInstance.LaunchTemplateSpecificationProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def license_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.LicenseSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The license configurations.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-licensespecifications
        '''
        result = self._values.get("license_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.LicenseSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def monitoring(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Specifies whether detailed monitoring is enabled for the instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-monitoring
        '''
        result = self._values.get("monitoring")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def network_interfaces(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.NetworkInterfaceProperty, _IResolvable_da3f097b]]]]:
        '''The network interfaces to associate with the instance.

        .. epigraph::

           If you use this property to point to a network interface, you must terminate the original interface before attaching a new one to allow the update of the instance to succeed.

           If this resource has a public IP address and is also in a VPC that is defined in the same template, you must use the `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ to declare a dependency on the VPC-gateway attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-networkinterfaces
        '''
        result = self._values.get("network_interfaces")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.NetworkInterfaceProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def placement_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of an existing placement group that you want to launch the instance into (cluster | partition | spread).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-placementgroupname
        '''
        result = self._values.get("placement_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_dns_name_options(
        self,
    ) -> typing.Optional[typing.Union[CfnInstance.PrivateDnsNameOptionsProperty, _IResolvable_da3f097b]]:
        '''The options for the instance hostname.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-privatednsnameoptions
        '''
        result = self._values.get("private_dns_name_options")
        return typing.cast(typing.Optional[typing.Union[CfnInstance.PrivateDnsNameOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.

        Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.

        You cannot specify this option and the network interfaces option in the same request.

        If you make an update to an instance that requires replacement, you must assign a new private IP address. During a replacement, AWS CloudFormation creates a new instance but doesn't delete the old instance until the stack has successfully updated. If the stack update fails, AWS CloudFormation uses the old instance to roll back the stack to the previous working state. The old and new instances cannot have the same private IP address.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-privateipaddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def propagate_tags_to_volume_on_creation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether to assign the tags from the instance to all of the volumes attached to the instance at launch.

        If you specify ``true`` and you assign tags to the instance, those tags are automatically assigned to all of the volumes that you attach to the instance at launch. If you specify ``false`` , those tags are not assigned to the attached volumes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation
        '''
        result = self._values.get("propagate_tags_to_volume_on_creation")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def ramdisk_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the RAM disk to select.

        Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, go to the AWS Resource Center and search for the kernel ID.
        .. epigraph::

           We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `PV-GRUB <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ramdiskid
        '''
        result = self._values.get("ramdisk_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups. You can create a security group using `CreateSecurityGroup <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html>`_ .

        If you specify a network interface, you must specify any security groups as part of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''[EC2-Classic, default VPC] The names of the security groups.

        For a nondefault VPC, you must use security group IDs instead.

        You cannot specify this option and the network interfaces option in the same request. The list can contain both the name of existing Amazon EC2 security groups or references to AWS::EC2::SecurityGroup resources created in the template.

        Default: Amazon EC2 uses the default security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-securitygroups
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def source_dest_check(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.

        If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-sourcedestcheck
        '''
        result = self._values.get("source_dest_check")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def ssm_associations(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.SsmAssociationProperty, _IResolvable_da3f097b]]]]:
        '''The SSM `document <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-document.html>`_ and parameter values in AWS Systems Manager to associate with this instance. To use this property, you must specify an IAM instance profile role for the instance. For more information, see `Create an Instance Profile for Systems Manager <https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-configuring-access-role.html>`_ in the *AWS Systems Manager User Guide* .

        .. epigraph::

           You can currently associate only one document with an instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-ssmassociations
        '''
        result = self._values.get("ssm_associations")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.SsmAssociationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def subnet_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC] The ID of the subnet to launch the instance into.

        If you specify a network interface, you must specify any subnets as part of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-subnetid
        '''
        result = self._values.get("subnet_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to add to the instance.

        These tags are not applied to the EBS volumes, such as the root volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def tenancy(self) -> typing.Optional[builtins.str]:
        '''The tenancy of the instance (if the instance is running in a VPC).

        An instance with a tenancy of ``dedicated`` runs on single-tenant hardware.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-tenancy
        '''
        result = self._values.get("tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user_data(self) -> typing.Optional[builtins.str]:
        '''The user data to make available to the instance.

        For more information, see `Run commands on your Linux instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ and `Run commands on your Windows instance at launch <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-windows-user-data.html>`_ . If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text. User data is limited to 16 KB.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-userdata
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volumes(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.VolumeProperty, _IResolvable_da3f097b]]]]:
        '''The volumes to attach to the instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html#cfn-ec2-instance-volumes
        '''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnInstance.VolumeProperty, _IResolvable_da3f097b]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnInternetGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnInternetGateway",
):
    '''A CloudFormation ``AWS::EC2::InternetGateway``.

    Allocates an internet gateway for use with a VPC. After creating the Internet gateway, you then attach it to a VPC.

    :cloudformationResource: AWS::EC2::InternetGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_internet_gateway = ec2.CfnInternetGateway(self, "MyCfnInternetGateway",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::InternetGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param tags: Any tags to assign to the internet gateway.
        '''
        props = CfnInternetGatewayProps(tags=tags)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrInternetGatewayId")
    def attr_internet_gateway_id(self) -> builtins.str:
        '''The ID of the internet gateway.

        :cloudformationAttribute: InternetGatewayId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrInternetGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags to assign to the internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnInternetGatewayProps",
    jsii_struct_bases=[],
    name_mapping={"tags": "tags"},
)
class CfnInternetGatewayProps:
    def __init__(
        self,
        *,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnInternetGateway``.

        :param tags: Any tags to assign to the internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_internet_gateway_props = ec2.CfnInternetGatewayProps(
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags to assign to the internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html#cfn-ec2-internetgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnInternetGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnLaunchTemplate(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate",
):
    '''A CloudFormation ``AWS::EC2::LaunchTemplate``.

    Specifies a launch template for an Amazon EC2 instance. A launch template contains the parameters to launch an instance. For more information, see `Launch an instance from a launch template <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-launch-templates.html>`_ in the *Amazon EC2 User Guide* .

    :cloudformationResource: AWS::EC2::LaunchTemplate
    :exampleMetadata: infused
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html

    Example::

        # cluster: eks.Cluster
        
        
        user_data = """MIME-Version: 1.0
        Content-Type: multipart/mixed; boundary="==MYBOUNDARY=="
        
        --==MYBOUNDARY==
        Content-Type: text/x-shellscript; charset="us-ascii"
        
        #!/bin/bash
        echo "Running custom user data script"
        
        --==MYBOUNDARY==--\\
        """
        lt = ec2.CfnLaunchTemplate(self, "LaunchTemplate",
            launch_template_data=ec2.CfnLaunchTemplate.LaunchTemplateDataProperty(
                instance_type="t3.small",
                user_data=Fn.base64(user_data)
            )
        )
        
        cluster.add_nodegroup_capacity("extra-ng",
            launch_template_spec=eks.LaunchTemplateSpec(
                id=lt.ref,
                version=lt.attr_latest_version_number
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        launch_template_data: typing.Optional[typing.Union["CfnLaunchTemplate.LaunchTemplateDataProperty", _IResolvable_da3f097b]] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::LaunchTemplate``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param launch_template_data: The information for the launch template.
        :param launch_template_name: A name for the launch template.
        :param tag_specifications: The tags to apply to the launch template during creation.
        '''
        props = CfnLaunchTemplateProps(
            launch_template_data=launch_template_data,
            launch_template_name=launch_template_name,
            tag_specifications=tag_specifications,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrDefaultVersionNumber")
    def attr_default_version_number(self) -> builtins.str:
        '''The default version of the launch template, such as 2.

        The default version of a launch template cannot be specified in AWS CloudFormation . The default version can be set in the Amazon EC2 Console or by using the ``modify-launch-template`` AWS CLI command.

        :cloudformationAttribute: DefaultVersionNumber
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDefaultVersionNumber"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrLatestVersionNumber")
    def attr_latest_version_number(self) -> builtins.str:
        '''The latest version of the launch template, such as ``5`` .

        :cloudformationAttribute: LatestVersionNumber
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrLatestVersionNumber"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateData")
    def launch_template_data(
        self,
    ) -> typing.Optional[typing.Union["CfnLaunchTemplate.LaunchTemplateDataProperty", _IResolvable_da3f097b]]:
        '''The information for the launch template.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
        '''
        return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.LaunchTemplateDataProperty", _IResolvable_da3f097b]], jsii.get(self, "launchTemplateData"))

    @launch_template_data.setter
    def launch_template_data(
        self,
        value: typing.Optional[typing.Union["CfnLaunchTemplate.LaunchTemplateDataProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "launchTemplateData", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''A name for the launch template.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "launchTemplateName"))

    @launch_template_name.setter
    def launch_template_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "launchTemplateName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tagSpecifications")
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The tags to apply to the launch template during creation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "tagSpecifications"))

    @tag_specifications.setter
    def tag_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "tagSpecifications", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.AcceleratorCountProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorCountProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            :param max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .
            :param min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                accelerator_count_property = ec2.CfnLaunchTemplate.AcceleratorCountProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of accelerators.

            To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of accelerators.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratorcount.html#cfn-ec2-launchtemplate-acceleratorcount-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorCountProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorTotalMemoryMiBProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            :param max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                accelerator_total_memory_mi_bProperty = ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of accelerator memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of accelerator memory, in MiB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-acceleratortotalmemorymib.html#cfn-ec2-launchtemplate-acceleratortotalmemorymib-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorTotalMemoryMiBProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class BaselineEbsBandwidthMbpsProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                baseline_ebs_bandwidth_mbps_property = ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum baseline bandwidth, in Mbps.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum baseline bandwidth, in Mbps.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-baselineebsbandwidthmbps.html#cfn-ec2-launchtemplate-baselineebsbandwidthmbps-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselineEbsBandwidthMbpsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: typing.Optional[builtins.str] = None,
            ebs: typing.Optional[typing.Union["CfnLaunchTemplate.EbsProperty", _IResolvable_da3f097b]] = None,
            no_device: typing.Optional[builtins.str] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Information about a block device mapping for an Amazon EC2 launch template.

            ``BlockDeviceMapping`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param device_name: The device name (for example, /dev/sdh or xvdh).
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
            :param no_device: To omit the device from the block device mapping, specify an empty string.
            :param virtual_name: The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                block_device_mapping_property = ec2.CfnLaunchTemplate.BlockDeviceMappingProperty(
                    device_name="deviceName",
                    ebs=ec2.CfnLaunchTemplate.EbsProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        kms_key_id="kmsKeyId",
                        snapshot_id="snapshotId",
                        throughput=123,
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device="noDevice",
                    virtual_name="virtualName"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if device_name is not None:
                self._values["device_name"] = device_name
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> typing.Optional[builtins.str]:
            '''The device name (for example, /dev/sdh or xvdh).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-devicename
            '''
            result = self._values.get("device_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.EbsProperty", _IResolvable_da3f097b]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.EbsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def no_device(self) -> typing.Optional[builtins.str]:
            '''To omit the device from the block device mapping, specify an empty string.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name (ephemeralN).

            Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html#cfn-ec2-launchtemplate-blockdevicemapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "capacity_reservation_preference": "capacityReservationPreference",
            "capacity_reservation_target": "capacityReservationTarget",
        },
    )
    class CapacityReservationSpecificationProperty:
        def __init__(
            self,
            *,
            capacity_reservation_preference: typing.Optional[builtins.str] = None,
            capacity_reservation_target: typing.Optional[typing.Union["CfnLaunchTemplate.CapacityReservationTargetProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.

            ``CapacityReservationSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Possible preferences include:. - ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). - ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
            :param capacity_reservation_target: Information about the target Capacity Reservation or Capacity Reservation group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                capacity_reservation_specification_property = ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty(
                    capacity_reservation_preference="capacityReservationPreference",
                    capacity_reservation_target=ec2.CfnLaunchTemplate.CapacityReservationTargetProperty(
                        capacity_reservation_id="capacityReservationId",
                        capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if capacity_reservation_preference is not None:
                self._values["capacity_reservation_preference"] = capacity_reservation_preference
            if capacity_reservation_target is not None:
                self._values["capacity_reservation_target"] = capacity_reservation_target

        @builtins.property
        def capacity_reservation_preference(self) -> typing.Optional[builtins.str]:
            '''Indicates the instance's Capacity Reservation preferences. Possible preferences include:.

            - ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
            - ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification-capacityreservationpreference
            '''
            result = self._values.get("capacity_reservation_preference")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def capacity_reservation_target(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.CapacityReservationTargetProperty", _IResolvable_da3f097b]]:
            '''Information about the target Capacity Reservation or Capacity Reservation group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification-capacityreservationtarget
            '''
            result = self._values.get("capacity_reservation_target")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.CapacityReservationTargetProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityReservationSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.CapacityReservationTargetProperty",
        jsii_struct_bases=[],
        name_mapping={
            "capacity_reservation_id": "capacityReservationId",
            "capacity_reservation_resource_group_arn": "capacityReservationResourceGroupArn",
        },
    )
    class CapacityReservationTargetProperty:
        def __init__(
            self,
            *,
            capacity_reservation_id: typing.Optional[builtins.str] = None,
            capacity_reservation_resource_group_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a target Capacity Reservation.

            ``CapacityReservationTarget`` is a property of the `Amazon EC2 LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ property type.

            :param capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
            :param capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                capacity_reservation_target_property = ec2.CfnLaunchTemplate.CapacityReservationTargetProperty(
                    capacity_reservation_id="capacityReservationId",
                    capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if capacity_reservation_id is not None:
                self._values["capacity_reservation_id"] = capacity_reservation_id
            if capacity_reservation_resource_group_arn is not None:
                self._values["capacity_reservation_resource_group_arn"] = capacity_reservation_resource_group_arn

        @builtins.property
        def capacity_reservation_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Capacity Reservation in which to run the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationid
            '''
            result = self._values.get("capacity_reservation_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def capacity_reservation_resource_group_arn(
            self,
        ) -> typing.Optional[builtins.str]:
            '''The ARN of the Capacity Reservation resource group in which to run the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-capacityreservationtarget.html#cfn-ec2-launchtemplate-capacityreservationtarget-capacityreservationresourcegrouparn
            '''
            result = self._values.get("capacity_reservation_resource_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CapacityReservationTargetProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.CpuOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"core_count": "coreCount", "threads_per_core": "threadsPerCore"},
    )
    class CpuOptionsProperty:
        def __init__(
            self,
            *,
            core_count: typing.Optional[jsii.Number] = None,
            threads_per_core: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the CPU options for an instance.

            For more information, see `Optimize CPU options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            ``CpuOptions`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param core_count: The number of CPU cores for the instance.
            :param threads_per_core: The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-cpuoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                cpu_options_property = ec2.CfnLaunchTemplate.CpuOptionsProperty(
                    core_count=123,
                    threads_per_core=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if core_count is not None:
                self._values["core_count"] = core_count
            if threads_per_core is not None:
                self._values["threads_per_core"] = threads_per_core

        @builtins.property
        def core_count(self) -> typing.Optional[jsii.Number]:
            '''The number of CPU cores for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-cpuoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions-corecount
            '''
            result = self._values.get("core_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def threads_per_core(self) -> typing.Optional[jsii.Number]:
            '''The number of threads per CPU core.

            To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-cpuoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions-threadspercore
            '''
            result = self._values.get("threads_per_core")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CpuOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.CreditSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"cpu_credits": "cpuCredits"},
    )
    class CreditSpecificationProperty:
        def __init__(
            self,
            *,
            cpu_credits: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the credit option for CPU usage of a T2, T3, or T3a instance.

            ``CreditSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param cpu_credits: The credit option for CPU usage of a T2, T3, or T3a instance. Valid values are ``standard`` and ``unlimited`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-creditspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                credit_specification_property = ec2.CfnLaunchTemplate.CreditSpecificationProperty(
                    cpu_credits="cpuCredits"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if cpu_credits is not None:
                self._values["cpu_credits"] = cpu_credits

        @builtins.property
        def cpu_credits(self) -> typing.Optional[builtins.str]:
            '''The credit option for CPU usage of a T2, T3, or T3a instance.

            Valid values are ``standard`` and ``unlimited`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-creditspecification.html#cfn-ec2-launchtemplate-launchtemplatedata-creditspecification-cpucredits
            '''
            result = self._values.get("cpu_credits")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "CreditSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.EbsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "kms_key_id": "kmsKeyId",
            "snapshot_id": "snapshotId",
            "throughput": "throughput",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            iops: typing.Optional[jsii.Number] = None,
            kms_key_id: typing.Optional[builtins.str] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            throughput: typing.Optional[jsii.Number] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Parameters for a block device for an EBS volume in an Amazon EC2 launch template.

            ``Ebs`` is a property of `AWS::EC2::LaunchTemplate BlockDeviceMapping <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html>`_ .

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
            :param encrypted: Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is supported for ``io1`` , ``io2`` , and ``gp3`` volumes only. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.
            :param kms_key_id: The ARN of the symmetric AWS Key Management Service ( AWS KMS ) CMK used for encryption.
            :param snapshot_id: The ID of the snapshot.
            :param throughput: The throughput to provision for a ``gp3`` volume, with a maximum of 1,000 MiB/s. Valid Range: Minimum value of 125. Maximum value of 1000.
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` : 1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ebs_property = ec2.CfnLaunchTemplate.EbsProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    kms_key_id="kmsKeyId",
                    snapshot_id="snapshotId",
                    throughput=123,
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if kms_key_id is not None:
                self._values["kms_key_id"] = kms_key_id
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if throughput is not None:
                self._values["throughput"] = throughput
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the EBS volume is encrypted.

            Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000-16,000 IOPS
            - ``io1`` : 100-64,000 IOPS
            - ``io2`` : 100-64,000 IOPS

            For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS.

            This parameter is supported for ``io1`` , ``io2`` , and ``gp3`` volumes only. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def kms_key_id(self) -> typing.Optional[builtins.str]:
            '''The ARN of the symmetric AWS Key Management Service ( AWS KMS ) CMK used for encryption.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-kmskeyid
            '''
            result = self._values.get("kms_key_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def throughput(self) -> typing.Optional[jsii.Number]:
            '''The throughput to provision for a ``gp3`` volume, with a maximum of 1,000 MiB/s.

            Valid Range: Minimum value of 125. Maximum value of 1000.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-throughput
            '''
            result = self._values.get("throughput")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:

            - ``gp2`` and ``gp3`` : 1-16,384
            - ``io1`` and ``io2`` : 4-16,384
            - ``st1`` and ``sc1`` : 125-16,384
            - ``standard`` : 1-1,024

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping-ebs.html#cfn-ec2-launchtemplate-blockdevicemapping-ebs-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"type": "type"},
    )
    class ElasticGpuSpecificationProperty:
        def __init__(self, *, type: typing.Optional[builtins.str] = None) -> None:
            '''Specifies a specification for an Elastic GPU for an Amazon EC2 launch template.

            ``ElasticGpuSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param type: The type of Elastic Graphics accelerator. For more information about the values to specify for ``Type`` , see `Elastic Graphics Basics <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics>`_ , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                elastic_gpu_specification_property = ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty(
                    type="type"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of Elastic Graphics accelerator.

            For more information about the values to specify for ``Type`` , see `Elastic Graphics Basics <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics>`_ , specifically the Elastic Graphics accelerator column, in the *Amazon Elastic Compute Cloud User Guide for Windows Instances* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-elasticgpuspecification.html#cfn-ec2-launchtemplate-elasticgpuspecification-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ElasticGpuSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.EnclaveOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class EnclaveOptionsProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

            :param enabled: If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-enclaveoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                enclave_options_property = ec2.CfnLaunchTemplate.EnclaveOptionsProperty(
                    enabled=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''If this parameter is set to ``true`` , the instance is enabled for AWS Nitro Enclaves;

            otherwise, it is not enabled for AWS Nitro Enclaves.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-enclaveoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-enclaveoptions-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EnclaveOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.HibernationOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"configured": "configured"},
    )
    class HibernationOptionsProperty:
        def __init__(
            self,
            *,
            configured: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies whether your instance is configured for hibernation.

            This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites>`_ . For more information, see `Hibernate Your Instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon EC2 User Guide* .

            ``HibernationOptions`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param configured: If you set this parameter to ``true`` , the instance is enabled for hibernation. Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-hibernationoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                hibernation_options_property = ec2.CfnLaunchTemplate.HibernationOptionsProperty(
                    configured=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if configured is not None:
                self._values["configured"] = configured

        @builtins.property
        def configured(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''If you set this parameter to ``true`` , the instance is enabled for hibernation.

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-hibernationoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-hibernationoptions-configured
            '''
            result = self._values.get("configured")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "HibernationOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.IamInstanceProfileProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn", "name": "name"},
    )
    class IamInstanceProfileProperty:
        def __init__(
            self,
            *,
            arn: typing.Optional[builtins.str] = None,
            name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an IAM instance profile, which is a container for an IAM role for your instance.

            You can use an IAM role to distribute your AWS credentials to your instances.

            If you are creating the launch template for use with an Amazon EC2 Auto Scaling group, you can specify either the name or the ARN of the instance profile, but not both.

            ``IamInstanceProfile`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param arn: The Amazon Resource Name (ARN) of the instance profile.
            :param name: The name of the instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                iam_instance_profile_property = ec2.CfnLaunchTemplate.IamInstanceProfileProperty(
                    arn="arn",
                    name="name"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn
            if name is not None:
                self._values["name"] = name

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def name(self) -> typing.Optional[builtins.str]:
            '''The name of the instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile-name
            '''
            result = self._values.get("name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IamInstanceProfileProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"market_type": "marketType", "spot_options": "spotOptions"},
    )
    class InstanceMarketOptionsProperty:
        def __init__(
            self,
            *,
            market_type: typing.Optional[builtins.str] = None,
            spot_options: typing.Optional[typing.Union["CfnLaunchTemplate.SpotOptionsProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies the market (purchasing) option for an instance.

            ``InstanceMarketOptions`` is a property of the `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param market_type: The market type.
            :param spot_options: The options for Spot Instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_market_options_property = ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty(
                    market_type="marketType",
                    spot_options=ec2.CfnLaunchTemplate.SpotOptionsProperty(
                        block_duration_minutes=123,
                        instance_interruption_behavior="instanceInterruptionBehavior",
                        max_price="maxPrice",
                        spot_instance_type="spotInstanceType",
                        valid_until="validUntil"
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if market_type is not None:
                self._values["market_type"] = market_type
            if spot_options is not None:
                self._values["spot_options"] = spot_options

        @builtins.property
        def market_type(self) -> typing.Optional[builtins.str]:
            '''The market type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-markettype
            '''
            result = self._values.get("market_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def spot_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.SpotOptionsProperty", _IResolvable_da3f097b]]:
            '''The options for Spot Instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions
            '''
            result = self._values.get("spot_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.SpotOptionsProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceMarketOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.InstanceRequirementsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "accelerator_count": "acceleratorCount",
            "accelerator_manufacturers": "acceleratorManufacturers",
            "accelerator_names": "acceleratorNames",
            "accelerator_total_memory_mib": "acceleratorTotalMemoryMiB",
            "accelerator_types": "acceleratorTypes",
            "bare_metal": "bareMetal",
            "baseline_ebs_bandwidth_mbps": "baselineEbsBandwidthMbps",
            "burstable_performance": "burstablePerformance",
            "cpu_manufacturers": "cpuManufacturers",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_generations": "instanceGenerations",
            "local_storage": "localStorage",
            "local_storage_types": "localStorageTypes",
            "memory_gib_per_v_cpu": "memoryGiBPerVCpu",
            "memory_mib": "memoryMiB",
            "network_interface_count": "networkInterfaceCount",
            "on_demand_max_price_percentage_over_lowest_price": "onDemandMaxPricePercentageOverLowestPrice",
            "require_hibernate_support": "requireHibernateSupport",
            "spot_max_price_percentage_over_lowest_price": "spotMaxPricePercentageOverLowestPrice",
            "total_local_storage_gb": "totalLocalStorageGb",
            "v_cpu_count": "vCpuCount",
        },
    )
    class InstanceRequirementsProperty:
        def __init__(
            self,
            *,
            accelerator_count: typing.Optional[typing.Union["CfnLaunchTemplate.AcceleratorCountProperty", _IResolvable_da3f097b]] = None,
            accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_total_memory_mib: typing.Optional[typing.Union["CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty", _IResolvable_da3f097b]] = None,
            accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            bare_metal: typing.Optional[builtins.str] = None,
            baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union["CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty", _IResolvable_da3f097b]] = None,
            burstable_performance: typing.Optional[builtins.str] = None,
            cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
            local_storage: typing.Optional[builtins.str] = None,
            local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            memory_gib_per_v_cpu: typing.Optional[typing.Union["CfnLaunchTemplate.MemoryGiBPerVCpuProperty", _IResolvable_da3f097b]] = None,
            memory_mib: typing.Optional[typing.Union["CfnLaunchTemplate.MemoryMiBProperty", _IResolvable_da3f097b]] = None,
            network_interface_count: typing.Optional[typing.Union["CfnLaunchTemplate.NetworkInterfaceCountProperty", _IResolvable_da3f097b]] = None,
            on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            require_hibernate_support: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            total_local_storage_gb: typing.Optional[typing.Union["CfnLaunchTemplate.TotalLocalStorageGBProperty", _IResolvable_da3f097b]] = None,
            v_cpu_count: typing.Optional[typing.Union["CfnLaunchTemplate.VCpuCountProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            When you specify multiple parameters, you get instance types that satisfy all of the specified parameters. If you specify multiple values for a parameter, you get instance types that satisfy any of the specified values.
            .. epigraph::

               You must specify ``VCpuCount`` and ``MemoryMiB`` . All other parameters are optional. Any unspecified optional parameter is set to its default.

            For more information, see `Attribute-based instance type selection for EC2 Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ , `Attribute-based instance type selection for Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html>`_ , and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :param accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits
            :param accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer
            :param accelerator_names: The accelerators that must be on the instance type. - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . Default: Any accelerator
            :param accelerator_total_memory_mib: The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits
            :param accelerator_types: The accelerator types that must be on the instance type. - For instance types with GPU accelerators, specify ``gpu`` . - For instance types with FPGA accelerators, specify ``fpga`` . - For instance types with inference accelerators, specify ``inference`` . Default: Any accelerator type
            :param bare_metal: Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``
            :param baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``
            :param cpu_manufacturers: The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer
            :param excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. Default: No excluded instance types
            :param instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types
            :param local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``
            :param local_storage_types: The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SDD) storage, specify ``sdd`` . Default: ``hdd`` and ``sdd``
            :param memory_gib_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits
            :param memory_mib: The minimum and maximum amount of memory, in MiB.
            :param network_interface_count: The minimum and maximum number of network interfaces. Default: No minimum or maximum limits
            :param on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum youâ€™ll pay for an On-Demand Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``
            :param require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``
            :param spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances. This is the maximum youâ€™ll pay for a Spot Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``100``
            :param total_local_storage_gb: The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits
            :param v_cpu_count: The minimum and maximum number of vCPUs.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_requirements_property = ec2.CfnLaunchTemplate.InstanceRequirementsProperty(
                    accelerator_count=ec2.CfnLaunchTemplate.AcceleratorCountProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty(
                        max=123,
                        min=123
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    memory_gi_bPer_vCpu=ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2.CfnLaunchTemplate.MemoryMiBProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2.CfnLaunchTemplate.VCpuCountProperty(
                        max=123,
                        min=123
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if accelerator_count is not None:
                self._values["accelerator_count"] = accelerator_count
            if accelerator_manufacturers is not None:
                self._values["accelerator_manufacturers"] = accelerator_manufacturers
            if accelerator_names is not None:
                self._values["accelerator_names"] = accelerator_names
            if accelerator_total_memory_mib is not None:
                self._values["accelerator_total_memory_mib"] = accelerator_total_memory_mib
            if accelerator_types is not None:
                self._values["accelerator_types"] = accelerator_types
            if bare_metal is not None:
                self._values["bare_metal"] = bare_metal
            if baseline_ebs_bandwidth_mbps is not None:
                self._values["baseline_ebs_bandwidth_mbps"] = baseline_ebs_bandwidth_mbps
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cpu_manufacturers is not None:
                self._values["cpu_manufacturers"] = cpu_manufacturers
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_generations is not None:
                self._values["instance_generations"] = instance_generations
            if local_storage is not None:
                self._values["local_storage"] = local_storage
            if local_storage_types is not None:
                self._values["local_storage_types"] = local_storage_types
            if memory_gib_per_v_cpu is not None:
                self._values["memory_gib_per_v_cpu"] = memory_gib_per_v_cpu
            if memory_mib is not None:
                self._values["memory_mib"] = memory_mib
            if network_interface_count is not None:
                self._values["network_interface_count"] = network_interface_count
            if on_demand_max_price_percentage_over_lowest_price is not None:
                self._values["on_demand_max_price_percentage_over_lowest_price"] = on_demand_max_price_percentage_over_lowest_price
            if require_hibernate_support is not None:
                self._values["require_hibernate_support"] = require_hibernate_support
            if spot_max_price_percentage_over_lowest_price is not None:
                self._values["spot_max_price_percentage_over_lowest_price"] = spot_max_price_percentage_over_lowest_price
            if total_local_storage_gb is not None:
                self._values["total_local_storage_gb"] = total_local_storage_gb
            if v_cpu_count is not None:
                self._values["v_cpu_count"] = v_cpu_count

        @builtins.property
        def accelerator_count(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.AcceleratorCountProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-acceleratorcount
            '''
            result = self._values.get("accelerator_count")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.AcceleratorCountProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def accelerator_manufacturers(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether instance types must have accelerators by specific manufacturers.

            - For instance types with NVIDIA devices, specify ``nvidia`` .
            - For instance types with AMD devices, specify ``amd`` .
            - For instance types with AWS devices, specify ``amazon-web-services`` .
            - For instance types with Xilinx devices, specify ``xilinx`` .

            Default: Any manufacturer

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-acceleratormanufacturers
            '''
            result = self._values.get("accelerator_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerators that must be on the instance type.

            - For instance types with NVIDIA A100 GPUs, specify ``a100`` .
            - For instance types with NVIDIA V100 GPUs, specify ``v100`` .
            - For instance types with NVIDIA K80 GPUs, specify ``k80`` .
            - For instance types with NVIDIA T4 GPUs, specify ``t4`` .
            - For instance types with NVIDIA M60 GPUs, specify ``m60`` .
            - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` .
            - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` .

            Default: Any accelerator

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-acceleratornames
            '''
            result = self._values.get("accelerator_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_total_memory_mib(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-acceleratortotalmemorymib
            '''
            result = self._values.get("accelerator_total_memory_mib")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def accelerator_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerator types that must be on the instance type.

            - For instance types with GPU accelerators, specify ``gpu`` .
            - For instance types with FPGA accelerators, specify ``fpga`` .
            - For instance types with inference accelerators, specify ``inference`` .

            Default: Any accelerator type

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-acceleratortypes
            '''
            result = self._values.get("accelerator_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def bare_metal(self) -> typing.Optional[builtins.str]:
            '''Indicates whether bare metal instance types must be included, excluded, or required.

            - To include bare metal instance types, specify ``included`` .
            - To require only bare metal instance types, specify ``required`` .
            - To exclude bare metal instance types, specify ``excluded`` .

            Default: ``excluded``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-baremetal
            '''
            result = self._values.get("bare_metal")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def baseline_ebs_bandwidth_mbps(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-baselineebsbandwidthmbps
            '''
            result = self._values.get("baseline_ebs_bandwidth_mbps")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def burstable_performance(self) -> typing.Optional[builtins.str]:
            '''Indicates whether burstable performance T instance types are included, excluded, or required.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ .

            - To include burstable performance instance types, specify ``included`` .
            - To require only burstable performance instance types, specify ``required`` .
            - To exclude burstable performance instance types, specify ``excluded`` .

            Default: ``excluded``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-burstableperformance
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cpu_manufacturers(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CPU manufacturers to include.

            - For instance types with Intel CPUs, specify ``intel`` .
            - For instance types with AMD CPUs, specify ``amd`` .
            - For instance types with AWS CPUs, specify ``amazon-web-services`` .

            .. epigraph::

               Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

            Default: Any manufacturer

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-cpumanufacturers
            '''
            result = self._values.get("cpu_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def excluded_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to exclude.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

            Default: No excluded instance types

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-excludedinstancetypes
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_generations(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether current or previous generation instance types are included.

            The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            For current generation instance types, specify ``current`` .

            For previous generation instance types, specify ``previous`` .

            Default: Current and previous generation instance types

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-instancegenerations
            '''
            result = self._values.get("instance_generations")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def local_storage(self) -> typing.Optional[builtins.str]:
            '''Indicates whether instance types with instance store volumes are included, excluded, or required.

            For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* .

            - To include instance types with instance store volumes, specify ``included`` .
            - To require only instance types with instance store volumes, specify ``required`` .
            - To exclude instance types with instance store volumes, specify ``excluded`` .

            Default: ``included``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-localstorage
            '''
            result = self._values.get("local_storage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def local_storage_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of local storage that is required.

            - For instance types with hard disk drive (HDD) storage, specify ``hdd`` .
            - For instance types with solid state drive (SDD) storage, specify ``sdd`` .

            Default: ``hdd`` and ``sdd``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-localstoragetypes
            '''
            result = self._values.get("local_storage_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def memory_gib_per_v_cpu(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.MemoryGiBPerVCpuProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-memorygibpervcpu
            '''
            result = self._values.get("memory_gib_per_v_cpu")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.MemoryGiBPerVCpuProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def memory_mib(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.MemoryMiBProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of memory, in MiB.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-memorymib
            '''
            result = self._values.get("memory_mib")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.MemoryMiBProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def network_interface_count(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.NetworkInterfaceCountProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of network interfaces.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-networkinterfacecount
            '''
            result = self._values.get("network_interface_count")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.NetworkInterfaceCountProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def on_demand_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''The price protection threshold for On-Demand Instances.

            This is the maximum youâ€™ll pay for an On-Demand Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``20``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-ondemandmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("on_demand_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def require_hibernate_support(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether instance types must support hibernation for On-Demand Instances.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ .

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-requirehibernatesupport
            '''
            result = self._values.get("require_hibernate_support")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def spot_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''The price protection threshold for Spot Instances.

            This is the maximum youâ€™ll pay for a Spot Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``100``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-spotmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("spot_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def total_local_storage_gb(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.TotalLocalStorageGBProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of total local storage, in GB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-totallocalstoragegb
            '''
            result = self._values.get("total_local_storage_gb")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.TotalLocalStorageGBProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def v_cpu_count(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.VCpuCountProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of vCPUs.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancerequirements.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements-vcpucount
            '''
            result = self._values.get("v_cpu_count")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.VCpuCountProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceRequirementsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.Ipv6AddProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class Ipv6AddProperty:
        def __init__(
            self,
            *,
            ipv6_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an IPv6 address in an Amazon EC2 launch template.

            ``Ipv6Add`` is a property of `AWS::EC2::LaunchTemplate NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html>`_ .

            :param ipv6_address: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ipv6_add_property = ec2.CfnLaunchTemplate.Ipv6AddProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if ipv6_address is not None:
                self._values["ipv6_address"] = ipv6_address

        @builtins.property
        def ipv6_address(self) -> typing.Optional[builtins.str]:
            '''One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.

            You can't use this option if you're specifying a number of IPv6 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-ipv6add.html#cfn-ec2-launchtemplate-ipv6add-ipv6address
            '''
            result = self._values.get("ipv6_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "Ipv6AddProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.LaunchTemplateDataProperty",
        jsii_struct_bases=[],
        name_mapping={
            "block_device_mappings": "blockDeviceMappings",
            "capacity_reservation_specification": "capacityReservationSpecification",
            "cpu_options": "cpuOptions",
            "credit_specification": "creditSpecification",
            "disable_api_termination": "disableApiTermination",
            "ebs_optimized": "ebsOptimized",
            "elastic_gpu_specifications": "elasticGpuSpecifications",
            "elastic_inference_accelerators": "elasticInferenceAccelerators",
            "enclave_options": "enclaveOptions",
            "hibernation_options": "hibernationOptions",
            "iam_instance_profile": "iamInstanceProfile",
            "image_id": "imageId",
            "instance_initiated_shutdown_behavior": "instanceInitiatedShutdownBehavior",
            "instance_market_options": "instanceMarketOptions",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "kernel_id": "kernelId",
            "key_name": "keyName",
            "license_specifications": "licenseSpecifications",
            "metadata_options": "metadataOptions",
            "monitoring": "monitoring",
            "network_interfaces": "networkInterfaces",
            "placement": "placement",
            "private_dns_name_options": "privateDnsNameOptions",
            "ram_disk_id": "ramDiskId",
            "security_group_ids": "securityGroupIds",
            "security_groups": "securityGroups",
            "tag_specifications": "tagSpecifications",
            "user_data": "userData",
        },
    )
    class LaunchTemplateDataProperty:
        def __init__(
            self,
            *,
            block_device_mappings: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]] = None,
            capacity_reservation_specification: typing.Optional[typing.Union["CfnLaunchTemplate.CapacityReservationSpecificationProperty", _IResolvable_da3f097b]] = None,
            cpu_options: typing.Optional[typing.Union["CfnLaunchTemplate.CpuOptionsProperty", _IResolvable_da3f097b]] = None,
            credit_specification: typing.Optional[typing.Union["CfnLaunchTemplate.CreditSpecificationProperty", _IResolvable_da3f097b]] = None,
            disable_api_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            elastic_gpu_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            elastic_inference_accelerators: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]] = None,
            enclave_options: typing.Optional[typing.Union["CfnLaunchTemplate.EnclaveOptionsProperty", _IResolvable_da3f097b]] = None,
            hibernation_options: typing.Optional[typing.Union["CfnLaunchTemplate.HibernationOptionsProperty", _IResolvable_da3f097b]] = None,
            iam_instance_profile: typing.Optional[typing.Union["CfnLaunchTemplate.IamInstanceProfileProperty", _IResolvable_da3f097b]] = None,
            image_id: typing.Optional[builtins.str] = None,
            instance_initiated_shutdown_behavior: typing.Optional[builtins.str] = None,
            instance_market_options: typing.Optional[typing.Union["CfnLaunchTemplate.InstanceMarketOptionsProperty", _IResolvable_da3f097b]] = None,
            instance_requirements: typing.Optional[typing.Union["CfnLaunchTemplate.InstanceRequirementsProperty", _IResolvable_da3f097b]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            kernel_id: typing.Optional[builtins.str] = None,
            key_name: typing.Optional[builtins.str] = None,
            license_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.LicenseSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            metadata_options: typing.Optional[typing.Union["CfnLaunchTemplate.MetadataOptionsProperty", _IResolvable_da3f097b]] = None,
            monitoring: typing.Optional[typing.Union["CfnLaunchTemplate.MonitoringProperty", _IResolvable_da3f097b]] = None,
            network_interfaces: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.NetworkInterfaceProperty", _IResolvable_da3f097b]]]] = None,
            placement: typing.Optional[typing.Union["CfnLaunchTemplate.PlacementProperty", _IResolvable_da3f097b]] = None,
            private_dns_name_options: typing.Optional[typing.Union["CfnLaunchTemplate.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]] = None,
            ram_disk_id: typing.Optional[builtins.str] = None,
            security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
            security_groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.TagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            user_data: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The information to include in the launch template.

            :param block_device_mappings: The block device mapping.
            :param capacity_reservation_specification: The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open`` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
            :param cpu_options: The CPU options for the instance. For more information, see `Optimizing CPU Options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param credit_specification: The credit option for CPU usage of the instance. Valid for T2, T3, or T3a instances only.
            :param disable_api_termination: If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance.
            :param ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
            :param elastic_gpu_specifications: An elastic GPU to associate with the instance.
            :param elastic_inference_accelerators: The elastic inference accelerator for the instance.
            :param enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see `What is AWS Nitro Enclaves? <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html>`_ in the *AWS Nitro Enclaves User Guide* . You can't enable AWS Nitro Enclaves and hibernation on the same instance.
            :param hibernation_options: Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites>`_ . For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param iam_instance_profile: The name or Amazon Resource Name (ARN) of an IAM instance profile.
            :param image_id: The ID of the AMI.
            :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: ``stop``
            :param instance_market_options: The market (purchasing) option for the instances.
            :param instance_requirements: ``CfnLaunchTemplate.LaunchTemplateDataProperty.InstanceRequirements``.
            :param instance_type: The instance type. For more information, see `Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . If you specify ``InstanceTypes`` , you can't specify ``InstanceRequirements`` .
            :param kernel_id: The ID of the kernel. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .
            :param key_name: The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ . .. epigraph:: If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
            :param license_specifications: The license configurations.
            :param metadata_options: The metadata options for the instance. For more information, see `Instance Metadata and User Data <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param monitoring: The monitoring for the instance.
            :param network_interfaces: One or more network interfaces. If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
            :param placement: The placement for the instance.
            :param private_dns_name_options: The options for the instance hostname. The default values are inherited from the subnet.
            :param ram_disk_id: The ID of the RAM disk. .. epigraph:: We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
            :param security_group_ids: One or more security group IDs. You can create a security group using `CreateSecurityGroup <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html>`_ . You cannot specify both a security group ID and security name in the same request.
            :param security_groups: [EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.
            :param tag_specifications: The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch.
            :param user_data: The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see `Running Commands on Your Linux Instance at Launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ (Linux) or `Adding User Data <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data>`_ (Windows). If you are creating the launch template for use with AWS Batch , the user data must be provided in the `MIME multi-part archive format <https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive>`_ . For more information, see `Amazon EC2 user data in launch templates <https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html>`_ in the *AWS Batch User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                launch_template_data_property = ec2.CfnLaunchTemplate.LaunchTemplateDataProperty(
                    block_device_mappings=[ec2.CfnLaunchTemplate.BlockDeviceMappingProperty(
                        device_name="deviceName",
                        ebs=ec2.CfnLaunchTemplate.EbsProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            kms_key_id="kmsKeyId",
                            snapshot_id="snapshotId",
                            throughput=123,
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    capacity_reservation_specification=ec2.CfnLaunchTemplate.CapacityReservationSpecificationProperty(
                        capacity_reservation_preference="capacityReservationPreference",
                        capacity_reservation_target=ec2.CfnLaunchTemplate.CapacityReservationTargetProperty(
                            capacity_reservation_id="capacityReservationId",
                            capacity_reservation_resource_group_arn="capacityReservationResourceGroupArn"
                        )
                    ),
                    cpu_options=ec2.CfnLaunchTemplate.CpuOptionsProperty(
                        core_count=123,
                        threads_per_core=123
                    ),
                    credit_specification=ec2.CfnLaunchTemplate.CreditSpecificationProperty(
                        cpu_credits="cpuCredits"
                    ),
                    disable_api_termination=False,
                    ebs_optimized=False,
                    elastic_gpu_specifications=[ec2.CfnLaunchTemplate.ElasticGpuSpecificationProperty(
                        type="type"
                    )],
                    elastic_inference_accelerators=[ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty(
                        count=123,
                        type="type"
                    )],
                    enclave_options=ec2.CfnLaunchTemplate.EnclaveOptionsProperty(
                        enabled=False
                    ),
                    hibernation_options=ec2.CfnLaunchTemplate.HibernationOptionsProperty(
                        configured=False
                    ),
                    iam_instance_profile=ec2.CfnLaunchTemplate.IamInstanceProfileProperty(
                        arn="arn",
                        name="name"
                    ),
                    image_id="imageId",
                    instance_initiated_shutdown_behavior="instanceInitiatedShutdownBehavior",
                    instance_market_options=ec2.CfnLaunchTemplate.InstanceMarketOptionsProperty(
                        market_type="marketType",
                        spot_options=ec2.CfnLaunchTemplate.SpotOptionsProperty(
                            block_duration_minutes=123,
                            instance_interruption_behavior="instanceInterruptionBehavior",
                            max_price="maxPrice",
                            spot_instance_type="spotInstanceType",
                            valid_until="validUntil"
                        )
                    ),
                    instance_requirements=ec2.CfnLaunchTemplate.InstanceRequirementsProperty(
                        accelerator_count=ec2.CfnLaunchTemplate.AcceleratorCountProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2.CfnLaunchTemplate.AcceleratorTotalMemoryMiBProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2.CfnLaunchTemplate.BaselineEbsBandwidthMbpsProperty(
                            max=123,
                            min=123
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        memory_gi_bPer_vCpu=ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2.CfnLaunchTemplate.MemoryMiBProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2.CfnLaunchTemplate.VCpuCountProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    license_specifications=[ec2.CfnLaunchTemplate.LicenseSpecificationProperty(
                        license_configuration_arn="licenseConfigurationArn"
                    )],
                    metadata_options=ec2.CfnLaunchTemplate.MetadataOptionsProperty(
                        http_endpoint="httpEndpoint",
                        http_protocol_ipv6="httpProtocolIpv6",
                        http_put_response_hop_limit=123,
                        http_tokens="httpTokens",
                        instance_metadata_tags="instanceMetadataTags"
                    ),
                    monitoring=ec2.CfnLaunchTemplate.MonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2.CfnLaunchTemplate.NetworkInterfaceProperty(
                        associate_carrier_ip_address=False,
                        associate_public_ip_address=False,
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        groups=["groups"],
                        interface_type="interfaceType",
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2.CfnLaunchTemplate.Ipv6AddProperty(
                            ipv6_address="ipv6Address"
                        )],
                        network_card_index=123,
                        network_interface_id="networkInterfaceId",
                        private_ip_address="privateIpAddress",
                        private_ip_addresses=[ec2.CfnLaunchTemplate.PrivateIpAddProperty(
                            primary=False,
                            private_ip_address="privateIpAddress"
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    placement=ec2.CfnLaunchTemplate.PlacementProperty(
                        affinity="affinity",
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        host_id="hostId",
                        host_resource_group_arn="hostResourceGroupArn",
                        partition_number=123,
                        spread_domain="spreadDomain",
                        tenancy="tenancy"
                    ),
                    private_dns_name_options=ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty(
                        enable_resource_name_dns_aaaa_record=False,
                        enable_resource_name_dns_aRecord=False,
                        hostname_type="hostnameType"
                    ),
                    ram_disk_id="ramDiskId",
                    security_group_ids=["securityGroupIds"],
                    security_groups=["securityGroups"],
                    tag_specifications=[ec2.CfnLaunchTemplate.TagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if block_device_mappings is not None:
                self._values["block_device_mappings"] = block_device_mappings
            if capacity_reservation_specification is not None:
                self._values["capacity_reservation_specification"] = capacity_reservation_specification
            if cpu_options is not None:
                self._values["cpu_options"] = cpu_options
            if credit_specification is not None:
                self._values["credit_specification"] = credit_specification
            if disable_api_termination is not None:
                self._values["disable_api_termination"] = disable_api_termination
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized
            if elastic_gpu_specifications is not None:
                self._values["elastic_gpu_specifications"] = elastic_gpu_specifications
            if elastic_inference_accelerators is not None:
                self._values["elastic_inference_accelerators"] = elastic_inference_accelerators
            if enclave_options is not None:
                self._values["enclave_options"] = enclave_options
            if hibernation_options is not None:
                self._values["hibernation_options"] = hibernation_options
            if iam_instance_profile is not None:
                self._values["iam_instance_profile"] = iam_instance_profile
            if image_id is not None:
                self._values["image_id"] = image_id
            if instance_initiated_shutdown_behavior is not None:
                self._values["instance_initiated_shutdown_behavior"] = instance_initiated_shutdown_behavior
            if instance_market_options is not None:
                self._values["instance_market_options"] = instance_market_options
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if kernel_id is not None:
                self._values["kernel_id"] = kernel_id
            if key_name is not None:
                self._values["key_name"] = key_name
            if license_specifications is not None:
                self._values["license_specifications"] = license_specifications
            if metadata_options is not None:
                self._values["metadata_options"] = metadata_options
            if monitoring is not None:
                self._values["monitoring"] = monitoring
            if network_interfaces is not None:
                self._values["network_interfaces"] = network_interfaces
            if placement is not None:
                self._values["placement"] = placement
            if private_dns_name_options is not None:
                self._values["private_dns_name_options"] = private_dns_name_options
            if ram_disk_id is not None:
                self._values["ram_disk_id"] = ram_disk_id
            if security_group_ids is not None:
                self._values["security_group_ids"] = security_group_ids
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if tag_specifications is not None:
                self._values["tag_specifications"] = tag_specifications
            if user_data is not None:
                self._values["user_data"] = user_data

        @builtins.property
        def block_device_mappings(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]]:
            '''The block device mapping.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-blockdevicemappings
            '''
            result = self._values.get("block_device_mappings")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def capacity_reservation_specification(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.CapacityReservationSpecificationProperty", _IResolvable_da3f097b]]:
            '''The Capacity Reservation targeting option.

            If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open`` , which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-capacityreservationspecification
            '''
            result = self._values.get("capacity_reservation_specification")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.CapacityReservationSpecificationProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def cpu_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.CpuOptionsProperty", _IResolvable_da3f097b]]:
            '''The CPU options for the instance.

            For more information, see `Optimizing CPU Options <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-cpuoptions
            '''
            result = self._values.get("cpu_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.CpuOptionsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def credit_specification(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.CreditSpecificationProperty", _IResolvable_da3f097b]]:
            '''The credit option for CPU usage of the instance.

            Valid for T2, T3, or T3a instances only.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-creditspecification
            '''
            result = self._values.get("credit_specification")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.CreditSpecificationProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def disable_api_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''If you set this parameter to ``true`` , you can't terminate the instance using the Amazon EC2 console, CLI, or API;

            otherwise, you can. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_ . Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate`` , you can terminate the instance by running the shutdown command from the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-disableapitermination
            '''
            result = self._values.get("disable_api_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def ebs_optimized(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the instance is optimized for Amazon EBS I/O.

            This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ebsoptimized
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def elastic_gpu_specifications(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''An elastic GPU to associate with the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticgpuspecifications
            '''
            result = self._values.get("elastic_gpu_specifications")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.ElasticGpuSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def elastic_inference_accelerators(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]]:
            '''The elastic inference accelerator for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-elasticinferenceaccelerators
            '''
            result = self._values.get("elastic_inference_accelerators")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def enclave_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.EnclaveOptionsProperty", _IResolvable_da3f097b]]:
            '''Indicates whether the instance is enabled for AWS Nitro Enclaves.

            For more information, see `What is AWS Nitro Enclaves? <https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html>`_ in the *AWS Nitro Enclaves User Guide* .

            You can't enable AWS Nitro Enclaves and hibernation on the same instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-enclaveoptions
            '''
            result = self._values.get("enclave_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.EnclaveOptionsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def hibernation_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.HibernationOptionsProperty", _IResolvable_da3f097b]]:
            '''Indicates whether an instance is enabled for hibernation.

            This parameter is valid only if the instance meets the `hibernation prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites>`_ . For more information, see `Hibernate your instance <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-hibernationoptions
            '''
            result = self._values.get("hibernation_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.HibernationOptionsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def iam_instance_profile(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.IamInstanceProfileProperty", _IResolvable_da3f097b]]:
            '''The name or Amazon Resource Name (ARN) of an IAM instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-iaminstanceprofile
            '''
            result = self._values.get("iam_instance_profile")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.IamInstanceProfileProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def image_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the AMI.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-imageid
            '''
            result = self._values.get("image_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_initiated_shutdown_behavior(self) -> typing.Optional[builtins.str]:
            '''Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).

            Default: ``stop``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instanceinitiatedshutdownbehavior
            '''
            result = self._values.get("instance_initiated_shutdown_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_market_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.InstanceMarketOptionsProperty", _IResolvable_da3f097b]]:
            '''The market (purchasing) option for the instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions
            '''
            result = self._values.get("instance_market_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.InstanceMarketOptionsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.InstanceRequirementsProperty", _IResolvable_da3f097b]]:
            '''``CfnLaunchTemplate.LaunchTemplateDataProperty.InstanceRequirements``.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.InstanceRequirementsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type. For more information, see `Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            If you specify ``InstanceTypes`` , you can't specify ``InstanceRequirements`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def kernel_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the kernel.

            We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon EC2 User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-kernelid
            '''
            result = self._values.get("kernel_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key_name(self) -> typing.Optional[builtins.str]:
            '''The name of the key pair. You can create a key pair using `CreateKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html>`_ or `ImportKeyPair <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html>`_ .

            .. epigraph::

               If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-keyname
            '''
            result = self._values.get("key_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def license_specifications(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LicenseSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''The license configurations.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-licensespecifications
            '''
            result = self._values.get("license_specifications")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.LicenseSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def metadata_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.MetadataOptionsProperty", _IResolvable_da3f097b]]:
            '''The metadata options for the instance.

            For more information, see `Instance Metadata and User Data <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions
            '''
            result = self._values.get("metadata_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.MetadataOptionsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def monitoring(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.MonitoringProperty", _IResolvable_da3f097b]]:
            '''The monitoring for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-monitoring
            '''
            result = self._values.get("monitoring")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.MonitoringProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def network_interfaces(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.NetworkInterfaceProperty", _IResolvable_da3f097b]]]]:
            '''One or more network interfaces.

            If you specify a network interface, you must specify any security groups and subnets as part of the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-networkinterfaces
            '''
            result = self._values.get("network_interfaces")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.NetworkInterfaceProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.PlacementProperty", _IResolvable_da3f097b]]:
            '''The placement for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-placement
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.PlacementProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def private_dns_name_options(
            self,
        ) -> typing.Optional[typing.Union["CfnLaunchTemplate.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]]:
            '''The options for the instance hostname.

            The default values are inherited from the subnet.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions
            '''
            result = self._values.get("private_dns_name_options")
            return typing.cast(typing.Optional[typing.Union["CfnLaunchTemplate.PrivateDnsNameOptionsProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def ram_disk_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the RAM disk.

            .. epigraph::

               We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see `User Provided Kernels <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-ramdiskid
            '''
            result = self._values.get("ram_disk_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
            '''One or more security group IDs.

            You can create a security group using `CreateSecurityGroup <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html>`_ . You cannot specify both a security group ID and security name in the same request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroupids
            '''
            result = self._values.get("security_group_ids")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def security_groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''[EC2-Classic, default VPC] One or more security group names.

            For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def tag_specifications(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.TagSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''The tags to apply to the resources during launch.

            You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications
            '''
            result = self._values.get("tag_specifications")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.TagSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def user_data(self) -> typing.Optional[builtins.str]:
            '''The user data to make available to the instance.

            You must provide base64-encoded text. User data is limited to 16 KB. For more information, see `Running Commands on Your Linux Instance at Launch <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html>`_ (Linux) or `Adding User Data <https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data>`_ (Windows).

            If you are creating the launch template for use with AWS Batch , the user data must be provided in the `MIME multi-part archive format <https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive>`_ . For more information, see `Amazon EC2 user data in launch templates <https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html>`_ in the *AWS Batch User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-userdata
            '''
            result = self._values.get("user_data")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateDataProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty",
        jsii_struct_bases=[],
        name_mapping={"count": "count", "type": "type"},
    )
    class LaunchTemplateElasticInferenceAcceleratorProperty:
        def __init__(
            self,
            *,
            count: typing.Optional[jsii.Number] = None,
            type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies an elastic inference accelerator.

            ``LaunchTemplateElasticInferenceAccelerator`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param count: The number of elastic inference accelerators to attach to the instance. Default: 1
            :param type: The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                launch_template_elastic_inference_accelerator_property = ec2.CfnLaunchTemplate.LaunchTemplateElasticInferenceAcceleratorProperty(
                    count=123,
                    type="type"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if count is not None:
                self._values["count"] = count
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def count(self) -> typing.Optional[jsii.Number]:
            '''The number of elastic inference accelerators to attach to the instance.

            Default: 1

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-count
            '''
            result = self._values.get("count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of elastic inference accelerator.

            The possible values are eia1.medium, eia1.large, and eia1.xlarge.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator.html#cfn-ec2-launchtemplate-launchtemplateelasticinferenceaccelerator-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateElasticInferenceAcceleratorProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class LaunchTemplateTagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        ) -> None:
            '''Specifies the tags to apply to the launch template during creation.

            ``LaunchTemplateTagSpecification`` is a property of `AWS::EC2::LaunchTemplate <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html>`_ .

            :param resource_type: The type of resource. To tag the launch template, ``ResourceType`` must be ``launch-template`` .
            :param tags: The tags for the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                launch_template_tag_specification_property = ec2.CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource.

            To tag the launch template, ``ResourceType`` must be ``launch-template`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
            '''The tags for the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatetagspecification.html#cfn-ec2-launchtemplate-launchtemplatetagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateTagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.LicenseSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"license_configuration_arn": "licenseConfigurationArn"},
    )
    class LicenseSpecificationProperty:
        def __init__(
            self,
            *,
            license_configuration_arn: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a license configuration for an instance.

            ``LicenseSpecification`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                license_specification_property = ec2.CfnLaunchTemplate.LicenseSpecificationProperty(
                    license_configuration_arn="licenseConfigurationArn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if license_configuration_arn is not None:
                self._values["license_configuration_arn"] = license_configuration_arn

        @builtins.property
        def license_configuration_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the license configuration.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-licensespecification.html#cfn-ec2-launchtemplate-licensespecification-licenseconfigurationarn
            '''
            result = self._values.get("license_configuration_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LicenseSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryGiBPerVCpuProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            :param max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                memory_gi_bPer_vCpu_property = ec2.CfnLaunchTemplate.MemoryGiBPerVCpuProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory per vCPU, in GiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory per vCPU, in GiB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorygibpervcpu.html#cfn-ec2-launchtemplate-memorygibpervcpu-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryGiBPerVCpuProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.MemoryMiBProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryMiBProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory, in MiB.

            :param max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                memory_mi_bProperty = ec2.CfnLaunchTemplate.MemoryMiBProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory, in MiB.

            To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-memorymib.html#cfn-ec2-launchtemplate-memorymib-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryMiBProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.MetadataOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "http_endpoint": "httpEndpoint",
            "http_protocol_ipv6": "httpProtocolIpv6",
            "http_put_response_hop_limit": "httpPutResponseHopLimit",
            "http_tokens": "httpTokens",
            "instance_metadata_tags": "instanceMetadataTags",
        },
    )
    class MetadataOptionsProperty:
        def __init__(
            self,
            *,
            http_endpoint: typing.Optional[builtins.str] = None,
            http_protocol_ipv6: typing.Optional[builtins.str] = None,
            http_put_response_hop_limit: typing.Optional[jsii.Number] = None,
            http_tokens: typing.Optional[builtins.str] = None,
            instance_metadata_tags: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the metadata options for the instance.

            ``MetadataOptions`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled`` . .. epigraph:: If you specify a value of ``disabled`` , you will not be able to access your instance metadata.
            :param http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. Default: ``disabled``
            :param http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel. Default: 1 Possible values: Integers from 1 to 64
            :param http_tokens: The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is ``optional`` . If the state is ``optional`` , you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned. If the state is ``required`` , you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.
            :param instance_metadata_tags: Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `Work with instance tags using the instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS>`_ . Default: ``disabled``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                metadata_options_property = ec2.CfnLaunchTemplate.MetadataOptionsProperty(
                    http_endpoint="httpEndpoint",
                    http_protocol_ipv6="httpProtocolIpv6",
                    http_put_response_hop_limit=123,
                    http_tokens="httpTokens",
                    instance_metadata_tags="instanceMetadataTags"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if http_endpoint is not None:
                self._values["http_endpoint"] = http_endpoint
            if http_protocol_ipv6 is not None:
                self._values["http_protocol_ipv6"] = http_protocol_ipv6
            if http_put_response_hop_limit is not None:
                self._values["http_put_response_hop_limit"] = http_put_response_hop_limit
            if http_tokens is not None:
                self._values["http_tokens"] = http_tokens
            if instance_metadata_tags is not None:
                self._values["instance_metadata_tags"] = instance_metadata_tags

        @builtins.property
        def http_endpoint(self) -> typing.Optional[builtins.str]:
            '''Enables or disables the HTTP metadata endpoint on your instances.

            If the parameter is not specified, the default state is ``enabled`` .
            .. epigraph::

               If you specify a value of ``disabled`` , you will not be able to access your instance metadata.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions-httpendpoint
            '''
            result = self._values.get("http_endpoint")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def http_protocol_ipv6(self) -> typing.Optional[builtins.str]:
            '''Enables or disables the IPv6 endpoint for the instance metadata service.

            Default: ``disabled``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions-httpprotocolipv6
            '''
            result = self._values.get("http_protocol_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def http_put_response_hop_limit(self) -> typing.Optional[jsii.Number]:
            '''The desired HTTP PUT response hop limit for instance metadata requests.

            The larger the number, the further instance metadata requests can travel.

            Default: 1

            Possible values: Integers from 1 to 64

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions-httpputresponsehoplimit
            '''
            result = self._values.get("http_put_response_hop_limit")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def http_tokens(self) -> typing.Optional[builtins.str]:
            '''The state of token usage for your instance metadata requests.

            If the parameter is not specified in the request, the default state is ``optional`` .

            If the state is ``optional`` , you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.

            If the state is ``required`` , you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions-httptokens
            '''
            result = self._values.get("http_tokens")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_metadata_tags(self) -> typing.Optional[builtins.str]:
            '''Set to ``enabled`` to allow access to instance tags from the instance metadata.

            Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see `Work with instance tags using the instance metadata <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS>`_ .

            Default: ``disabled``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-metadataoptions-instancemetadatatags
            '''
            result = self._values.get("instance_metadata_tags")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MetadataOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.MonitoringProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class MonitoringProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies whether detailed monitoring is enabled for an instance.

            ``Monitoring`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param enabled: Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-monitoring.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                monitoring_property = ec2.CfnLaunchTemplate.MonitoringProperty(
                    enabled=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Specify ``true`` to enable detailed monitoring.

            Otherwise, basic monitoring is enabled.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-monitoring.html#cfn-ec2-launchtemplate-launchtemplatedata-monitoring-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MonitoringProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkInterfaceCountProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of network interfaces.

            :param max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                network_interface_count_property = ec2.CfnLaunchTemplate.NetworkInterfaceCountProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of network interfaces.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of network interfaces.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterfacecount.html#cfn-ec2-launchtemplate-networkinterfacecount-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceCountProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.NetworkInterfaceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "associate_carrier_ip_address": "associateCarrierIpAddress",
            "associate_public_ip_address": "associatePublicIpAddress",
            "delete_on_termination": "deleteOnTermination",
            "description": "description",
            "device_index": "deviceIndex",
            "groups": "groups",
            "interface_type": "interfaceType",
            "ipv6_address_count": "ipv6AddressCount",
            "ipv6_addresses": "ipv6Addresses",
            "network_card_index": "networkCardIndex",
            "network_interface_id": "networkInterfaceId",
            "private_ip_address": "privateIpAddress",
            "private_ip_addresses": "privateIpAddresses",
            "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
            "subnet_id": "subnetId",
        },
    )
    class NetworkInterfaceProperty:
        def __init__(
            self,
            *,
            associate_carrier_ip_address: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            description: typing.Optional[builtins.str] = None,
            device_index: typing.Optional[jsii.Number] = None,
            groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            interface_type: typing.Optional[builtins.str] = None,
            ipv6_address_count: typing.Optional[jsii.Number] = None,
            ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.Ipv6AddProperty", _IResolvable_da3f097b]]]] = None,
            network_card_index: typing.Optional[jsii.Number] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
            private_ip_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnLaunchTemplate.PrivateIpAddProperty", _IResolvable_da3f097b]]]] = None,
            secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the parameters for a network interface.

            ``NetworkInterface`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param associate_carrier_ip_address: Indicates whether to associate a Carrier IP address with eth0 for a new network interface. Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see `Carrier IP addresses <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .
            :param associate_public_ip_address: Associates a public IPv4 address with eth0 for a new network interface.
            :param delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
            :param description: A description for the network interface.
            :param device_index: The device index for the network interface attachment.
            :param groups: The IDs of one or more security groups.
            :param interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` . For more information, see `Elastic Fabric Adapter <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . If you are not creating an EFA, specify ``interface`` or omit this parameter. Valid values: ``interface`` | ``efa``
            :param ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
            :param ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
            :param network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
            :param network_interface_id: The ID of the network interface.
            :param private_ip_address: The primary private IPv4 address of the network interface.
            :param private_ip_addresses: One or more private IPv4 addresses.
            :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface.
            :param subnet_id: The ID of the subnet for the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                network_interface_property = ec2.CfnLaunchTemplate.NetworkInterfaceProperty(
                    associate_carrier_ip_address=False,
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    device_index=123,
                    groups=["groups"],
                    interface_type="interfaceType",
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2.CfnLaunchTemplate.Ipv6AddProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_card_index=123,
                    network_interface_id="networkInterfaceId",
                    private_ip_address="privateIpAddress",
                    private_ip_addresses=[ec2.CfnLaunchTemplate.PrivateIpAddProperty(
                        primary=False,
                        private_ip_address="privateIpAddress"
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if associate_carrier_ip_address is not None:
                self._values["associate_carrier_ip_address"] = associate_carrier_ip_address
            if associate_public_ip_address is not None:
                self._values["associate_public_ip_address"] = associate_public_ip_address
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if description is not None:
                self._values["description"] = description
            if device_index is not None:
                self._values["device_index"] = device_index
            if groups is not None:
                self._values["groups"] = groups
            if interface_type is not None:
                self._values["interface_type"] = interface_type
            if ipv6_address_count is not None:
                self._values["ipv6_address_count"] = ipv6_address_count
            if ipv6_addresses is not None:
                self._values["ipv6_addresses"] = ipv6_addresses
            if network_card_index is not None:
                self._values["network_card_index"] = network_card_index
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address
            if private_ip_addresses is not None:
                self._values["private_ip_addresses"] = private_ip_addresses
            if secondary_private_ip_address_count is not None:
                self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id

        @builtins.property
        def associate_carrier_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to associate a Carrier IP address with eth0 for a new network interface.

            Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see `Carrier IP addresses <https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip>`_ in the *AWS Wavelength Developer Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatecarrieripaddress
            '''
            result = self._values.get("associate_carrier_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def associate_public_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Associates a public IPv4 address with eth0 for a new network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-associatepublicipaddress
            '''
            result = self._values.get("associate_public_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the network interface is deleted when the instance is terminated.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def device_index(self) -> typing.Optional[jsii.Number]:
            '''The device index for the network interface attachment.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-deviceindex
            '''
            result = self._values.get("device_index")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of one or more security groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-groups
            '''
            result = self._values.get("groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def interface_type(self) -> typing.Optional[builtins.str]:
            '''The type of network interface.

            To create an Elastic Fabric Adapter (EFA), specify ``efa`` . For more information, see `Elastic Fabric Adapter <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            If you are not creating an EFA, specify ``interface`` or omit this parameter.

            Valid values: ``interface`` | ``efa``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-interfacetype
            '''
            result = self._values.get("interface_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of IPv6 addresses to assign to a network interface.

            Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresscount
            '''
            result = self._values.get("ipv6_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_addresses(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.Ipv6AddProperty", _IResolvable_da3f097b]]]]:
            '''One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.

            You can't use this option if you're specifying a number of IPv6 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-ipv6addresses
            '''
            result = self._values.get("ipv6_addresses")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.Ipv6AddProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def network_card_index(self) -> typing.Optional[jsii.Number]:
            '''The index of the network card.

            Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkcardindex
            '''
            result = self._values.get("network_card_index")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The primary private IPv4 address of the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_addresses(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.PrivateIpAddProperty", _IResolvable_da3f097b]]]]:
            '''One or more private IPv4 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-privateipaddresses
            '''
            result = self._values.get("private_ip_addresses")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnLaunchTemplate.PrivateIpAddProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of secondary private IPv4 addresses to assign to a network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-secondaryprivateipaddresscount
            '''
            result = self._values.get("secondary_private_ip_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet for the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html#cfn-ec2-launchtemplate-networkinterface-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.PlacementProperty",
        jsii_struct_bases=[],
        name_mapping={
            "affinity": "affinity",
            "availability_zone": "availabilityZone",
            "group_name": "groupName",
            "host_id": "hostId",
            "host_resource_group_arn": "hostResourceGroupArn",
            "partition_number": "partitionNumber",
            "spread_domain": "spreadDomain",
            "tenancy": "tenancy",
        },
    )
    class PlacementProperty:
        def __init__(
            self,
            *,
            affinity: typing.Optional[builtins.str] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            group_name: typing.Optional[builtins.str] = None,
            host_id: typing.Optional[builtins.str] = None,
            host_resource_group_arn: typing.Optional[builtins.str] = None,
            partition_number: typing.Optional[jsii.Number] = None,
            spread_domain: typing.Optional[builtins.str] = None,
            tenancy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the placement of an instance.

            ``Placement`` is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param affinity: The affinity setting for an instance on a Dedicated Host.
            :param availability_zone: The Availability Zone for the instance.
            :param group_name: The name of the placement group for the instance.
            :param host_id: The ID of the Dedicated Host for the instance.
            :param host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .
            :param partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition`` .
            :param spread_domain: Reserved for future use.
            :param tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                placement_property = ec2.CfnLaunchTemplate.PlacementProperty(
                    affinity="affinity",
                    availability_zone="availabilityZone",
                    group_name="groupName",
                    host_id="hostId",
                    host_resource_group_arn="hostResourceGroupArn",
                    partition_number=123,
                    spread_domain="spreadDomain",
                    tenancy="tenancy"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if affinity is not None:
                self._values["affinity"] = affinity
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if group_name is not None:
                self._values["group_name"] = group_name
            if host_id is not None:
                self._values["host_id"] = host_id
            if host_resource_group_arn is not None:
                self._values["host_resource_group_arn"] = host_resource_group_arn
            if partition_number is not None:
                self._values["partition_number"] = partition_number
            if spread_domain is not None:
                self._values["spread_domain"] = spread_domain
            if tenancy is not None:
                self._values["tenancy"] = tenancy

        @builtins.property
        def affinity(self) -> typing.Optional[builtins.str]:
            '''The affinity setting for an instance on a Dedicated Host.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-affinity
            '''
            result = self._values.get("affinity")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the placement group for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-groupname
            '''
            result = self._values.get("group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the Dedicated Host for the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-hostid
            '''
            result = self._values.get("host_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def host_resource_group_arn(self) -> typing.Optional[builtins.str]:
            '''The ARN of the host resource group in which to launch the instances.

            If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-hostresourcegrouparn
            '''
            result = self._values.get("host_resource_group_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def partition_number(self) -> typing.Optional[jsii.Number]:
            '''The number of the partition the instance should launch in.

            Valid only if the placement group strategy is set to ``partition`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-partitionnumber
            '''
            result = self._values.get("partition_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spread_domain(self) -> typing.Optional[builtins.str]:
            '''Reserved for future use.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-spreaddomain
            '''
            result = self._values.get("spread_domain")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenancy(self) -> typing.Optional[builtins.str]:
            '''The tenancy of the instance (if the instance is running in a VPC).

            An instance with a tenancy of dedicated runs on single-tenant hardware.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-placement.html#cfn-ec2-launchtemplate-launchtemplatedata-placement-tenancy
            '''
            result = self._values.get("tenancy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PlacementProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_resource_name_dns_aaaa_record": "enableResourceNameDnsAaaaRecord",
            "enable_resource_name_dns_a_record": "enableResourceNameDnsARecord",
            "hostname_type": "hostnameType",
        },
    )
    class PrivateDnsNameOptionsProperty:
        def __init__(
            self,
            *,
            enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            hostname_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the options for instance hostnames.

            :param enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
            :param enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
            :param hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_dns_name_options_property = ec2.CfnLaunchTemplate.PrivateDnsNameOptionsProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enable_resource_name_dns_aaaa_record is not None:
                self._values["enable_resource_name_dns_aaaa_record"] = enable_resource_name_dns_aaaa_record
            if enable_resource_name_dns_a_record is not None:
                self._values["enable_resource_name_dns_a_record"] = enable_resource_name_dns_a_record
            if hostname_type is not None:
                self._values["hostname_type"] = hostname_type

        @builtins.property
        def enable_resource_name_dns_aaaa_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions-enableresourcenamednsaaaarecord
            '''
            result = self._values.get("enable_resource_name_dns_aaaa_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def enable_resource_name_dns_a_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS A records.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions-enableresourcenamednsarecord
            '''
            result = self._values.get("enable_resource_name_dns_a_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def hostname_type(self) -> typing.Optional[builtins.str]:
            '''The type of hostname for EC2 instances.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-privatednsnameoptions-hostnametype
            '''
            result = self._values.get("hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateDnsNameOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.PrivateIpAddProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddProperty:
        def __init__(
            self,
            *,
            primary: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            private_ip_address: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a secondary private IPv4 address for a network interface.

            ``PrivateIpAdd`` is a property of `AWS::EC2::LaunchTemplate NetworkInterface <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html>`_ .

            :param primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
            :param private_ip_address: The private IPv4 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_ip_add_property = ec2.CfnLaunchTemplate.PrivateIpAddProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if primary is not None:
                self._values["primary"] = primary
            if private_ip_address is not None:
                self._values["private_ip_address"] = private_ip_address

        @builtins.property
        def primary(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the private IPv4 address is the primary private IPv4 address.

            Only one IPv4 address can be designated as primary.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-primary
            '''
            result = self._values.get("primary")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def private_ip_address(self) -> typing.Optional[builtins.str]:
            '''The private IPv4 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-privateipadd.html#cfn-ec2-launchtemplate-privateipadd-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.SpotOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={
            "block_duration_minutes": "blockDurationMinutes",
            "instance_interruption_behavior": "instanceInterruptionBehavior",
            "max_price": "maxPrice",
            "spot_instance_type": "spotInstanceType",
            "valid_until": "validUntil",
        },
    )
    class SpotOptionsProperty:
        def __init__(
            self,
            *,
            block_duration_minutes: typing.Optional[jsii.Number] = None,
            instance_interruption_behavior: typing.Optional[builtins.str] = None,
            max_price: typing.Optional[builtins.str] = None,
            spot_instance_type: typing.Optional[builtins.str] = None,
            valid_until: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies options for Spot Instances.

            ``SpotOptions`` is a property of `AWS::EC2::LaunchTemplate InstanceMarketOptions <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html>`_ .

            :param block_duration_minutes: The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).
            :param instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate`` .
            :param max_price: The maximum hourly price you're willing to pay for the Spot Instances.
            :param spot_instance_type: The Spot Instance request type. If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.
            :param valid_until: The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_options_property = ec2.CfnLaunchTemplate.SpotOptionsProperty(
                    block_duration_minutes=123,
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    max_price="maxPrice",
                    spot_instance_type="spotInstanceType",
                    valid_until="validUntil"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if block_duration_minutes is not None:
                self._values["block_duration_minutes"] = block_duration_minutes
            if instance_interruption_behavior is not None:
                self._values["instance_interruption_behavior"] = instance_interruption_behavior
            if max_price is not None:
                self._values["max_price"] = max_price
            if spot_instance_type is not None:
                self._values["spot_instance_type"] = spot_instance_type
            if valid_until is not None:
                self._values["valid_until"] = valid_until

        @builtins.property
        def block_duration_minutes(self) -> typing.Optional[jsii.Number]:
            '''The required duration for the Spot Instances (also known as Spot blocks), in minutes.

            This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions-blockdurationminutes
            '''
            result = self._values.get("block_duration_minutes")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
            '''The behavior when a Spot Instance is interrupted.

            The default is ``terminate`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions-instanceinterruptionbehavior
            '''
            result = self._values.get("instance_interruption_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def max_price(self) -> typing.Optional[builtins.str]:
            '''The maximum hourly price you're willing to pay for the Spot Instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions-maxprice
            '''
            result = self._values.get("max_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def spot_instance_type(self) -> typing.Optional[builtins.str]:
            '''The Spot Instance request type.

            If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions-spotinstancetype
            '''
            result = self._values.get("spot_instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_until(self) -> typing.Optional[builtins.str]:
            '''The end date of the request.

            For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions.html#cfn-ec2-launchtemplate-launchtemplatedata-instancemarketoptions-spotoptions-validuntil
            '''
            result = self._values.get("valid_until")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.TagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class TagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        ) -> None:
            '''Specifies the tags to apply to a resource when the resource is created for the launch template.

            ``TagSpecification`` is a property type of ```TagSpecifications`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications>`_ . ```TagSpecifications`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications>`_ is a property of `AWS::EC2::LaunchTemplate LaunchTemplateData <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html>`_ .

            :param resource_type: The type of resource to tag. Currently, the resource types that support tagging on creation are ``instance`` and ``volume`` . To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ . *Conditional* : Required if tags are set.
            :param tags: The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                tag_specification_property = ec2.CfnLaunchTemplate.TagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource to tag.

            Currently, the resource types that support tagging on creation are ``instance`` and ``volume`` . To tag a resource after it has been created, see `CreateTags <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html>`_ .

            *Conditional* : Required if tags are set.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
            '''The tags to apply to the resource.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html#cfn-ec2-launchtemplate-tagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class TotalLocalStorageGBProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total local storage, in GB.

            :param max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                total_local_storage_gBProperty = ec2.CfnLaunchTemplate.TotalLocalStorageGBProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of total local storage, in GB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of total local storage, in GB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-totallocalstoragegb.html#cfn-ec2-launchtemplate-totallocalstoragegb-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TotalLocalStorageGBProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplate.VCpuCountProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class VCpuCountProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of vCPUs.

            :param max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                v_cpu_count_property = ec2.CfnLaunchTemplate.VCpuCountProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of vCPUs.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of vCPUs.

            To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-vcpucount.html#cfn-ec2-launchtemplate-vcpucount-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VCpuCountProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnLaunchTemplateProps",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_data": "launchTemplateData",
        "launch_template_name": "launchTemplateName",
        "tag_specifications": "tagSpecifications",
    },
)
class CfnLaunchTemplateProps:
    def __init__(
        self,
        *,
        launch_template_data: typing.Optional[typing.Union[CfnLaunchTemplate.LaunchTemplateDataProperty, _IResolvable_da3f097b]] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty, _IResolvable_da3f097b]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnLaunchTemplate``.

        :param launch_template_data: The information for the launch template.
        :param launch_template_name: A name for the launch template.
        :param tag_specifications: The tags to apply to the launch template during creation.

        :exampleMetadata: infused
        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html

        Example::

            # cluster: eks.Cluster
            
            
            user_data = """MIME-Version: 1.0
            Content-Type: multipart/mixed; boundary="==MYBOUNDARY=="
            
            --==MYBOUNDARY==
            Content-Type: text/x-shellscript; charset="us-ascii"
            
            #!/bin/bash
            echo "Running custom user data script"
            
            --==MYBOUNDARY==--\\
            """
            lt = ec2.CfnLaunchTemplate(self, "LaunchTemplate",
                launch_template_data=ec2.CfnLaunchTemplate.LaunchTemplateDataProperty(
                    instance_type="t3.small",
                    user_data=Fn.base64(user_data)
                )
            )
            
            cluster.add_nodegroup_capacity("extra-ng",
                launch_template_spec=eks.LaunchTemplateSpec(
                    id=lt.ref,
                    version=lt.attr_latest_version_number
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if launch_template_data is not None:
            self._values["launch_template_data"] = launch_template_data
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if tag_specifications is not None:
            self._values["tag_specifications"] = tag_specifications

    @builtins.property
    def launch_template_data(
        self,
    ) -> typing.Optional[typing.Union[CfnLaunchTemplate.LaunchTemplateDataProperty, _IResolvable_da3f097b]]:
        '''The information for the launch template.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatedata
        '''
        result = self._values.get("launch_template_data")
        return typing.cast(typing.Optional[typing.Union[CfnLaunchTemplate.LaunchTemplateDataProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''A name for the launch template.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-launchtemplatename
        '''
        result = self._values.get("launch_template_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tag_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The tags to apply to the launch template during creation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications
        '''
        result = self._values.get("tag_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnLaunchTemplate.LaunchTemplateTagSpecificationProperty, _IResolvable_da3f097b]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLaunchTemplateProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnLocalGatewayRoute(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnLocalGatewayRoute",
):
    '''A CloudFormation ``AWS::EC2::LocalGatewayRoute``.

    Creates a static route for the specified local gateway route table.

    :cloudformationResource: AWS::EC2::LocalGatewayRoute
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_local_gateway_route = ec2.CfnLocalGatewayRoute(self, "MyCfnLocalGatewayRoute",
            destination_cidr_block="destinationCidrBlock",
            local_gateway_route_table_id="localGatewayRouteTableId",
            local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        destination_cidr_block: builtins.str,
        local_gateway_route_table_id: builtins.str,
        local_gateway_virtual_interface_group_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::LocalGatewayRoute``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param destination_cidr_block: The CIDR block used for destination matches.
        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param local_gateway_virtual_interface_group_id: The ID of the virtual interface group.
        '''
        props = CfnLocalGatewayRouteProps(
            destination_cidr_block=destination_cidr_block,
            local_gateway_route_table_id=local_gateway_route_table_id,
            local_gateway_virtual_interface_group_id=local_gateway_virtual_interface_group_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the local gateway route table.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrType")
    def attr_type(self) -> builtins.str:
        '''The type of local gateway route.

        :cloudformationAttribute: Type
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> builtins.str:
        '''The CIDR block used for destination matches.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "destinationCidrBlock"))

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="localGatewayRouteTableId")
    def local_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the local gateway route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "localGatewayRouteTableId"))

    @local_gateway_route_table_id.setter
    def local_gateway_route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "localGatewayRouteTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="localGatewayVirtualInterfaceGroupId")
    def local_gateway_virtual_interface_group_id(self) -> builtins.str:
        '''The ID of the virtual interface group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
        '''
        return typing.cast(builtins.str, jsii.get(self, "localGatewayVirtualInterfaceGroupId"))

    @local_gateway_virtual_interface_group_id.setter
    def local_gateway_virtual_interface_group_id(self, value: builtins.str) -> None:
        jsii.set(self, "localGatewayVirtualInterfaceGroupId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnLocalGatewayRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "local_gateway_route_table_id": "localGatewayRouteTableId",
        "local_gateway_virtual_interface_group_id": "localGatewayVirtualInterfaceGroupId",
    },
)
class CfnLocalGatewayRouteProps:
    def __init__(
        self,
        *,
        destination_cidr_block: builtins.str,
        local_gateway_route_table_id: builtins.str,
        local_gateway_virtual_interface_group_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnLocalGatewayRoute``.

        :param destination_cidr_block: The CIDR block used for destination matches.
        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param local_gateway_virtual_interface_group_id: The ID of the virtual interface group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_local_gateway_route_props = ec2.CfnLocalGatewayRouteProps(
                destination_cidr_block="destinationCidrBlock",
                local_gateway_route_table_id="localGatewayRouteTableId",
                local_gateway_virtual_interface_group_id="localGatewayVirtualInterfaceGroupId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "destination_cidr_block": destination_cidr_block,
            "local_gateway_route_table_id": local_gateway_route_table_id,
            "local_gateway_virtual_interface_group_id": local_gateway_virtual_interface_group_id,
        }

    @builtins.property
    def destination_cidr_block(self) -> builtins.str:
        '''The CIDR block used for destination matches.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        assert result is not None, "Required property 'destination_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def local_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the local gateway route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayroutetableid
        '''
        result = self._values.get("local_gateway_route_table_id")
        assert result is not None, "Required property 'local_gateway_route_table_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def local_gateway_virtual_interface_group_id(self) -> builtins.str:
        '''The ID of the virtual interface group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroute.html#cfn-ec2-localgatewayroute-localgatewayvirtualinterfacegroupid
        '''
        result = self._values.get("local_gateway_virtual_interface_group_id")
        assert result is not None, "Required property 'local_gateway_virtual_interface_group_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnLocalGatewayRouteTableVPCAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnLocalGatewayRouteTableVPCAssociation",
):
    '''A CloudFormation ``AWS::EC2::LocalGatewayRouteTableVPCAssociation``.

    Associates the specified VPC with the specified local gateway route table.

    :cloudformationResource: AWS::EC2::LocalGatewayRouteTableVPCAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_local_gateway_route_table_vPCAssociation = ec2.CfnLocalGatewayRouteTableVPCAssociation(self, "MyCfnLocalGatewayRouteTableVPCAssociation",
            local_gateway_route_table_id="localGatewayRouteTableId",
            vpc_id="vpcId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        local_gateway_route_table_id: builtins.str,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::LocalGatewayRouteTableVPCAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param vpc_id: The ID of the VPC.
        :param tags: The tags assigned to the association.
        '''
        props = CfnLocalGatewayRouteTableVPCAssociationProps(
            local_gateway_route_table_id=local_gateway_route_table_id,
            vpc_id=vpc_id,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrLocalGatewayId")
    def attr_local_gateway_id(self) -> builtins.str:
        '''The ID of the local gateway.

        :cloudformationAttribute: LocalGatewayId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrLocalGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrLocalGatewayRouteTableVpcAssociationId")
    def attr_local_gateway_route_table_vpc_association_id(self) -> builtins.str:
        '''The ID of the association.

        :cloudformationAttribute: LocalGatewayRouteTableVpcAssociationId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrLocalGatewayRouteTableVpcAssociationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the association.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags assigned to the association.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="localGatewayRouteTableId")
    def local_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the local gateway route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "localGatewayRouteTableId"))

    @local_gateway_route_table_id.setter
    def local_gateway_route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "localGatewayRouteTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnLocalGatewayRouteTableVPCAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "local_gateway_route_table_id": "localGatewayRouteTableId",
        "vpc_id": "vpcId",
        "tags": "tags",
    },
)
class CfnLocalGatewayRouteTableVPCAssociationProps:
    def __init__(
        self,
        *,
        local_gateway_route_table_id: builtins.str,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnLocalGatewayRouteTableVPCAssociation``.

        :param local_gateway_route_table_id: The ID of the local gateway route table.
        :param vpc_id: The ID of the VPC.
        :param tags: The tags assigned to the association.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_local_gateway_route_table_vPCAssociation_props = ec2.CfnLocalGatewayRouteTableVPCAssociationProps(
                local_gateway_route_table_id="localGatewayRouteTableId",
                vpc_id="vpcId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "local_gateway_route_table_id": local_gateway_route_table_id,
            "vpc_id": vpc_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def local_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the local gateway route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-localgatewayroutetableid
        '''
        result = self._values.get("local_gateway_route_table_id")
        assert result is not None, "Required property 'local_gateway_route_table_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags assigned to the association.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-localgatewayroutetablevpcassociation.html#cfn-ec2-localgatewayroutetablevpcassociation-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnLocalGatewayRouteTableVPCAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNatGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNatGateway",
):
    '''A CloudFormation ``AWS::EC2::NatGateway``.

    Specifies a network address translation (NAT) gateway in the specified subnet. You can create either a public NAT gateway or a private NAT gateway. The default is a public NAT gateway. If you create a public NAT gateway, you must specify an elastic IP address.

    With a NAT gateway, instances in a private subnet can connect to the internet, other AWS services, or an on-premises network using the IP address of the NAT gateway.

    If you add a default route ( ``AWS::EC2::Route`` resource) that points to a NAT gateway, specify the NAT gateway ID for the route's ``NatGatewayId`` property.

    For more information, see `NAT Gateways <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html>`_ in the *Amazon VPC User Guide* .

    :cloudformationResource: AWS::EC2::NatGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_nat_gateway = ec2.CfnNatGateway(self, "MyCfnNatGateway",
            subnet_id="subnetId",
        
            # the properties below are optional
            allocation_id="allocationId",
            connectivity_type="connectivityType",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_id: builtins.str,
        allocation_id: typing.Optional[builtins.str] = None,
        connectivity_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NatGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param subnet_id: The ID of the subnet in which the NAT gateway is located.
        :param allocation_id: [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
        :param connectivity_type: Indicates whether the NAT gateway supports public or private connectivity.
        :param tags: The tags for the NAT gateway.
        '''
        props = CfnNatGatewayProps(
            subnet_id=subnet_id,
            allocation_id=allocation_id,
            connectivity_type=connectivity_type,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet in which the NAT gateway is located.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allocationId")
    def allocation_id(self) -> typing.Optional[builtins.str]:
        '''[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "allocationId"))

    @allocation_id.setter
    def allocation_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "allocationId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connectivityType")
    def connectivity_type(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the NAT gateway supports public or private connectivity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "connectivityType"))

    @connectivity_type.setter
    def connectivity_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "connectivityType", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNatGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "subnet_id": "subnetId",
        "allocation_id": "allocationId",
        "connectivity_type": "connectivityType",
        "tags": "tags",
    },
)
class CfnNatGatewayProps:
    def __init__(
        self,
        *,
        subnet_id: builtins.str,
        allocation_id: typing.Optional[builtins.str] = None,
        connectivity_type: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNatGateway``.

        :param subnet_id: The ID of the subnet in which the NAT gateway is located.
        :param allocation_id: [Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.
        :param connectivity_type: Indicates whether the NAT gateway supports public or private connectivity.
        :param tags: The tags for the NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_nat_gateway_props = ec2.CfnNatGatewayProps(
                subnet_id="subnetId",
            
                # the properties below are optional
                allocation_id="allocationId",
                connectivity_type="connectivityType",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_id": subnet_id,
        }
        if allocation_id is not None:
            self._values["allocation_id"] = allocation_id
        if connectivity_type is not None:
            self._values["connectivity_type"] = connectivity_type
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet in which the NAT gateway is located.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-subnetid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def allocation_id(self) -> typing.Optional[builtins.str]:
        '''[Public NAT gateway only] The allocation ID of the Elastic IP address that's associated with the NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-allocationid
        '''
        result = self._values.get("allocation_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def connectivity_type(self) -> typing.Optional[builtins.str]:
        '''Indicates whether the NAT gateway supports public or private connectivity.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-connectivitytype
        '''
        result = self._values.get("connectivity_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-natgateway.html#cfn-ec2-natgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNatGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkAcl(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkAcl",
):
    '''A CloudFormation ``AWS::EC2::NetworkAcl``.

    Specifies a network ACL for your VPC.

    :cloudformationResource: AWS::EC2::NetworkAcl
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_acl = ec2.CfnNetworkAcl(self, "MyCfnNetworkAcl",
            vpc_id="vpcId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkAcl``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param vpc_id: The ID of the VPC for the network ACL.
        :param tags: The tags for the network ACL.
        '''
        props = CfnNetworkAclProps(vpc_id=vpc_id, tags=tags)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the network ACL.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC for the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkAclEntry(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkAclEntry",
):
    '''A CloudFormation ``AWS::EC2::NetworkAclEntry``.

    Specifies an entry, known as a rule, in a network ACL with a rule number you specify. Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules.

    For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.

    :cloudformationResource: AWS::EC2::NetworkAclEntry
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_acl_entry = ec2.CfnNetworkAclEntry(self, "MyCfnNetworkAclEntry",
            network_acl_id="networkAclId",
            protocol=123,
            rule_action="ruleAction",
            rule_number=123,
        
            # the properties below are optional
            cidr_block="cidrBlock",
            egress=False,
            icmp=ec2.CfnNetworkAclEntry.IcmpProperty(
                code=123,
                type=123
            ),
            ipv6_cidr_block="ipv6CidrBlock",
            port_range=ec2.CfnNetworkAclEntry.PortRangeProperty(
                from=123,
                to=123
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_acl_id: builtins.str,
        protocol: jsii.Number,
        rule_action: builtins.str,
        rule_number: jsii.Number,
        cidr_block: typing.Optional[builtins.str] = None,
        egress: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        icmp: typing.Optional[typing.Union["CfnNetworkAclEntry.IcmpProperty", _IResolvable_da3f097b]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        port_range: typing.Optional[typing.Union["CfnNetworkAclEntry.PortRangeProperty", _IResolvable_da3f097b]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkAclEntry``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param network_acl_id: The ID of the ACL for the entry.
        :param protocol: The IP protocol that the rule applies to. You must specify -1 or a protocol number. You can specify -1 for all protocols. .. epigraph:: If you specify -1, all ports are opened and the ``PortRange`` property is ignored.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param cidr_block: The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.
        :param egress: Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ). By default, AWS CloudFormation specifies ``false`` .
        :param icmp: The Internet Control Message Protocol (ICMP) code and type. Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
        :param ipv6_cidr_block: The IPv6 network range to allow or deny, in CIDR notation. Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.
        :param port_range: The range of port numbers for the UDP/TCP protocol. Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.
        '''
        props = CfnNetworkAclEntryProps(
            network_acl_id=network_acl_id,
            protocol=protocol,
            rule_action=rule_action,
            rule_number=rule_number,
            cidr_block=cidr_block,
            egress=egress,
            icmp=icmp,
            ipv6_cidr_block=ipv6_cidr_block,
            port_range=port_range,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the network ACL entry.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAclId")
    def network_acl_id(self) -> builtins.str:
        '''The ID of the ACL for the entry.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkAclId"))

    @network_acl_id.setter
    def network_acl_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkAclId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="protocol")
    def protocol(self) -> jsii.Number:
        '''The IP protocol that the rule applies to.

        You must specify -1 or a protocol number. You can specify -1 for all protocols.
        .. epigraph::

           If you specify -1, all ports are opened and the ``PortRange`` property is ignored.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
        '''
        return typing.cast(jsii.Number, jsii.get(self, "protocol"))

    @protocol.setter
    def protocol(self, value: jsii.Number) -> None:
        jsii.set(self, "protocol", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ruleAction")
    def rule_action(self) -> builtins.str:
        '''Whether to allow or deny traffic that matches the rule;

        valid values are "allow" or "deny".

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
        '''
        return typing.cast(builtins.str, jsii.get(self, "ruleAction"))

    @rule_action.setter
    def rule_action(self, value: builtins.str) -> None:
        jsii.set(self, "ruleAction", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ruleNumber")
    def rule_number(self) -> jsii.Number:
        '''Rule number to assign to the entry, such as 100.

        ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
        '''
        return typing.cast(jsii.Number, jsii.get(self, "ruleNumber"))

    @rule_number.setter
    def rule_number(self, value: jsii.Number) -> None:
        jsii.set(self, "ruleNumber", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrBlock"))

    @cidr_block.setter
    def cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="egress")
    def egress(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ).

        By default, AWS CloudFormation specifies ``false`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "egress"))

    @egress.setter
    def egress(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "egress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="icmp")
    def icmp(
        self,
    ) -> typing.Optional[typing.Union["CfnNetworkAclEntry.IcmpProperty", _IResolvable_da3f097b]]:
        '''The Internet Control Message Protocol (ICMP) code and type.

        Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
        '''
        return typing.cast(typing.Optional[typing.Union["CfnNetworkAclEntry.IcmpProperty", _IResolvable_da3f097b]], jsii.get(self, "icmp"))

    @icmp.setter
    def icmp(
        self,
        value: typing.Optional[typing.Union["CfnNetworkAclEntry.IcmpProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "icmp", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 network range to allow or deny, in CIDR notation.

        Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv6CidrBlock"))

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6CidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="portRange")
    def port_range(
        self,
    ) -> typing.Optional[typing.Union["CfnNetworkAclEntry.PortRangeProperty", _IResolvable_da3f097b]]:
        '''The range of port numbers for the UDP/TCP protocol.

        Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
        '''
        return typing.cast(typing.Optional[typing.Union["CfnNetworkAclEntry.PortRangeProperty", _IResolvable_da3f097b]], jsii.get(self, "portRange"))

    @port_range.setter
    def port_range(
        self,
        value: typing.Optional[typing.Union["CfnNetworkAclEntry.PortRangeProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "portRange", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkAclEntry.IcmpProperty",
        jsii_struct_bases=[],
        name_mapping={"code": "code", "type": "type"},
    )
    class IcmpProperty:
        def __init__(
            self,
            *,
            code: typing.Optional[jsii.Number] = None,
            type: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes the ICMP type and code.

            :param code: The Internet Control Message Protocol (ICMP) code. You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.
            :param type: The Internet Control Message Protocol (ICMP) type. You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the ``CreateNetworkAclEntry`` protocol parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                icmp_property = ec2.CfnNetworkAclEntry.IcmpProperty(
                    code=123,
                    type=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if code is not None:
                self._values["code"] = code
            if type is not None:
                self._values["type"] = type

        @builtins.property
        def code(self) -> typing.Optional[jsii.Number]:
            '''The Internet Control Message Protocol (ICMP) code.

            You can use -1 to specify all ICMP codes for the given ICMP type. Requirement is conditional: Required if you specify 1 (ICMP) for the protocol parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-code
            '''
            result = self._values.get("code")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def type(self) -> typing.Optional[jsii.Number]:
            '''The Internet Control Message Protocol (ICMP) type.

            You can use -1 to specify all ICMP types. Conditional requirement: Required if you specify 1 (ICMP) for the ``CreateNetworkAclEntry`` protocol parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-icmp.html#cfn-ec2-networkaclentry-icmp-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IcmpProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkAclEntry.PortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_": "from", "to": "to"},
    )
    class PortRangeProperty:
        def __init__(
            self,
            *,
            from_: typing.Optional[jsii.Number] = None,
            to: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a range of ports.

            :param from_: The first port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.
            :param to: The last port in the range. Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                port_range_property = ec2.CfnNetworkAclEntry.PortRangeProperty(
                    from=123,
                    to=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if from_ is not None:
                self._values["from_"] = from_
            if to is not None:
                self._values["to"] = to

        @builtins.property
        def from_(self) -> typing.Optional[jsii.Number]:
            '''The first port in the range.

            Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-from
            '''
            result = self._values.get("from_")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to(self) -> typing.Optional[jsii.Number]:
            '''The last port in the range.

            Required if you specify 6 (TCP) or 17 (UDP) for the protocol parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkaclentry-portrange.html#cfn-ec2-networkaclentry-portrange-to
            '''
            result = self._values.get("to")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkAclEntryProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_acl_id": "networkAclId",
        "protocol": "protocol",
        "rule_action": "ruleAction",
        "rule_number": "ruleNumber",
        "cidr_block": "cidrBlock",
        "egress": "egress",
        "icmp": "icmp",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "port_range": "portRange",
    },
)
class CfnNetworkAclEntryProps:
    def __init__(
        self,
        *,
        network_acl_id: builtins.str,
        protocol: jsii.Number,
        rule_action: builtins.str,
        rule_number: jsii.Number,
        cidr_block: typing.Optional[builtins.str] = None,
        egress: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        icmp: typing.Optional[typing.Union[CfnNetworkAclEntry.IcmpProperty, _IResolvable_da3f097b]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        port_range: typing.Optional[typing.Union[CfnNetworkAclEntry.PortRangeProperty, _IResolvable_da3f097b]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkAclEntry``.

        :param network_acl_id: The ID of the ACL for the entry.
        :param protocol: The IP protocol that the rule applies to. You must specify -1 or a protocol number. You can specify -1 for all protocols. .. epigraph:: If you specify -1, all ports are opened and the ``PortRange`` property is ignored.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param cidr_block: The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.
        :param egress: Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ). By default, AWS CloudFormation specifies ``false`` .
        :param icmp: The Internet Control Message Protocol (ICMP) code and type. Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.
        :param ipv6_cidr_block: The IPv6 network range to allow or deny, in CIDR notation. Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.
        :param port_range: The range of port numbers for the UDP/TCP protocol. Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_acl_entry_props = ec2.CfnNetworkAclEntryProps(
                network_acl_id="networkAclId",
                protocol=123,
                rule_action="ruleAction",
                rule_number=123,
            
                # the properties below are optional
                cidr_block="cidrBlock",
                egress=False,
                icmp=ec2.CfnNetworkAclEntry.IcmpProperty(
                    code=123,
                    type=123
                ),
                ipv6_cidr_block="ipv6CidrBlock",
                port_range=ec2.CfnNetworkAclEntry.PortRangeProperty(
                    from=123,
                    to=123
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "network_acl_id": network_acl_id,
            "protocol": protocol,
            "rule_action": rule_action,
            "rule_number": rule_number,
        }
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if egress is not None:
            self._values["egress"] = egress
        if icmp is not None:
            self._values["icmp"] = icmp
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if port_range is not None:
            self._values["port_range"] = port_range

    @builtins.property
    def network_acl_id(self) -> builtins.str:
        '''The ID of the ACL for the entry.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-networkaclid
        '''
        result = self._values.get("network_acl_id")
        assert result is not None, "Required property 'network_acl_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def protocol(self) -> jsii.Number:
        '''The IP protocol that the rule applies to.

        You must specify -1 or a protocol number. You can specify -1 for all protocols.
        .. epigraph::

           If you specify -1, all ports are opened and the ``PortRange`` property is ignored.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-protocol
        '''
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def rule_action(self) -> builtins.str:
        '''Whether to allow or deny traffic that matches the rule;

        valid values are "allow" or "deny".

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ruleaction
        '''
        result = self._values.get("rule_action")
        assert result is not None, "Required property 'rule_action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule_number(self) -> jsii.Number:
        '''Rule number to assign to the entry, such as 100.

        ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-rulenumber
        '''
        result = self._values.get("rule_number")
        assert result is not None, "Required property 'rule_number' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-cidrblock
        '''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def egress(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Whether this rule applies to egress traffic from the subnet ( ``true`` ) or ingress traffic to the subnet ( ``false`` ).

        By default, AWS CloudFormation specifies ``false`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-egress
        '''
        result = self._values.get("egress")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def icmp(
        self,
    ) -> typing.Optional[typing.Union[CfnNetworkAclEntry.IcmpProperty, _IResolvable_da3f097b]]:
        '''The Internet Control Message Protocol (ICMP) code and type.

        Requirement is conditional: Required if specifying 1 (ICMP) for the protocol parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-icmp
        '''
        result = self._values.get("icmp")
        return typing.cast(typing.Optional[typing.Union[CfnNetworkAclEntry.IcmpProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 network range to allow or deny, in CIDR notation.

        Requirement is conditional: You must specify the ``CidrBlock`` or ``Ipv6CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def port_range(
        self,
    ) -> typing.Optional[typing.Union[CfnNetworkAclEntry.PortRangeProperty, _IResolvable_da3f097b]]:
        '''The range of port numbers for the UDP/TCP protocol.

        Conditional required if specifying 6 (TCP) or 17 (UDP) for the protocol parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkaclentry.html#cfn-ec2-networkaclentry-portrange
        '''
        result = self._values.get("port_range")
        return typing.cast(typing.Optional[typing.Union[CfnNetworkAclEntry.PortRangeProperty, _IResolvable_da3f097b]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkAclEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkAclProps",
    jsii_struct_bases=[],
    name_mapping={"vpc_id": "vpcId", "tags": "tags"},
)
class CfnNetworkAclProps:
    def __init__(
        self,
        *,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkAcl``.

        :param vpc_id: The ID of the VPC for the network ACL.
        :param tags: The tags for the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_acl_props = ec2.CfnNetworkAclProps(
                vpc_id="vpcId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC for the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkacl.html#cfn-ec2-networkacl-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkAclProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInsightsAccessScope(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScope",
):
    '''A CloudFormation ``AWS::EC2::NetworkInsightsAccessScope``.

    Describes a Network Access Scope. A Network Access Scope defines outbound (egress) and inbound (ingress) traffic patterns, including sources, destinations, paths, and traffic types.

    Network Access Analyzer identifies unintended network access to your resources on AWS . When you start an analysis on a Network Access Scope, Network Access Analyzer produces findings. For more information, see the `Network Access Analyzer User Guide <https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/>`_ .

    :cloudformationResource: AWS::EC2::NetworkInsightsAccessScope
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_insights_access_scope = ec2.CfnNetworkInsightsAccessScope(self, "MyCfnNetworkInsightsAccessScope",
            exclude_paths=[ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(
                destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                    packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                    packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )]
            )],
            match_paths=[ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(
                destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                    packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                    packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                ),
                through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )]
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        exclude_paths: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]] = None,
        match_paths: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInsightsAccessScope``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param exclude_paths: The paths to exclude.
        :param match_paths: The paths to match.
        :param tags: The tags.
        '''
        props = CfnNetworkInsightsAccessScopeProps(
            exclude_paths=exclude_paths, match_paths=match_paths, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCreatedDate")
    def attr_created_date(self) -> builtins.str:
        '''The creation date.

        :cloudformationAttribute: CreatedDate
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCreatedDate"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsAccessScopeArn")
    def attr_network_insights_access_scope_arn(self) -> builtins.str:
        '''The ARN of the Network Access Scope.

        :cloudformationAttribute: NetworkInsightsAccessScopeArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsAccessScopeArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsAccessScopeId")
    def attr_network_insights_access_scope_id(self) -> builtins.str:
        '''The ID of the Network Access Scope.

        :cloudformationAttribute: NetworkInsightsAccessScopeId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsAccessScopeId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrUpdatedDate")
    def attr_updated_date(self) -> builtins.str:
        '''The last updated date.

        :cloudformationAttribute: UpdatedDate
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrUpdatedDate"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="excludePaths")
    def exclude_paths(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]]:
        '''The paths to exclude.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]], jsii.get(self, "excludePaths"))

    @exclude_paths.setter
    def exclude_paths(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "excludePaths", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="matchPaths")
    def match_paths(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]]:
        '''The paths to match.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]], jsii.get(self, "matchPaths"))

    @match_paths.setter
    def match_paths(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "matchPaths", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination": "destination",
            "source": "source",
            "through_resources": "throughResources",
        },
    )
    class AccessScopePathRequestProperty:
        def __init__(
            self,
            *,
            destination: typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PathStatementRequestProperty", _IResolvable_da3f097b]] = None,
            source: typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PathStatementRequestProperty", _IResolvable_da3f097b]] = None,
            through_resources: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty", _IResolvable_da3f097b]]]] = None,
        ) -> None:
            '''Describes a path.

            :param destination: The destination.
            :param source: The source.
            :param through_resources: The through resources.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                access_scope_path_request_property = ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(
                    destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if destination is not None:
                self._values["destination"] = destination
            if source is not None:
                self._values["source"] = source
            if through_resources is not None:
                self._values["through_resources"] = through_resources

        @builtins.property
        def destination(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PathStatementRequestProperty", _IResolvable_da3f097b]]:
            '''The destination.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-destination
            '''
            result = self._values.get("destination")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PathStatementRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def source(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PathStatementRequestProperty", _IResolvable_da3f097b]]:
            '''The source.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-source
            '''
            result = self._values.get("source")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PathStatementRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def through_resources(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty", _IResolvable_da3f097b]]]]:
            '''The through resources.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-accessscopepathrequest.html#cfn-ec2-networkinsightsaccessscope-accessscopepathrequest-throughresources
            '''
            result = self._values.get("through_resources")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty", _IResolvable_da3f097b]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AccessScopePathRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_addresses": "destinationAddresses",
            "destination_ports": "destinationPorts",
            "destination_prefix_lists": "destinationPrefixLists",
            "protocols": "protocols",
            "source_addresses": "sourceAddresses",
            "source_ports": "sourcePorts",
            "source_prefix_lists": "sourcePrefixLists",
        },
    )
    class PacketHeaderStatementRequestProperty:
        def __init__(
            self,
            *,
            destination_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            destination_ports: typing.Optional[typing.Sequence[builtins.str]] = None,
            destination_prefix_lists: typing.Optional[typing.Sequence[builtins.str]] = None,
            protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_ports: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_prefix_lists: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes a packet header statement.

            :param destination_addresses: The destination addresses.
            :param destination_ports: The destination ports.
            :param destination_prefix_lists: The destination prefix lists.
            :param protocols: The protocols.
            :param source_addresses: The source addresses.
            :param source_ports: The source ports.
            :param source_prefix_lists: The source prefix lists.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                packet_header_statement_request_property = ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                    destination_addresses=["destinationAddresses"],
                    destination_ports=["destinationPorts"],
                    destination_prefix_lists=["destinationPrefixLists"],
                    protocols=["protocols"],
                    source_addresses=["sourceAddresses"],
                    source_ports=["sourcePorts"],
                    source_prefix_lists=["sourcePrefixLists"]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if destination_addresses is not None:
                self._values["destination_addresses"] = destination_addresses
            if destination_ports is not None:
                self._values["destination_ports"] = destination_ports
            if destination_prefix_lists is not None:
                self._values["destination_prefix_lists"] = destination_prefix_lists
            if protocols is not None:
                self._values["protocols"] = protocols
            if source_addresses is not None:
                self._values["source_addresses"] = source_addresses
            if source_ports is not None:
                self._values["source_ports"] = source_ports
            if source_prefix_lists is not None:
                self._values["source_prefix_lists"] = source_prefix_lists

        @builtins.property
        def destination_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationaddresses
            '''
            result = self._values.get("destination_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def destination_ports(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination ports.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationports
            '''
            result = self._values.get("destination_ports")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def destination_prefix_lists(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination prefix lists.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-destinationprefixlists
            '''
            result = self._values.get("destination_prefix_lists")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def protocols(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The protocols.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-protocols
            '''
            result = self._values.get("protocols")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceaddresses
            '''
            result = self._values.get("source_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_ports(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source ports.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceports
            '''
            result = self._values.get("source_ports")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_prefix_lists(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source prefix lists.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-packetheaderstatementrequest.html#cfn-ec2-networkinsightsaccessscope-packetheaderstatementrequest-sourceprefixlists
            '''
            result = self._values.get("source_prefix_lists")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PacketHeaderStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "packet_header_statement": "packetHeaderStatement",
            "resource_statement": "resourceStatement",
        },
    )
    class PathStatementRequestProperty:
        def __init__(
            self,
            *,
            packet_header_statement: typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty", _IResolvable_da3f097b]] = None,
            resource_statement: typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes a path statement.

            :param packet_header_statement: The packet header statement.
            :param resource_statement: The resource statement.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                path_statement_request_property = ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                    packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_ports=["destinationPorts"],
                        destination_prefix_lists=["destinationPrefixLists"],
                        protocols=["protocols"],
                        source_addresses=["sourceAddresses"],
                        source_ports=["sourcePorts"],
                        source_prefix_lists=["sourcePrefixLists"]
                    ),
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if packet_header_statement is not None:
                self._values["packet_header_statement"] = packet_header_statement
            if resource_statement is not None:
                self._values["resource_statement"] = resource_statement

        @builtins.property
        def packet_header_statement(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty", _IResolvable_da3f097b]]:
            '''The packet header statement.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-packetheaderstatement
            '''
            result = self._values.get("packet_header_statement")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def resource_statement(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty", _IResolvable_da3f097b]]:
            '''The resource statement.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-pathstatementrequest.html#cfn-ec2-networkinsightsaccessscope-pathstatementrequest-resourcestatement
            '''
            result = self._values.get("resource_statement")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PathStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"resources": "resources", "resource_types": "resourceTypes"},
    )
    class ResourceStatementRequestProperty:
        def __init__(
            self,
            *,
            resources: typing.Optional[typing.Sequence[builtins.str]] = None,
            resource_types: typing.Optional[typing.Sequence[builtins.str]] = None,
        ) -> None:
            '''Describes a resource statement.

            :param resources: The resources.
            :param resource_types: The resource types.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                resource_statement_request_property = ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                    resources=["resources"],
                    resource_types=["resourceTypes"]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resources is not None:
                self._values["resources"] = resources
            if resource_types is not None:
                self._values["resource_types"] = resource_types

        @builtins.property
        def resources(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The resources.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resources
            '''
            result = self._values.get("resources")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def resource_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The resource types.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-resourcestatementrequest.html#cfn-ec2-networkinsightsaccessscope-resourcestatementrequest-resourcetypes
            '''
            result = self._values.get("resource_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ResourceStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_statement": "resourceStatement"},
    )
    class ThroughResourcesStatementRequestProperty:
        def __init__(
            self,
            *,
            resource_statement: typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes a through resource statement.

            :param resource_statement: The resource statement.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                through_resources_statement_request_property = ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(
                    resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                        resources=["resources"],
                        resource_types=["resourceTypes"]
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_statement is not None:
                self._values["resource_statement"] = resource_statement

        @builtins.property
        def resource_statement(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty", _IResolvable_da3f097b]]:
            '''The resource statement.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsaccessscope-throughresourcesstatementrequest.html#cfn-ec2-networkinsightsaccessscope-throughresourcesstatementrequest-resourcestatement
            '''
            result = self._values.get("resource_statement")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ThroughResourcesStatementRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInsightsAccessScopeAnalysis(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScopeAnalysis",
):
    '''A CloudFormation ``AWS::EC2::NetworkInsightsAccessScopeAnalysis``.

    Describes a Network Access Scope analysis.

    :cloudformationResource: AWS::EC2::NetworkInsightsAccessScopeAnalysis
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_insights_access_scope_analysis = ec2.CfnNetworkInsightsAccessScopeAnalysis(self, "MyCfnNetworkInsightsAccessScopeAnalysis",
            network_insights_access_scope_id="networkInsightsAccessScopeId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_insights_access_scope_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInsightsAccessScopeAnalysis``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param network_insights_access_scope_id: The ID of the Network Access Scope.
        :param tags: The tags.
        '''
        props = CfnNetworkInsightsAccessScopeAnalysisProps(
            network_insights_access_scope_id=network_insights_access_scope_id,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAnalyzedEniCount")
    def attr_analyzed_eni_count(self) -> jsii.Number:
        '''The number of network interfaces analyzed.

        :cloudformationAttribute: AnalyzedEniCount
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrAnalyzedEniCount"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrEndDate")
    def attr_end_date(self) -> builtins.str:
        '''The end date of the analysis.

        :cloudformationAttribute: EndDate
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrEndDate"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrFindingsFound")
    def attr_findings_found(self) -> builtins.str:
        '''Indicates whether there are findings (true | false | unknown).

        :cloudformationAttribute: FindingsFound
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrFindingsFound"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsAccessScopeAnalysisArn")
    def attr_network_insights_access_scope_analysis_arn(self) -> builtins.str:
        '''The ARN of the Network Access Scope analysis.

        :cloudformationAttribute: NetworkInsightsAccessScopeAnalysisArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsAccessScopeAnalysisArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsAccessScopeAnalysisId")
    def attr_network_insights_access_scope_analysis_id(self) -> builtins.str:
        '''The ID of the Network Access Scope analysis.

        :cloudformationAttribute: NetworkInsightsAccessScopeAnalysisId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsAccessScopeAnalysisId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStartDate")
    def attr_start_date(self) -> builtins.str:
        '''The start date of the analysis.

        :cloudformationAttribute: StartDate
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStartDate"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> builtins.str:
        '''The status of the analysis (running | succeeded | failed).

        :cloudformationAttribute: Status
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStatus"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStatusMessage")
    def attr_status_message(self) -> builtins.str:
        '''The status message.

        :cloudformationAttribute: StatusMessage
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStatusMessage"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInsightsAccessScopeId")
    def network_insights_access_scope_id(self) -> builtins.str:
        '''The ID of the Network Access Scope.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInsightsAccessScopeId"))

    @network_insights_access_scope_id.setter
    def network_insights_access_scope_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInsightsAccessScopeId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScopeAnalysisProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_insights_access_scope_id": "networkInsightsAccessScopeId",
        "tags": "tags",
    },
)
class CfnNetworkInsightsAccessScopeAnalysisProps:
    def __init__(
        self,
        *,
        network_insights_access_scope_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInsightsAccessScopeAnalysis``.

        :param network_insights_access_scope_id: The ID of the Network Access Scope.
        :param tags: The tags.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_insights_access_scope_analysis_props = ec2.CfnNetworkInsightsAccessScopeAnalysisProps(
                network_insights_access_scope_id="networkInsightsAccessScopeId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "network_insights_access_scope_id": network_insights_access_scope_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def network_insights_access_scope_id(self) -> builtins.str:
        '''The ID of the Network Access Scope.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-networkinsightsaccessscopeid
        '''
        result = self._values.get("network_insights_access_scope_id")
        assert result is not None, "Required property 'network_insights_access_scope_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscopeanalysis.html#cfn-ec2-networkinsightsaccessscopeanalysis-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsAccessScopeAnalysisProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAccessScopeProps",
    jsii_struct_bases=[],
    name_mapping={
        "exclude_paths": "excludePaths",
        "match_paths": "matchPaths",
        "tags": "tags",
    },
)
class CfnNetworkInsightsAccessScopeProps:
    def __init__(
        self,
        *,
        exclude_paths: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty, _IResolvable_da3f097b]]]] = None,
        match_paths: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty, _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInsightsAccessScope``.

        :param exclude_paths: The paths to exclude.
        :param match_paths: The paths to match.
        :param tags: The tags.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_insights_access_scope_props = ec2.CfnNetworkInsightsAccessScopeProps(
                exclude_paths=[ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(
                    destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    )]
                )],
                match_paths=[ec2.CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty(
                    destination=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    source=ec2.CfnNetworkInsightsAccessScope.PathStatementRequestProperty(
                        packet_header_statement=ec2.CfnNetworkInsightsAccessScope.PacketHeaderStatementRequestProperty(
                            destination_addresses=["destinationAddresses"],
                            destination_ports=["destinationPorts"],
                            destination_prefix_lists=["destinationPrefixLists"],
                            protocols=["protocols"],
                            source_addresses=["sourceAddresses"],
                            source_ports=["sourcePorts"],
                            source_prefix_lists=["sourcePrefixLists"]
                        ),
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    ),
                    through_resources=[ec2.CfnNetworkInsightsAccessScope.ThroughResourcesStatementRequestProperty(
                        resource_statement=ec2.CfnNetworkInsightsAccessScope.ResourceStatementRequestProperty(
                            resources=["resources"],
                            resource_types=["resourceTypes"]
                        )
                    )]
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if exclude_paths is not None:
            self._values["exclude_paths"] = exclude_paths
        if match_paths is not None:
            self._values["match_paths"] = match_paths
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def exclude_paths(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty, _IResolvable_da3f097b]]]]:
        '''The paths to exclude.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-excludepaths
        '''
        result = self._values.get("exclude_paths")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def match_paths(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty, _IResolvable_da3f097b]]]]:
        '''The paths to match.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-matchpaths
        '''
        result = self._values.get("match_paths")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInsightsAccessScope.AccessScopePathRequestProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsaccessscope.html#cfn-ec2-networkinsightsaccessscope-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsAccessScopeProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInsightsAnalysis(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis",
):
    '''A CloudFormation ``AWS::EC2::NetworkInsightsAnalysis``.

    Specifies a network insights analysis.

    :cloudformationResource: AWS::EC2::NetworkInsightsAnalysis
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_insights_analysis = ec2.CfnNetworkInsightsAnalysis(self, "MyCfnNetworkInsightsAnalysis",
            network_insights_path_id="networkInsightsPathId",
        
            # the properties below are optional
            filter_in_arns=["filterInArns"],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_insights_path_id: builtins.str,
        filter_in_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInsightsAnalysis``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param network_insights_path_id: The ID of the path.
        :param filter_in_arns: The Amazon Resource Names (ARN) of the resources that the path must traverse.
        :param tags: The tags to apply.
        '''
        props = CfnNetworkInsightsAnalysisProps(
            network_insights_path_id=network_insights_path_id,
            filter_in_arns=filter_in_arns,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAlternatePathHints")
    def attr_alternate_path_hints(self) -> _IResolvable_da3f097b:
        '''Potential intermediate components.

        :cloudformationAttribute: AlternatePathHints
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrAlternatePathHints"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrExplanations")
    def attr_explanations(self) -> _IResolvable_da3f097b:
        '''The explanations.

        For more information, see `Reachability Analyzer explanation codes <https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html>`_ .

        :cloudformationAttribute: Explanations
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrExplanations"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrForwardPathComponents")
    def attr_forward_path_components(self) -> _IResolvable_da3f097b:
        '''The components in the path from source to destination.

        :cloudformationAttribute: ForwardPathComponents
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrForwardPathComponents"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsAnalysisArn")
    def attr_network_insights_analysis_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the network insights analysis.

        :cloudformationAttribute: NetworkInsightsAnalysisArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsAnalysisArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsAnalysisId")
    def attr_network_insights_analysis_id(self) -> builtins.str:
        '''The ID of the network insights analysis.

        :cloudformationAttribute: NetworkInsightsAnalysisId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsAnalysisId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkPathFound")
    def attr_network_path_found(self) -> _IResolvable_da3f097b:
        '''Indicates whether the destination is reachable from the source.

        :cloudformationAttribute: NetworkPathFound
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrNetworkPathFound"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrReturnPathComponents")
    def attr_return_path_components(self) -> _IResolvable_da3f097b:
        '''The components in the path from destination to source.

        :cloudformationAttribute: ReturnPathComponents
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrReturnPathComponents"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStartDate")
    def attr_start_date(self) -> builtins.str:
        '''The time the analysis started.

        :cloudformationAttribute: StartDate
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStartDate"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStatus")
    def attr_status(self) -> builtins.str:
        '''The status of the network insights analysis.

        :cloudformationAttribute: Status
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStatus"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrStatusMessage")
    def attr_status_message(self) -> builtins.str:
        '''The status message, if the status is ``failed`` .

        :cloudformationAttribute: StatusMessage
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrStatusMessage"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to apply.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInsightsPathId")
    def network_insights_path_id(self) -> builtins.str:
        '''The ID of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInsightsPathId"))

    @network_insights_path_id.setter
    def network_insights_path_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInsightsPathId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="filterInArns")
    def filter_in_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of the resources that the path must traverse.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "filterInArns"))

    @filter_in_arns.setter
    def filter_in_arns(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "filterInArns", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AlternatePathHintProperty",
        jsii_struct_bases=[],
        name_mapping={"component_arn": "componentArn", "component_id": "componentId"},
    )
    class AlternatePathHintProperty:
        def __init__(
            self,
            *,
            component_arn: typing.Optional[builtins.str] = None,
            component_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes an potential intermediate component of a feasible path.

            :param component_arn: The Amazon Resource Name (ARN) of the component.
            :param component_id: The ID of the component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                alternate_path_hint_property = ec2.CfnNetworkInsightsAnalysis.AlternatePathHintProperty(
                    component_arn="componentArn",
                    component_id="componentId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if component_arn is not None:
                self._values["component_arn"] = component_arn
            if component_id is not None:
                self._values["component_id"] = component_id

        @builtins.property
        def component_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentarn
            '''
            result = self._values.get("component_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def component_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-alternatepathhint.html#cfn-ec2-networkinsightsanalysis-alternatepathhint-componentid
            '''
            result = self._values.get("component_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AlternatePathHintProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr": "cidr",
            "egress": "egress",
            "port_range": "portRange",
            "protocol": "protocol",
            "rule_action": "ruleAction",
            "rule_number": "ruleNumber",
        },
    )
    class AnalysisAclRuleProperty:
        def __init__(
            self,
            *,
            cidr: typing.Optional[builtins.str] = None,
            egress: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            port_range: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]] = None,
            protocol: typing.Optional[builtins.str] = None,
            rule_action: typing.Optional[builtins.str] = None,
            rule_number: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a network access control (ACL) rule.

            :param cidr: The IPv4 address range, in CIDR notation.
            :param egress: Indicates whether the rule is an outbound rule.
            :param port_range: The range of ports.
            :param protocol: The protocol.
            :param rule_action: Indicates whether to allow or deny traffic that matches the rule.
            :param rule_number: The rule number.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_acl_rule_property = ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(
                    cidr="cidr",
                    egress=False,
                    port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                        from=123,
                        to=123
                    ),
                    protocol="protocol",
                    rule_action="ruleAction",
                    rule_number=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr
            if egress is not None:
                self._values["egress"] = egress
            if port_range is not None:
                self._values["port_range"] = port_range
            if protocol is not None:
                self._values["protocol"] = protocol
            if rule_action is not None:
                self._values["rule_action"] = rule_action
            if rule_number is not None:
                self._values["rule_number"] = rule_number

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR notation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def egress(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the rule is an outbound rule.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-egress
            '''
            result = self._values.get("egress")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def port_range(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]:
            '''The range of ports.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-portrange
            '''
            result = self._values.get("port_range")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rule_action(self) -> typing.Optional[builtins.str]:
            '''Indicates whether to allow or deny traffic that matches the rule.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-ruleaction
            '''
            result = self._values.get("rule_action")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def rule_number(self) -> typing.Optional[jsii.Number]:
            '''The rule number.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisaclrule.html#cfn-ec2-networkinsightsanalysis-analysisaclrule-rulenumber
            '''
            result = self._values.get("rule_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisAclRuleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn", "id": "id"},
    )
    class AnalysisComponentProperty:
        def __init__(
            self,
            *,
            arn: typing.Optional[builtins.str] = None,
            id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a path component.

            :param arn: The Amazon Resource Name (ARN) of the component.
            :param id: The ID of the component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_component_property = ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                    arn="arn",
                    id="id"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn
            if id is not None:
                self._values["id"] = id

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def id(self) -> typing.Optional[builtins.str]:
            '''The ID of the component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysiscomponent.html#cfn-ec2-networkinsightsanalysis-analysiscomponent-id
            '''
            result = self._values.get("id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisComponentProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty",
        jsii_struct_bases=[],
        name_mapping={
            "instance_port": "instancePort",
            "load_balancer_port": "loadBalancerPort",
        },
    )
    class AnalysisLoadBalancerListenerProperty:
        def __init__(
            self,
            *,
            instance_port: typing.Optional[jsii.Number] = None,
            load_balancer_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a load balancer listener.

            :param instance_port: [Classic Load Balancers] The back-end port for the listener.
            :param load_balancer_port: The port on which the load balancer is listening.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_load_balancer_listener_property = ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty(
                    instance_port=123,
                    load_balancer_port=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if instance_port is not None:
                self._values["instance_port"] = instance_port
            if load_balancer_port is not None:
                self._values["load_balancer_port"] = load_balancer_port

        @builtins.property
        def instance_port(self) -> typing.Optional[jsii.Number]:
            '''[Classic Load Balancers] The back-end port for the listener.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-instanceport
            '''
            result = self._values.get("instance_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def load_balancer_port(self) -> typing.Optional[jsii.Number]:
            '''The port on which the load balancer is listening.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancerlistener.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancerlistener-loadbalancerport
            '''
            result = self._values.get("load_balancer_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisLoadBalancerListenerProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty",
        jsii_struct_bases=[],
        name_mapping={
            "address": "address",
            "availability_zone": "availabilityZone",
            "instance": "instance",
            "port": "port",
        },
    )
    class AnalysisLoadBalancerTargetProperty:
        def __init__(
            self,
            *,
            address: typing.Optional[builtins.str] = None,
            availability_zone: typing.Optional[builtins.str] = None,
            instance: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a load balancer target.

            :param address: The IP address.
            :param availability_zone: The Availability Zone.
            :param instance: Information about the instance.
            :param port: The port on which the target is listening.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_load_balancer_target_property = ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty(
                    address="address",
                    availability_zone="availabilityZone",
                    instance=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    port=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if address is not None:
                self._values["address"] = address
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if instance is not None:
                self._values["instance"] = instance
            if port is not None:
                self._values["port"] = port

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''The IP address.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''Information about the instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-instance
            '''
            result = self._values.get("instance")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The port on which the target is listening.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisloadbalancertarget.html#cfn-ec2-networkinsightsanalysis-analysisloadbalancertarget-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisLoadBalancerTargetProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_addresses": "destinationAddresses",
            "destination_port_ranges": "destinationPortRanges",
            "protocol": "protocol",
            "source_addresses": "sourceAddresses",
            "source_port_ranges": "sourcePortRanges",
        },
    )
    class AnalysisPacketHeaderProperty:
        def __init__(
            self,
            *,
            destination_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            destination_port_ranges: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]] = None,
            protocol: typing.Optional[builtins.str] = None,
            source_addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            source_port_ranges: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]] = None,
        ) -> None:
            '''Describes a header.

            Reflects any changes made by a component as traffic passes through. The fields of an inbound header are null except for the first component of a path.

            :param destination_addresses: The destination addresses.
            :param destination_port_ranges: The destination port ranges.
            :param protocol: The protocol.
            :param source_addresses: The source addresses.
            :param source_port_ranges: The source port ranges.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_packet_header_property = ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty(
                    destination_addresses=["destinationAddresses"],
                    destination_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                        from=123,
                        to=123
                    )],
                    protocol="protocol",
                    source_addresses=["sourceAddresses"],
                    source_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                        from=123,
                        to=123
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if destination_addresses is not None:
                self._values["destination_addresses"] = destination_addresses
            if destination_port_ranges is not None:
                self._values["destination_port_ranges"] = destination_port_ranges
            if protocol is not None:
                self._values["protocol"] = protocol
            if source_addresses is not None:
                self._values["source_addresses"] = source_addresses
            if source_port_ranges is not None:
                self._values["source_port_ranges"] = source_port_ranges

        @builtins.property
        def destination_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The destination addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationaddresses
            '''
            result = self._values.get("destination_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def destination_port_ranges(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]]:
            '''The destination port ranges.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-destinationportranges
            '''
            result = self._values.get("destination_port_ranges")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The source addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceaddresses
            '''
            result = self._values.get("source_addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def source_port_ranges(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]]:
            '''The source port ranges.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysispacketheader.html#cfn-ec2-networkinsightsanalysis-analysispacketheader-sourceportranges
            '''
            result = self._values.get("source_port_ranges")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisPacketHeaderProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty",
        jsii_struct_bases=[],
        name_mapping={
            "destination_cidr": "destinationCidr",
            "destination_prefix_list_id": "destinationPrefixListId",
            "egress_only_internet_gateway_id": "egressOnlyInternetGatewayId",
            "gateway_id": "gatewayId",
            "instance_id": "instanceId",
            "nat_gateway_id": "natGatewayId",
            "network_interface_id": "networkInterfaceId",
            "origin": "origin",
            "transit_gateway_id": "transitGatewayId",
            "vpc_peering_connection_id": "vpcPeeringConnectionId",
        },
    )
    class AnalysisRouteTableRouteProperty:
        def __init__(
            self,
            *,
            destination_cidr: typing.Optional[builtins.str] = None,
            destination_prefix_list_id: typing.Optional[builtins.str] = None,
            egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
            gateway_id: typing.Optional[builtins.str] = None,
            instance_id: typing.Optional[builtins.str] = None,
            nat_gateway_id: typing.Optional[builtins.str] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            origin: typing.Optional[builtins.str] = None,
            transit_gateway_id: typing.Optional[builtins.str] = None,
            vpc_peering_connection_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a route table route.

            :param destination_cidr: The destination IPv4 address, in CIDR notation.
            :param destination_prefix_list_id: The prefix of the AWS service .
            :param egress_only_internet_gateway_id: The ID of an egress-only internet gateway.
            :param gateway_id: The ID of the gateway, such as an internet gateway or virtual private gateway.
            :param instance_id: The ID of the instance, such as a NAT instance.
            :param nat_gateway_id: The ID of a NAT gateway.
            :param network_interface_id: The ID of a network interface.
            :param origin: Describes how the route was created. The following are possible values:. - ``CreateRouteTable`` - The route was automatically created when the route table was created. - ``CreateRoute`` - The route was manually added to the route table. - ``EnableVgwRoutePropagation`` - The route was propagated by route propagation.
            :param transit_gateway_id: The ID of a transit gateway.
            :param vpc_peering_connection_id: The ID of a VPC peering connection.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_route_table_route_property = ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(
                    destination_cidr="destinationCidr",
                    destination_prefix_list_id="destinationPrefixListId",
                    egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                    gateway_id="gatewayId",
                    instance_id="instanceId",
                    nat_gateway_id="natGatewayId",
                    network_interface_id="networkInterfaceId",
                    origin="origin",
                    transit_gateway_id="transitGatewayId",
                    vpc_peering_connection_id="vpcPeeringConnectionId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if destination_cidr is not None:
                self._values["destination_cidr"] = destination_cidr
            if destination_prefix_list_id is not None:
                self._values["destination_prefix_list_id"] = destination_prefix_list_id
            if egress_only_internet_gateway_id is not None:
                self._values["egress_only_internet_gateway_id"] = egress_only_internet_gateway_id
            if gateway_id is not None:
                self._values["gateway_id"] = gateway_id
            if instance_id is not None:
                self._values["instance_id"] = instance_id
            if nat_gateway_id is not None:
                self._values["nat_gateway_id"] = nat_gateway_id
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if origin is not None:
                self._values["origin"] = origin
            if transit_gateway_id is not None:
                self._values["transit_gateway_id"] = transit_gateway_id
            if vpc_peering_connection_id is not None:
                self._values["vpc_peering_connection_id"] = vpc_peering_connection_id

        @builtins.property
        def destination_cidr(self) -> typing.Optional[builtins.str]:
            '''The destination IPv4 address, in CIDR notation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationcidr
            '''
            result = self._values.get("destination_cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The prefix of the AWS service .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-destinationprefixlistid
            '''
            result = self._values.get("destination_prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def egress_only_internet_gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of an egress-only internet gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-egressonlyinternetgatewayid
            '''
            result = self._values.get("egress_only_internet_gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the gateway, such as an internet gateway or virtual private gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-gatewayid
            '''
            result = self._values.get("gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the instance, such as a NAT instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-instanceid
            '''
            result = self._values.get("instance_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def nat_gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a NAT gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-natgatewayid
            '''
            result = self._values.get("nat_gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def origin(self) -> typing.Optional[builtins.str]:
            '''Describes how the route was created. The following are possible values:.

            - ``CreateRouteTable`` - The route was automatically created when the route table was created.
            - ``CreateRoute`` - The route was manually added to the route table.
            - ``EnableVgwRoutePropagation`` - The route was propagated by route propagation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-origin
            '''
            result = self._values.get("origin")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def transit_gateway_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a transit gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-transitgatewayid
            '''
            result = self._values.get("transit_gateway_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def vpc_peering_connection_id(self) -> typing.Optional[builtins.str]:
            '''The ID of a VPC peering connection.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysisroutetableroute.html#cfn-ec2-networkinsightsanalysis-analysisroutetableroute-vpcpeeringconnectionid
            '''
            result = self._values.get("vpc_peering_connection_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisRouteTableRouteProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty",
        jsii_struct_bases=[],
        name_mapping={
            "cidr": "cidr",
            "direction": "direction",
            "port_range": "portRange",
            "prefix_list_id": "prefixListId",
            "protocol": "protocol",
            "security_group_id": "securityGroupId",
        },
    )
    class AnalysisSecurityGroupRuleProperty:
        def __init__(
            self,
            *,
            cidr: typing.Optional[builtins.str] = None,
            direction: typing.Optional[builtins.str] = None,
            port_range: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]] = None,
            prefix_list_id: typing.Optional[builtins.str] = None,
            protocol: typing.Optional[builtins.str] = None,
            security_group_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a security group rule.

            :param cidr: The IPv4 address range, in CIDR notation.
            :param direction: The direction. The following are possible values:. - egress - ingress
            :param port_range: The port range.
            :param prefix_list_id: The prefix list ID.
            :param protocol: The protocol name.
            :param security_group_id: The security group ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                analysis_security_group_rule_property = ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(
                    cidr="cidr",
                    direction="direction",
                    port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                        from=123,
                        to=123
                    ),
                    prefix_list_id="prefixListId",
                    protocol="protocol",
                    security_group_id="securityGroupId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if cidr is not None:
                self._values["cidr"] = cidr
            if direction is not None:
                self._values["direction"] = direction
            if port_range is not None:
                self._values["port_range"] = port_range
            if prefix_list_id is not None:
                self._values["prefix_list_id"] = prefix_list_id
            if protocol is not None:
                self._values["protocol"] = protocol
            if security_group_id is not None:
                self._values["security_group_id"] = security_group_id

        @builtins.property
        def cidr(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR notation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-cidr
            '''
            result = self._values.get("cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def direction(self) -> typing.Optional[builtins.str]:
            '''The direction. The following are possible values:.

            - egress
            - ingress

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-direction
            '''
            result = self._values.get("direction")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port_range(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]:
            '''The port range.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-portrange
            '''
            result = self._values.get("port_range")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''The prefix list ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-prefixlistid
            '''
            result = self._values.get("prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The protocol name.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_group_id(self) -> typing.Optional[builtins.str]:
            '''The security group ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-analysissecuritygrouprule.html#cfn-ec2-networkinsightsanalysis-analysissecuritygrouprule-securitygroupid
            '''
            result = self._values.get("security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AnalysisSecurityGroupRuleProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.ExplanationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "acl": "acl",
            "acl_rule": "aclRule",
            "address": "address",
            "addresses": "addresses",
            "attached_to": "attachedTo",
            "availability_zones": "availabilityZones",
            "cidrs": "cidrs",
            "classic_load_balancer_listener": "classicLoadBalancerListener",
            "component": "component",
            "customer_gateway": "customerGateway",
            "destination": "destination",
            "destination_vpc": "destinationVpc",
            "direction": "direction",
            "elastic_load_balancer_listener": "elasticLoadBalancerListener",
            "explanation_code": "explanationCode",
            "ingress_route_table": "ingressRouteTable",
            "internet_gateway": "internetGateway",
            "load_balancer_arn": "loadBalancerArn",
            "load_balancer_listener_port": "loadBalancerListenerPort",
            "load_balancer_target": "loadBalancerTarget",
            "load_balancer_target_group": "loadBalancerTargetGroup",
            "load_balancer_target_groups": "loadBalancerTargetGroups",
            "load_balancer_target_port": "loadBalancerTargetPort",
            "missing_component": "missingComponent",
            "nat_gateway": "natGateway",
            "network_interface": "networkInterface",
            "packet_field": "packetField",
            "port": "port",
            "port_ranges": "portRanges",
            "prefix_list": "prefixList",
            "protocols": "protocols",
            "route_table": "routeTable",
            "route_table_route": "routeTableRoute",
            "security_group": "securityGroup",
            "security_group_rule": "securityGroupRule",
            "security_groups": "securityGroups",
            "source_vpc": "sourceVpc",
            "state": "state",
            "subnet": "subnet",
            "subnet_route_table": "subnetRouteTable",
            "vpc": "vpc",
            "vpc_endpoint": "vpcEndpoint",
            "vpc_peering_connection": "vpcPeeringConnection",
            "vpn_connection": "vpnConnection",
            "vpn_gateway": "vpnGateway",
        },
    )
    class ExplanationProperty:
        def __init__(
            self,
            *,
            acl: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            acl_rule: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty", _IResolvable_da3f097b]] = None,
            address: typing.Optional[builtins.str] = None,
            addresses: typing.Optional[typing.Sequence[builtins.str]] = None,
            attached_to: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
            cidrs: typing.Optional[typing.Sequence[builtins.str]] = None,
            classic_load_balancer_listener: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty", _IResolvable_da3f097b]] = None,
            component: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            customer_gateway: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            destination: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            destination_vpc: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            direction: typing.Optional[builtins.str] = None,
            elastic_load_balancer_listener: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            explanation_code: typing.Optional[builtins.str] = None,
            ingress_route_table: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            internet_gateway: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            load_balancer_arn: typing.Optional[builtins.str] = None,
            load_balancer_listener_port: typing.Optional[jsii.Number] = None,
            load_balancer_target: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty", _IResolvable_da3f097b]] = None,
            load_balancer_target_group: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            load_balancer_target_groups: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]]] = None,
            load_balancer_target_port: typing.Optional[jsii.Number] = None,
            missing_component: typing.Optional[builtins.str] = None,
            nat_gateway: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            network_interface: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            packet_field: typing.Optional[builtins.str] = None,
            port: typing.Optional[jsii.Number] = None,
            port_ranges: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]] = None,
            prefix_list: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            protocols: typing.Optional[typing.Sequence[builtins.str]] = None,
            route_table: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            route_table_route: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty", _IResolvable_da3f097b]] = None,
            security_group: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            security_group_rule: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty", _IResolvable_da3f097b]] = None,
            security_groups: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]]] = None,
            source_vpc: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            state: typing.Optional[builtins.str] = None,
            subnet: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            subnet_route_table: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            vpc: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            vpc_endpoint: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            vpc_peering_connection: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            vpn_connection: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            vpn_gateway: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes an explanation code for an unreachable path.

            For more information, see `Reachability Analyzer explanation codes <https://docs.aws.amazon.com/vpc/latest/reachability/explanation-codes.html>`_ .

            :param acl: The network ACL.
            :param acl_rule: The network ACL rule.
            :param address: The IPv4 address, in CIDR notation.
            :param addresses: The IPv4 addresses, in CIDR notation.
            :param attached_to: The resource to which the component is attached.
            :param availability_zones: The Availability Zones.
            :param cidrs: The CIDR ranges.
            :param classic_load_balancer_listener: The listener for a Classic Load Balancer.
            :param component: The component.
            :param customer_gateway: The customer gateway.
            :param destination: The destination.
            :param destination_vpc: The destination VPC.
            :param direction: The direction. The following are possible values:. - egress - ingress
            :param elastic_load_balancer_listener: The load balancer listener.
            :param explanation_code: The explanation code.
            :param ingress_route_table: The route table.
            :param internet_gateway: The internet gateway.
            :param load_balancer_arn: The Amazon Resource Name (ARN) of the load balancer.
            :param load_balancer_listener_port: The listener port of the load balancer.
            :param load_balancer_target: The target.
            :param load_balancer_target_group: The target group.
            :param load_balancer_target_groups: The target groups.
            :param load_balancer_target_port: The target port.
            :param missing_component: The missing component.
            :param nat_gateway: The NAT gateway.
            :param network_interface: The network interface.
            :param packet_field: The packet field.
            :param port: The port.
            :param port_ranges: The port ranges.
            :param prefix_list: The prefix list.
            :param protocols: The protocols.
            :param route_table: The route table.
            :param route_table_route: The route table route.
            :param security_group: The security group.
            :param security_group_rule: The security group rule.
            :param security_groups: The security groups.
            :param source_vpc: The source VPC.
            :param state: The state.
            :param subnet: The subnet.
            :param subnet_route_table: The route table for the subnet.
            :param vpc: The component VPC.
            :param vpc_endpoint: The VPC endpoint.
            :param vpc_peering_connection: The VPC peering connection.
            :param vpn_connection: The VPN connection.
            :param vpn_gateway: The VPN gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                explanation_property = ec2.CfnNetworkInsightsAnalysis.ExplanationProperty(
                    acl=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    acl_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(
                        cidr="cidr",
                        egress=False,
                        port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        protocol="protocol",
                        rule_action="ruleAction",
                        rule_number=123
                    ),
                    address="address",
                    addresses=["addresses"],
                    attached_to=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    availability_zones=["availabilityZones"],
                    cidrs=["cidrs"],
                    classic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty(
                        instance_port=123,
                        load_balancer_port=123
                    ),
                    component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    customer_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    destination=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    destination_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    direction="direction",
                    elastic_load_balancer_listener=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    explanation_code="explanationCode",
                    ingress_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    internet_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    load_balancer_arn="loadBalancerArn",
                    load_balancer_listener_port=123,
                    load_balancer_target=ec2.CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty(
                        address="address",
                        availability_zone="availabilityZone",
                        instance=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                            arn="arn",
                            id="id"
                        ),
                        port=123
                    ),
                    load_balancer_target_group=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    load_balancer_target_groups=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )],
                    load_balancer_target_port=123,
                    missing_component="missingComponent",
                    nat_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    network_interface=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    packet_field="packetField",
                    port=123,
                    port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                        from=123,
                        to=123
                    )],
                    prefix_list=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    protocols=["protocols"],
                    route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    route_table_route=ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(
                        destination_cidr="destinationCidr",
                        destination_prefix_list_id="destinationPrefixListId",
                        egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                        gateway_id="gatewayId",
                        instance_id="instanceId",
                        nat_gateway_id="natGatewayId",
                        network_interface_id="networkInterfaceId",
                        origin="origin",
                        transit_gateway_id="transitGatewayId",
                        vpc_peering_connection_id="vpcPeeringConnectionId"
                    ),
                    security_group=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    security_group_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(
                        cidr="cidr",
                        direction="direction",
                        port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        prefix_list_id="prefixListId",
                        protocol="protocol",
                        security_group_id="securityGroupId"
                    ),
                    security_groups=[ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )],
                    source_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    state="state",
                    subnet=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    subnet_route_table=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpc_endpoint=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpc_peering_connection=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpn_connection=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpn_gateway=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if acl is not None:
                self._values["acl"] = acl
            if acl_rule is not None:
                self._values["acl_rule"] = acl_rule
            if address is not None:
                self._values["address"] = address
            if addresses is not None:
                self._values["addresses"] = addresses
            if attached_to is not None:
                self._values["attached_to"] = attached_to
            if availability_zones is not None:
                self._values["availability_zones"] = availability_zones
            if cidrs is not None:
                self._values["cidrs"] = cidrs
            if classic_load_balancer_listener is not None:
                self._values["classic_load_balancer_listener"] = classic_load_balancer_listener
            if component is not None:
                self._values["component"] = component
            if customer_gateway is not None:
                self._values["customer_gateway"] = customer_gateway
            if destination is not None:
                self._values["destination"] = destination
            if destination_vpc is not None:
                self._values["destination_vpc"] = destination_vpc
            if direction is not None:
                self._values["direction"] = direction
            if elastic_load_balancer_listener is not None:
                self._values["elastic_load_balancer_listener"] = elastic_load_balancer_listener
            if explanation_code is not None:
                self._values["explanation_code"] = explanation_code
            if ingress_route_table is not None:
                self._values["ingress_route_table"] = ingress_route_table
            if internet_gateway is not None:
                self._values["internet_gateway"] = internet_gateway
            if load_balancer_arn is not None:
                self._values["load_balancer_arn"] = load_balancer_arn
            if load_balancer_listener_port is not None:
                self._values["load_balancer_listener_port"] = load_balancer_listener_port
            if load_balancer_target is not None:
                self._values["load_balancer_target"] = load_balancer_target
            if load_balancer_target_group is not None:
                self._values["load_balancer_target_group"] = load_balancer_target_group
            if load_balancer_target_groups is not None:
                self._values["load_balancer_target_groups"] = load_balancer_target_groups
            if load_balancer_target_port is not None:
                self._values["load_balancer_target_port"] = load_balancer_target_port
            if missing_component is not None:
                self._values["missing_component"] = missing_component
            if nat_gateway is not None:
                self._values["nat_gateway"] = nat_gateway
            if network_interface is not None:
                self._values["network_interface"] = network_interface
            if packet_field is not None:
                self._values["packet_field"] = packet_field
            if port is not None:
                self._values["port"] = port
            if port_ranges is not None:
                self._values["port_ranges"] = port_ranges
            if prefix_list is not None:
                self._values["prefix_list"] = prefix_list
            if protocols is not None:
                self._values["protocols"] = protocols
            if route_table is not None:
                self._values["route_table"] = route_table
            if route_table_route is not None:
                self._values["route_table_route"] = route_table_route
            if security_group is not None:
                self._values["security_group"] = security_group
            if security_group_rule is not None:
                self._values["security_group_rule"] = security_group_rule
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if source_vpc is not None:
                self._values["source_vpc"] = source_vpc
            if state is not None:
                self._values["state"] = state
            if subnet is not None:
                self._values["subnet"] = subnet
            if subnet_route_table is not None:
                self._values["subnet_route_table"] = subnet_route_table
            if vpc is not None:
                self._values["vpc"] = vpc
            if vpc_endpoint is not None:
                self._values["vpc_endpoint"] = vpc_endpoint
            if vpc_peering_connection is not None:
                self._values["vpc_peering_connection"] = vpc_peering_connection
            if vpn_connection is not None:
                self._values["vpn_connection"] = vpn_connection
            if vpn_gateway is not None:
                self._values["vpn_gateway"] = vpn_gateway

        @builtins.property
        def acl(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The network ACL.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-acl
            '''
            result = self._values.get("acl")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def acl_rule(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty", _IResolvable_da3f097b]]:
            '''The network ACL rule.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-aclrule
            '''
            result = self._values.get("acl_rule")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def address(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address, in CIDR notation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-address
            '''
            result = self._values.get("address")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def addresses(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IPv4 addresses, in CIDR notation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-addresses
            '''
            result = self._values.get("addresses")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def attached_to(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The resource to which the component is attached.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-attachedto
            '''
            result = self._values.get("attached_to")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The Availability Zones.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-availabilityzones
            '''
            result = self._values.get("availability_zones")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def cidrs(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CIDR ranges.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-cidrs
            '''
            result = self._values.get("cidrs")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def classic_load_balancer_listener(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty", _IResolvable_da3f097b]]:
            '''The listener for a Classic Load Balancer.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-classicloadbalancerlistener
            '''
            result = self._values.get("classic_load_balancer_listener")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisLoadBalancerListenerProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def component(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-component
            '''
            result = self._values.get("component")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def customer_gateway(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The customer gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-customergateway
            '''
            result = self._values.get("customer_gateway")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def destination(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The destination.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destination
            '''
            result = self._values.get("destination")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def destination_vpc(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The destination VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-destinationvpc
            '''
            result = self._values.get("destination_vpc")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def direction(self) -> typing.Optional[builtins.str]:
            '''The direction. The following are possible values:.

            - egress
            - ingress

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-direction
            '''
            result = self._values.get("direction")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def elastic_load_balancer_listener(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The load balancer listener.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-elasticloadbalancerlistener
            '''
            result = self._values.get("elastic_load_balancer_listener")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def explanation_code(self) -> typing.Optional[builtins.str]:
            '''The explanation code.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-explanationcode
            '''
            result = self._values.get("explanation_code")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def ingress_route_table(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The route table.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-ingressroutetable
            '''
            result = self._values.get("ingress_route_table")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def internet_gateway(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The internet gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-internetgateway
            '''
            result = self._values.get("internet_gateway")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def load_balancer_arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the load balancer.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerarn
            '''
            result = self._values.get("load_balancer_arn")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def load_balancer_listener_port(self) -> typing.Optional[jsii.Number]:
            '''The listener port of the load balancer.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancerlistenerport
            '''
            result = self._values.get("load_balancer_listener_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def load_balancer_target(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty", _IResolvable_da3f097b]]:
            '''The target.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertarget
            '''
            result = self._values.get("load_balancer_target")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisLoadBalancerTargetProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def load_balancer_target_group(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The target group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroup
            '''
            result = self._values.get("load_balancer_target_group")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def load_balancer_target_groups(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]]]:
            '''The target groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetgroups
            '''
            result = self._values.get("load_balancer_target_groups")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def load_balancer_target_port(self) -> typing.Optional[jsii.Number]:
            '''The target port.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-loadbalancertargetport
            '''
            result = self._values.get("load_balancer_target_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def missing_component(self) -> typing.Optional[builtins.str]:
            '''The missing component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-missingcomponent
            '''
            result = self._values.get("missing_component")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def nat_gateway(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The NAT gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-natgateway
            '''
            result = self._values.get("nat_gateway")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def network_interface(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-networkinterface
            '''
            result = self._values.get("network_interface")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def packet_field(self) -> typing.Optional[builtins.str]:
            '''The packet field.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-packetfield
            '''
            result = self._values.get("packet_field")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def port(self) -> typing.Optional[jsii.Number]:
            '''The port.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-port
            '''
            result = self._values.get("port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def port_ranges(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]]:
            '''The port ranges.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-portranges
            '''
            result = self._values.get("port_ranges")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.PortRangeProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def prefix_list(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The prefix list.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-prefixlist
            '''
            result = self._values.get("prefix_list")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def protocols(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The protocols.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-protocols
            '''
            result = self._values.get("protocols")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def route_table(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The route table.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetable
            '''
            result = self._values.get("route_table")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def route_table_route(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty", _IResolvable_da3f097b]]:
            '''The route table route.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-routetableroute
            '''
            result = self._values.get("route_table_route")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def security_group(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The security group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroup
            '''
            result = self._values.get("security_group")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def security_group_rule(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty", _IResolvable_da3f097b]]:
            '''The security group rule.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygrouprule
            '''
            result = self._values.get("security_group_rule")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def security_groups(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]]]:
            '''The security groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def source_vpc(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The source VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-sourcevpc
            '''
            result = self._values.get("source_vpc")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def state(self) -> typing.Optional[builtins.str]:
            '''The state.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-state
            '''
            result = self._values.get("state")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The subnet.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnet
            '''
            result = self._values.get("subnet")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def subnet_route_table(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The route table for the subnet.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-subnetroutetable
            '''
            result = self._values.get("subnet_route_table")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def vpc(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The component VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpc
            '''
            result = self._values.get("vpc")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def vpc_endpoint(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The VPC endpoint.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcendpoint
            '''
            result = self._values.get("vpc_endpoint")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def vpc_peering_connection(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The VPC peering connection.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpcpeeringconnection
            '''
            result = self._values.get("vpc_peering_connection")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def vpn_connection(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The VPN connection.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpnconnection
            '''
            result = self._values.get("vpn_connection")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def vpn_gateway(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The VPN gateway.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-explanation.html#cfn-ec2-networkinsightsanalysis-explanation-vpngateway
            '''
            result = self._values.get("vpn_gateway")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ExplanationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.PathComponentProperty",
        jsii_struct_bases=[],
        name_mapping={
            "acl_rule": "aclRule",
            "component": "component",
            "destination_vpc": "destinationVpc",
            "inbound_header": "inboundHeader",
            "outbound_header": "outboundHeader",
            "route_table_route": "routeTableRoute",
            "security_group_rule": "securityGroupRule",
            "sequence_number": "sequenceNumber",
            "source_vpc": "sourceVpc",
            "subnet": "subnet",
            "vpc": "vpc",
        },
    )
    class PathComponentProperty:
        def __init__(
            self,
            *,
            acl_rule: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty", _IResolvable_da3f097b]] = None,
            component: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            destination_vpc: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            inbound_header: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty", _IResolvable_da3f097b]] = None,
            outbound_header: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty", _IResolvable_da3f097b]] = None,
            route_table_route: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty", _IResolvable_da3f097b]] = None,
            security_group_rule: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty", _IResolvable_da3f097b]] = None,
            sequence_number: typing.Optional[jsii.Number] = None,
            source_vpc: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            subnet: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
            vpc: typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes a path component.

            :param acl_rule: The network ACL rule.
            :param component: The component.
            :param destination_vpc: The destination VPC.
            :param inbound_header: The inbound header.
            :param outbound_header: The outbound header.
            :param route_table_route: The route table route.
            :param security_group_rule: The security group rule.
            :param sequence_number: The sequence number.
            :param source_vpc: The source VPC.
            :param subnet: The subnet.
            :param vpc: The component VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                path_component_property = ec2.CfnNetworkInsightsAnalysis.PathComponentProperty(
                    acl_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty(
                        cidr="cidr",
                        egress=False,
                        port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        protocol="protocol",
                        rule_action="ruleAction",
                        rule_number=123
                    ),
                    component=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    destination_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    inbound_header=ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        )],
                        protocol="protocol",
                        source_addresses=["sourceAddresses"],
                        source_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        )]
                    ),
                    outbound_header=ec2.CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty(
                        destination_addresses=["destinationAddresses"],
                        destination_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        )],
                        protocol="protocol",
                        source_addresses=["sourceAddresses"],
                        source_port_ranges=[ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        )]
                    ),
                    route_table_route=ec2.CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty(
                        destination_cidr="destinationCidr",
                        destination_prefix_list_id="destinationPrefixListId",
                        egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                        gateway_id="gatewayId",
                        instance_id="instanceId",
                        nat_gateway_id="natGatewayId",
                        network_interface_id="networkInterfaceId",
                        origin="origin",
                        transit_gateway_id="transitGatewayId",
                        vpc_peering_connection_id="vpcPeeringConnectionId"
                    ),
                    security_group_rule=ec2.CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty(
                        cidr="cidr",
                        direction="direction",
                        port_range=ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                            from=123,
                            to=123
                        ),
                        prefix_list_id="prefixListId",
                        protocol="protocol",
                        security_group_id="securityGroupId"
                    ),
                    sequence_number=123,
                    source_vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    subnet=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    ),
                    vpc=ec2.CfnNetworkInsightsAnalysis.AnalysisComponentProperty(
                        arn="arn",
                        id="id"
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if acl_rule is not None:
                self._values["acl_rule"] = acl_rule
            if component is not None:
                self._values["component"] = component
            if destination_vpc is not None:
                self._values["destination_vpc"] = destination_vpc
            if inbound_header is not None:
                self._values["inbound_header"] = inbound_header
            if outbound_header is not None:
                self._values["outbound_header"] = outbound_header
            if route_table_route is not None:
                self._values["route_table_route"] = route_table_route
            if security_group_rule is not None:
                self._values["security_group_rule"] = security_group_rule
            if sequence_number is not None:
                self._values["sequence_number"] = sequence_number
            if source_vpc is not None:
                self._values["source_vpc"] = source_vpc
            if subnet is not None:
                self._values["subnet"] = subnet
            if vpc is not None:
                self._values["vpc"] = vpc

        @builtins.property
        def acl_rule(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty", _IResolvable_da3f097b]]:
            '''The network ACL rule.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-aclrule
            '''
            result = self._values.get("acl_rule")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisAclRuleProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def component(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The component.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-component
            '''
            result = self._values.get("component")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def destination_vpc(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The destination VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-destinationvpc
            '''
            result = self._values.get("destination_vpc")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def inbound_header(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty", _IResolvable_da3f097b]]:
            '''The inbound header.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-inboundheader
            '''
            result = self._values.get("inbound_header")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def outbound_header(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty", _IResolvable_da3f097b]]:
            '''The outbound header.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-outboundheader
            '''
            result = self._values.get("outbound_header")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisPacketHeaderProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def route_table_route(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty", _IResolvable_da3f097b]]:
            '''The route table route.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-routetableroute
            '''
            result = self._values.get("route_table_route")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisRouteTableRouteProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def security_group_rule(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty", _IResolvable_da3f097b]]:
            '''The security group rule.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-securitygrouprule
            '''
            result = self._values.get("security_group_rule")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisSecurityGroupRuleProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def sequence_number(self) -> typing.Optional[jsii.Number]:
            '''The sequence number.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sequencenumber
            '''
            result = self._values.get("sequence_number")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def source_vpc(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The source VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-sourcevpc
            '''
            result = self._values.get("source_vpc")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def subnet(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The subnet.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-subnet
            '''
            result = self._values.get("subnet")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def vpc(
            self,
        ) -> typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]]:
            '''The component VPC.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-pathcomponent.html#cfn-ec2-networkinsightsanalysis-pathcomponent-vpc
            '''
            result = self._values.get("vpc")
            return typing.cast(typing.Optional[typing.Union["CfnNetworkInsightsAnalysis.AnalysisComponentProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PathComponentProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysis.PortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_": "from", "to": "to"},
    )
    class PortRangeProperty:
        def __init__(
            self,
            *,
            from_: typing.Optional[jsii.Number] = None,
            to: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Describes a range of ports.

            :param from_: The first port in the range.
            :param to: The last port in the range.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                port_range_property = ec2.CfnNetworkInsightsAnalysis.PortRangeProperty(
                    from=123,
                    to=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if from_ is not None:
                self._values["from_"] = from_
            if to is not None:
                self._values["to"] = to

        @builtins.property
        def from_(self) -> typing.Optional[jsii.Number]:
            '''The first port in the range.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-from
            '''
            result = self._values.get("from_")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to(self) -> typing.Optional[jsii.Number]:
            '''The last port in the range.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinsightsanalysis-portrange.html#cfn-ec2-networkinsightsanalysis-portrange-to
            '''
            result = self._values.get("to")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsAnalysisProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_insights_path_id": "networkInsightsPathId",
        "filter_in_arns": "filterInArns",
        "tags": "tags",
    },
)
class CfnNetworkInsightsAnalysisProps:
    def __init__(
        self,
        *,
        network_insights_path_id: builtins.str,
        filter_in_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInsightsAnalysis``.

        :param network_insights_path_id: The ID of the path.
        :param filter_in_arns: The Amazon Resource Names (ARN) of the resources that the path must traverse.
        :param tags: The tags to apply.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_insights_analysis_props = ec2.CfnNetworkInsightsAnalysisProps(
                network_insights_path_id="networkInsightsPathId",
            
                # the properties below are optional
                filter_in_arns=["filterInArns"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "network_insights_path_id": network_insights_path_id,
        }
        if filter_in_arns is not None:
            self._values["filter_in_arns"] = filter_in_arns
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def network_insights_path_id(self) -> builtins.str:
        '''The ID of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-networkinsightspathid
        '''
        result = self._values.get("network_insights_path_id")
        assert result is not None, "Required property 'network_insights_path_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filter_in_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of the resources that the path must traverse.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-filterinarns
        '''
        result = self._values.get("filter_in_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to apply.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightsanalysis.html#cfn-ec2-networkinsightsanalysis-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsAnalysisProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInsightsPath(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsPath",
):
    '''A CloudFormation ``AWS::EC2::NetworkInsightsPath``.

    Specifies a path to analyze for reachability.

    VPC Reachability Analyzer enables you to analyze and debug network reachability between two resources in your virtual private cloud (VPC). For more information, see the `Reachability Analyzer User Guide <https://docs.aws.amazon.com/vpc/latest/reachability/what-is-reachability-analyzer.html>`_ .

    :cloudformationResource: AWS::EC2::NetworkInsightsPath
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_insights_path = ec2.CfnNetworkInsightsPath(self, "MyCfnNetworkInsightsPath",
            destination="destination",
            protocol="protocol",
            source="source",
        
            # the properties below are optional
            destination_ip="destinationIp",
            destination_port=123,
            source_ip="sourceIp",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        destination: builtins.str,
        protocol: builtins.str,
        source: builtins.str,
        destination_ip: typing.Optional[builtins.str] = None,
        destination_port: typing.Optional[jsii.Number] = None,
        source_ip: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInsightsPath``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param destination: The AWS resource that is the destination of the path.
        :param protocol: The protocol.
        :param source: The AWS resource that is the source of the path.
        :param destination_ip: The IP address of the AWS resource that is the destination of the path.
        :param destination_port: The destination port.
        :param source_ip: The IP address of the AWS resource that is the source of the path.
        :param tags: The tags to add to the path.
        '''
        props = CfnNetworkInsightsPathProps(
            destination=destination,
            protocol=protocol,
            source=source,
            destination_ip=destination_ip,
            destination_port=destination_port,
            source_ip=source_ip,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCreatedDate")
    def attr_created_date(self) -> builtins.str:
        '''The time stamp when the path was created.

        :cloudformationAttribute: CreatedDate
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCreatedDate"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsPathArn")
    def attr_network_insights_path_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the path.

        :cloudformationAttribute: NetworkInsightsPathArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsPathArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInsightsPathId")
    def attr_network_insights_path_id(self) -> builtins.str:
        '''The ID of the path.

        :cloudformationAttribute: NetworkInsightsPathId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkInsightsPathId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to add to the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destination")
    def destination(self) -> builtins.str:
        '''The AWS resource that is the destination of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
        '''
        return typing.cast(builtins.str, jsii.get(self, "destination"))

    @destination.setter
    def destination(self, value: builtins.str) -> None:
        jsii.set(self, "destination", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="protocol")
    def protocol(self) -> builtins.str:
        '''The protocol.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
        '''
        return typing.cast(builtins.str, jsii.get(self, "protocol"))

    @protocol.setter
    def protocol(self, value: builtins.str) -> None:
        jsii.set(self, "protocol", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="source")
    def source(self) -> builtins.str:
        '''The AWS resource that is the source of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
        '''
        return typing.cast(builtins.str, jsii.get(self, "source"))

    @source.setter
    def source(self, value: builtins.str) -> None:
        jsii.set(self, "source", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationIp")
    def destination_ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the AWS resource that is the destination of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationIp"))

    @destination_ip.setter
    def destination_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationIp", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationPort")
    def destination_port(self) -> typing.Optional[jsii.Number]:
        '''The destination port.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "destinationPort"))

    @destination_port.setter
    def destination_port(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "destinationPort", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceIp")
    def source_ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the AWS resource that is the source of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceIp"))

    @source_ip.setter
    def source_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceIp", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInsightsPathProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination": "destination",
        "protocol": "protocol",
        "source": "source",
        "destination_ip": "destinationIp",
        "destination_port": "destinationPort",
        "source_ip": "sourceIp",
        "tags": "tags",
    },
)
class CfnNetworkInsightsPathProps:
    def __init__(
        self,
        *,
        destination: builtins.str,
        protocol: builtins.str,
        source: builtins.str,
        destination_ip: typing.Optional[builtins.str] = None,
        destination_port: typing.Optional[jsii.Number] = None,
        source_ip: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInsightsPath``.

        :param destination: The AWS resource that is the destination of the path.
        :param protocol: The protocol.
        :param source: The AWS resource that is the source of the path.
        :param destination_ip: The IP address of the AWS resource that is the destination of the path.
        :param destination_port: The destination port.
        :param source_ip: The IP address of the AWS resource that is the source of the path.
        :param tags: The tags to add to the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_insights_path_props = ec2.CfnNetworkInsightsPathProps(
                destination="destination",
                protocol="protocol",
                source="source",
            
                # the properties below are optional
                destination_ip="destinationIp",
                destination_port=123,
                source_ip="sourceIp",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "destination": destination,
            "protocol": protocol,
            "source": source,
        }
        if destination_ip is not None:
            self._values["destination_ip"] = destination_ip
        if destination_port is not None:
            self._values["destination_port"] = destination_port
        if source_ip is not None:
            self._values["source_ip"] = source_ip
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def destination(self) -> builtins.str:
        '''The AWS resource that is the destination of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destination
        '''
        result = self._values.get("destination")
        assert result is not None, "Required property 'destination' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def protocol(self) -> builtins.str:
        '''The protocol.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-protocol
        '''
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def source(self) -> builtins.str:
        '''The AWS resource that is the source of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-source
        '''
        result = self._values.get("source")
        assert result is not None, "Required property 'source' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def destination_ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the AWS resource that is the destination of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationip
        '''
        result = self._values.get("destination_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port(self) -> typing.Optional[jsii.Number]:
        '''The destination port.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-destinationport
        '''
        result = self._values.get("destination_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def source_ip(self) -> typing.Optional[builtins.str]:
        '''The IP address of the AWS resource that is the source of the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-sourceip
        '''
        result = self._values.get("source_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to add to the path.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinsightspath.html#cfn-ec2-networkinsightspath-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInsightsPathProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInterface(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterface",
):
    '''A CloudFormation ``AWS::EC2::NetworkInterface``.

    Describes a network interface in an Amazon EC2 instance for AWS CloudFormation .

    :cloudformationResource: AWS::EC2::NetworkInterface
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_interface = ec2.CfnNetworkInterface(self, "MyCfnNetworkInterface",
            subnet_id="subnetId",
        
            # the properties below are optional
            description="description",
            group_set=["groupSet"],
            interface_type="interfaceType",
            ipv6_address_count=123,
            ipv6_addresses=[ec2.CfnNetworkInterface.InstanceIpv6AddressProperty(
                ipv6_address="ipv6Address"
            )],
            private_ip_address="privateIpAddress",
            private_ip_addresses=[ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty(
                primary=False,
                private_ip_address="privateIpAddress"
            )],
            secondary_private_ip_address_count=123,
            source_dest_check=False,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
        interface_type: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInterface.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        private_ip_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnNetworkInterface.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]] = None,
        secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
        source_dest_check: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInterface``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param subnet_id: The ID of the subnet to associate with the network interface.
        :param description: A description for the network interface.
        :param group_set: The security group IDs associated with this network interface.
        :param interface_type: The type of network interface. The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .
        :param ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.
        :param ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface. If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.
        :param private_ip_address: Assigns a single private IP address to the network interface, which is used as the primary private IP address. If you want to specify multiple private IP address, use the ``PrivateIpAddresses`` property.
        :param private_ip_addresses: Assigns private IP addresses to the network interface. You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.
        :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` . The number of IP addresses you can assign to a network interface varies by instance type. For more information, see `IP Addresses Per ENI Per Instance Type <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param source_dest_check: Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
        :param tags: An arbitrary set of tags (key-value pairs) for this network interface.
        '''
        props = CfnNetworkInterfaceProps(
            subnet_id=subnet_id,
            description=description,
            group_set=group_set,
            interface_type=interface_type,
            ipv6_address_count=ipv6_address_count,
            ipv6_addresses=ipv6_addresses,
            private_ip_address=private_ip_address,
            private_ip_addresses=private_ip_addresses,
            secondary_private_ip_address_count=secondary_private_ip_address_count,
            source_dest_check=source_dest_check,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the network interface.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPrimaryPrivateIpAddress")
    def attr_primary_private_ip_address(self) -> builtins.str:
        '''The primary private IP address of the network interface.

        For example, ``10.0.0.192`` .

        :cloudformationAttribute: PrimaryPrivateIpAddress
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPrimaryPrivateIpAddress"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrSecondaryPrivateIpAddresses")
    def attr_secondary_private_ip_addresses(self) -> typing.List[builtins.str]:
        '''The secondary private IP addresses of the network interface.

        For example, ``["10.0.0.161", "10.0.0.162", "10.0.0.163"]`` .

        :cloudformationAttribute: SecondaryPrivateIpAddresses
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "attrSecondaryPrivateIpAddresses"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''An arbitrary set of tags (key-value pairs) for this network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet to associate with the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupSet")
    def group_set(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The security group IDs associated with this network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "groupSet"))

    @group_set.setter
    def group_set(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "groupSet", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="interfaceType")
    def interface_type(self) -> typing.Optional[builtins.str]:
        '''The type of network interface.

        The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "interfaceType"))

    @interface_type.setter
    def interface_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "interfaceType", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6AddressCount")
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of IPv6 addresses to assign to a network interface.

        Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "ipv6AddressCount"))

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6AddressCount", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6Addresses")
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInterface.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]]:
        '''One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.

        If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInterface.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]], jsii.get(self, "ipv6Addresses"))

    @ipv6_addresses.setter
    def ipv6_addresses(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInterface.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "ipv6Addresses", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateIpAddress")
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''Assigns a single private IP address to the network interface, which is used as the primary private IP address.

        If you want to specify multiple private IP address, use the ``PrivateIpAddresses`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "privateIpAddress"))

    @private_ip_address.setter
    def private_ip_address(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "privateIpAddress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateIpAddresses")
    def private_ip_addresses(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInterface.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''Assigns private IP addresses to the network interface.

        You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInterface.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "privateIpAddresses"))

    @private_ip_addresses.setter
    def private_ip_addresses(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnNetworkInterface.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "privateIpAddresses", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of secondary private IPv4 addresses to assign to a network interface.

        When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` .

        The number of IP addresses you can assign to a network interface varies by instance type. For more information, see `IP Addresses Per ENI Per Instance Type <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "secondaryPrivateIpAddressCount"))

    @secondary_private_ip_address_count.setter
    def secondary_private_ip_address_count(
        self,
        value: typing.Optional[jsii.Number],
    ) -> None:
        jsii.set(self, "secondaryPrivateIpAddressCount", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceDestCheck")
    def source_dest_check(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.

        If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "sourceDestCheck"))

    @source_dest_check.setter
    def source_dest_check(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "sourceDestCheck", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterface.InstanceIpv6AddressProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class InstanceIpv6AddressProperty:
        def __init__(self, *, ipv6_address: builtins.str) -> None:
            '''Describes the IPv6 addresses to associate with the network interface.

            :param ipv6_address: An IPv6 address to associate with the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_ipv6_address_property = ec2.CfnNetworkInterface.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "ipv6_address": ipv6_address,
            }

        @builtins.property
        def ipv6_address(self) -> builtins.str:
            '''An IPv6 address to associate with the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-instanceipv6address.html#cfn-ec2-networkinterface-instanceipv6address-ipv6address
            '''
            result = self._values.get("ipv6_address")
            assert result is not None, "Required property 'ipv6_address' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceIpv6AddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"primary": "primary", "private_ip_address": "privateIpAddress"},
    )
    class PrivateIpAddressSpecificationProperty:
        def __init__(
            self,
            *,
            primary: typing.Union[builtins.bool, _IResolvable_da3f097b],
            private_ip_address: builtins.str,
        ) -> None:
            '''Describes a secondary private IPv4 address for a network interface.

            :param primary: Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
            :param private_ip_address: The private IP address of the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_ip_address_specification_property = ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "primary": primary,
                "private_ip_address": private_ip_address,
            }

        @builtins.property
        def primary(self) -> typing.Union[builtins.bool, _IResolvable_da3f097b]:
            '''Sets the private IP address as the primary private address.

            You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-primary
            '''
            result = self._values.get("primary")
            assert result is not None, "Required property 'primary' is missing"
            return typing.cast(typing.Union[builtins.bool, _IResolvable_da3f097b], result)

        @builtins.property
        def private_ip_address(self) -> builtins.str:
            '''The private IP address of the network interface.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-networkinterface-privateipaddressspecification.html#cfn-ec2-networkinterface-privateipaddressspecification-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            assert result is not None, "Required property 'private_ip_address' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddressSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInterfaceAttachment(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterfaceAttachment",
):
    '''A CloudFormation ``AWS::EC2::NetworkInterfaceAttachment``.

    Attaches an elastic network interface (ENI) to an Amazon EC2 instance. You can use this resource type to attach additional network interfaces to an instance without interruption.

    :cloudformationResource: AWS::EC2::NetworkInterfaceAttachment
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_interface_attachment = ec2.CfnNetworkInterfaceAttachment(self, "MyCfnNetworkInterfaceAttachment",
            device_index="deviceIndex",
            instance_id="instanceId",
            network_interface_id="networkInterfaceId",
        
            # the properties below are optional
            delete_on_termination=False
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        device_index: builtins.str,
        instance_id: builtins.str,
        network_interface_id: builtins.str,
        delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInterfaceAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param device_index: The network interface's position in the attachment order. For example, the first attached network interface has a ``DeviceIndex`` of 0.
        :param instance_id: The ID of the instance to which you will attach the ENI.
        :param network_interface_id: The ID of the ENI that you want to attach.
        :param delete_on_termination: Whether to delete the network interface when the instance terminates. By default, this value is set to ``true`` .
        '''
        props = CfnNetworkInterfaceAttachmentProps(
            device_index=device_index,
            instance_id=instance_id,
            network_interface_id=network_interface_id,
            delete_on_termination=delete_on_termination,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="deviceIndex")
    def device_index(self) -> builtins.str:
        '''The network interface's position in the attachment order.

        For example, the first attached network interface has a ``DeviceIndex`` of 0.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-deviceindex
        '''
        return typing.cast(builtins.str, jsii.get(self, "deviceIndex"))

    @device_index.setter
    def device_index(self, value: builtins.str) -> None:
        jsii.set(self, "deviceIndex", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        '''The ID of the instance to which you will attach the ENI.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-instanceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        '''The ID of the ENI that you want to attach.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-networkinterfaceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="deleteOnTermination")
    def delete_on_termination(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Whether to delete the network interface when the instance terminates.

        By default, this value is set to ``true`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-deleteonterm
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "deleteOnTermination"))

    @delete_on_termination.setter
    def delete_on_termination(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "deleteOnTermination", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterfaceAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "device_index": "deviceIndex",
        "instance_id": "instanceId",
        "network_interface_id": "networkInterfaceId",
        "delete_on_termination": "deleteOnTermination",
    },
)
class CfnNetworkInterfaceAttachmentProps:
    def __init__(
        self,
        *,
        device_index: builtins.str,
        instance_id: builtins.str,
        network_interface_id: builtins.str,
        delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInterfaceAttachment``.

        :param device_index: The network interface's position in the attachment order. For example, the first attached network interface has a ``DeviceIndex`` of 0.
        :param instance_id: The ID of the instance to which you will attach the ENI.
        :param network_interface_id: The ID of the ENI that you want to attach.
        :param delete_on_termination: Whether to delete the network interface when the instance terminates. By default, this value is set to ``true`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_interface_attachment_props = ec2.CfnNetworkInterfaceAttachmentProps(
                device_index="deviceIndex",
                instance_id="instanceId",
                network_interface_id="networkInterfaceId",
            
                # the properties below are optional
                delete_on_termination=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "device_index": device_index,
            "instance_id": instance_id,
            "network_interface_id": network_interface_id,
        }
        if delete_on_termination is not None:
            self._values["delete_on_termination"] = delete_on_termination

    @builtins.property
    def device_index(self) -> builtins.str:
        '''The network interface's position in the attachment order.

        For example, the first attached network interface has a ``DeviceIndex`` of 0.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-deviceindex
        '''
        result = self._values.get("device_index")
        assert result is not None, "Required property 'device_index' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_id(self) -> builtins.str:
        '''The ID of the instance to which you will attach the ENI.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-instanceid
        '''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        '''The ID of the ENI that you want to attach.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def delete_on_termination(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Whether to delete the network interface when the instance terminates.

        By default, this value is set to ``true`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-network-interface-attachment.html#cfn-ec2-network-interface-attachment-deleteonterm
        '''
        result = self._values.get("delete_on_termination")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInterfaceAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnNetworkInterfacePermission(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterfacePermission",
):
    '''A CloudFormation ``AWS::EC2::NetworkInterfacePermission``.

    Specifies a permission for an Amazon EC2 network interface. For example, you can grant an AWS authorized partner account permission to attach the specified network interface to an instance in their account.

    :cloudformationResource: AWS::EC2::NetworkInterfacePermission
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_network_interface_permission = ec2.CfnNetworkInterfacePermission(self, "MyCfnNetworkInterfacePermission",
            aws_account_id="awsAccountId",
            network_interface_id="networkInterfaceId",
            permission="permission"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        aws_account_id: builtins.str,
        network_interface_id: builtins.str,
        permission: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::NetworkInterfacePermission``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param aws_account_id: The AWS account ID.
        :param network_interface_id: The ID of the network interface.
        :param permission: The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .
        '''
        props = CfnNetworkInterfacePermissionProps(
            aws_account_id=aws_account_id,
            network_interface_id=network_interface_id,
            permission=permission,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="awsAccountId")
    def aws_account_id(self) -> builtins.str:
        '''The AWS account ID.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
        '''
        return typing.cast(builtins.str, jsii.get(self, "awsAccountId"))

    @aws_account_id.setter
    def aws_account_id(self, value: builtins.str) -> None:
        jsii.set(self, "awsAccountId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        '''The ID of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="permission")
    def permission(self) -> builtins.str:
        '''The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
        '''
        return typing.cast(builtins.str, jsii.get(self, "permission"))

    @permission.setter
    def permission(self, value: builtins.str) -> None:
        jsii.set(self, "permission", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterfacePermissionProps",
    jsii_struct_bases=[],
    name_mapping={
        "aws_account_id": "awsAccountId",
        "network_interface_id": "networkInterfaceId",
        "permission": "permission",
    },
)
class CfnNetworkInterfacePermissionProps:
    def __init__(
        self,
        *,
        aws_account_id: builtins.str,
        network_interface_id: builtins.str,
        permission: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInterfacePermission``.

        :param aws_account_id: The AWS account ID.
        :param network_interface_id: The ID of the network interface.
        :param permission: The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_interface_permission_props = ec2.CfnNetworkInterfacePermissionProps(
                aws_account_id="awsAccountId",
                network_interface_id="networkInterfaceId",
                permission="permission"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "aws_account_id": aws_account_id,
            "network_interface_id": network_interface_id,
            "permission": permission,
        }

    @builtins.property
    def aws_account_id(self) -> builtins.str:
        '''The AWS account ID.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-awsaccountid
        '''
        result = self._values.get("aws_account_id")
        assert result is not None, "Required property 'aws_account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        '''The ID of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def permission(self) -> builtins.str:
        '''The type of permission to grant: ``INSTANCE-ATTACH`` or ``EIP-ASSOCIATE`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterfacepermission.html#cfn-ec2-networkinterfacepermission-permission
        '''
        result = self._values.get("permission")
        assert result is not None, "Required property 'permission' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInterfacePermissionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnNetworkInterfaceProps",
    jsii_struct_bases=[],
    name_mapping={
        "subnet_id": "subnetId",
        "description": "description",
        "group_set": "groupSet",
        "interface_type": "interfaceType",
        "ipv6_address_count": "ipv6AddressCount",
        "ipv6_addresses": "ipv6Addresses",
        "private_ip_address": "privateIpAddress",
        "private_ip_addresses": "privateIpAddresses",
        "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
        "source_dest_check": "sourceDestCheck",
        "tags": "tags",
    },
)
class CfnNetworkInterfaceProps:
    def __init__(
        self,
        *,
        subnet_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        group_set: typing.Optional[typing.Sequence[builtins.str]] = None,
        interface_type: typing.Optional[builtins.str] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnNetworkInterface.InstanceIpv6AddressProperty, _IResolvable_da3f097b]]]] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        private_ip_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnNetworkInterface.PrivateIpAddressSpecificationProperty, _IResolvable_da3f097b]]]] = None,
        secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
        source_dest_check: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnNetworkInterface``.

        :param subnet_id: The ID of the subnet to associate with the network interface.
        :param description: A description for the network interface.
        :param group_set: The security group IDs associated with this network interface.
        :param interface_type: The type of network interface. The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .
        :param ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.
        :param ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface. If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.
        :param private_ip_address: Assigns a single private IP address to the network interface, which is used as the primary private IP address. If you want to specify multiple private IP address, use the ``PrivateIpAddresses`` property.
        :param private_ip_addresses: Assigns private IP addresses to the network interface. You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.
        :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` . The number of IP addresses you can assign to a network interface varies by instance type. For more information, see `IP Addresses Per ENI Per Instance Type <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param source_dest_check: Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives. If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.
        :param tags: An arbitrary set of tags (key-value pairs) for this network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_network_interface_props = ec2.CfnNetworkInterfaceProps(
                subnet_id="subnetId",
            
                # the properties below are optional
                description="description",
                group_set=["groupSet"],
                interface_type="interfaceType",
                ipv6_address_count=123,
                ipv6_addresses=[ec2.CfnNetworkInterface.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )],
                private_ip_address="privateIpAddress",
                private_ip_addresses=[ec2.CfnNetworkInterface.PrivateIpAddressSpecificationProperty(
                    primary=False,
                    private_ip_address="privateIpAddress"
                )],
                secondary_private_ip_address_count=123,
                source_dest_check=False,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_id": subnet_id,
        }
        if description is not None:
            self._values["description"] = description
        if group_set is not None:
            self._values["group_set"] = group_set
        if interface_type is not None:
            self._values["interface_type"] = interface_type
        if ipv6_address_count is not None:
            self._values["ipv6_address_count"] = ipv6_address_count
        if ipv6_addresses is not None:
            self._values["ipv6_addresses"] = ipv6_addresses
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if private_ip_addresses is not None:
            self._values["private_ip_addresses"] = private_ip_addresses
        if secondary_private_ip_address_count is not None:
            self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
        if source_dest_check is not None:
            self._values["source_dest_check"] = source_dest_check
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet to associate with the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-subnetid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description for the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_set(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The security group IDs associated with this network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-groupset
        '''
        result = self._values.get("group_set")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def interface_type(self) -> typing.Optional[builtins.str]:
        '''The type of network interface.

        The default is ``interface`` . The supported values are ``efa`` and ``trunk`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-interfacetype
        '''
        result = self._values.get("interface_type")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of IPv6 addresses to assign to a network interface.

        Amazon EC2 automatically selects the IPv6 addresses from the subnet range. To specify specific IPv6 addresses, use the ``Ipv6Addresses`` property and don't specify this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresscount
        '''
        result = self._values.get("ipv6_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_addresses(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInterface.InstanceIpv6AddressProperty, _IResolvable_da3f097b]]]]:
        '''One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet to associate with the network interface.

        If you're specifying a number of IPv6 addresses, use the ``Ipv6AddressCount`` property and don't specify this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-ipv6addresses
        '''
        result = self._values.get("ipv6_addresses")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInterface.InstanceIpv6AddressProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''Assigns a single private IP address to the network interface, which is used as the primary private IP address.

        If you want to specify multiple private IP address, use the ``PrivateIpAddresses`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddress
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_addresses(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInterface.PrivateIpAddressSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''Assigns private IP addresses to the network interface.

        You can specify a primary private IP address by setting the value of the ``Primary`` property to ``true`` in the ``PrivateIpAddressSpecification`` property. If you want EC2 to automatically assign private IP addresses, use the ``SecondaryPrivateIpAddressCount`` property and do not specify this property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-privateipaddresses
        '''
        result = self._values.get("private_ip_addresses")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnNetworkInterface.PrivateIpAddressSpecificationProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
        '''The number of secondary private IPv4 addresses to assign to a network interface.

        When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using ``privateIpAddresses`` .

        The number of IP addresses you can assign to a network interface varies by instance type. For more information, see `IP Addresses Per ENI Per Instance Type <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-secondaryprivateipaddresscount
        '''
        result = self._values.get("secondary_private_ip_address_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def source_dest_check(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Enable or disable source/destination checks, which ensure that the instance is either the source or the destination of any traffic that it receives.

        If the value is ``true`` , source/destination checks are enabled; otherwise, they are disabled. The default value is ``true`` . You must disable source/destination checks if the instance runs services such as network address translation, routing, or firewalls.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-sourcedestcheck
        '''
        result = self._values.get("source_dest_check")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''An arbitrary set of tags (key-value pairs) for this network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-networkinterface.html#cfn-ec2-networkinterface-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnNetworkInterfaceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnPlacementGroup(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnPlacementGroup",
):
    '''A CloudFormation ``AWS::EC2::PlacementGroup``.

    Specifies a placement group in which to launch instances. The strategy of the placement group determines how the instances are organized within the group.

    A ``cluster`` placement group is a logical grouping of instances within a single Availability Zone that benefit from low network latency, high network throughput. A ``spread`` placement group places instances on distinct hardware. A ``partition`` placement group places groups of instances in different partitions, where instances in one partition do not share the same hardware with instances in another partition.

    For more information, see `Placement Groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html>`_ in the *Amazon EC2 User Guide* .

    :cloudformationResource: AWS::EC2::PlacementGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_placement_group = ec2.CfnPlacementGroup(self, "MyCfnPlacementGroup",
            strategy="strategy"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        strategy: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::PlacementGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param strategy: The placement strategy.
        '''
        props = CfnPlacementGroupProps(strategy=strategy)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="strategy")
    def strategy(self) -> typing.Optional[builtins.str]:
        '''The placement strategy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "strategy"))

    @strategy.setter
    def strategy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "strategy", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnPlacementGroupProps",
    jsii_struct_bases=[],
    name_mapping={"strategy": "strategy"},
)
class CfnPlacementGroupProps:
    def __init__(self, *, strategy: typing.Optional[builtins.str] = None) -> None:
        '''Properties for defining a ``CfnPlacementGroup``.

        :param strategy: The placement strategy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_placement_group_props = ec2.CfnPlacementGroupProps(
                strategy="strategy"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if strategy is not None:
            self._values["strategy"] = strategy

    @builtins.property
    def strategy(self) -> typing.Optional[builtins.str]:
        '''The placement strategy.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-placementgroup.html#cfn-ec2-placementgroup-strategy
        '''
        result = self._values.get("strategy")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPlacementGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnPrefixList(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnPrefixList",
):
    '''A CloudFormation ``AWS::EC2::PrefixList``.

    Specifies a managed prefix list. You can add one or more entries to the prefix list. Each entry consists of a CIDR block and an optional description.

    You must specify the maximum number of entries for the prefix list. The maximum number of entries cannot be changed later.

    :cloudformationResource: AWS::EC2::PrefixList
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_prefix_list = ec2.CfnPrefixList(self, "MyCfnPrefixList",
            address_family="addressFamily",
            max_entries=123,
            prefix_list_name="prefixListName",
        
            # the properties below are optional
            entries=[ec2.CfnPrefixList.EntryProperty(
                cidr="cidr",
        
                # the properties below are optional
                description="description"
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        address_family: builtins.str,
        max_entries: jsii.Number,
        prefix_list_name: builtins.str,
        entries: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnPrefixList.EntryProperty", _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::PrefixList``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param address_family: The IP address type. Valid Values: ``IPv4`` | ``IPv6``
        :param max_entries: The maximum number of entries for the prefix list.
        :param prefix_list_name: A name for the prefix list. Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .
        :param entries: One or more entries for the prefix list.
        :param tags: The tags for the prefix list.
        '''
        props = CfnPrefixListProps(
            address_family=address_family,
            max_entries=max_entries,
            prefix_list_name=prefix_list_name,
            entries=entries,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrArn")
    def attr_arn(self) -> builtins.str:
        '''The ARN of the prefix list.

        For example, ``arn:aws:ec2:us-east-1:123456789012:prefix-list/pl-0123123123123abcd`` .

        :cloudformationAttribute: Arn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrOwnerId")
    def attr_owner_id(self) -> builtins.str:
        '''The ID of the owner of the prefix list.

        For example, ``123456789012`` .

        :cloudformationAttribute: OwnerId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrOwnerId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrPrefixListId")
    def attr_prefix_list_id(self) -> builtins.str:
        '''The ID of the prefix list.

        For example, ``pl-0123123123123abcd`` .

        :cloudformationAttribute: PrefixListId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrPrefixListId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrVersion")
    def attr_version(self) -> jsii.Number:
        '''The version of the prefix list.

        For example, ``1`` .

        :cloudformationAttribute: Version
        '''
        return typing.cast(jsii.Number, jsii.get(self, "attrVersion"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="addressFamily")
    def address_family(self) -> builtins.str:
        '''The IP address type.

        Valid Values: ``IPv4`` | ``IPv6``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
        '''
        return typing.cast(builtins.str, jsii.get(self, "addressFamily"))

    @address_family.setter
    def address_family(self, value: builtins.str) -> None:
        jsii.set(self, "addressFamily", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="maxEntries")
    def max_entries(self) -> jsii.Number:
        '''The maximum number of entries for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
        '''
        return typing.cast(jsii.Number, jsii.get(self, "maxEntries"))

    @max_entries.setter
    def max_entries(self, value: jsii.Number) -> None:
        jsii.set(self, "maxEntries", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="prefixListName")
    def prefix_list_name(self) -> builtins.str:
        '''A name for the prefix list.

        Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
        '''
        return typing.cast(builtins.str, jsii.get(self, "prefixListName"))

    @prefix_list_name.setter
    def prefix_list_name(self, value: builtins.str) -> None:
        jsii.set(self, "prefixListName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="entries")
    def entries(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnPrefixList.EntryProperty", _IResolvable_da3f097b]]]]:
        '''One or more entries for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnPrefixList.EntryProperty", _IResolvable_da3f097b]]]], jsii.get(self, "entries"))

    @entries.setter
    def entries(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnPrefixList.EntryProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "entries", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnPrefixList.EntryProperty",
        jsii_struct_bases=[],
        name_mapping={"cidr": "cidr", "description": "description"},
    )
    class EntryProperty:
        def __init__(
            self,
            *,
            cidr: builtins.str,
            description: typing.Optional[builtins.str] = None,
        ) -> None:
            '''An entry for a prefix list.

            :param cidr: The CIDR block.
            :param description: A description for the entry. Constraints: Up to 255 characters in length.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                entry_property = ec2.CfnPrefixList.EntryProperty(
                    cidr="cidr",
                
                    # the properties below are optional
                    description="description"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "cidr": cidr,
            }
            if description is not None:
                self._values["description"] = description

        @builtins.property
        def cidr(self) -> builtins.str:
            '''The CIDR block.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-cidr
            '''
            result = self._values.get("cidr")
            assert result is not None, "Required property 'cidr' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the entry.

            Constraints: Up to 255 characters in length.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-prefixlist-entry.html#cfn-ec2-prefixlist-entry-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EntryProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnPrefixListProps",
    jsii_struct_bases=[],
    name_mapping={
        "address_family": "addressFamily",
        "max_entries": "maxEntries",
        "prefix_list_name": "prefixListName",
        "entries": "entries",
        "tags": "tags",
    },
)
class CfnPrefixListProps:
    def __init__(
        self,
        *,
        address_family: builtins.str,
        max_entries: jsii.Number,
        prefix_list_name: builtins.str,
        entries: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnPrefixList.EntryProperty, _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnPrefixList``.

        :param address_family: The IP address type. Valid Values: ``IPv4`` | ``IPv6``
        :param max_entries: The maximum number of entries for the prefix list.
        :param prefix_list_name: A name for the prefix list. Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .
        :param entries: One or more entries for the prefix list.
        :param tags: The tags for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_prefix_list_props = ec2.CfnPrefixListProps(
                address_family="addressFamily",
                max_entries=123,
                prefix_list_name="prefixListName",
            
                # the properties below are optional
                entries=[ec2.CfnPrefixList.EntryProperty(
                    cidr="cidr",
            
                    # the properties below are optional
                    description="description"
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "address_family": address_family,
            "max_entries": max_entries,
            "prefix_list_name": prefix_list_name,
        }
        if entries is not None:
            self._values["entries"] = entries
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def address_family(self) -> builtins.str:
        '''The IP address type.

        Valid Values: ``IPv4`` | ``IPv6``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-addressfamily
        '''
        result = self._values.get("address_family")
        assert result is not None, "Required property 'address_family' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def max_entries(self) -> jsii.Number:
        '''The maximum number of entries for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-maxentries
        '''
        result = self._values.get("max_entries")
        assert result is not None, "Required property 'max_entries' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def prefix_list_name(self) -> builtins.str:
        '''A name for the prefix list.

        Constraints: Up to 255 characters in length. The name cannot start with ``com.amazonaws`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-prefixlistname
        '''
        result = self._values.get("prefix_list_name")
        assert result is not None, "Required property 'prefix_list_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def entries(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnPrefixList.EntryProperty, _IResolvable_da3f097b]]]]:
        '''One or more entries for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-entries
        '''
        result = self._values.get("entries")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnPrefixList.EntryProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-prefixlist.html#cfn-ec2-prefixlist-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnPrefixListProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnRoute(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnRoute",
):
    '''A CloudFormation ``AWS::EC2::Route``.

    Specifies a route in a route table within a VPC.

    You must specify either ``DestinationCidrBlock`` or ``DestinationIpv6CidrBlock`` , plus the ID of one of the target resources.

    If you create a route that references a transit gateway in the same template where you create the transit gateway, you must declare a dependency on the transit gateway attachment. The route table cannot use the transit gateway until it has successfully attached to the VPC. Add a `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ in the ``AWS::EC2::Route`` resource to explicitly declare a dependency on the ``AWS::EC2::TransitGatewayAttachment`` resource.

    :cloudformationResource: AWS::EC2::Route
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_route = ec2.CfnRoute(self, "MyCfnRoute",
            route_table_id="routeTableId",
        
            # the properties below are optional
            carrier_gateway_id="carrierGatewayId",
            destination_cidr_block="destinationCidrBlock",
            destination_ipv6_cidr_block="destinationIpv6CidrBlock",
            egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
            gateway_id="gatewayId",
            instance_id="instanceId",
            local_gateway_id="localGatewayId",
            nat_gateway_id="natGatewayId",
            network_interface_id="networkInterfaceId",
            transit_gateway_id="transitGatewayId",
            vpc_endpoint_id="vpcEndpointId",
            vpc_peering_connection_id="vpcPeeringConnectionId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        route_table_id: builtins.str,
        carrier_gateway_id: typing.Optional[builtins.str] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_ipv6_cidr_block: typing.Optional[builtins.str] = None,
        egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
        gateway_id: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        local_gateway_id: typing.Optional[builtins.str] = None,
        nat_gateway_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_endpoint_id: typing.Optional[builtins.str] = None,
        vpc_peering_connection_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::Route``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param route_table_id: The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.
        :param carrier_gateway_id: The ID of the carrier gateway.
        :param destination_cidr_block: The IPv4 CIDR block used for the destination match.
        :param destination_ipv6_cidr_block: The IPv6 CIDR block used for the destination match.
        :param egress_only_internet_gateway_id: The ID of the egress-only internet gateway.
        :param gateway_id: The ID of an internet gateway or virtual private gateway attached to your VPC.
        :param instance_id: The ID of a NAT instance in your VPC.
        :param local_gateway_id: The ID of the local gateway.
        :param nat_gateway_id: The ID of a NAT gateway.
        :param network_interface_id: The ID of the network interface.
        :param transit_gateway_id: The ID of a transit gateway.
        :param vpc_endpoint_id: The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
        :param vpc_peering_connection_id: The ID of a VPC peering connection.
        '''
        props = CfnRouteProps(
            route_table_id=route_table_id,
            carrier_gateway_id=carrier_gateway_id,
            destination_cidr_block=destination_cidr_block,
            destination_ipv6_cidr_block=destination_ipv6_cidr_block,
            egress_only_internet_gateway_id=egress_only_internet_gateway_id,
            gateway_id=gateway_id,
            instance_id=instance_id,
            local_gateway_id=local_gateway_id,
            nat_gateway_id=nat_gateway_id,
            network_interface_id=network_interface_id,
            transit_gateway_id=transit_gateway_id,
            vpc_endpoint_id=vpc_endpoint_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        The routing table must be associated with the same VPC that the virtual private gateway is attached to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "routeTableId"))

    @route_table_id.setter
    def route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "routeTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="carrierGatewayId")
    def carrier_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "carrierGatewayId"))

    @carrier_gateway_id.setter
    def carrier_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "carrierGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR block used for the destination match.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationCidrBlock"))

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationIpv6CidrBlock")
    def destination_ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR block used for the destination match.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationIpv6CidrBlock"))

    @destination_ipv6_cidr_block.setter
    def destination_ipv6_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationIpv6CidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the egress-only internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "egressOnlyInternetGatewayId"))

    @egress_only_internet_gateway_id.setter
    def egress_only_internet_gateway_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "egressOnlyInternetGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gatewayId")
    def gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an internet gateway or virtual private gateway attached to your VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "gatewayId"))

    @gateway_id.setter
    def gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "gatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a NAT instance in your VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="localGatewayId")
    def local_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "localGatewayId"))

    @local_gateway_id.setter
    def local_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "localGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="natGatewayId")
    def nat_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "natGatewayId"))

    @nat_gateway_id.setter
    def nat_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "natGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "transitGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a VPC endpoint.

        Supported for Gateway Load Balancer endpoints only.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcEndpointId"))

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcEndpointId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a VPC peering connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcPeeringConnectionId"))

    @vpc_peering_connection_id.setter
    def vpc_peering_connection_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcPeeringConnectionId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "route_table_id": "routeTableId",
        "carrier_gateway_id": "carrierGatewayId",
        "destination_cidr_block": "destinationCidrBlock",
        "destination_ipv6_cidr_block": "destinationIpv6CidrBlock",
        "egress_only_internet_gateway_id": "egressOnlyInternetGatewayId",
        "gateway_id": "gatewayId",
        "instance_id": "instanceId",
        "local_gateway_id": "localGatewayId",
        "nat_gateway_id": "natGatewayId",
        "network_interface_id": "networkInterfaceId",
        "transit_gateway_id": "transitGatewayId",
        "vpc_endpoint_id": "vpcEndpointId",
        "vpc_peering_connection_id": "vpcPeeringConnectionId",
    },
)
class CfnRouteProps:
    def __init__(
        self,
        *,
        route_table_id: builtins.str,
        carrier_gateway_id: typing.Optional[builtins.str] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_ipv6_cidr_block: typing.Optional[builtins.str] = None,
        egress_only_internet_gateway_id: typing.Optional[builtins.str] = None,
        gateway_id: typing.Optional[builtins.str] = None,
        instance_id: typing.Optional[builtins.str] = None,
        local_gateway_id: typing.Optional[builtins.str] = None,
        nat_gateway_id: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_endpoint_id: typing.Optional[builtins.str] = None,
        vpc_peering_connection_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnRoute``.

        :param route_table_id: The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.
        :param carrier_gateway_id: The ID of the carrier gateway.
        :param destination_cidr_block: The IPv4 CIDR block used for the destination match.
        :param destination_ipv6_cidr_block: The IPv6 CIDR block used for the destination match.
        :param egress_only_internet_gateway_id: The ID of the egress-only internet gateway.
        :param gateway_id: The ID of an internet gateway or virtual private gateway attached to your VPC.
        :param instance_id: The ID of a NAT instance in your VPC.
        :param local_gateway_id: The ID of the local gateway.
        :param nat_gateway_id: The ID of a NAT gateway.
        :param network_interface_id: The ID of the network interface.
        :param transit_gateway_id: The ID of a transit gateway.
        :param vpc_endpoint_id: The ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
        :param vpc_peering_connection_id: The ID of a VPC peering connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_route_props = ec2.CfnRouteProps(
                route_table_id="routeTableId",
            
                # the properties below are optional
                carrier_gateway_id="carrierGatewayId",
                destination_cidr_block="destinationCidrBlock",
                destination_ipv6_cidr_block="destinationIpv6CidrBlock",
                egress_only_internet_gateway_id="egressOnlyInternetGatewayId",
                gateway_id="gatewayId",
                instance_id="instanceId",
                local_gateway_id="localGatewayId",
                nat_gateway_id="natGatewayId",
                network_interface_id="networkInterfaceId",
                transit_gateway_id="transitGatewayId",
                vpc_endpoint_id="vpcEndpointId",
                vpc_peering_connection_id="vpcPeeringConnectionId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "route_table_id": route_table_id,
        }
        if carrier_gateway_id is not None:
            self._values["carrier_gateway_id"] = carrier_gateway_id
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if destination_ipv6_cidr_block is not None:
            self._values["destination_ipv6_cidr_block"] = destination_ipv6_cidr_block
        if egress_only_internet_gateway_id is not None:
            self._values["egress_only_internet_gateway_id"] = egress_only_internet_gateway_id
        if gateway_id is not None:
            self._values["gateway_id"] = gateway_id
        if instance_id is not None:
            self._values["instance_id"] = instance_id
        if local_gateway_id is not None:
            self._values["local_gateway_id"] = local_gateway_id
        if nat_gateway_id is not None:
            self._values["nat_gateway_id"] = nat_gateway_id
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if vpc_endpoint_id is not None:
            self._values["vpc_endpoint_id"] = vpc_endpoint_id
        if vpc_peering_connection_id is not None:
            self._values["vpc_peering_connection_id"] = vpc_peering_connection_id

    @builtins.property
    def route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        The routing table must be associated with the same VPC that the virtual private gateway is attached to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-routetableid
        '''
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def carrier_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the carrier gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-carriergatewayid
        '''
        result = self._values.get("carrier_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR block used for the destination match.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR block used for the destination match.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-destinationipv6cidrblock
        '''
        result = self._values.get("destination_ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def egress_only_internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the egress-only internet gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-egressonlyinternetgatewayid
        '''
        result = self._values.get("egress_only_internet_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an internet gateway or virtual private gateway attached to your VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-gatewayid
        '''
        result = self._values.get("gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def instance_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a NAT instance in your VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-instanceid
        '''
        result = self._values.get("instance_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the local gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-localgatewayid
        '''
        result = self._values.get("local_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def nat_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a NAT gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-natgatewayid
        '''
        result = self._values.get("nat_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a VPC endpoint.

        Supported for Gateway Load Balancer endpoints only.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcendpointid
        '''
        result = self._values.get("vpc_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_peering_connection_id(self) -> typing.Optional[builtins.str]:
        '''The ID of a VPC peering connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html#cfn-ec2-route-vpcpeeringconnectionid
        '''
        result = self._values.get("vpc_peering_connection_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnRouteTable(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnRouteTable",
):
    '''A CloudFormation ``AWS::EC2::RouteTable``.

    Specifies a route table for a specified VPC. After you create a route table, you can add routes and associate the table with a subnet.

    For more information, see `Route Tables <https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Route_Tables.html>`_ in the *Amazon Virtual Private Cloud User Guide* .

    :cloudformationResource: AWS::EC2::RouteTable
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_route_table = ec2.CfnRouteTable(self, "MyCfnRouteTable",
            vpc_id="vpcId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::RouteTable``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param vpc_id: The ID of the VPC.
        :param tags: Any tags assigned to the route table.
        '''
        props = CfnRouteTableProps(vpc_id=vpc_id, tags=tags)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrRouteTableId")
    def attr_route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        :cloudformationAttribute: RouteTableId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrRouteTableId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnRouteTableProps",
    jsii_struct_bases=[],
    name_mapping={"vpc_id": "vpcId", "tags": "tags"},
)
class CfnRouteTableProps:
    def __init__(
        self,
        *,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnRouteTable``.

        :param vpc_id: The ID of the VPC.
        :param tags: Any tags assigned to the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_route_table_props = ec2.CfnRouteTableProps(
                vpc_id="vpcId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html#cfn-ec2-routetable-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnRouteTableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnSecurityGroup(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroup",
):
    '''A CloudFormation ``AWS::EC2::SecurityGroup``.

    Specifies a security group. To create a security group, use the `VpcId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid>`_ property to specify the VPC for which to create the security group.

    This type supports updates. For more information about updating stacks, see `AWS CloudFormation Stacks Updates <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks.html>`_ .
    .. epigraph::

       To cross-reference two security groups in the ingress and egress rules of those security groups, use the `AWS::EC2::SecurityGroupEgress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html>`_ and `AWS::EC2::SecurityGroupIngress <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-ingress.html>`_ resources to define your rules. Do not use the embedded ingress and egress rules in the ``AWS::EC2::SecurityGroup`` . Doing so creates a circular dependency, which AWS CloudFormation doesn't allow.

    :cloudformationResource: AWS::EC2::SecurityGroup
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_security_group = ec2.CfnSecurityGroup(self, "MyCfnSecurityGroup",
            group_description="groupDescription",
        
            # the properties below are optional
            group_name="groupName",
            security_group_egress=[ec2.CfnSecurityGroup.EgressProperty(
                ip_protocol="ipProtocol",
        
                # the properties below are optional
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                destination_prefix_list_id="destinationPrefixListId",
                destination_security_group_id="destinationSecurityGroupId",
                from_port=123,
                to_port=123
            )],
            security_group_ingress=[ec2.CfnSecurityGroup.IngressProperty(
                ip_protocol="ipProtocol",
        
                # the properties below are optional
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                from_port=123,
                source_prefix_list_id="sourcePrefixListId",
                source_security_group_id="sourceSecurityGroupId",
                source_security_group_name="sourceSecurityGroupName",
                source_security_group_owner_id="sourceSecurityGroupOwnerId",
                to_port=123
            )],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            vpc_id="vpcId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        group_description: builtins.str,
        group_name: typing.Optional[builtins.str] = None,
        security_group_egress: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSecurityGroup.EgressProperty", _IResolvable_da3f097b]]]] = None,
        security_group_ingress: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSecurityGroup.IngressProperty", _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::SecurityGroup``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param group_description: A description for the security group. This is informational only. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param group_name: The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param security_group_egress: [VPC only] The outbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.
        :param security_group_ingress: The inbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.
        :param tags: Any tags assigned to the security group.
        :param vpc_id: [VPC only] The ID of the VPC for the security group.
        '''
        props = CfnSecurityGroupProps(
            group_description=group_description,
            group_name=group_name,
            security_group_egress=security_group_egress,
            security_group_ingress=security_group_ingress,
            tags=tags,
            vpc_id=vpc_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrGroupId")
    def attr_group_id(self) -> builtins.str:
        '''The group ID of the specified security group, such as ``sg-94b3a1f6`` .

        :cloudformationAttribute: GroupId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrGroupId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> builtins.str:
        '''The physical ID of the VPC.

        You can obtain the physical ID by using a reference to an `AWS::EC2::VPC <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html>`_ , such as: ``{ "Ref" : "myVPC" }`` .

        :cloudformationAttribute: VpcId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrVpcId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupDescription")
    def group_description(self) -> builtins.str:
        '''A description for the security group. This is informational only.

        Constraints: Up to 255 characters in length

        Constraints for EC2-Classic: ASCII characters

        Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-groupdescription
        '''
        return typing.cast(builtins.str, jsii.get(self, "groupDescription"))

    @group_description.setter
    def group_description(self, value: builtins.str) -> None:
        jsii.set(self, "groupDescription", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupName")
    def group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the security group.

        Constraints: Up to 255 characters in length. Cannot start with ``sg-`` .

        Constraints for EC2-Classic: ASCII characters

        Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-groupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "groupName"))

    @group_name.setter
    def group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "groupName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupEgress")
    def security_group_egress(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSecurityGroup.EgressProperty", _IResolvable_da3f097b]]]]:
        '''[VPC only] The outbound rules associated with the security group.

        There is a short interruption during which you cannot connect to the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-securitygroupegress
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSecurityGroup.EgressProperty", _IResolvable_da3f097b]]]], jsii.get(self, "securityGroupEgress"))

    @security_group_egress.setter
    def security_group_egress(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSecurityGroup.EgressProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "securityGroupEgress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupIngress")
    def security_group_ingress(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSecurityGroup.IngressProperty", _IResolvable_da3f097b]]]]:
        '''The inbound rules associated with the security group.

        There is a short interruption during which you cannot connect to the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-securitygroupingress
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSecurityGroup.IngressProperty", _IResolvable_da3f097b]]]], jsii.get(self, "securityGroupIngress"))

    @security_group_ingress.setter
    def security_group_ingress(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSecurityGroup.IngressProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "securityGroupIngress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''[VPC only] The ID of the VPC for the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroup.EgressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ip_protocol": "ipProtocol",
            "cidr_ip": "cidrIp",
            "cidr_ipv6": "cidrIpv6",
            "description": "description",
            "destination_prefix_list_id": "destinationPrefixListId",
            "destination_security_group_id": "destinationSecurityGroupId",
            "from_port": "fromPort",
            "to_port": "toPort",
        },
    )
    class EgressProperty:
        def __init__(
            self,
            *,
            ip_protocol: builtins.str,
            cidr_ip: typing.Optional[builtins.str] = None,
            cidr_ipv6: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            destination_prefix_list_id: typing.Optional[builtins.str] = None,
            destination_security_group_id: typing.Optional[builtins.str] = None,
            from_port: typing.Optional[jsii.Number] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies an outbound rule for a security group.

            An outbound rule permits instances to send traffic to the specified IPv4 or IPv6 address range, or to the instances associated with the specified destination security groups.

            You must specify only one of the following properties: ``CidrIp`` , ``CidrIpv6`` , ``DestinationPrefixListId`` , or ``DestinationSecurityGroupId`` .

            The EC2 Security Group Rule is an embedded property of the ``AWS::EC2::SecurityGroup`` type.

            :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
            :param cidr_ip: The IPv4 address range, in CIDR format.
            :param cidr_ipv6: The IPv6 address range, in CIDR format.
            :param description: A description for the security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
            :param destination_prefix_list_id: [EC2-VPC only] The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
            :param destination_security_group_id: The ID of the destination VPC security group.
            :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
            :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                egress_property = ec2.CfnSecurityGroup.EgressProperty(
                    ip_protocol="ipProtocol",
                
                    # the properties below are optional
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    destination_prefix_list_id="destinationPrefixListId",
                    destination_security_group_id="destinationSecurityGroupId",
                    from_port=123,
                    to_port=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "ip_protocol": ip_protocol,
            }
            if cidr_ip is not None:
                self._values["cidr_ip"] = cidr_ip
            if cidr_ipv6 is not None:
                self._values["cidr_ipv6"] = cidr_ipv6
            if description is not None:
                self._values["description"] = description
            if destination_prefix_list_id is not None:
                self._values["destination_prefix_list_id"] = destination_prefix_list_id
            if destination_security_group_id is not None:
                self._values["destination_security_group_id"] = destination_security_group_id
            if from_port is not None:
                self._values["from_port"] = from_port
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def ip_protocol(self) -> builtins.str:
            '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

            [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-ipprotocol
            '''
            result = self._values.get("ip_protocol")
            assert result is not None, "Required property 'ip_protocol' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def cidr_ip(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR format.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidrip
            '''
            result = self._values.get("cidr_ip")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cidr_ipv6(self) -> typing.Optional[builtins.str]:
            '''The IPv6 address range, in CIDR format.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidripv6
            '''
            result = self._values.get("cidr_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the security group rule.

            Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''[EC2-VPC only] The prefix list IDs for the destination AWS service.

            This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-destinationprefixlistid
            '''
            result = self._values.get("destination_prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def destination_security_group_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the destination VPC security group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-destsecgroupid
            '''
            result = self._values.get("destination_security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

            A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

            A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EgressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroup.IngressProperty",
        jsii_struct_bases=[],
        name_mapping={
            "ip_protocol": "ipProtocol",
            "cidr_ip": "cidrIp",
            "cidr_ipv6": "cidrIpv6",
            "description": "description",
            "from_port": "fromPort",
            "source_prefix_list_id": "sourcePrefixListId",
            "source_security_group_id": "sourceSecurityGroupId",
            "source_security_group_name": "sourceSecurityGroupName",
            "source_security_group_owner_id": "sourceSecurityGroupOwnerId",
            "to_port": "toPort",
        },
    )
    class IngressProperty:
        def __init__(
            self,
            *,
            ip_protocol: builtins.str,
            cidr_ip: typing.Optional[builtins.str] = None,
            cidr_ipv6: typing.Optional[builtins.str] = None,
            description: typing.Optional[builtins.str] = None,
            from_port: typing.Optional[jsii.Number] = None,
            source_prefix_list_id: typing.Optional[builtins.str] = None,
            source_security_group_id: typing.Optional[builtins.str] = None,
            source_security_group_name: typing.Optional[builtins.str] = None,
            source_security_group_owner_id: typing.Optional[builtins.str] = None,
            to_port: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies an inbound rule for a security group.

            An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.

            You must specify only one of the following properties: ``CidrIp`` , ``CidrIpv6`` , ``SourcePrefixListId`` , ``SourceSecurityGroupId`` , or ``SourceSecurityGroupName`` .

            The EC2 Security Group Rule is an embedded property of the ``AWS::EC2::SecurityGroup`` type.

            :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
            :param cidr_ip: The IPv4 address range, in CIDR format.
            :param cidr_ipv6: The IPv6 address range, in CIDR format.
            :param description: A description for the security group rule. Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
            :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
            :param source_prefix_list_id: [EC2-VPC only] The ID of a prefix list.
            :param source_security_group_id: The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
            :param source_security_group_name: [EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
            :param source_security_group_owner_id: [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.
            :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ingress_property = ec2.CfnSecurityGroup.IngressProperty(
                    ip_protocol="ipProtocol",
                
                    # the properties below are optional
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    from_port=123,
                    source_prefix_list_id="sourcePrefixListId",
                    source_security_group_id="sourceSecurityGroupId",
                    source_security_group_name="sourceSecurityGroupName",
                    source_security_group_owner_id="sourceSecurityGroupOwnerId",
                    to_port=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "ip_protocol": ip_protocol,
            }
            if cidr_ip is not None:
                self._values["cidr_ip"] = cidr_ip
            if cidr_ipv6 is not None:
                self._values["cidr_ipv6"] = cidr_ipv6
            if description is not None:
                self._values["description"] = description
            if from_port is not None:
                self._values["from_port"] = from_port
            if source_prefix_list_id is not None:
                self._values["source_prefix_list_id"] = source_prefix_list_id
            if source_security_group_id is not None:
                self._values["source_security_group_id"] = source_security_group_id
            if source_security_group_name is not None:
                self._values["source_security_group_name"] = source_security_group_name
            if source_security_group_owner_id is not None:
                self._values["source_security_group_owner_id"] = source_security_group_owner_id
            if to_port is not None:
                self._values["to_port"] = to_port

        @builtins.property
        def ip_protocol(self) -> builtins.str:
            '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

            [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-ipprotocol
            '''
            result = self._values.get("ip_protocol")
            assert result is not None, "Required property 'ip_protocol' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def cidr_ip(self) -> typing.Optional[builtins.str]:
            '''The IPv4 address range, in CIDR format.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidrip
            '''
            result = self._values.get("cidr_ip")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cidr_ipv6(self) -> typing.Optional[builtins.str]:
            '''The IPv6 address range, in CIDR format.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-cidripv6
            '''
            result = self._values.get("cidr_ipv6")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''A description for the security group rule.

            Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def from_port(self) -> typing.Optional[jsii.Number]:
            '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

            A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-fromport
            '''
            result = self._values.get("from_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def source_prefix_list_id(self) -> typing.Optional[builtins.str]:
            '''[EC2-VPC only] The ID of a prefix list.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-securitygroup-ingress-sourceprefixlistid
            '''
            result = self._values.get("source_prefix_list_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_security_group_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the security group.

            You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-sourcesecuritygroupid
            '''
            result = self._values.get("source_security_group_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_security_group_name(self) -> typing.Optional[builtins.str]:
            '''[EC2-Classic, default VPC] The name of the source security group.

            You can't specify this parameter in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-sourcesecuritygroupname
            '''
            result = self._values.get("source_security_group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def source_security_group_owner_id(self) -> typing.Optional[builtins.str]:
            '''[nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account.

            You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

            If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-sourcesecuritygroupownerid
            '''
            result = self._values.get("source_security_group_owner_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def to_port(self) -> typing.Optional[jsii.Number]:
            '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

            A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-rule.html#cfn-ec2-security-group-rule-toport
            '''
            result = self._values.get("to_port")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IngressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_c2943556)
class CfnSecurityGroupEgress(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroupEgress",
):
    '''A CloudFormation ``AWS::EC2::SecurityGroupEgress``.

    [EC2-VPC only] Adds the specified egress rules to a security group for use with a VPC.

    An outbound rule permits instances to send traffic to the specified destination IPv4 or IPv6 CIDR address ranges, or to the specified destination security groups for the same VPC.

    You specify a protocol for each rule (for example, TCP). For the TCP and UDP protocols, you must also specify the destination port or port range. For the ICMP protocol, you must also specify the ICMP type and code. You can use -1 for the type or code to mean all types or all codes.

    You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.

    Rule changes are propagated to affected instances as quickly as possible. However, a small delay might occur.

    For more information about VPC security group limits, see `Amazon VPC Limits <https://docs.aws.amazon.com/vpc/latest/userguide/amazon-vpc-limits.html>`_ .

    Use ``AWS::EC2::SecurityGroupIngress`` and ``AWS::EC2::SecurityGroupEgress`` only when necessary, typically to allow security groups to reference each other in ingress and egress rules. Otherwise, use the embedded ingress and egress rules of the security group. For more information, see `Amazon EC2 Security Groups <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html>`_ .

    :cloudformationResource: AWS::EC2::SecurityGroupEgress
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_security_group_egress = ec2.CfnSecurityGroupEgress(self, "MyCfnSecurityGroupEgress",
            group_id="groupId",
            ip_protocol="ipProtocol",
        
            # the properties below are optional
            cidr_ip="cidrIp",
            cidr_ipv6="cidrIpv6",
            description="description",
            destination_prefix_list_id="destinationPrefixListId",
            destination_security_group_id="destinationSecurityGroupId",
            from_port=123,
            to_port=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        group_id: builtins.str,
        ip_protocol: builtins.str,
        cidr_ip: typing.Optional[builtins.str] = None,
        cidr_ipv6: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        destination_prefix_list_id: typing.Optional[builtins.str] = None,
        destination_security_group_id: typing.Optional[builtins.str] = None,
        from_port: typing.Optional[jsii.Number] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::SecurityGroupEgress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param group_id: The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
        :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param cidr_ip: The IPv4 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param cidr_ipv6: The IPv6 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param description: The description of an egress (outbound) security group rule.
        :param destination_prefix_list_id: [EC2-VPC only] The prefix list IDs for an AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param destination_security_group_id: The ID of the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        '''
        props = CfnSecurityGroupEgressProps(
            group_id=group_id,
            ip_protocol=ip_protocol,
            cidr_ip=cidr_ip,
            cidr_ipv6=cidr_ipv6,
            description=description,
            destination_prefix_list_id=destination_prefix_list_id,
            destination_security_group_id=destination_security_group_id,
            from_port=from_port,
            to_port=to_port,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupId")
    def group_id(self) -> builtins.str:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-groupid
        '''
        return typing.cast(builtins.str, jsii.get(self, "groupId"))

    @group_id.setter
    def group_id(self, value: builtins.str) -> None:
        jsii.set(self, "groupId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipProtocol")
    def ip_protocol(self) -> builtins.str:
        '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

        [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-ipprotocol
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipProtocol"))

    @ip_protocol.setter
    def ip_protocol(self, value: builtins.str) -> None:
        jsii.set(self, "ipProtocol", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrIp")
    def cidr_ip(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR format.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-cidrip
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrIp"))

    @cidr_ip.setter
    def cidr_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrIp", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrIpv6")
    def cidr_ipv6(self) -> typing.Optional[builtins.str]:
        '''The IPv6 address range, in CIDR format.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-cidripv6
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrIpv6"))

    @cidr_ipv6.setter
    def cidr_ipv6(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrIpv6", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of an egress (outbound) security group rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC only] The prefix list IDs for an AWS service.

        This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationPrefixListId"))

    @destination_prefix_list_id.setter
    def destination_prefix_list_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationPrefixListId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationSecurityGroupId")
    def destination_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationSecurityGroupId"))

    @destination_security_group_id.setter
    def destination_security_group_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "destinationSecurityGroupId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="fromPort")
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

        A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-fromport
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "fromPort"))

    @from_port.setter
    def from_port(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "fromPort", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="toPort")
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

        A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-toport
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "toPort"))

    @to_port.setter
    def to_port(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "toPort", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroupEgressProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_id": "groupId",
        "ip_protocol": "ipProtocol",
        "cidr_ip": "cidrIp",
        "cidr_ipv6": "cidrIpv6",
        "description": "description",
        "destination_prefix_list_id": "destinationPrefixListId",
        "destination_security_group_id": "destinationSecurityGroupId",
        "from_port": "fromPort",
        "to_port": "toPort",
    },
)
class CfnSecurityGroupEgressProps:
    def __init__(
        self,
        *,
        group_id: builtins.str,
        ip_protocol: builtins.str,
        cidr_ip: typing.Optional[builtins.str] = None,
        cidr_ipv6: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        destination_prefix_list_id: typing.Optional[builtins.str] = None,
        destination_security_group_id: typing.Optional[builtins.str] = None,
        from_port: typing.Optional[jsii.Number] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for defining a ``CfnSecurityGroupEgress``.

        :param group_id: The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.
        :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param cidr_ip: The IPv4 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param cidr_ipv6: The IPv6 address range, in CIDR format. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param description: The description of an egress (outbound) security group rule.
        :param destination_prefix_list_id: [EC2-VPC only] The prefix list IDs for an AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param destination_security_group_id: The ID of the security group. You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).
        :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_security_group_egress_props = ec2.CfnSecurityGroupEgressProps(
                group_id="groupId",
                ip_protocol="ipProtocol",
            
                # the properties below are optional
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                destination_prefix_list_id="destinationPrefixListId",
                destination_security_group_id="destinationSecurityGroupId",
                from_port=123,
                to_port=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "group_id": group_id,
            "ip_protocol": ip_protocol,
        }
        if cidr_ip is not None:
            self._values["cidr_ip"] = cidr_ip
        if cidr_ipv6 is not None:
            self._values["cidr_ipv6"] = cidr_ipv6
        if description is not None:
            self._values["description"] = description
        if destination_prefix_list_id is not None:
            self._values["destination_prefix_list_id"] = destination_prefix_list_id
        if destination_security_group_id is not None:
            self._values["destination_security_group_id"] = destination_security_group_id
        if from_port is not None:
            self._values["from_port"] = from_port
        if to_port is not None:
            self._values["to_port"] = to_port

    @builtins.property
    def group_id(self) -> builtins.str:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-groupid
        '''
        result = self._values.get("group_id")
        assert result is not None, "Required property 'group_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

        [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-ipprotocol
        '''
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidr_ip(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR format.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-cidrip
        '''
        result = self._values.get("cidr_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cidr_ipv6(self) -> typing.Optional[builtins.str]:
        '''The IPv6 address range, in CIDR format.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-cidripv6
        '''
        result = self._values.get("cidr_ipv6")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of an egress (outbound) security group rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC only] The prefix list IDs for an AWS service.

        This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-destinationprefixlistid
        '''
        result = self._values.get("destination_prefix_list_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify a destination security group ( ``DestinationPrefixListId`` or ``DestinationSecurityGroupId`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-destinationsecuritygroupid
        '''
        result = self._values.get("destination_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

        A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-fromport
        '''
        result = self._values.get("from_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

        A value of ``-1`` indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-security-group-egress.html#cfn-ec2-securitygroupegress-toport
        '''
        result = self._values.get("to_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupEgressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnSecurityGroupIngress(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroupIngress",
):
    '''A CloudFormation ``AWS::EC2::SecurityGroupIngress``.

    Adds an inbound rule to a security group.

    An inbound rule permits instances to receive traffic from the specified IPv4 or IPv6 CIDR address range, or from the instances associated with the specified security group.

    You specify a protocol for each rule (for example, TCP). For TCP and UDP, you must also specify a port or port range. For ICMP/ICMPv6, you must also specify the ICMP/ICMPv6 type and code. You can use -1 to mean all types or all codes.

    You must specify a source security group ( ``SourcePrefixListId`` , ``SourceSecurityGroupId`` , or ``SourceSecurityGroupName`` ) or a CIDR range ( ``CidrIp`` or ``CidrIpv6`` ). If you do not specify one of these parameters, the stack will launch successfully but the rule will not be added to the security group.

    Rule changes are propagated to instances within the security group as quickly as possible. However, a small delay might occur.

    :cloudformationResource: AWS::EC2::SecurityGroupIngress
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_security_group_ingress = ec2.CfnSecurityGroupIngress(self, "MyCfnSecurityGroupIngress",
            ip_protocol="ipProtocol",
        
            # the properties below are optional
            cidr_ip="cidrIp",
            cidr_ipv6="cidrIpv6",
            description="description",
            from_port=123,
            group_id="groupId",
            group_name="groupName",
            source_prefix_list_id="sourcePrefixListId",
            source_security_group_id="sourceSecurityGroupId",
            source_security_group_name="sourceSecurityGroupName",
            source_security_group_owner_id="sourceSecurityGroupOwnerId",
            to_port=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        ip_protocol: builtins.str,
        cidr_ip: typing.Optional[builtins.str] = None,
        cidr_ipv6: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        from_port: typing.Optional[jsii.Number] = None,
        group_id: typing.Optional[builtins.str] = None,
        group_name: typing.Optional[builtins.str] = None,
        source_prefix_list_id: typing.Optional[builtins.str] = None,
        source_security_group_id: typing.Optional[builtins.str] = None,
        source_security_group_name: typing.Optional[builtins.str] = None,
        source_security_group_owner_id: typing.Optional[builtins.str] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::SecurityGroupIngress``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param cidr_ip: The IPv4 address range, in CIDR format.
        :param cidr_ipv6: The IPv6 address range, in CIDR format.
        :param description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.
        :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.
        :param group_id: The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID. You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.
        :param group_name: The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param source_prefix_list_id: [EC2-VPC only] The ID of a prefix list.
        :param source_security_group_id: The ID of the security group. You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.
        :param source_security_group_name: [EC2-Classic, default VPC] The name of the source security group. You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.
        :param source_security_group_owner_id: [nondefault VPC] The AWS account ID that owns the source security group. You can't specify this property with an IP address range. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.
        :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.
        '''
        props = CfnSecurityGroupIngressProps(
            ip_protocol=ip_protocol,
            cidr_ip=cidr_ip,
            cidr_ipv6=cidr_ipv6,
            description=description,
            from_port=from_port,
            group_id=group_id,
            group_name=group_name,
            source_prefix_list_id=source_prefix_list_id,
            source_security_group_id=source_security_group_id,
            source_security_group_name=source_security_group_name,
            source_security_group_owner_id=source_security_group_owner_id,
            to_port=to_port,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipProtocol")
    def ip_protocol(self) -> builtins.str:
        '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

        [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-ipprotocol
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipProtocol"))

    @ip_protocol.setter
    def ip_protocol(self, value: builtins.str) -> None:
        jsii.set(self, "ipProtocol", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrIp")
    def cidr_ip(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR format.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-cidrip
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrIp"))

    @cidr_ip.setter
    def cidr_ip(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrIp", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrIpv6")
    def cidr_ipv6(self) -> typing.Optional[builtins.str]:
        '''The IPv6 address range, in CIDR format.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-cidripv6
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrIpv6"))

    @cidr_ipv6.setter
    def cidr_ipv6(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrIpv6", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''Updates the description of an ingress (inbound) security group rule.

        You can replace an existing description, or add a description to a rule that did not have one previously.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="fromPort")
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

        A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        Use this for ICMP and any protocol that uses ports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-fromport
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "fromPort"))

    @from_port.setter
    def from_port(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "fromPort", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupId")
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.

        You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-groupid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "groupId"))

    @group_id.setter
    def group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "groupId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupName")
    def group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the security group.

        Constraints: Up to 255 characters in length. Cannot start with ``sg-`` .

        Constraints for EC2-Classic: ASCII characters

        Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-groupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "groupName"))

    @group_name.setter
    def group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "groupName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourcePrefixListId")
    def source_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC only] The ID of a prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourcePrefixListId"))

    @source_prefix_list_id.setter
    def source_prefix_list_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourcePrefixListId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceSecurityGroupId")
    def source_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceSecurityGroupId"))

    @source_security_group_id.setter
    def source_security_group_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceSecurityGroupId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceSecurityGroupName")
    def source_security_group_name(self) -> typing.Optional[builtins.str]:
        '''[EC2-Classic, default VPC] The name of the source security group.

        You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupname
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceSecurityGroupName"))

    @source_security_group_name.setter
    def source_security_group_name(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "sourceSecurityGroupName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceSecurityGroupOwnerId")
    def source_security_group_owner_id(self) -> typing.Optional[builtins.str]:
        '''[nondefault VPC] The AWS account ID that owns the source security group.

        You can't specify this property with an IP address range.

        If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupownerid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "sourceSecurityGroupOwnerId"))

    @source_security_group_owner_id.setter
    def source_security_group_owner_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "sourceSecurityGroupOwnerId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="toPort")
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

        A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        Use this for ICMP and any protocol that uses ports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-toport
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "toPort"))

    @to_port.setter
    def to_port(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "toPort", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroupIngressProps",
    jsii_struct_bases=[],
    name_mapping={
        "ip_protocol": "ipProtocol",
        "cidr_ip": "cidrIp",
        "cidr_ipv6": "cidrIpv6",
        "description": "description",
        "from_port": "fromPort",
        "group_id": "groupId",
        "group_name": "groupName",
        "source_prefix_list_id": "sourcePrefixListId",
        "source_security_group_id": "sourceSecurityGroupId",
        "source_security_group_name": "sourceSecurityGroupName",
        "source_security_group_owner_id": "sourceSecurityGroupOwnerId",
        "to_port": "toPort",
    },
)
class CfnSecurityGroupIngressProps:
    def __init__(
        self,
        *,
        ip_protocol: builtins.str,
        cidr_ip: typing.Optional[builtins.str] = None,
        cidr_ipv6: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        from_port: typing.Optional[jsii.Number] = None,
        group_id: typing.Optional[builtins.str] = None,
        group_name: typing.Optional[builtins.str] = None,
        source_prefix_list_id: typing.Optional[builtins.str] = None,
        source_security_group_id: typing.Optional[builtins.str] = None,
        source_security_group_name: typing.Optional[builtins.str] = None,
        source_security_group_owner_id: typing.Optional[builtins.str] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for defining a ``CfnSecurityGroupIngress``.

        :param ip_protocol: The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ). [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param cidr_ip: The IPv4 address range, in CIDR format.
        :param cidr_ipv6: The IPv6 address range, in CIDR format.
        :param description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.
        :param from_port: The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.
        :param group_id: The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID. You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.
        :param group_name: The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param source_prefix_list_id: [EC2-VPC only] The ID of a prefix list.
        :param source_security_group_id: The ID of the security group. You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.
        :param source_security_group_name: [EC2-Classic, default VPC] The name of the source security group. You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.
        :param source_security_group_owner_id: [nondefault VPC] The AWS account ID that owns the source security group. You can't specify this property with an IP address range. If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.
        :param to_port: The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes. Use this for ICMP and any protocol that uses ports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_security_group_ingress_props = ec2.CfnSecurityGroupIngressProps(
                ip_protocol="ipProtocol",
            
                # the properties below are optional
                cidr_ip="cidrIp",
                cidr_ipv6="cidrIpv6",
                description="description",
                from_port=123,
                group_id="groupId",
                group_name="groupName",
                source_prefix_list_id="sourcePrefixListId",
                source_security_group_id="sourceSecurityGroupId",
                source_security_group_name="sourceSecurityGroupName",
                source_security_group_owner_id="sourceSecurityGroupOwnerId",
                to_port=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "ip_protocol": ip_protocol,
        }
        if cidr_ip is not None:
            self._values["cidr_ip"] = cidr_ip
        if cidr_ipv6 is not None:
            self._values["cidr_ipv6"] = cidr_ipv6
        if description is not None:
            self._values["description"] = description
        if from_port is not None:
            self._values["from_port"] = from_port
        if group_id is not None:
            self._values["group_id"] = group_id
        if group_name is not None:
            self._values["group_name"] = group_name
        if source_prefix_list_id is not None:
            self._values["source_prefix_list_id"] = source_prefix_list_id
        if source_security_group_id is not None:
            self._values["source_security_group_id"] = source_security_group_id
        if source_security_group_name is not None:
            self._values["source_security_group_name"] = source_security_group_name
        if source_security_group_owner_id is not None:
            self._values["source_security_group_owner_id"] = source_security_group_owner_id
        if to_port is not None:
            self._values["to_port"] = to_port

    @builtins.property
    def ip_protocol(self) -> builtins.str:
        '''The IP protocol name ( ``tcp`` , ``udp`` , ``icmp`` , ``icmpv6`` ) or number (see `Protocol Numbers <https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ ).

        [VPC only] Use ``-1`` to specify all protocols. When authorizing security group rules, specifying ``-1`` or a protocol number other than ``tcp`` , ``udp`` , ``icmp`` , or ``icmpv6`` allows traffic on all ports, regardless of any port range you specify. For ``tcp`` , ``udp`` , and ``icmp`` , you must specify a port range. For ``icmpv6`` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-ipprotocol
        '''
        result = self._values.get("ip_protocol")
        assert result is not None, "Required property 'ip_protocol' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidr_ip(self) -> typing.Optional[builtins.str]:
        '''The IPv4 address range, in CIDR format.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-cidrip
        '''
        result = self._values.get("cidr_ip")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cidr_ipv6(self) -> typing.Optional[builtins.str]:
        '''The IPv6 address range, in CIDR format.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-cidripv6
        '''
        result = self._values.get("cidr_ipv6")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Updates the description of an ingress (inbound) security group rule.

        You can replace an existing description, or add a description to a rule that did not have one previously.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number.

        A value of ``-1`` indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        Use this for ICMP and any protocol that uses ports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-fromport
        '''
        result = self._values.get("from_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.

        You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-groupid
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the security group.

        Constraints: Up to 255 characters in length. Cannot start with ``sg-`` .

        Constraints for EC2-Classic: ASCII characters

        Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-groupname
        '''
        result = self._values.get("group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_prefix_list_id(self) -> typing.Optional[builtins.str]:
        '''[EC2-VPC only] The ID of a prefix list.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-securitygroupingress-sourceprefixlistid
        '''
        result = self._values.get("source_prefix_list_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_security_group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the security group.

        You must specify either the security group ID or the security group name. For security groups in a nondefault VPC, you must specify the security group ID.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupid
        '''
        result = self._values.get("source_security_group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_security_group_name(self) -> typing.Optional[builtins.str]:
        '''[EC2-Classic, default VPC] The name of the source security group.

        You must specify the ``GroupName`` property or the ``GroupId`` property. For security groups that are in a VPC, you must use the ``GroupId`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupname
        '''
        result = self._values.get("source_security_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def source_security_group_owner_id(self) -> typing.Optional[builtins.str]:
        '''[nondefault VPC] The AWS account ID that owns the source security group.

        You can't specify this property with an IP address range.

        If you specify ``SourceSecurityGroupName`` or ``SourceSecurityGroupId`` and that security group is owned by a different account than the account creating the stack, you must specify the ``SourceSecurityGroupOwnerId`` ; otherwise, this property is optional.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-sourcesecuritygroupownerid
        '''
        result = self._values.get("source_security_group_owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code.

        A value of ``-1`` indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.

        Use this for ICMP and any protocol that uses ports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group-ingress.html#cfn-ec2-security-group-ingress-toport
        '''
        result = self._values.get("to_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupIngressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_description": "groupDescription",
        "group_name": "groupName",
        "security_group_egress": "securityGroupEgress",
        "security_group_ingress": "securityGroupIngress",
        "tags": "tags",
        "vpc_id": "vpcId",
    },
)
class CfnSecurityGroupProps:
    def __init__(
        self,
        *,
        group_description: builtins.str,
        group_name: typing.Optional[builtins.str] = None,
        security_group_egress: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnSecurityGroup.EgressProperty, _IResolvable_da3f097b]]]] = None,
        security_group_ingress: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnSecurityGroup.IngressProperty, _IResolvable_da3f097b]]]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnSecurityGroup``.

        :param group_description: A description for the security group. This is informational only. Constraints: Up to 255 characters in length Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param group_name: The name of the security group. Constraints: Up to 255 characters in length. Cannot start with ``sg-`` . Constraints for EC2-Classic: ASCII characters Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*
        :param security_group_egress: [VPC only] The outbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.
        :param security_group_ingress: The inbound rules associated with the security group. There is a short interruption during which you cannot connect to the security group.
        :param tags: Any tags assigned to the security group.
        :param vpc_id: [VPC only] The ID of the VPC for the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_security_group_props = ec2.CfnSecurityGroupProps(
                group_description="groupDescription",
            
                # the properties below are optional
                group_name="groupName",
                security_group_egress=[ec2.CfnSecurityGroup.EgressProperty(
                    ip_protocol="ipProtocol",
            
                    # the properties below are optional
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    destination_prefix_list_id="destinationPrefixListId",
                    destination_security_group_id="destinationSecurityGroupId",
                    from_port=123,
                    to_port=123
                )],
                security_group_ingress=[ec2.CfnSecurityGroup.IngressProperty(
                    ip_protocol="ipProtocol",
            
                    # the properties below are optional
                    cidr_ip="cidrIp",
                    cidr_ipv6="cidrIpv6",
                    description="description",
                    from_port=123,
                    source_prefix_list_id="sourcePrefixListId",
                    source_security_group_id="sourceSecurityGroupId",
                    source_security_group_name="sourceSecurityGroupName",
                    source_security_group_owner_id="sourceSecurityGroupOwnerId",
                    to_port=123
                )],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                vpc_id="vpcId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "group_description": group_description,
        }
        if group_name is not None:
            self._values["group_name"] = group_name
        if security_group_egress is not None:
            self._values["security_group_egress"] = security_group_egress
        if security_group_ingress is not None:
            self._values["security_group_ingress"] = security_group_ingress
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def group_description(self) -> builtins.str:
        '''A description for the security group. This is informational only.

        Constraints: Up to 255 characters in length

        Constraints for EC2-Classic: ASCII characters

        Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-groupdescription
        '''
        result = self._values.get("group_description")
        assert result is not None, "Required property 'group_description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the security group.

        Constraints: Up to 255 characters in length. Cannot start with ``sg-`` .

        Constraints for EC2-Classic: ASCII characters

        Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&;{}!$*

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-groupname
        '''
        result = self._values.get("group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def security_group_egress(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnSecurityGroup.EgressProperty, _IResolvable_da3f097b]]]]:
        '''[VPC only] The outbound rules associated with the security group.

        There is a short interruption during which you cannot connect to the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-securitygroupegress
        '''
        result = self._values.get("security_group_egress")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnSecurityGroup.EgressProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def security_group_ingress(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnSecurityGroup.IngressProperty, _IResolvable_da3f097b]]]]:
        '''The inbound rules associated with the security group.

        There is a short interruption during which you cannot connect to the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-securitygroupingress
        '''
        result = self._values.get("security_group_ingress")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnSecurityGroup.IngressProperty, _IResolvable_da3f097b]]]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''[VPC only] The ID of the VPC for the security group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html#cfn-ec2-securitygroup-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnSpotFleet(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet",
):
    '''A CloudFormation ``AWS::EC2::SpotFleet``.

    Specifies a Spot Fleet request. A Spot Fleet request contains the configuration information to launch a fleet, or group, of instances.

    The Spot Fleet request specifies the total target capacity and the On-Demand target capacity for the fleet. Amazon EC2 calculates the difference between the total capacity and On-Demand capacity, and launches the difference as Spot capacity.

    The Spot Fleet request can include multiple launch specifications that vary by instance type, AMI, Availability Zone, or subnet.

    By default, the Spot Fleet requests Spot Instances in the Spot pool where the price per unit is the lowest. Each launch specification can include its own instance weighting that reflects the value of the instance type to your application workload.

    Alternatively, you can specify that the Spot Fleet distribute the target capacity across the Spot pools included in its launch specifications. By ensuring that the Spot Instances in your Spot Fleet are in different Spot pools, you can improve the availability of your fleet.

    You can specify tags for the Spot Instances. You cannot tag other resource types in a Spot Fleet request because only the ``instance`` resource type is supported.

    For more information, see `Spot Fleet Requests <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

    :cloudformationResource: AWS::EC2::SpotFleet
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_spot_fleet = ec2.CfnSpotFleet(self, "MyCfnSpotFleet",
            spot_fleet_request_config_data=ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty(
                iam_fleet_role="iamFleetRole",
                target_capacity=123,
        
                # the properties below are optional
                allocation_strategy="allocationStrategy",
                context="context",
                excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                instance_interruption_behavior="instanceInterruptionBehavior",
                instance_pools_to_use_count=123,
                launch_specifications=[ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(
                    image_id="imageId",
        
                    # the properties below are optional
                    block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(
                        device_name="deviceName",
        
                        # the properties below are optional
                        ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            snapshot_id="snapshotId",
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    ebs_optimized=False,
                    iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(
                        arn="arn"
                    ),
                    instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(
                        associate_public_ip_address=False,
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        groups=["groups"],
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(
                            ipv6_address="ipv6Address"
                        )],
                        network_interface_id="networkInterfaceId",
                        private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(
                            private_ip_address="privateIpAddress",
        
                            # the properties below are optional
                            primary=False
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    placement=ec2.CfnSpotFleet.SpotPlacementProperty(
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        tenancy="tenancy"
                    ),
                    ramdisk_id="ramdiskId",
                    security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(
                        group_id="groupId"
                    )],
                    spot_price="spotPrice",
                    subnet_id="subnetId",
                    tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData",
                    weighted_capacity=123
                )],
                launch_template_configs=[ec2.CfnSpotFleet.LaunchTemplateConfigProperty(
                    launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(
                        version="version",
        
                        # the properties below are optional
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName"
                    ),
                    overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(
                        availability_zone="availabilityZone",
                        instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        priority=123,
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )],
                load_balancers_config=ec2.CfnSpotFleet.LoadBalancersConfigProperty(
                    classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(
                        classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(
                            name="name"
                        )]
                    ),
                    target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(
                        target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(
                            arn="arn"
                        )]
                    )
                ),
                on_demand_allocation_strategy="onDemandAllocationStrategy",
                on_demand_max_total_price="onDemandMaxTotalPrice",
                on_demand_target_capacity=123,
                replace_unhealthy_instances=False,
                spot_maintenance_strategies=ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(
                    capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                ),
                spot_max_total_price="spotMaxTotalPrice",
                spot_price="spotPrice",
                target_capacity_unit_type="targetCapacityUnitType",
                terminate_instances_with_expiration=False,
                type="type",
                valid_from="validFrom",
                valid_until="validUntil"
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        spot_fleet_request_config_data: typing.Union["CfnSpotFleet.SpotFleetRequestConfigDataProperty", _IResolvable_da3f097b],
    ) -> None:
        '''Create a new ``AWS::EC2::SpotFleet``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param spot_fleet_request_config_data: Describes the configuration of a Spot Fleet request.
        '''
        props = CfnSpotFleetProps(
            spot_fleet_request_config_data=spot_fleet_request_config_data
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the Spot Fleet.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="spotFleetRequestConfigData")
    def spot_fleet_request_config_data(
        self,
    ) -> typing.Union["CfnSpotFleet.SpotFleetRequestConfigDataProperty", _IResolvable_da3f097b]:
        '''Describes the configuration of a Spot Fleet request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
        '''
        return typing.cast(typing.Union["CfnSpotFleet.SpotFleetRequestConfigDataProperty", _IResolvable_da3f097b], jsii.get(self, "spotFleetRequestConfigData"))

    @spot_fleet_request_config_data.setter
    def spot_fleet_request_config_data(
        self,
        value: typing.Union["CfnSpotFleet.SpotFleetRequestConfigDataProperty", _IResolvable_da3f097b],
    ) -> None:
        jsii.set(self, "spotFleetRequestConfigData", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.AcceleratorCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :param max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .
            :param min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                accelerator_count_request_property = ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of accelerators.

            To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of accelerators.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratorcountrequest.html#cfn-ec2-spotfleet-acceleratorcountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class AcceleratorTotalMemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            :param max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                accelerator_total_memory_mi_bRequest_property = ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of accelerator memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of accelerator memory, in MiB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-acceleratortotalmemorymibrequest.html#cfn-ec2-spotfleet-acceleratortotalmemorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "AcceleratorTotalMemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class BaselineEbsBandwidthMbpsRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            :param max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
            :param min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                baseline_ebs_bandwidth_mbps_request_property = ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum baseline bandwidth, in Mbps.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum baseline bandwidth, in Mbps.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-baselineebsbandwidthmbpsrequest.html#cfn-ec2-spotfleet-baselineebsbandwidthmbpsrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BaselineEbsBandwidthMbpsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.BlockDeviceMappingProperty",
        jsii_struct_bases=[],
        name_mapping={
            "device_name": "deviceName",
            "ebs": "ebs",
            "no_device": "noDevice",
            "virtual_name": "virtualName",
        },
    )
    class BlockDeviceMappingProperty:
        def __init__(
            self,
            *,
            device_name: builtins.str,
            ebs: typing.Optional[typing.Union["CfnSpotFleet.EbsBlockDeviceProperty", _IResolvable_da3f097b]] = None,
            no_device: typing.Optional[builtins.str] = None,
            virtual_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies a block device mapping.

            You can specify ``Ebs`` or ``VirtualName`` , but not both.

            :param device_name: The device name (for example, ``/dev/sdh`` or ``xvdh`` ).
            :param ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
            :param no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
            :param virtual_name: The virtual device name ( ``ephemeral`` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume. NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect. Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                block_device_mapping_property = ec2.CfnSpotFleet.BlockDeviceMappingProperty(
                    device_name="deviceName",
                
                    # the properties below are optional
                    ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(
                        delete_on_termination=False,
                        encrypted=False,
                        iops=123,
                        snapshot_id="snapshotId",
                        volume_size=123,
                        volume_type="volumeType"
                    ),
                    no_device="noDevice",
                    virtual_name="virtualName"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "device_name": device_name,
            }
            if ebs is not None:
                self._values["ebs"] = ebs
            if no_device is not None:
                self._values["no_device"] = no_device
            if virtual_name is not None:
                self._values["virtual_name"] = virtual_name

        @builtins.property
        def device_name(self) -> builtins.str:
            '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-devicename
            '''
            result = self._values.get("device_name")
            assert result is not None, "Required property 'device_name' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def ebs(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.EbsBlockDeviceProperty", _IResolvable_da3f097b]]:
            '''Parameters used to automatically set up EBS volumes when the instance is launched.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-ebs
            '''
            result = self._values.get("ebs")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.EbsBlockDeviceProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def no_device(self) -> typing.Optional[builtins.str]:
            '''To omit the device from the block device mapping, specify an empty string.

            When this property is specified, the device is removed from the block device mapping regardless of the assigned value.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-nodevice
            '''
            result = self._values.get("no_device")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def virtual_name(self) -> typing.Optional[builtins.str]:
            '''The virtual device name ( ``ephemeral`` N).

            Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ``ephemeral0`` and ``ephemeral1`` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

            NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

            Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-blockdevicemapping.html#cfn-ec2-spotfleet-blockdevicemapping-virtualname
            '''
            result = self._values.get("virtual_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "BlockDeviceMappingProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.ClassicLoadBalancerProperty",
        jsii_struct_bases=[],
        name_mapping={"name": "name"},
    )
    class ClassicLoadBalancerProperty:
        def __init__(self, *, name: builtins.str) -> None:
            '''Specifies a Classic Load Balancer.

            :param name: The name of the load balancer.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                classic_load_balancer_property = ec2.CfnSpotFleet.ClassicLoadBalancerProperty(
                    name="name"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "name": name,
            }

        @builtins.property
        def name(self) -> builtins.str:
            '''The name of the load balancer.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancer.html#cfn-ec2-spotfleet-classicloadbalancer-name
            '''
            result = self._values.get("name")
            assert result is not None, "Required property 'name' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClassicLoadBalancerProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"classic_load_balancers": "classicLoadBalancers"},
    )
    class ClassicLoadBalancersConfigProperty:
        def __init__(
            self,
            *,
            classic_load_balancers: typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.ClassicLoadBalancerProperty", _IResolvable_da3f097b]]],
        ) -> None:
            '''Specifies the Classic Load Balancers to attach to a Spot Fleet.

            Spot Fleet registers the running Spot Instances with these Classic Load Balancers.

            :param classic_load_balancers: One or more Classic Load Balancers.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                classic_load_balancers_config_property = ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(
                    classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(
                        name="name"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "classic_load_balancers": classic_load_balancers,
            }

        @builtins.property
        def classic_load_balancers(
            self,
        ) -> typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.ClassicLoadBalancerProperty", _IResolvable_da3f097b]]]:
            '''One or more Classic Load Balancers.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-classicloadbalancersconfig.html#cfn-ec2-spotfleet-classicloadbalancersconfig-classicloadbalancers
            '''
            result = self._values.get("classic_load_balancers")
            assert result is not None, "Required property 'classic_load_balancers' is missing"
            return typing.cast(typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.ClassicLoadBalancerProperty", _IResolvable_da3f097b]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "ClassicLoadBalancersConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.EbsBlockDeviceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "delete_on_termination": "deleteOnTermination",
            "encrypted": "encrypted",
            "iops": "iops",
            "snapshot_id": "snapshotId",
            "volume_size": "volumeSize",
            "volume_type": "volumeType",
        },
    )
    class EbsBlockDeviceProperty:
        def __init__(
            self,
            *,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            iops: typing.Optional[jsii.Number] = None,
            snapshot_id: typing.Optional[builtins.str] = None,
            volume_size: typing.Optional[jsii.Number] = None,
            volume_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a block device for an EBS volume.

            :param delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .
            :param encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS Encryption <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters>`_ in the *Amazon EC2 User Guide* . In no case can you remove encryption from an encrypted volume. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ . This parameter is not returned by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .
            :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.
            :param snapshot_id: The ID of the snapshot.
            :param volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` :1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024
            :param volume_type: The volume type. For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                ebs_block_device_property = ec2.CfnSpotFleet.EbsBlockDeviceProperty(
                    delete_on_termination=False,
                    encrypted=False,
                    iops=123,
                    snapshot_id="snapshotId",
                    volume_size=123,
                    volume_type="volumeType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if encrypted is not None:
                self._values["encrypted"] = encrypted
            if iops is not None:
                self._values["iops"] = iops
            if snapshot_id is not None:
                self._values["snapshot_id"] = snapshot_id
            if volume_size is not None:
                self._values["volume_size"] = volume_size
            if volume_type is not None:
                self._values["volume_type"] = volume_type

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the EBS volume is deleted on instance termination.

            For more information, see `Preserving Amazon EBS volumes on instance termination <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination>`_ in the *Amazon EC2 User Guide* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def encrypted(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot.

            The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Amazon EBS Encryption <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters>`_ in the *Amazon EC2 User Guide* .

            In no case can you remove encryption from an encrypted volume.

            Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see `Supported Instance Types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .

            This parameter is not returned by `DescribeImageAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-encrypted
            '''
            result = self._values.get("encrypted")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def iops(self) -> typing.Optional[jsii.Number]:
            '''The number of I/O operations per second (IOPS).

            For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

            The following are the supported values for each volume type:

            - ``gp3`` : 3,000-16,000 IOPS
            - ``io1`` : 100-64,000 IOPS
            - ``io2`` : 100-64,000 IOPS

            For ``io1`` and ``io2`` volumes, we guarantee 64,000 IOPS only for `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families guarantee performance up to 32,000 IOPS.

            This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-iops
            '''
            result = self._values.get("iops")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def snapshot_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the snapshot.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-snapshotid
            '''
            result = self._values.get("snapshot_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def volume_size(self) -> typing.Optional[jsii.Number]:
            '''The size of the volume, in GiBs.

            You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

            The following are the supported volumes sizes for each volume type:

            - ``gp2`` and ``gp3`` :1-16,384
            - ``io1`` and ``io2`` : 4-16,384
            - ``st1`` and ``sc1`` : 125-16,384
            - ``standard`` : 1-1,024

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumesize
            '''
            result = self._values.get("volume_size")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def volume_type(self) -> typing.Optional[builtins.str]:
            '''The volume type.

            For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon EC2 User Guide* . If the volume type is ``io1`` or ``io2`` , you must specify the IOPS that the volume supports.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-ebsblockdevice.html#cfn-ec2-spotfleet-ebsblockdevice-volumetype
            '''
            result = self._values.get("volume_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "EbsBlockDeviceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "version": "version",
            "launch_template_id": "launchTemplateId",
            "launch_template_name": "launchTemplateName",
        },
    )
    class FleetLaunchTemplateSpecificationProperty:
        def __init__(
            self,
            *,
            version: builtins.str,
            launch_template_id: typing.Optional[builtins.str] = None,
            launch_template_name: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the Amazon EC2 launch template and the launch template version that can be used by a Spot Fleet request to configure Amazon EC2 instances.

            For information about launch templates, see `Launching an instance from a launch template <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

            :param version: The version number of the launch template. You must specify a version number. AWS CloudFormation does not support specifying ``$Latest`` or ``$Default`` for the template version number. Minimum length of 1. Maximum length of 255. Versions must fit the following pattern: ``[\\ u0020-\\ uD7FF\\ uE000-\\ uFFFD\\ uD800\\ uDC00-\\ uDBFF\\ uDFFF\\r\\n\\t]*``
            :param launch_template_id: The ID of the launch template. If you specify the template ID, you can't specify the template name.
            :param launch_template_name: The name of the launch template. You must specify either a template name or a template ID. Minimum length of 3. Maximum length of 128. Names must match the following pattern: ``[a-zA-Z0-9\\(\\)\\.-/_]+``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                fleet_launch_template_specification_property = ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(
                    version="version",
                
                    # the properties below are optional
                    launch_template_id="launchTemplateId",
                    launch_template_name="launchTemplateName"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "version": version,
            }
            if launch_template_id is not None:
                self._values["launch_template_id"] = launch_template_id
            if launch_template_name is not None:
                self._values["launch_template_name"] = launch_template_name

        @builtins.property
        def version(self) -> builtins.str:
            '''The version number of the launch template.

            You must specify a version number. AWS CloudFormation does not support specifying ``$Latest`` or ``$Default`` for the template version number.

            Minimum length of 1. Maximum length of 255. Versions must fit the following pattern: ``[\\ u0020-\\ uD7FF\\ uE000-\\ uFFFD\\ uD800\\ uDC00-\\ uDBFF\\ uDFFF\\r\\n\\t]*``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-version
            '''
            result = self._values.get("version")
            assert result is not None, "Required property 'version' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def launch_template_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the launch template.

            If you specify the template ID, you can't specify the template name.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplateid
            '''
            result = self._values.get("launch_template_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def launch_template_name(self) -> typing.Optional[builtins.str]:
            '''The name of the launch template. You must specify either a template name or a template ID.

            Minimum length of 3. Maximum length of 128. Names must match the following pattern: ``[a-zA-Z0-9\\(\\)\\.-/_]+``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-fleetlaunchtemplatespecification.html#cfn-ec2-spotfleet-fleetlaunchtemplatespecification-launchtemplatename
            '''
            result = self._values.get("launch_template_name")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "FleetLaunchTemplateSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.GroupIdentifierProperty",
        jsii_struct_bases=[],
        name_mapping={"group_id": "groupId"},
    )
    class GroupIdentifierProperty:
        def __init__(self, *, group_id: builtins.str) -> None:
            '''Describes a security group.

            :param group_id: The ID of the security group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                group_identifier_property = ec2.CfnSpotFleet.GroupIdentifierProperty(
                    group_id="groupId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "group_id": group_id,
            }

        @builtins.property
        def group_id(self) -> builtins.str:
            '''The ID of the security group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-groupidentifier.html#cfn-ec2-spotfleet-groupidentifier-groupid
            '''
            result = self._values.get("group_id")
            assert result is not None, "Required property 'group_id' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "GroupIdentifierProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn"},
    )
    class IamInstanceProfileSpecificationProperty:
        def __init__(self, *, arn: typing.Optional[builtins.str] = None) -> None:
            '''Describes an IAM instance profile.

            :param arn: The Amazon Resource Name (ARN) of the instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                iam_instance_profile_specification_property = ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(
                    arn="arn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if arn is not None:
                self._values["arn"] = arn

        @builtins.property
        def arn(self) -> typing.Optional[builtins.str]:
            '''The Amazon Resource Name (ARN) of the instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-iaminstanceprofilespecification.html#cfn-ec2-spotfleet-iaminstanceprofilespecification-arn
            '''
            result = self._values.get("arn")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "IamInstanceProfileSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.InstanceIpv6AddressProperty",
        jsii_struct_bases=[],
        name_mapping={"ipv6_address": "ipv6Address"},
    )
    class InstanceIpv6AddressProperty:
        def __init__(self, *, ipv6_address: builtins.str) -> None:
            '''Describes an IPv6 address.

            :param ipv6_address: The IPv6 address.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_ipv6_address_property = ec2.CfnSpotFleet.InstanceIpv6AddressProperty(
                    ipv6_address="ipv6Address"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "ipv6_address": ipv6_address,
            }

        @builtins.property
        def ipv6_address(self) -> builtins.str:
            '''The IPv6 address.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instanceipv6address.html#cfn-ec2-spotfleet-instanceipv6address-ipv6address
            '''
            result = self._values.get("ipv6_address")
            assert result is not None, "Required property 'ipv6_address' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceIpv6AddressProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "associate_public_ip_address": "associatePublicIpAddress",
            "delete_on_termination": "deleteOnTermination",
            "description": "description",
            "device_index": "deviceIndex",
            "groups": "groups",
            "ipv6_address_count": "ipv6AddressCount",
            "ipv6_addresses": "ipv6Addresses",
            "network_interface_id": "networkInterfaceId",
            "private_ip_addresses": "privateIpAddresses",
            "secondary_private_ip_address_count": "secondaryPrivateIpAddressCount",
            "subnet_id": "subnetId",
        },
    )
    class InstanceNetworkInterfaceSpecificationProperty:
        def __init__(
            self,
            *,
            associate_public_ip_address: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            delete_on_termination: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            description: typing.Optional[builtins.str] = None,
            device_index: typing.Optional[jsii.Number] = None,
            groups: typing.Optional[typing.Sequence[builtins.str]] = None,
            ipv6_address_count: typing.Optional[jsii.Number] = None,
            ipv6_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]] = None,
            network_interface_id: typing.Optional[builtins.str] = None,
            private_ip_addresses: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            secondary_private_ip_address_count: typing.Optional[jsii.Number] = None,
            subnet_id: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes a network interface.

            :param associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is ``true`` .
            :param delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
            :param description: The description of the network interface. Applies only if creating a network interface when launching an instance.
            :param device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0. If you specify a network interface when launching an instance, you must specify the device index.
            :param groups: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
            :param ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
            :param ipv6_addresses: One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
            :param network_interface_id: The ID of the network interface. If you are creating a Spot Fleet, omit this parameter because you canâ€™t specify a network interface ID in a launch specification.
            :param private_ip_addresses: One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.
            :param secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.
            :param subnet_id: The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_network_interface_specification_property = ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(
                    associate_public_ip_address=False,
                    delete_on_termination=False,
                    description="description",
                    device_index=123,
                    groups=["groups"],
                    ipv6_address_count=123,
                    ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(
                        ipv6_address="ipv6Address"
                    )],
                    network_interface_id="networkInterfaceId",
                    private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(
                        private_ip_address="privateIpAddress",
                
                        # the properties below are optional
                        primary=False
                    )],
                    secondary_private_ip_address_count=123,
                    subnet_id="subnetId"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if associate_public_ip_address is not None:
                self._values["associate_public_ip_address"] = associate_public_ip_address
            if delete_on_termination is not None:
                self._values["delete_on_termination"] = delete_on_termination
            if description is not None:
                self._values["description"] = description
            if device_index is not None:
                self._values["device_index"] = device_index
            if groups is not None:
                self._values["groups"] = groups
            if ipv6_address_count is not None:
                self._values["ipv6_address_count"] = ipv6_address_count
            if ipv6_addresses is not None:
                self._values["ipv6_addresses"] = ipv6_addresses
            if network_interface_id is not None:
                self._values["network_interface_id"] = network_interface_id
            if private_ip_addresses is not None:
                self._values["private_ip_addresses"] = private_ip_addresses
            if secondary_private_ip_address_count is not None:
                self._values["secondary_private_ip_address_count"] = secondary_private_ip_address_count
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id

        @builtins.property
        def associate_public_ip_address(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.

            The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is ``true`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-associatepublicipaddress
            '''
            result = self._values.get("associate_public_ip_address")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def delete_on_termination(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the network interface is deleted when the instance is terminated.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deleteontermination
            '''
            result = self._values.get("delete_on_termination")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def description(self) -> typing.Optional[builtins.str]:
            '''The description of the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-description
            '''
            result = self._values.get("description")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def device_index(self) -> typing.Optional[jsii.Number]:
            '''The position of the network interface in the attachment order.

            A primary network interface has a device index of 0.

            If you specify a network interface when launching an instance, you must specify the device index.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-deviceindex
            '''
            result = self._values.get("device_index")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def groups(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The IDs of the security groups for the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-groups
            '''
            result = self._values.get("groups")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def ipv6_address_count(self) -> typing.Optional[jsii.Number]:
            '''A number of IPv6 addresses to assign to the network interface.

            Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresscount
            '''
            result = self._values.get("ipv6_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def ipv6_addresses(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]]:
            '''One or more IPv6 addresses to assign to the network interface.

            You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-ipv6addresses
            '''
            result = self._values.get("ipv6_addresses")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.InstanceIpv6AddressProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def network_interface_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the network interface.

            If you are creating a Spot Fleet, omit this parameter because you canâ€™t specify a network interface ID in a launch specification.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-networkinterfaceid
            '''
            result = self._values.get("network_interface_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def private_ip_addresses(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''One or more private IPv4 addresses to assign to the network interface.

            Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-privateipaddresses
            '''
            result = self._values.get("private_ip_addresses")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.PrivateIpAddressSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def secondary_private_ip_address_count(self) -> typing.Optional[jsii.Number]:
            '''The number of secondary private IPv4 addresses.

            You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a `RunInstances <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html>`_ request.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-secondaryprivateipaddresscount
            '''
            result = self._values.get("secondary_private_ip_address_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet associated with the network interface.

            Applies only if creating a network interface when launching an instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancenetworkinterfacespecification.html#cfn-ec2-spotfleet-instancenetworkinterfacespecification-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceNetworkInterfaceSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.InstanceRequirementsRequestProperty",
        jsii_struct_bases=[],
        name_mapping={
            "accelerator_count": "acceleratorCount",
            "accelerator_manufacturers": "acceleratorManufacturers",
            "accelerator_names": "acceleratorNames",
            "accelerator_total_memory_mib": "acceleratorTotalMemoryMiB",
            "accelerator_types": "acceleratorTypes",
            "bare_metal": "bareMetal",
            "baseline_ebs_bandwidth_mbps": "baselineEbsBandwidthMbps",
            "burstable_performance": "burstablePerformance",
            "cpu_manufacturers": "cpuManufacturers",
            "excluded_instance_types": "excludedInstanceTypes",
            "instance_generations": "instanceGenerations",
            "local_storage": "localStorage",
            "local_storage_types": "localStorageTypes",
            "memory_gib_per_v_cpu": "memoryGiBPerVCpu",
            "memory_mib": "memoryMiB",
            "network_interface_count": "networkInterfaceCount",
            "on_demand_max_price_percentage_over_lowest_price": "onDemandMaxPricePercentageOverLowestPrice",
            "require_hibernate_support": "requireHibernateSupport",
            "spot_max_price_percentage_over_lowest_price": "spotMaxPricePercentageOverLowestPrice",
            "total_local_storage_gb": "totalLocalStorageGb",
            "v_cpu_count": "vCpuCount",
        },
    )
    class InstanceRequirementsRequestProperty:
        def __init__(
            self,
            *,
            accelerator_count: typing.Optional[typing.Union["CfnSpotFleet.AcceleratorCountRequestProperty", _IResolvable_da3f097b]] = None,
            accelerator_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_names: typing.Optional[typing.Sequence[builtins.str]] = None,
            accelerator_total_memory_mib: typing.Optional[typing.Union["CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty", _IResolvable_da3f097b]] = None,
            accelerator_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            bare_metal: typing.Optional[builtins.str] = None,
            baseline_ebs_bandwidth_mbps: typing.Optional[typing.Union["CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty", _IResolvable_da3f097b]] = None,
            burstable_performance: typing.Optional[builtins.str] = None,
            cpu_manufacturers: typing.Optional[typing.Sequence[builtins.str]] = None,
            excluded_instance_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            instance_generations: typing.Optional[typing.Sequence[builtins.str]] = None,
            local_storage: typing.Optional[builtins.str] = None,
            local_storage_types: typing.Optional[typing.Sequence[builtins.str]] = None,
            memory_gib_per_v_cpu: typing.Optional[typing.Union["CfnSpotFleet.MemoryGiBPerVCpuRequestProperty", _IResolvable_da3f097b]] = None,
            memory_mib: typing.Optional[typing.Union["CfnSpotFleet.MemoryMiBRequestProperty", _IResolvable_da3f097b]] = None,
            network_interface_count: typing.Optional[typing.Union["CfnSpotFleet.NetworkInterfaceCountRequestProperty", _IResolvable_da3f097b]] = None,
            on_demand_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            require_hibernate_support: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            spot_max_price_percentage_over_lowest_price: typing.Optional[jsii.Number] = None,
            total_local_storage_gb: typing.Optional[typing.Union["CfnSpotFleet.TotalLocalStorageGBRequestProperty", _IResolvable_da3f097b]] = None,
            v_cpu_count: typing.Optional[typing.Union["CfnSpotFleet.VCpuCountRangeRequestProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.

            When you specify multiple parameters, you get instance types that satisfy all of the specified parameters. If you specify multiple values for a parameter, you get instance types that satisfy any of the specified values.
            .. epigraph::

               You must specify ``VCpuCount`` and ``MemoryMiB`` . All other parameters are optional. Any unspecified optional parameter is set to its default.

            For more information, see `Attribute-based instance type selection for EC2 Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html>`_ , `Attribute-based instance type selection for Spot Fleet <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html>`_ , and `Spot placement score <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html>`_ in the *Amazon EC2 User Guide* .

            :param accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance. To exclude accelerator-enabled instance types, set ``Max`` to ``0`` . Default: No minimum or maximum limits
            :param accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers. - For instance types with NVIDIA devices, specify ``nvidia`` . - For instance types with AMD devices, specify ``amd`` . - For instance types with AWS devices, specify ``amazon-web-services`` . - For instance types with Xilinx devices, specify ``xilinx`` . Default: Any manufacturer
            :param accelerator_names: The accelerators that must be on the instance type. - For instance types with NVIDIA A100 GPUs, specify ``a100`` . - For instance types with NVIDIA V100 GPUs, specify ``v100`` . - For instance types with NVIDIA K80 GPUs, specify ``k80`` . - For instance types with NVIDIA T4 GPUs, specify ``t4`` . - For instance types with NVIDIA M60 GPUs, specify ``m60`` . - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` . - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` . Default: Any accelerator
            :param accelerator_total_memory_mib: The minimum and maximum amount of total accelerator memory, in MiB. Default: No minimum or maximum limits
            :param accelerator_types: The accelerator types that must be on the instance type. - To include instance types with GPU hardware, specify ``gpu`` . - To include instance types with FPGA hardware, specify ``fpga`` . - To include instance types with inference hardware, specify ``inference`` . Default: Any accelerator type
            :param bare_metal: Indicates whether bare metal instance types must be included, excluded, or required. - To include bare metal instance types, specify ``included`` . - To require only bare metal instance types, specify ``required`` . - To exclude bare metal instance types, specify ``excluded`` . Default: ``excluded``
            :param baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* . Default: No minimum or maximum limits
            :param burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ . - To include burstable performance instance types, specify ``included`` . - To require only burstable performance instance types, specify ``required`` . - To exclude burstable performance instance types, specify ``excluded`` . Default: ``excluded``
            :param cpu_manufacturers: The CPU manufacturers to include. - For instance types with Intel CPUs, specify ``intel`` . - For instance types with AMD CPUs, specify ``amd`` . - For instance types with AWS CPUs, specify ``amazon-web-services`` . .. epigraph:: Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. Default: Any manufacturer
            :param excluded_instance_types: The instance types to exclude. You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` . For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types. Default: No excluded instance types
            :param instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* . For current generation instance types, specify ``current`` . For previous generation instance types, specify ``previous`` . Default: Current and previous generation instance types
            :param local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* . - To include instance types with instance store volumes, specify ``included`` . - To require only instance types with instance store volumes, specify ``required`` . - To exclude instance types with instance store volumes, specify ``excluded`` . Default: ``included``
            :param local_storage_types: The type of local storage that is required. - For instance types with hard disk drive (HDD) storage, specify ``hdd`` . - For instance types with solid state drive (SDD) storage, specify ``sdd`` . Default: ``hdd`` and ``sdd``
            :param memory_gib_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB. Default: No minimum or maximum limits
            :param memory_mib: The minimum and maximum amount of memory, in MiB.
            :param network_interface_count: The minimum and maximum number of network interfaces. Default: No minimum or maximum limits
            :param on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances. This is the maximum youâ€™ll pay for an On-Demand Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``20``
            :param require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances. This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ . Default: ``false``
            :param spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instance. This is the maximum youâ€™ll pay for an Spot Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. To turn off price protection, specify a high value, such as ``999999`` . This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ . .. epigraph:: If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. Default: ``100``
            :param total_local_storage_gb: The minimum and maximum amount of total local storage, in GB. Default: No minimum or maximum limits
            :param v_cpu_count: The minimum and maximum number of vCPUs.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                instance_requirements_request_property = ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                    accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_manufacturers=["acceleratorManufacturers"],
                    accelerator_names=["acceleratorNames"],
                    accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    accelerator_types=["acceleratorTypes"],
                    bare_metal="bareMetal",
                    baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                        max=123,
                        min=123
                    ),
                    burstable_performance="burstablePerformance",
                    cpu_manufacturers=["cpuManufacturers"],
                    excluded_instance_types=["excludedInstanceTypes"],
                    instance_generations=["instanceGenerations"],
                    local_storage="localStorage",
                    local_storage_types=["localStorageTypes"],
                    memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                        max=123,
                        min=123
                    ),
                    memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                        max=123,
                        min=123
                    ),
                    network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                        max=123,
                        min=123
                    ),
                    on_demand_max_price_percentage_over_lowest_price=123,
                    require_hibernate_support=False,
                    spot_max_price_percentage_over_lowest_price=123,
                    total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                        max=123,
                        min=123
                    ),
                    v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                        max=123,
                        min=123
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if accelerator_count is not None:
                self._values["accelerator_count"] = accelerator_count
            if accelerator_manufacturers is not None:
                self._values["accelerator_manufacturers"] = accelerator_manufacturers
            if accelerator_names is not None:
                self._values["accelerator_names"] = accelerator_names
            if accelerator_total_memory_mib is not None:
                self._values["accelerator_total_memory_mib"] = accelerator_total_memory_mib
            if accelerator_types is not None:
                self._values["accelerator_types"] = accelerator_types
            if bare_metal is not None:
                self._values["bare_metal"] = bare_metal
            if baseline_ebs_bandwidth_mbps is not None:
                self._values["baseline_ebs_bandwidth_mbps"] = baseline_ebs_bandwidth_mbps
            if burstable_performance is not None:
                self._values["burstable_performance"] = burstable_performance
            if cpu_manufacturers is not None:
                self._values["cpu_manufacturers"] = cpu_manufacturers
            if excluded_instance_types is not None:
                self._values["excluded_instance_types"] = excluded_instance_types
            if instance_generations is not None:
                self._values["instance_generations"] = instance_generations
            if local_storage is not None:
                self._values["local_storage"] = local_storage
            if local_storage_types is not None:
                self._values["local_storage_types"] = local_storage_types
            if memory_gib_per_v_cpu is not None:
                self._values["memory_gib_per_v_cpu"] = memory_gib_per_v_cpu
            if memory_mib is not None:
                self._values["memory_mib"] = memory_mib
            if network_interface_count is not None:
                self._values["network_interface_count"] = network_interface_count
            if on_demand_max_price_percentage_over_lowest_price is not None:
                self._values["on_demand_max_price_percentage_over_lowest_price"] = on_demand_max_price_percentage_over_lowest_price
            if require_hibernate_support is not None:
                self._values["require_hibernate_support"] = require_hibernate_support
            if spot_max_price_percentage_over_lowest_price is not None:
                self._values["spot_max_price_percentage_over_lowest_price"] = spot_max_price_percentage_over_lowest_price
            if total_local_storage_gb is not None:
                self._values["total_local_storage_gb"] = total_local_storage_gb
            if v_cpu_count is not None:
                self._values["v_cpu_count"] = v_cpu_count

        @builtins.property
        def accelerator_count(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.AcceleratorCountRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

            To exclude accelerator-enabled instance types, set ``Max`` to ``0`` .

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratorcount
            '''
            result = self._values.get("accelerator_count")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.AcceleratorCountRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def accelerator_manufacturers(
            self,
        ) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether instance types must have accelerators by specific manufacturers.

            - For instance types with NVIDIA devices, specify ``nvidia`` .
            - For instance types with AMD devices, specify ``amd`` .
            - For instance types with AWS devices, specify ``amazon-web-services`` .
            - For instance types with Xilinx devices, specify ``xilinx`` .

            Default: Any manufacturer

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratormanufacturers
            '''
            result = self._values.get("accelerator_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_names(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerators that must be on the instance type.

            - For instance types with NVIDIA A100 GPUs, specify ``a100`` .
            - For instance types with NVIDIA V100 GPUs, specify ``v100`` .
            - For instance types with NVIDIA K80 GPUs, specify ``k80`` .
            - For instance types with NVIDIA T4 GPUs, specify ``t4`` .
            - For instance types with NVIDIA M60 GPUs, specify ``m60`` .
            - For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520`` .
            - For instance types with Xilinx VU9P FPGAs, specify ``vu9p`` .

            Default: Any accelerator

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratornames
            '''
            result = self._values.get("accelerator_names")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def accelerator_total_memory_mib(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of total accelerator memory, in MiB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortotalmemorymib
            '''
            result = self._values.get("accelerator_total_memory_mib")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def accelerator_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The accelerator types that must be on the instance type.

            - To include instance types with GPU hardware, specify ``gpu`` .
            - To include instance types with FPGA hardware, specify ``fpga`` .
            - To include instance types with inference hardware, specify ``inference`` .

            Default: Any accelerator type

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-acceleratortypes
            '''
            result = self._values.get("accelerator_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def bare_metal(self) -> typing.Optional[builtins.str]:
            '''Indicates whether bare metal instance types must be included, excluded, or required.

            - To include bare metal instance types, specify ``included`` .
            - To require only bare metal instance types, specify ``required`` .
            - To exclude bare metal instance types, specify ``excluded`` .

            Default: ``excluded``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baremetal
            '''
            result = self._values.get("bare_metal")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def baseline_ebs_bandwidth_mbps(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.

            For more information, see `Amazon EBSâ€“optimized instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html>`_ in the *Amazon EC2 User Guide* .

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-baselineebsbandwidthmbps
            '''
            result = self._values.get("baseline_ebs_bandwidth_mbps")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def burstable_performance(self) -> typing.Optional[builtins.str]:
            '''Indicates whether burstable performance T instance types are included, excluded, or required.

            For more information, see `Burstable performance instances <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html>`_ .

            - To include burstable performance instance types, specify ``included`` .
            - To require only burstable performance instance types, specify ``required`` .
            - To exclude burstable performance instance types, specify ``excluded`` .

            Default: ``excluded``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-burstableperformance
            '''
            result = self._values.get("burstable_performance")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def cpu_manufacturers(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The CPU manufacturers to include.

            - For instance types with Intel CPUs, specify ``intel`` .
            - For instance types with AMD CPUs, specify ``amd`` .
            - For instance types with AWS CPUs, specify ``amazon-web-services`` .

            .. epigraph::

               Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.

            Default: Any manufacturer

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-cpumanufacturers
            '''
            result = self._values.get("cpu_manufacturers")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def excluded_instance_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The instance types to exclude.

            You can use strings with one or more wild cards, represented by an asterisk ( ``*`` ), to exclude an instance family, type, size, or generation. The following are examples: ``m5.8xlarge`` , ``c5*.*`` , ``m5a.*`` , ``r*`` , ``*3*`` .

            For example, if you specify ``c5*`` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*`` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

            Default: No excluded instance types

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-excludedinstancetypes
            '''
            result = self._values.get("excluded_instance_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def instance_generations(self) -> typing.Optional[typing.List[builtins.str]]:
            '''Indicates whether current or previous generation instance types are included.

            The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see `Instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html>`_ in the *Amazon EC2 User Guide* .

            For current generation instance types, specify ``current`` .

            For previous generation instance types, specify ``previous`` .

            Default: Current and previous generation instance types

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-instancegenerations
            '''
            result = self._values.get("instance_generations")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def local_storage(self) -> typing.Optional[builtins.str]:
            '''Indicates whether instance types with instance store volumes are included, excluded, or required.

            For more information, `Amazon EC2 instance store <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html>`_ in the *Amazon EC2 User Guide* .

            - To include instance types with instance store volumes, specify ``included`` .
            - To require only instance types with instance store volumes, specify ``required`` .
            - To exclude instance types with instance store volumes, specify ``excluded`` .

            Default: ``included``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstorage
            '''
            result = self._values.get("local_storage")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def local_storage_types(self) -> typing.Optional[typing.List[builtins.str]]:
            '''The type of local storage that is required.

            - For instance types with hard disk drive (HDD) storage, specify ``hdd`` .
            - For instance types with solid state drive (SDD) storage, specify ``sdd`` .

            Default: ``hdd`` and ``sdd``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-localstoragetypes
            '''
            result = self._values.get("local_storage_types")
            return typing.cast(typing.Optional[typing.List[builtins.str]], result)

        @builtins.property
        def memory_gib_per_v_cpu(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.MemoryGiBPerVCpuRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorygibpervcpu
            '''
            result = self._values.get("memory_gib_per_v_cpu")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.MemoryGiBPerVCpuRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def memory_mib(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.MemoryMiBRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of memory, in MiB.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-memorymib
            '''
            result = self._values.get("memory_mib")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.MemoryMiBRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def network_interface_count(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.NetworkInterfaceCountRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of network interfaces.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-networkinterfacecount
            '''
            result = self._values.get("network_interface_count")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.NetworkInterfaceCountRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def on_demand_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''The price protection threshold for On-Demand Instances.

            This is the maximum youâ€™ll pay for an On-Demand Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``20``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-ondemandmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("on_demand_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def require_hibernate_support(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether instance types must support hibernation for On-Demand Instances.

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ .

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-requirehibernatesupport
            '''
            result = self._values.get("require_hibernate_support")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def spot_max_price_percentage_over_lowest_price(
            self,
        ) -> typing.Optional[jsii.Number]:
            '''The price protection threshold for Spot Instance.

            This is the maximum youâ€™ll pay for an Spot Instance, expressed as a percentage above the cheapest M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold.

            The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

            To turn off price protection, specify a high value, such as ``999999`` .

            This parameter is not supported for `GetSpotPlacementScores <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html>`_ and `GetInstanceTypesFromInstanceRequirements <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html>`_ .
            .. epigraph::

               If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib`` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

            Default: ``100``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-spotmaxpricepercentageoverlowestprice
            '''
            result = self._values.get("spot_max_price_percentage_over_lowest_price")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def total_local_storage_gb(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.TotalLocalStorageGBRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum amount of total local storage, in GB.

            Default: No minimum or maximum limits

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-totallocalstoragegb
            '''
            result = self._values.get("total_local_storage_gb")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.TotalLocalStorageGBRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def v_cpu_count(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.VCpuCountRangeRequestProperty", _IResolvable_da3f097b]]:
            '''The minimum and maximum number of vCPUs.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-instancerequirementsrequest.html#cfn-ec2-spotfleet-instancerequirementsrequest-vcpucount
            '''
            result = self._values.get("v_cpu_count")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.VCpuCountRangeRequestProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "InstanceRequirementsRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.LaunchTemplateConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "launch_template_specification": "launchTemplateSpecification",
            "overrides": "overrides",
        },
    )
    class LaunchTemplateConfigProperty:
        def __init__(
            self,
            *,
            launch_template_specification: typing.Optional[typing.Union["CfnSpotFleet.FleetLaunchTemplateSpecificationProperty", _IResolvable_da3f097b]] = None,
            overrides: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.LaunchTemplateOverridesProperty", _IResolvable_da3f097b]]]] = None,
        ) -> None:
            '''Specifies a launch template and overrides.

            :param launch_template_specification: The launch template.
            :param overrides: Any parameters that you specify override the same parameters in the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                launch_template_config_property = ec2.CfnSpotFleet.LaunchTemplateConfigProperty(
                    launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(
                        version="version",
                
                        # the properties below are optional
                        launch_template_id="launchTemplateId",
                        launch_template_name="launchTemplateName"
                    ),
                    overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(
                        availability_zone="availabilityZone",
                        instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        priority=123,
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        weighted_capacity=123
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if launch_template_specification is not None:
                self._values["launch_template_specification"] = launch_template_specification
            if overrides is not None:
                self._values["overrides"] = overrides

        @builtins.property
        def launch_template_specification(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.FleetLaunchTemplateSpecificationProperty", _IResolvable_da3f097b]]:
            '''The launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-launchtemplatespecification
            '''
            result = self._values.get("launch_template_specification")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.FleetLaunchTemplateSpecificationProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def overrides(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.LaunchTemplateOverridesProperty", _IResolvable_da3f097b]]]]:
            '''Any parameters that you specify override the same parameters in the launch template.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html#cfn-ec2-spotfleet-launchtemplateconfig-overrides
            '''
            result = self._values.get("overrides")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.LaunchTemplateOverridesProperty", _IResolvable_da3f097b]]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.LaunchTemplateOverridesProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "priority": "priority",
            "spot_price": "spotPrice",
            "subnet_id": "subnetId",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class LaunchTemplateOverridesProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            instance_requirements: typing.Optional[typing.Union["CfnSpotFleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            priority: typing.Optional[jsii.Number] = None,
            spot_price: typing.Optional[builtins.str] = None,
            subnet_id: typing.Optional[builtins.str] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies overrides for a launch template.

            :param availability_zone: The Availability Zone in which to launch the instances.
            :param instance_requirements: The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceTypes`` .
            :param instance_type: The instance type.
            :param priority: The priority for the launch template override. The highest priority is launched first. If ``OnDemandAllocationStrategy`` is set to ``prioritized`` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. If the Spot ``AllocationStrategy`` is set to ``capacityOptimizedPrioritized`` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first. Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
            :param spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance.
            :param subnet_id: The ID of the subnet in which to launch the instances.
            :param weighted_capacity: The number of units provided by the specified instance type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                launch_template_overrides_property = ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(
                    availability_zone="availabilityZone",
                    instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    priority=123,
                    spot_price="spotPrice",
                    subnet_id="subnetId",
                    weighted_capacity=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if priority is not None:
                self._values["priority"] = priority
            if spot_price is not None:
                self._values["spot_price"] = spot_price
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone in which to launch the instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]]:
            '''The instance requirements.

            When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceTypes`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def priority(self) -> typing.Optional[jsii.Number]:
            '''The priority for the launch template override. The highest priority is launched first.

            If ``OnDemandAllocationStrategy`` is set to ``prioritized`` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

            If the Spot ``AllocationStrategy`` is set to ``capacityOptimizedPrioritized`` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

            Valid values are whole numbers starting at ``0`` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-priority
            '''
            result = self._values.get("priority")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def spot_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-spotprice
            '''
            result = self._values.get("spot_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the subnet in which to launch the instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units provided by the specified instance type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateoverrides.html#cfn-ec2-spotfleet-launchtemplateoverrides-weightedcapacity
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LaunchTemplateOverridesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.LoadBalancersConfigProperty",
        jsii_struct_bases=[],
        name_mapping={
            "classic_load_balancers_config": "classicLoadBalancersConfig",
            "target_groups_config": "targetGroupsConfig",
        },
    )
    class LoadBalancersConfigProperty:
        def __init__(
            self,
            *,
            classic_load_balancers_config: typing.Optional[typing.Union["CfnSpotFleet.ClassicLoadBalancersConfigProperty", _IResolvable_da3f097b]] = None,
            target_groups_config: typing.Optional[typing.Union["CfnSpotFleet.TargetGroupsConfigProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Specifies the Classic Load Balancers and target groups to attach to a Spot Fleet request.

            :param classic_load_balancers_config: The Classic Load Balancers.
            :param target_groups_config: The target groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                load_balancers_config_property = ec2.CfnSpotFleet.LoadBalancersConfigProperty(
                    classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(
                        classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(
                            name="name"
                        )]
                    ),
                    target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(
                        target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(
                            arn="arn"
                        )]
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if classic_load_balancers_config is not None:
                self._values["classic_load_balancers_config"] = classic_load_balancers_config
            if target_groups_config is not None:
                self._values["target_groups_config"] = target_groups_config

        @builtins.property
        def classic_load_balancers_config(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.ClassicLoadBalancersConfigProperty", _IResolvable_da3f097b]]:
            '''The Classic Load Balancers.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-classicloadbalancersconfig
            '''
            result = self._values.get("classic_load_balancers_config")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.ClassicLoadBalancersConfigProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def target_groups_config(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.TargetGroupsConfigProperty", _IResolvable_da3f097b]]:
            '''The target groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-loadbalancersconfig.html#cfn-ec2-spotfleet-loadbalancersconfig-targetgroupsconfig
            '''
            result = self._values.get("target_groups_config")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.TargetGroupsConfigProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "LoadBalancersConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryGiBPerVCpuRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory per vCPU, in GiB.

            :param max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                memory_gi_bPer_vCpu_request_property = ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory per vCPU, in GiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory per vCPU, in GiB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorygibpervcpurequest.html#cfn-ec2-spotfleet-memorygibpervcpurequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryGiBPerVCpuRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.MemoryMiBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class MemoryMiBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of memory, in MiB.

            :param max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                memory_mi_bRequest_property = ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of memory, in MiB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of memory, in MiB.

            To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-memorymibrequest.html#cfn-ec2-spotfleet-memorymibrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "MemoryMiBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class NetworkInterfaceCountRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of network interfaces.

            :param max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                network_interface_count_request_property = ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of network interfaces.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of network interfaces.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-networkinterfacecountrequest.html#cfn-ec2-spotfleet-networkinterfacecountrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "NetworkInterfaceCountRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"private_ip_address": "privateIpAddress", "primary": "primary"},
    )
    class PrivateIpAddressSpecificationProperty:
        def __init__(
            self,
            *,
            private_ip_address: builtins.str,
            primary: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes a secondary private IPv4 address for a network interface.

            :param private_ip_address: The private IPv4 addresses.
            :param primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_ip_address_specification_property = ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(
                    private_ip_address="privateIpAddress",
                
                    # the properties below are optional
                    primary=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "private_ip_address": private_ip_address,
            }
            if primary is not None:
                self._values["primary"] = primary

        @builtins.property
        def private_ip_address(self) -> builtins.str:
            '''The private IPv4 addresses.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-privateipaddress
            '''
            result = self._values.get("private_ip_address")
            assert result is not None, "Required property 'private_ip_address' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def primary(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the private IPv4 address is the primary private IPv4 address.

            Only one IPv4 address can be designated as primary.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-privateipaddressspecification.html#cfn-ec2-spotfleet-privateipaddressspecification-primary
            '''
            result = self._values.get("primary")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateIpAddressSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotCapacityRebalanceProperty",
        jsii_struct_bases=[],
        name_mapping={
            "replacement_strategy": "replacementStrategy",
            "termination_delay": "terminationDelay",
        },
    )
    class SpotCapacityRebalanceProperty:
        def __init__(
            self,
            *,
            replacement_strategy: typing.Optional[builtins.str] = None,
            termination_delay: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

            :param replacement_strategy: The replacement strategy to use. Only available for fleets of type ``maintain`` . ``launch`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running. ``launch-before-terminate`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.
            :param termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance. Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` . Not valid when ``ReplacementStrategy`` is set to ``launch`` . Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_capacity_rebalance_property = ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(
                    replacement_strategy="replacementStrategy",
                    termination_delay=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if replacement_strategy is not None:
                self._values["replacement_strategy"] = replacement_strategy
            if termination_delay is not None:
                self._values["termination_delay"] = termination_delay

        @builtins.property
        def replacement_strategy(self) -> typing.Optional[builtins.str]:
            '''The replacement strategy to use. Only available for fleets of type ``maintain`` .

            ``launch`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

            ``launch-before-terminate`` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in ``TerminationDelay`` ), terminates the instances that received a rebalance notification.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-replacementstrategy
            '''
            result = self._values.get("replacement_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def termination_delay(self) -> typing.Optional[jsii.Number]:
            '''The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

            Required when ``ReplacementStrategy`` is set to ``launch-before-terminate`` .

            Not valid when ``ReplacementStrategy`` is set to ``launch`` .

            Valid values: Minimum value of ``120`` seconds. Maximum value of ``7200`` seconds.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotcapacityrebalance.html#cfn-ec2-spotfleet-spotcapacityrebalance-terminationdelay
            '''
            result = self._values.get("termination_delay")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotCapacityRebalanceProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "image_id": "imageId",
            "block_device_mappings": "blockDeviceMappings",
            "ebs_optimized": "ebsOptimized",
            "iam_instance_profile": "iamInstanceProfile",
            "instance_requirements": "instanceRequirements",
            "instance_type": "instanceType",
            "kernel_id": "kernelId",
            "key_name": "keyName",
            "monitoring": "monitoring",
            "network_interfaces": "networkInterfaces",
            "placement": "placement",
            "ramdisk_id": "ramdiskId",
            "security_groups": "securityGroups",
            "spot_price": "spotPrice",
            "subnet_id": "subnetId",
            "tag_specifications": "tagSpecifications",
            "user_data": "userData",
            "weighted_capacity": "weightedCapacity",
        },
    )
    class SpotFleetLaunchSpecificationProperty:
        def __init__(
            self,
            *,
            image_id: builtins.str,
            block_device_mappings: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]] = None,
            ebs_optimized: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            iam_instance_profile: typing.Optional[typing.Union["CfnSpotFleet.IamInstanceProfileSpecificationProperty", _IResolvable_da3f097b]] = None,
            instance_requirements: typing.Optional[typing.Union["CfnSpotFleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]] = None,
            instance_type: typing.Optional[builtins.str] = None,
            kernel_id: typing.Optional[builtins.str] = None,
            key_name: typing.Optional[builtins.str] = None,
            monitoring: typing.Optional[typing.Union["CfnSpotFleet.SpotFleetMonitoringProperty", _IResolvable_da3f097b]] = None,
            network_interfaces: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            placement: typing.Optional[typing.Union["CfnSpotFleet.SpotPlacementProperty", _IResolvable_da3f097b]] = None,
            ramdisk_id: typing.Optional[builtins.str] = None,
            security_groups: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.GroupIdentifierProperty", _IResolvable_da3f097b]]]] = None,
            spot_price: typing.Optional[builtins.str] = None,
            subnet_id: typing.Optional[builtins.str] = None,
            tag_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.SpotFleetTagSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            user_data: typing.Optional[builtins.str] = None,
            weighted_capacity: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''Specifies the launch specification for one or more Spot Instances.

            If you include On-Demand capacity in your fleet request, you can't use ``SpotFleetLaunchSpecification`` ; you must use `LaunchTemplateConfig <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-launchtemplateconfig.html>`_ .

            :param image_id: The ID of the AMI.
            :param block_device_mappings: One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
            :param ebs_optimized: Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance. Default: ``false``
            :param iam_instance_profile: The IAM instance profile.
            :param instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes. .. epigraph:: If you specify ``InstanceRequirements`` , you can't specify ``InstanceTypes`` .
            :param instance_type: The instance type.
            :param kernel_id: The ID of the kernel.
            :param key_name: The name of the key pair.
            :param monitoring: Enable or disable monitoring for the instances.
            :param network_interfaces: One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface. .. epigraph:: ``SpotFleetLaunchSpecification`` currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use `LaunchTemplateConfig <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html>`_ .
            :param placement: The placement information.
            :param ramdisk_id: The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
            :param security_groups: One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.
            :param spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. If this value is not specified, the default is the Spot price specified for the fleet. To determine the Spot price per unit hour, divide the Spot price by the value of ``WeightedCapacity`` .
            :param subnet_id: The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".
            :param tag_specifications: The tags to apply during creation.
            :param user_data: The Base64-encoded user data that instances use when starting up.
            :param weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O. If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_fleet_launch_specification_property = ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(
                    image_id="imageId",
                
                    # the properties below are optional
                    block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(
                        device_name="deviceName",
                
                        # the properties below are optional
                        ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(
                            delete_on_termination=False,
                            encrypted=False,
                            iops=123,
                            snapshot_id="snapshotId",
                            volume_size=123,
                            volume_type="volumeType"
                        ),
                        no_device="noDevice",
                        virtual_name="virtualName"
                    )],
                    ebs_optimized=False,
                    iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(
                        arn="arn"
                    ),
                    instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                        accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_manufacturers=["acceleratorManufacturers"],
                        accelerator_names=["acceleratorNames"],
                        accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        accelerator_types=["acceleratorTypes"],
                        bare_metal="bareMetal",
                        baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                            max=123,
                            min=123
                        ),
                        burstable_performance="burstablePerformance",
                        cpu_manufacturers=["cpuManufacturers"],
                        excluded_instance_types=["excludedInstanceTypes"],
                        instance_generations=["instanceGenerations"],
                        local_storage="localStorage",
                        local_storage_types=["localStorageTypes"],
                        memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                            max=123,
                            min=123
                        ),
                        memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                            max=123,
                            min=123
                        ),
                        network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                            max=123,
                            min=123
                        ),
                        on_demand_max_price_percentage_over_lowest_price=123,
                        require_hibernate_support=False,
                        spot_max_price_percentage_over_lowest_price=123,
                        total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                            max=123,
                            min=123
                        ),
                        v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                            max=123,
                            min=123
                        )
                    ),
                    instance_type="instanceType",
                    kernel_id="kernelId",
                    key_name="keyName",
                    monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(
                        enabled=False
                    ),
                    network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(
                        associate_public_ip_address=False,
                        delete_on_termination=False,
                        description="description",
                        device_index=123,
                        groups=["groups"],
                        ipv6_address_count=123,
                        ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(
                            ipv6_address="ipv6Address"
                        )],
                        network_interface_id="networkInterfaceId",
                        private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(
                            private_ip_address="privateIpAddress",
                
                            # the properties below are optional
                            primary=False
                        )],
                        secondary_private_ip_address_count=123,
                        subnet_id="subnetId"
                    )],
                    placement=ec2.CfnSpotFleet.SpotPlacementProperty(
                        availability_zone="availabilityZone",
                        group_name="groupName",
                        tenancy="tenancy"
                    ),
                    ramdisk_id="ramdiskId",
                    security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(
                        group_id="groupId"
                    )],
                    spot_price="spotPrice",
                    subnet_id="subnetId",
                    tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(
                        resource_type="resourceType",
                        tags=[CfnTag(
                            key="key",
                            value="value"
                        )]
                    )],
                    user_data="userData",
                    weighted_capacity=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "image_id": image_id,
            }
            if block_device_mappings is not None:
                self._values["block_device_mappings"] = block_device_mappings
            if ebs_optimized is not None:
                self._values["ebs_optimized"] = ebs_optimized
            if iam_instance_profile is not None:
                self._values["iam_instance_profile"] = iam_instance_profile
            if instance_requirements is not None:
                self._values["instance_requirements"] = instance_requirements
            if instance_type is not None:
                self._values["instance_type"] = instance_type
            if kernel_id is not None:
                self._values["kernel_id"] = kernel_id
            if key_name is not None:
                self._values["key_name"] = key_name
            if monitoring is not None:
                self._values["monitoring"] = monitoring
            if network_interfaces is not None:
                self._values["network_interfaces"] = network_interfaces
            if placement is not None:
                self._values["placement"] = placement
            if ramdisk_id is not None:
                self._values["ramdisk_id"] = ramdisk_id
            if security_groups is not None:
                self._values["security_groups"] = security_groups
            if spot_price is not None:
                self._values["spot_price"] = spot_price
            if subnet_id is not None:
                self._values["subnet_id"] = subnet_id
            if tag_specifications is not None:
                self._values["tag_specifications"] = tag_specifications
            if user_data is not None:
                self._values["user_data"] = user_data
            if weighted_capacity is not None:
                self._values["weighted_capacity"] = weighted_capacity

        @builtins.property
        def image_id(self) -> builtins.str:
            '''The ID of the AMI.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-imageid
            '''
            result = self._values.get("image_id")
            assert result is not None, "Required property 'image_id' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def block_device_mappings(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]]:
            '''One or more block devices that are mapped to the Spot Instances.

            You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-blockdevicemappings
            '''
            result = self._values.get("block_device_mappings")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.BlockDeviceMappingProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def ebs_optimized(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether the instances are optimized for EBS I/O.

            This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ebsoptimized
            '''
            result = self._values.get("ebs_optimized")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def iam_instance_profile(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.IamInstanceProfileSpecificationProperty", _IResolvable_da3f097b]]:
            '''The IAM instance profile.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-iaminstanceprofile
            '''
            result = self._values.get("iam_instance_profile")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.IamInstanceProfileSpecificationProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_requirements(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]]:
            '''The attributes for the instance types.

            When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
            .. epigraph::

               If you specify ``InstanceRequirements`` , you can't specify ``InstanceTypes`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancerequirements
            '''
            result = self._values.get("instance_requirements")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.InstanceRequirementsRequestProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def instance_type(self) -> typing.Optional[builtins.str]:
            '''The instance type.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-instancetype
            '''
            result = self._values.get("instance_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def kernel_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the kernel.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-kernelid
            '''
            result = self._values.get("kernel_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def key_name(self) -> typing.Optional[builtins.str]:
            '''The name of the key pair.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-keyname
            '''
            result = self._values.get("key_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def monitoring(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.SpotFleetMonitoringProperty", _IResolvable_da3f097b]]:
            '''Enable or disable monitoring for the instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-monitoring
            '''
            result = self._values.get("monitoring")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.SpotFleetMonitoringProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def network_interfaces(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''One or more network interfaces.

            If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.
            .. epigraph::

               ``SpotFleetLaunchSpecification`` currently does not support Elastic Fabric Adapter (EFA). To specify an EFA, you must use `LaunchTemplateConfig <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-networkinterfaces
            '''
            result = self._values.get("network_interfaces")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def placement(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.SpotPlacementProperty", _IResolvable_da3f097b]]:
            '''The placement information.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-placement
            '''
            result = self._values.get("placement")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.SpotPlacementProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def ramdisk_id(self) -> typing.Optional[builtins.str]:
            '''The ID of the RAM disk.

            Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-ramdiskid
            '''
            result = self._values.get("ramdisk_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def security_groups(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.GroupIdentifierProperty", _IResolvable_da3f097b]]]]:
            '''One or more security groups.

            When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-securitygroups
            '''
            result = self._values.get("security_groups")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.GroupIdentifierProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def spot_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            If this value is not specified, the default is the Spot price specified for the fleet. To determine the Spot price per unit hour, divide the Spot price by the value of ``WeightedCapacity`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-spotprice
            '''
            result = self._values.get("spot_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def subnet_id(self) -> typing.Optional[builtins.str]:
            '''The IDs of the subnets in which to launch the instances.

            To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-subnetid
            '''
            result = self._values.get("subnet_id")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tag_specifications(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.SpotFleetTagSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''The tags to apply during creation.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-tagspecifications
            '''
            result = self._values.get("tag_specifications")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.SpotFleetTagSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def user_data(self) -> typing.Optional[builtins.str]:
            '''The Base64-encoded user data that instances use when starting up.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-userdata
            '''
            result = self._values.get("user_data")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def weighted_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of units provided by the specified instance type.

            These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

            If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetlaunchspecification.html#cfn-ec2-spotfleet-spotfleetlaunchspecification-weightedcapacity
            '''
            result = self._values.get("weighted_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetLaunchSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotFleetMonitoringProperty",
        jsii_struct_bases=[],
        name_mapping={"enabled": "enabled"},
    )
    class SpotFleetMonitoringProperty:
        def __init__(
            self,
            *,
            enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ) -> None:
            '''Describes whether monitoring is enabled.

            :param enabled: Enables monitoring for the instance. Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_fleet_monitoring_property = ec2.CfnSpotFleet.SpotFleetMonitoringProperty(
                    enabled=False
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enabled is not None:
                self._values["enabled"] = enabled

        @builtins.property
        def enabled(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Enables monitoring for the instance.

            Default: ``false``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetmonitoring.html#cfn-ec2-spotfleet-spotfleetmonitoring-enabled
            '''
            result = self._values.get("enabled")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetMonitoringProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty",
        jsii_struct_bases=[],
        name_mapping={
            "iam_fleet_role": "iamFleetRole",
            "target_capacity": "targetCapacity",
            "allocation_strategy": "allocationStrategy",
            "context": "context",
            "excess_capacity_termination_policy": "excessCapacityTerminationPolicy",
            "instance_interruption_behavior": "instanceInterruptionBehavior",
            "instance_pools_to_use_count": "instancePoolsToUseCount",
            "launch_specifications": "launchSpecifications",
            "launch_template_configs": "launchTemplateConfigs",
            "load_balancers_config": "loadBalancersConfig",
            "on_demand_allocation_strategy": "onDemandAllocationStrategy",
            "on_demand_max_total_price": "onDemandMaxTotalPrice",
            "on_demand_target_capacity": "onDemandTargetCapacity",
            "replace_unhealthy_instances": "replaceUnhealthyInstances",
            "spot_maintenance_strategies": "spotMaintenanceStrategies",
            "spot_max_total_price": "spotMaxTotalPrice",
            "spot_price": "spotPrice",
            "target_capacity_unit_type": "targetCapacityUnitType",
            "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
            "type": "type",
            "valid_from": "validFrom",
            "valid_until": "validUntil",
        },
    )
    class SpotFleetRequestConfigDataProperty:
        def __init__(
            self,
            *,
            iam_fleet_role: builtins.str,
            target_capacity: jsii.Number,
            allocation_strategy: typing.Optional[builtins.str] = None,
            context: typing.Optional[builtins.str] = None,
            excess_capacity_termination_policy: typing.Optional[builtins.str] = None,
            instance_interruption_behavior: typing.Optional[builtins.str] = None,
            instance_pools_to_use_count: typing.Optional[jsii.Number] = None,
            launch_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.SpotFleetLaunchSpecificationProperty", _IResolvable_da3f097b]]]] = None,
            launch_template_configs: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.LaunchTemplateConfigProperty", _IResolvable_da3f097b]]]] = None,
            load_balancers_config: typing.Optional[typing.Union["CfnSpotFleet.LoadBalancersConfigProperty", _IResolvable_da3f097b]] = None,
            on_demand_allocation_strategy: typing.Optional[builtins.str] = None,
            on_demand_max_total_price: typing.Optional[builtins.str] = None,
            on_demand_target_capacity: typing.Optional[jsii.Number] = None,
            replace_unhealthy_instances: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            spot_maintenance_strategies: typing.Optional[typing.Union["CfnSpotFleet.SpotMaintenanceStrategiesProperty", _IResolvable_da3f097b]] = None,
            spot_max_total_price: typing.Optional[builtins.str] = None,
            spot_price: typing.Optional[builtins.str] = None,
            target_capacity_unit_type: typing.Optional[builtins.str] = None,
            terminate_instances_with_expiration: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            type: typing.Optional[builtins.str] = None,
            valid_from: typing.Optional[builtins.str] = None,
            valid_until: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Specifies the configuration of a Spot Fleet request.

            For more information, see `How Spot Fleet Works <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

            You must specify either ``LaunchSpecifications`` or ``LaunchTemplateConfigs`` .

            :param iam_fleet_role: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see `Spot Fleet Prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites>`_ in the *Amazon EC2 User Guide for Linux Instances* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set ``TerminateInstancesWithExpiration`` .
            :param target_capacity: The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.
            :param allocation_strategy: Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet request. If the allocation strategy is ``lowestPrice`` , Spot Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy. If the allocation strategy is ``diversified`` , Spot Fleet launches instances from all the Spot Instance pools that you specify. If the allocation strategy is ``capacityOptimized`` (recommended), Spot Fleet launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching. To give certain instance types a higher chance of launching first, use ``capacityOptimizedPrioritized`` . Set a priority for each instance type by using the ``Priority`` parameter for ``LaunchTemplateOverrides`` . You can assign the same priority to different ``LaunchTemplateOverrides`` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. ``capacityOptimizedPrioritized`` is supported only if your Spot Fleet uses a launch template. Note that if the ``OnDemandAllocationStrategy`` is set to ``prioritized`` , the same priority is applied when fulfilling On-Demand capacity.
            :param context: Reserved.
            :param excess_capacity_termination_policy: Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
            :param instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate`` .
            :param instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to ``lowest-price`` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify. Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
            :param launch_specifications: The launch specifications for the Spot Fleet request. If you specify ``LaunchSpecifications`` , you can't specify ``LaunchTemplateConfigs`` .
            :param launch_template_configs: The launch template and overrides. If you specify ``LaunchTemplateConfigs`` , you can't specify ``LaunchSpecifications`` .
            :param load_balancers_config: One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups. With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
            :param on_demand_allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify ``lowestPrice`` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify ``prioritized`` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to ``lowestPrice`` .
            :param on_demand_max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the ``onDemandMaxTotalPrice`` parameter, the ``spotMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnâ€™t met the target capacity.
            :param on_demand_target_capacity: The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.
            :param replace_unhealthy_instances: Indicates whether Spot Fleet should replace unhealthy instances.
            :param spot_maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
            :param spot_max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. You can use the ``spotdMaxTotalPrice`` parameter, the ``onDemandMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnâ€™t met the target capacity.
            :param spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. The default is the On-Demand price.
            :param target_capacity_unit_type: The unit for the target capacity. Default: ``units`` (translates to number of instances)
            :param terminate_instances_with_expiration: Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
            :param type: The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is ``request`` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is ``maintain`` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: ``maintain`` . ``instant`` is listed but is not used by Spot Fleet.
            :param valid_from: The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
            :param valid_until: The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_fleet_request_config_data_property = ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty(
                    iam_fleet_role="iamFleetRole",
                    target_capacity=123,
                
                    # the properties below are optional
                    allocation_strategy="allocationStrategy",
                    context="context",
                    excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    launch_specifications=[ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(
                        image_id="imageId",
                
                        # the properties below are optional
                        block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(
                            device_name="deviceName",
                
                            # the properties below are optional
                            ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(
                                delete_on_termination=False,
                                encrypted=False,
                                iops=123,
                                snapshot_id="snapshotId",
                                volume_size=123,
                                volume_type="volumeType"
                            ),
                            no_device="noDevice",
                            virtual_name="virtualName"
                        )],
                        ebs_optimized=False,
                        iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(
                            arn="arn"
                        ),
                        instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        kernel_id="kernelId",
                        key_name="keyName",
                        monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(
                            enabled=False
                        ),
                        network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(
                            associate_public_ip_address=False,
                            delete_on_termination=False,
                            description="description",
                            device_index=123,
                            groups=["groups"],
                            ipv6_address_count=123,
                            ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(
                                ipv6_address="ipv6Address"
                            )],
                            network_interface_id="networkInterfaceId",
                            private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(
                                private_ip_address="privateIpAddress",
                
                                # the properties below are optional
                                primary=False
                            )],
                            secondary_private_ip_address_count=123,
                            subnet_id="subnetId"
                        )],
                        placement=ec2.CfnSpotFleet.SpotPlacementProperty(
                            availability_zone="availabilityZone",
                            group_name="groupName",
                            tenancy="tenancy"
                        ),
                        ramdisk_id="ramdiskId",
                        security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(
                            group_id="groupId"
                        )],
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(
                            resource_type="resourceType",
                            tags=[CfnTag(
                                key="key",
                                value="value"
                            )]
                        )],
                        user_data="userData",
                        weighted_capacity=123
                    )],
                    launch_template_configs=[ec2.CfnSpotFleet.LaunchTemplateConfigProperty(
                        launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(
                            version="version",
                
                            # the properties below are optional
                            launch_template_id="launchTemplateId",
                            launch_template_name="launchTemplateName"
                        ),
                        overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(
                            availability_zone="availabilityZone",
                            instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                                accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_manufacturers=["acceleratorManufacturers"],
                                accelerator_names=["acceleratorNames"],
                                accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_types=["acceleratorTypes"],
                                bare_metal="bareMetal",
                                baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                burstable_performance="burstablePerformance",
                                cpu_manufacturers=["cpuManufacturers"],
                                excluded_instance_types=["excludedInstanceTypes"],
                                instance_generations=["instanceGenerations"],
                                local_storage="localStorage",
                                local_storage_types=["localStorageTypes"],
                                memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                on_demand_max_price_percentage_over_lowest_price=123,
                                require_hibernate_support=False,
                                spot_max_price_percentage_over_lowest_price=123,
                                total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                                    max=123,
                                    min=123
                                )
                            ),
                            instance_type="instanceType",
                            priority=123,
                            spot_price="spotPrice",
                            subnet_id="subnetId",
                            weighted_capacity=123
                        )]
                    )],
                    load_balancers_config=ec2.CfnSpotFleet.LoadBalancersConfigProperty(
                        classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(
                            classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(
                                name="name"
                            )]
                        ),
                        target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(
                            target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(
                                arn="arn"
                            )]
                        )
                    ),
                    on_demand_allocation_strategy="onDemandAllocationStrategy",
                    on_demand_max_total_price="onDemandMaxTotalPrice",
                    on_demand_target_capacity=123,
                    replace_unhealthy_instances=False,
                    spot_maintenance_strategies=ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(
                        capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    spot_max_total_price="spotMaxTotalPrice",
                    spot_price="spotPrice",
                    target_capacity_unit_type="targetCapacityUnitType",
                    terminate_instances_with_expiration=False,
                    type="type",
                    valid_from="validFrom",
                    valid_until="validUntil"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "iam_fleet_role": iam_fleet_role,
                "target_capacity": target_capacity,
            }
            if allocation_strategy is not None:
                self._values["allocation_strategy"] = allocation_strategy
            if context is not None:
                self._values["context"] = context
            if excess_capacity_termination_policy is not None:
                self._values["excess_capacity_termination_policy"] = excess_capacity_termination_policy
            if instance_interruption_behavior is not None:
                self._values["instance_interruption_behavior"] = instance_interruption_behavior
            if instance_pools_to_use_count is not None:
                self._values["instance_pools_to_use_count"] = instance_pools_to_use_count
            if launch_specifications is not None:
                self._values["launch_specifications"] = launch_specifications
            if launch_template_configs is not None:
                self._values["launch_template_configs"] = launch_template_configs
            if load_balancers_config is not None:
                self._values["load_balancers_config"] = load_balancers_config
            if on_demand_allocation_strategy is not None:
                self._values["on_demand_allocation_strategy"] = on_demand_allocation_strategy
            if on_demand_max_total_price is not None:
                self._values["on_demand_max_total_price"] = on_demand_max_total_price
            if on_demand_target_capacity is not None:
                self._values["on_demand_target_capacity"] = on_demand_target_capacity
            if replace_unhealthy_instances is not None:
                self._values["replace_unhealthy_instances"] = replace_unhealthy_instances
            if spot_maintenance_strategies is not None:
                self._values["spot_maintenance_strategies"] = spot_maintenance_strategies
            if spot_max_total_price is not None:
                self._values["spot_max_total_price"] = spot_max_total_price
            if spot_price is not None:
                self._values["spot_price"] = spot_price
            if target_capacity_unit_type is not None:
                self._values["target_capacity_unit_type"] = target_capacity_unit_type
            if terminate_instances_with_expiration is not None:
                self._values["terminate_instances_with_expiration"] = terminate_instances_with_expiration
            if type is not None:
                self._values["type"] = type
            if valid_from is not None:
                self._values["valid_from"] = valid_from
            if valid_until is not None:
                self._values["valid_until"] = valid_until

        @builtins.property
        def iam_fleet_role(self) -> builtins.str:
            '''The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf.

            For more information, see `Spot Fleet Prerequisites <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites>`_ in the *Amazon EC2 User Guide for Linux Instances* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set ``TerminateInstancesWithExpiration`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-iamfleetrole
            '''
            result = self._values.get("iam_fleet_role")
            assert result is not None, "Required property 'iam_fleet_role' is missing"
            return typing.cast(builtins.str, result)

        @builtins.property
        def target_capacity(self) -> jsii.Number:
            '''The number of units to request for the Spot Fleet.

            You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacity
            '''
            result = self._values.get("target_capacity")
            assert result is not None, "Required property 'target_capacity' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet request.

            If the allocation strategy is ``lowestPrice`` , Spot Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

            If the allocation strategy is ``diversified`` , Spot Fleet launches instances from all the Spot Instance pools that you specify.

            If the allocation strategy is ``capacityOptimized`` (recommended), Spot Fleet launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching. To give certain instance types a higher chance of launching first, use ``capacityOptimizedPrioritized`` . Set a priority for each instance type by using the ``Priority`` parameter for ``LaunchTemplateOverrides`` . You can assign the same priority to different ``LaunchTemplateOverrides`` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. ``capacityOptimizedPrioritized`` is supported only if your Spot Fleet uses a launch template. Note that if the ``OnDemandAllocationStrategy`` is set to ``prioritized`` , the same priority is applied when fulfilling On-Demand capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-allocationstrategy
            '''
            result = self._values.get("allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def context(self) -> typing.Optional[builtins.str]:
            '''Reserved.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-context
            '''
            result = self._values.get("context")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def excess_capacity_termination_policy(self) -> typing.Optional[builtins.str]:
            '''Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-excesscapacityterminationpolicy
            '''
            result = self._values.get("excess_capacity_termination_policy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_interruption_behavior(self) -> typing.Optional[builtins.str]:
            '''The behavior when a Spot Instance is interrupted.

            The default is ``terminate`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instanceinterruptionbehavior
            '''
            result = self._values.get("instance_interruption_behavior")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def instance_pools_to_use_count(self) -> typing.Optional[jsii.Number]:
            '''The number of Spot pools across which to allocate your target Spot capacity.

            Valid only when Spot *AllocationStrategy* is set to ``lowest-price`` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

            Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-instancepoolstousecount
            '''
            result = self._values.get("instance_pools_to_use_count")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def launch_specifications(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.SpotFleetLaunchSpecificationProperty", _IResolvable_da3f097b]]]]:
            '''The launch specifications for the Spot Fleet request.

            If you specify ``LaunchSpecifications`` , you can't specify ``LaunchTemplateConfigs`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchspecifications
            '''
            result = self._values.get("launch_specifications")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.SpotFleetLaunchSpecificationProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def launch_template_configs(
            self,
        ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.LaunchTemplateConfigProperty", _IResolvable_da3f097b]]]]:
            '''The launch template and overrides.

            If you specify ``LaunchTemplateConfigs`` , you can't specify ``LaunchSpecifications`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-launchtemplateconfigs
            '''
            result = self._values.get("launch_template_configs")
            return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.LaunchTemplateConfigProperty", _IResolvable_da3f097b]]]], result)

        @builtins.property
        def load_balancers_config(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.LoadBalancersConfigProperty", _IResolvable_da3f097b]]:
            '''One or more Classic Load Balancers and target groups to attach to the Spot Fleet request.

            Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.

            With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-loadbalancersconfig
            '''
            result = self._values.get("load_balancers_config")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.LoadBalancersConfigProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def on_demand_allocation_strategy(self) -> typing.Optional[builtins.str]:
            '''The order of the launch template overrides to use in fulfilling On-Demand capacity.

            If you specify ``lowestPrice`` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify ``prioritized`` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to ``lowestPrice`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandallocationstrategy
            '''
            result = self._values.get("on_demand_allocation_strategy")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def on_demand_max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for On-Demand Instances that you're willing to pay.

            You can use the ``onDemandMaxTotalPrice`` parameter, the ``spotMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnâ€™t met the target capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandmaxtotalprice
            '''
            result = self._values.get("on_demand_max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def on_demand_target_capacity(self) -> typing.Optional[jsii.Number]:
            '''The number of On-Demand units to request.

            You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is ``maintain`` , you can specify a target capacity of 0 and add capacity later.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-ondemandtargetcapacity
            '''
            result = self._values.get("on_demand_target_capacity")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def replace_unhealthy_instances(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether Spot Fleet should replace unhealthy instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-replaceunhealthyinstances
            '''
            result = self._values.get("replace_unhealthy_instances")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def spot_maintenance_strategies(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.SpotMaintenanceStrategiesProperty", _IResolvable_da3f097b]]:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaintenancestrategies
            '''
            result = self._values.get("spot_maintenance_strategies")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.SpotMaintenanceStrategiesProperty", _IResolvable_da3f097b]], result)

        @builtins.property
        def spot_max_total_price(self) -> typing.Optional[builtins.str]:
            '''The maximum amount per hour for Spot Instances that you're willing to pay.

            You can use the ``spotdMaxTotalPrice`` parameter, the ``onDemandMaxTotalPrice`` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnâ€™t met the target capacity.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotmaxtotalprice
            '''
            result = self._values.get("spot_max_total_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def spot_price(self) -> typing.Optional[builtins.str]:
            '''The maximum price per unit hour that you are willing to pay for a Spot Instance.

            The default is the On-Demand price.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-spotprice
            '''
            result = self._values.get("spot_price")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def target_capacity_unit_type(self) -> typing.Optional[builtins.str]:
            '''The unit for the target capacity.

            Default: ``units`` (translates to number of instances)

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-targetcapacityunittype
            '''
            result = self._values.get("target_capacity_unit_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def terminate_instances_with_expiration(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-terminateinstanceswithexpiration
            '''
            result = self._values.get("terminate_instances_with_expiration")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def type(self) -> typing.Optional[builtins.str]:
            '''The type of request.

            Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is ``request`` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is ``maintain`` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: ``maintain`` . ``instant`` is listed but is not used by Spot Fleet.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-type
            '''
            result = self._values.get("type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_from(self) -> typing.Optional[builtins.str]:
            '''The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

            By default, Amazon EC2 starts fulfilling the request immediately.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validfrom
            '''
            result = self._values.get("valid_from")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def valid_until(self) -> typing.Optional[builtins.str]:
            '''The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z).

            After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleetrequestconfigdata.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata-validuntil
            '''
            result = self._values.get("valid_until")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetRequestConfigDataProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={"resource_type": "resourceType", "tags": "tags"},
    )
    class SpotFleetTagSpecificationProperty:
        def __init__(
            self,
            *,
            resource_type: typing.Optional[builtins.str] = None,
            tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        ) -> None:
            '''The tags for a Spot Fleet resource.

            :param resource_type: The type of resource. Currently, the only resource type that is supported is ``instance`` . To tag the Spot Fleet request on creation, use the ``TagSpecifications`` parameter in ```SpotFleetRequestConfigData`` <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html>`_ .
            :param tags: The tags.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_fleet_tag_specification_property = ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(
                    resource_type="resourceType",
                    tags=[CfnTag(
                        key="key",
                        value="value"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if resource_type is not None:
                self._values["resource_type"] = resource_type
            if tags is not None:
                self._values["tags"] = tags

        @builtins.property
        def resource_type(self) -> typing.Optional[builtins.str]:
            '''The type of resource.

            Currently, the only resource type that is supported is ``instance`` . To tag the Spot Fleet request on creation, use the ``TagSpecifications`` parameter in ```SpotFleetRequestConfigData`` <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html>`_ .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-resourcetype
            '''
            result = self._values.get("resource_type")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
            '''The tags.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotfleettagspecification.html#cfn-ec2-spotfleet-spotfleettagspecification-tags
            '''
            result = self._values.get("tags")
            return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotFleetTagSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty",
        jsii_struct_bases=[],
        name_mapping={"capacity_rebalance": "capacityRebalance"},
    )
    class SpotMaintenanceStrategiesProperty:
        def __init__(
            self,
            *,
            capacity_rebalance: typing.Optional[typing.Union["CfnSpotFleet.SpotCapacityRebalanceProperty", _IResolvable_da3f097b]] = None,
        ) -> None:
            '''The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.

            :param capacity_rebalance: The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_maintenance_strategies_property = ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(
                    capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(
                        replacement_strategy="replacementStrategy",
                        termination_delay=123
                    )
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if capacity_rebalance is not None:
                self._values["capacity_rebalance"] = capacity_rebalance

        @builtins.property
        def capacity_rebalance(
            self,
        ) -> typing.Optional[typing.Union["CfnSpotFleet.SpotCapacityRebalanceProperty", _IResolvable_da3f097b]]:
            '''The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.

            For more information, see `Capacity rebalancing <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html>`_ in the *Amazon EC2 User Guide for Linux Instances* .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotmaintenancestrategies.html#cfn-ec2-spotfleet-spotmaintenancestrategies-capacityrebalance
            '''
            result = self._values.get("capacity_rebalance")
            return typing.cast(typing.Optional[typing.Union["CfnSpotFleet.SpotCapacityRebalanceProperty", _IResolvable_da3f097b]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotMaintenanceStrategiesProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.SpotPlacementProperty",
        jsii_struct_bases=[],
        name_mapping={
            "availability_zone": "availabilityZone",
            "group_name": "groupName",
            "tenancy": "tenancy",
        },
    )
    class SpotPlacementProperty:
        def __init__(
            self,
            *,
            availability_zone: typing.Optional[builtins.str] = None,
            group_name: typing.Optional[builtins.str] = None,
            tenancy: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes Spot Instance placement.

            :param availability_zone: The Availability Zone. To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
            :param group_name: The name of the placement group.
            :param tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for Spot Instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                spot_placement_property = ec2.CfnSpotFleet.SpotPlacementProperty(
                    availability_zone="availabilityZone",
                    group_name="groupName",
                    tenancy="tenancy"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if availability_zone is not None:
                self._values["availability_zone"] = availability_zone
            if group_name is not None:
                self._values["group_name"] = group_name
            if tenancy is not None:
                self._values["tenancy"] = tenancy

        @builtins.property
        def availability_zone(self) -> typing.Optional[builtins.str]:
            '''The Availability Zone.

            To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-availabilityzone
            '''
            result = self._values.get("availability_zone")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def group_name(self) -> typing.Optional[builtins.str]:
            '''The name of the placement group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-groupname
            '''
            result = self._values.get("group_name")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tenancy(self) -> typing.Optional[builtins.str]:
            '''The tenancy of the instance (if the instance is running in a VPC).

            An instance with a tenancy of ``dedicated`` runs on single-tenant hardware. The ``host`` tenancy is not supported for Spot Instances.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-spotplacement.html#cfn-ec2-spotfleet-spotplacement-tenancy
            '''
            result = self._values.get("tenancy")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "SpotPlacementProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.TargetGroupProperty",
        jsii_struct_bases=[],
        name_mapping={"arn": "arn"},
    )
    class TargetGroupProperty:
        def __init__(self, *, arn: builtins.str) -> None:
            '''Describes a load balancer target group.

            :param arn: The Amazon Resource Name (ARN) of the target group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                target_group_property = ec2.CfnSpotFleet.TargetGroupProperty(
                    arn="arn"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "arn": arn,
            }

        @builtins.property
        def arn(self) -> builtins.str:
            '''The Amazon Resource Name (ARN) of the target group.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroup.html#cfn-ec2-spotfleet-targetgroup-arn
            '''
            result = self._values.get("arn")
            assert result is not None, "Required property 'arn' is missing"
            return typing.cast(builtins.str, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TargetGroupProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.TargetGroupsConfigProperty",
        jsii_struct_bases=[],
        name_mapping={"target_groups": "targetGroups"},
    )
    class TargetGroupsConfigProperty:
        def __init__(
            self,
            *,
            target_groups: typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnSpotFleet.TargetGroupProperty", _IResolvable_da3f097b]]],
        ) -> None:
            '''Describes the target groups to attach to a Spot Fleet.

            Spot Fleet registers the running Spot Instances with these target groups.

            :param target_groups: One or more target groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                target_groups_config_property = ec2.CfnSpotFleet.TargetGroupsConfigProperty(
                    target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(
                        arn="arn"
                    )]
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "target_groups": target_groups,
            }

        @builtins.property
        def target_groups(
            self,
        ) -> typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.TargetGroupProperty", _IResolvable_da3f097b]]]:
            '''One or more target groups.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-targetgroupsconfig.html#cfn-ec2-spotfleet-targetgroupsconfig-targetgroups
            '''
            result = self._values.get("target_groups")
            assert result is not None, "Required property 'target_groups' is missing"
            return typing.cast(typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnSpotFleet.TargetGroupProperty", _IResolvable_da3f097b]]], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TargetGroupsConfigProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class TotalLocalStorageGBRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum amount of total local storage, in GB.

            :param max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
            :param min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                total_local_storage_gBRequest_property = ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum amount of total local storage, in GB.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum amount of total local storage, in GB.

            To specify no minimum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-totallocalstoragegbrequest.html#cfn-ec2-spotfleet-totallocalstoragegbrequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TotalLocalStorageGBRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleet.VCpuCountRangeRequestProperty",
        jsii_struct_bases=[],
        name_mapping={"max": "max", "min": "min"},
    )
    class VCpuCountRangeRequestProperty:
        def __init__(
            self,
            *,
            max: typing.Optional[jsii.Number] = None,
            min: typing.Optional[jsii.Number] = None,
        ) -> None:
            '''The minimum and maximum number of vCPUs.

            :param max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
            :param min: The minimum number of vCPUs. To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                v_cpu_count_range_request_property = ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                    max=123,
                    min=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if max is not None:
                self._values["max"] = max
            if min is not None:
                self._values["min"] = min

        @builtins.property
        def max(self) -> typing.Optional[jsii.Number]:
            '''The maximum number of vCPUs.

            To specify no maximum limit, omit this parameter.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-max
            '''
            result = self._values.get("max")
            return typing.cast(typing.Optional[jsii.Number], result)

        @builtins.property
        def min(self) -> typing.Optional[jsii.Number]:
            '''The minimum number of vCPUs.

            To specify no minimum limit, specify ``0`` .

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-spotfleet-vcpucountrangerequest.html#cfn-ec2-spotfleet-vcpucountrangerequest-min
            '''
            result = self._values.get("min")
            return typing.cast(typing.Optional[jsii.Number], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VCpuCountRangeRequestProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSpotFleetProps",
    jsii_struct_bases=[],
    name_mapping={"spot_fleet_request_config_data": "spotFleetRequestConfigData"},
)
class CfnSpotFleetProps:
    def __init__(
        self,
        *,
        spot_fleet_request_config_data: typing.Union[CfnSpotFleet.SpotFleetRequestConfigDataProperty, _IResolvable_da3f097b],
    ) -> None:
        '''Properties for defining a ``CfnSpotFleet``.

        :param spot_fleet_request_config_data: Describes the configuration of a Spot Fleet request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_spot_fleet_props = ec2.CfnSpotFleetProps(
                spot_fleet_request_config_data=ec2.CfnSpotFleet.SpotFleetRequestConfigDataProperty(
                    iam_fleet_role="iamFleetRole",
                    target_capacity=123,
            
                    # the properties below are optional
                    allocation_strategy="allocationStrategy",
                    context="context",
                    excess_capacity_termination_policy="excessCapacityTerminationPolicy",
                    instance_interruption_behavior="instanceInterruptionBehavior",
                    instance_pools_to_use_count=123,
                    launch_specifications=[ec2.CfnSpotFleet.SpotFleetLaunchSpecificationProperty(
                        image_id="imageId",
            
                        # the properties below are optional
                        block_device_mappings=[ec2.CfnSpotFleet.BlockDeviceMappingProperty(
                            device_name="deviceName",
            
                            # the properties below are optional
                            ebs=ec2.CfnSpotFleet.EbsBlockDeviceProperty(
                                delete_on_termination=False,
                                encrypted=False,
                                iops=123,
                                snapshot_id="snapshotId",
                                volume_size=123,
                                volume_type="volumeType"
                            ),
                            no_device="noDevice",
                            virtual_name="virtualName"
                        )],
                        ebs_optimized=False,
                        iam_instance_profile=ec2.CfnSpotFleet.IamInstanceProfileSpecificationProperty(
                            arn="arn"
                        ),
                        instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                            accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_manufacturers=["acceleratorManufacturers"],
                            accelerator_names=["acceleratorNames"],
                            accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            accelerator_types=["acceleratorTypes"],
                            bare_metal="bareMetal",
                            baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                                max=123,
                                min=123
                            ),
                            burstable_performance="burstablePerformance",
                            cpu_manufacturers=["cpuManufacturers"],
                            excluded_instance_types=["excludedInstanceTypes"],
                            instance_generations=["instanceGenerations"],
                            local_storage="localStorage",
                            local_storage_types=["localStorageTypes"],
                            memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                                max=123,
                                min=123
                            ),
                            memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                                max=123,
                                min=123
                            ),
                            network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                                max=123,
                                min=123
                            ),
                            on_demand_max_price_percentage_over_lowest_price=123,
                            require_hibernate_support=False,
                            spot_max_price_percentage_over_lowest_price=123,
                            total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                                max=123,
                                min=123
                            ),
                            v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                                max=123,
                                min=123
                            )
                        ),
                        instance_type="instanceType",
                        kernel_id="kernelId",
                        key_name="keyName",
                        monitoring=ec2.CfnSpotFleet.SpotFleetMonitoringProperty(
                            enabled=False
                        ),
                        network_interfaces=[ec2.CfnSpotFleet.InstanceNetworkInterfaceSpecificationProperty(
                            associate_public_ip_address=False,
                            delete_on_termination=False,
                            description="description",
                            device_index=123,
                            groups=["groups"],
                            ipv6_address_count=123,
                            ipv6_addresses=[ec2.CfnSpotFleet.InstanceIpv6AddressProperty(
                                ipv6_address="ipv6Address"
                            )],
                            network_interface_id="networkInterfaceId",
                            private_ip_addresses=[ec2.CfnSpotFleet.PrivateIpAddressSpecificationProperty(
                                private_ip_address="privateIpAddress",
            
                                # the properties below are optional
                                primary=False
                            )],
                            secondary_private_ip_address_count=123,
                            subnet_id="subnetId"
                        )],
                        placement=ec2.CfnSpotFleet.SpotPlacementProperty(
                            availability_zone="availabilityZone",
                            group_name="groupName",
                            tenancy="tenancy"
                        ),
                        ramdisk_id="ramdiskId",
                        security_groups=[ec2.CfnSpotFleet.GroupIdentifierProperty(
                            group_id="groupId"
                        )],
                        spot_price="spotPrice",
                        subnet_id="subnetId",
                        tag_specifications=[ec2.CfnSpotFleet.SpotFleetTagSpecificationProperty(
                            resource_type="resourceType",
                            tags=[CfnTag(
                                key="key",
                                value="value"
                            )]
                        )],
                        user_data="userData",
                        weighted_capacity=123
                    )],
                    launch_template_configs=[ec2.CfnSpotFleet.LaunchTemplateConfigProperty(
                        launch_template_specification=ec2.CfnSpotFleet.FleetLaunchTemplateSpecificationProperty(
                            version="version",
            
                            # the properties below are optional
                            launch_template_id="launchTemplateId",
                            launch_template_name="launchTemplateName"
                        ),
                        overrides=[ec2.CfnSpotFleet.LaunchTemplateOverridesProperty(
                            availability_zone="availabilityZone",
                            instance_requirements=ec2.CfnSpotFleet.InstanceRequirementsRequestProperty(
                                accelerator_count=ec2.CfnSpotFleet.AcceleratorCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_manufacturers=["acceleratorManufacturers"],
                                accelerator_names=["acceleratorNames"],
                                accelerator_total_memory_mi_b=ec2.CfnSpotFleet.AcceleratorTotalMemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                accelerator_types=["acceleratorTypes"],
                                bare_metal="bareMetal",
                                baseline_ebs_bandwidth_mbps=ec2.CfnSpotFleet.BaselineEbsBandwidthMbpsRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                burstable_performance="burstablePerformance",
                                cpu_manufacturers=["cpuManufacturers"],
                                excluded_instance_types=["excludedInstanceTypes"],
                                instance_generations=["instanceGenerations"],
                                local_storage="localStorage",
                                local_storage_types=["localStorageTypes"],
                                memory_gi_bPer_vCpu=ec2.CfnSpotFleet.MemoryGiBPerVCpuRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                memory_mi_b=ec2.CfnSpotFleet.MemoryMiBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                network_interface_count=ec2.CfnSpotFleet.NetworkInterfaceCountRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                on_demand_max_price_percentage_over_lowest_price=123,
                                require_hibernate_support=False,
                                spot_max_price_percentage_over_lowest_price=123,
                                total_local_storage_gb=ec2.CfnSpotFleet.TotalLocalStorageGBRequestProperty(
                                    max=123,
                                    min=123
                                ),
                                v_cpu_count=ec2.CfnSpotFleet.VCpuCountRangeRequestProperty(
                                    max=123,
                                    min=123
                                )
                            ),
                            instance_type="instanceType",
                            priority=123,
                            spot_price="spotPrice",
                            subnet_id="subnetId",
                            weighted_capacity=123
                        )]
                    )],
                    load_balancers_config=ec2.CfnSpotFleet.LoadBalancersConfigProperty(
                        classic_load_balancers_config=ec2.CfnSpotFleet.ClassicLoadBalancersConfigProperty(
                            classic_load_balancers=[ec2.CfnSpotFleet.ClassicLoadBalancerProperty(
                                name="name"
                            )]
                        ),
                        target_groups_config=ec2.CfnSpotFleet.TargetGroupsConfigProperty(
                            target_groups=[ec2.CfnSpotFleet.TargetGroupProperty(
                                arn="arn"
                            )]
                        )
                    ),
                    on_demand_allocation_strategy="onDemandAllocationStrategy",
                    on_demand_max_total_price="onDemandMaxTotalPrice",
                    on_demand_target_capacity=123,
                    replace_unhealthy_instances=False,
                    spot_maintenance_strategies=ec2.CfnSpotFleet.SpotMaintenanceStrategiesProperty(
                        capacity_rebalance=ec2.CfnSpotFleet.SpotCapacityRebalanceProperty(
                            replacement_strategy="replacementStrategy",
                            termination_delay=123
                        )
                    ),
                    spot_max_total_price="spotMaxTotalPrice",
                    spot_price="spotPrice",
                    target_capacity_unit_type="targetCapacityUnitType",
                    terminate_instances_with_expiration=False,
                    type="type",
                    valid_from="validFrom",
                    valid_until="validUntil"
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "spot_fleet_request_config_data": spot_fleet_request_config_data,
        }

    @builtins.property
    def spot_fleet_request_config_data(
        self,
    ) -> typing.Union[CfnSpotFleet.SpotFleetRequestConfigDataProperty, _IResolvable_da3f097b]:
        '''Describes the configuration of a Spot Fleet request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-spotfleet.html#cfn-ec2-spotfleet-spotfleetrequestconfigdata
        '''
        result = self._values.get("spot_fleet_request_config_data")
        assert result is not None, "Required property 'spot_fleet_request_config_data' is missing"
        return typing.cast(typing.Union[CfnSpotFleet.SpotFleetRequestConfigDataProperty, _IResolvable_da3f097b], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSpotFleetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnSubnet(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnet",
):
    '''A CloudFormation ``AWS::EC2::Subnet``.

    Specifies a subnet for a VPC.

    When you create each subnet, you provide the VPC ID and IPv4 CIDR block for the subnet. After you create a subnet, you can't change its CIDR block. The size of the subnet's IPv4 CIDR block can be the same as a VPC's IPv4 CIDR block, or a subset of a VPC's IPv4 CIDR block. If you create more than one subnet in a VPC, the subnets' CIDR blocks must not overlap. The smallest IPv4 subnet (and VPC) you can create uses a /28 netmask (16 IPv4 addresses), and the largest uses a /16 netmask (65,536 IPv4 addresses).

    If you've associated an IPv6 CIDR block with your VPC, you can create a subnet with an IPv6 CIDR block that uses a /64 prefix length.

    :cloudformationResource: AWS::EC2::Subnet
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_subnet = ec2.CfnSubnet(self, "MyCfnSubnet",
            cidr_block="cidrBlock",
            vpc_id="vpcId",
        
            # the properties below are optional
            assign_ipv6_address_on_creation=False,
            availability_zone="availabilityZone",
            availability_zone_id="availabilityZoneId",
            enable_dns64=False,
            ipv6_cidr_block="ipv6CidrBlock",
            ipv6_native=False,
            map_public_ip_on_launch=False,
            outpost_arn="outpostArn",
            private_dns_name_options_on_launch=ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty(
                enable_resource_name_dns_aaaa_record=False,
                enable_resource_name_dns_aRecord=False,
                hostname_type="hostnameType"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        assign_ipv6_address_on_creation: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        availability_zone_id: typing.Optional[builtins.str] = None,
        enable_dns64: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_native: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        map_public_ip_on_launch: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        private_dns_name_options_on_launch: typing.Optional[typing.Union["CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty", _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::Subnet``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param cidr_block: The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.
        :param vpc_id: The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.
        :param assign_ipv6_address_on_creation: Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` . If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` . If you specify ``AssignIpv6AddressOnCreation`` , you cannot specify ``MapPublicIpOnLaunch`` .
        :param availability_zone: The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.
        :param availability_zone_id: The AZ ID of the subnet.
        :param enable_dns64: Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. For more information, see `DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param ipv6_cidr_block: The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .
        :param ipv6_native: Indicates whether this is an IPv6 only subnet. For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param map_public_ip_on_launch: Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` . If you specify ``MapPublicIpOnLaunch`` , you cannot specify ``AssignIpv6AddressOnCreation`` .
        :param outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param private_dns_name_options_on_launch: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
        :param tags: Any tags assigned to the subnet.
        '''
        props = CfnSubnetProps(
            cidr_block=cidr_block,
            vpc_id=vpc_id,
            assign_ipv6_address_on_creation=assign_ipv6_address_on_creation,
            availability_zone=availability_zone,
            availability_zone_id=availability_zone_id,
            enable_dns64=enable_dns64,
            ipv6_cidr_block=ipv6_cidr_block,
            ipv6_native=ipv6_native,
            map_public_ip_on_launch=map_public_ip_on_launch,
            outpost_arn=outpost_arn,
            private_dns_name_options_on_launch=private_dns_name_options_on_launch,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAvailabilityZone")
    def attr_availability_zone(self) -> builtins.str:
        '''The Availability Zone of this subnet. For example:.

        ``{ "Fn::GetAtt" : [ "mySubnet", "AvailabilityZone" ] }``

        :cloudformationAttribute: AvailabilityZone
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpv6CidrBlocks")
    def attr_ipv6_cidr_blocks(self) -> typing.List[builtins.str]:
        '''The IPv6 CIDR blocks that are associated with the subnet, such as ``[ 2001:db8:1234:1a00::/64 ]`` .

        :cloudformationAttribute: Ipv6CidrBlocks
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "attrIpv6CidrBlocks"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkAclAssociationId")
    def attr_network_acl_association_id(self) -> builtins.str:
        '''The ID of the network ACL that is associated with the subnet's VPC, such as ``acl-5fb85d36`` .

        :cloudformationAttribute: NetworkAclAssociationId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrNetworkAclAssociationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrOutpostArn")
    def attr_outpost_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the Outpost.

        :cloudformationAttribute: OutpostArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrOutpostArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrVpcId")
    def attr_vpc_id(self) -> builtins.str:
        '''The ID of the subnet's VPC, such as ``vpc-11ad4878`` .

        :cloudformationAttribute: VpcId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrVpcId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> builtins.str:
        '''The IPv4 CIDR block assigned to the subnet.

        If you update this property, we create a new subnet, and then delete the existing one.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "cidrBlock"))

    @cidr_block.setter
    def cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "cidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC the subnet is in.

        If you update this property, you must also update the ``CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-awsec2subnet-prop-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="assignIpv6AddressOnCreation")
    def assign_ipv6_address_on_creation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` .

        If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .

        If you specify ``AssignIpv6AddressOnCreation`` , you cannot specify ``MapPublicIpOnLaunch`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "assignIpv6AddressOnCreation"))

    @assign_ipv6_address_on_creation.setter
    def assign_ipv6_address_on_creation(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "assignIpv6AddressOnCreation", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone of the subnet.

        If you update this property, you must also update the ``CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "availabilityZone"))

    @availability_zone.setter
    def availability_zone(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "availabilityZone", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZoneId")
    def availability_zone_id(self) -> typing.Optional[builtins.str]:
        '''The AZ ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "availabilityZoneId"))

    @availability_zone_id.setter
    def availability_zone_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "availabilityZoneId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enableDns64")
    def enable_dns64(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.

        For more information, see `DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "enableDns64"))

    @enable_dns64.setter
    def enable_dns64(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "enableDns64", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR block.

        If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv6CidrBlock"))

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6CidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6Native")
    def ipv6_native(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether this is an IPv6 only subnet.

        For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "ipv6Native"))

    @ipv6_native.setter
    def ipv6_native(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "ipv6Native", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="mapPublicIpOnLaunch")
    def map_public_ip_on_launch(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` .

        If you specify ``MapPublicIpOnLaunch`` , you cannot specify ``AssignIpv6AddressOnCreation`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "mapPublicIpOnLaunch"))

    @map_public_ip_on_launch.setter
    def map_public_ip_on_launch(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "mapPublicIpOnLaunch", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="outpostArn")
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "outpostArn"))

    @outpost_arn.setter
    def outpost_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "outpostArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsNameOptionsOnLaunch")
    def private_dns_name_options_on_launch(
        self,
    ) -> typing.Optional[typing.Union["CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty", _IResolvable_da3f097b]]:
        '''The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.

        For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
        '''
        return typing.cast(typing.Optional[typing.Union["CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty", _IResolvable_da3f097b]], jsii.get(self, "privateDnsNameOptionsOnLaunch"))

    @private_dns_name_options_on_launch.setter
    def private_dns_name_options_on_launch(
        self,
        value: typing.Optional[typing.Union["CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "privateDnsNameOptionsOnLaunch", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty",
        jsii_struct_bases=[],
        name_mapping={
            "enable_resource_name_dns_aaaa_record": "enableResourceNameDnsAaaaRecord",
            "enable_resource_name_dns_a_record": "enableResourceNameDnsARecord",
            "hostname_type": "hostnameType",
        },
    )
    class PrivateDnsNameOptionsOnLaunchProperty:
        def __init__(
            self,
            *,
            enable_resource_name_dns_aaaa_record: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            enable_resource_name_dns_a_record: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
            hostname_type: typing.Optional[builtins.str] = None,
        ) -> None:
            '''Describes the options for instance hostnames.

            :param enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
            :param enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
            :param hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                private_dns_name_options_on_launch_property = ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if enable_resource_name_dns_aaaa_record is not None:
                self._values["enable_resource_name_dns_aaaa_record"] = enable_resource_name_dns_aaaa_record
            if enable_resource_name_dns_a_record is not None:
                self._values["enable_resource_name_dns_a_record"] = enable_resource_name_dns_a_record
            if hostname_type is not None:
                self._values["hostname_type"] = hostname_type

        @builtins.property
        def enable_resource_name_dns_aaaa_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsaaaarecord
            '''
            result = self._values.get("enable_resource_name_dns_aaaa_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def enable_resource_name_dns_a_record(
            self,
        ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
            '''Indicates whether to respond to DNS queries for instance hostnames with DNS A records.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-enableresourcenamednsarecord
            '''
            result = self._values.get("enable_resource_name_dns_a_record")
            return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

        @builtins.property
        def hostname_type(self) -> typing.Optional[builtins.str]:
            '''The type of hostname for EC2 instances.

            For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-subnet-privatednsnameoptionsonlaunch.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch-hostnametype
            '''
            result = self._values.get("hostname_type")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "PrivateDnsNameOptionsOnLaunchProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.implements(_IInspectable_c2943556)
class CfnSubnetCidrBlock(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetCidrBlock",
):
    '''A CloudFormation ``AWS::EC2::SubnetCidrBlock``.

    Associates a CIDR block with your subnet. You can associate a single IPv6 CIDR block with your subnet. An IPv6 CIDR block must have a prefix length of /64.

    :cloudformationResource: AWS::EC2::SubnetCidrBlock
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_subnet_cidr_block = ec2.CfnSubnetCidrBlock(self, "MyCfnSubnetCidrBlock",
            ipv6_cidr_block="ipv6CidrBlock",
            subnet_id="subnetId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        ipv6_cidr_block: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::SubnetCidrBlock``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param ipv6_cidr_block: The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length. This parameter is required for an IPv6 only subnet.
        :param subnet_id: The ID of the subnet.
        '''
        props = CfnSubnetCidrBlockProps(
            ipv6_cidr_block=ipv6_cidr_block, subnet_id=subnet_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> builtins.str:
        '''The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.

        This parameter is required for an IPv6 only subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipv6CidrBlock"))

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "ipv6CidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetCidrBlockProps",
    jsii_struct_bases=[],
    name_mapping={"ipv6_cidr_block": "ipv6CidrBlock", "subnet_id": "subnetId"},
)
class CfnSubnetCidrBlockProps:
    def __init__(
        self,
        *,
        ipv6_cidr_block: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnSubnetCidrBlock``.

        :param ipv6_cidr_block: The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length. This parameter is required for an IPv6 only subnet.
        :param subnet_id: The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_subnet_cidr_block_props = ec2.CfnSubnetCidrBlockProps(
                ipv6_cidr_block="ipv6CidrBlock",
                subnet_id="subnetId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "ipv6_cidr_block": ipv6_cidr_block,
            "subnet_id": subnet_id,
        }

    @builtins.property
    def ipv6_cidr_block(self) -> builtins.str:
        '''The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.

        This parameter is required for an IPv6 only subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        assert result is not None, "Required property 'ipv6_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetcidrblock.html#cfn-ec2-subnetcidrblock-subnetid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetCidrBlockProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnSubnetNetworkAclAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetNetworkAclAssociation",
):
    '''A CloudFormation ``AWS::EC2::SubnetNetworkAclAssociation``.

    Associates a subnet with a network ACL. For more information, see `ReplaceNetworkAclAssociation <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-ReplaceNetworkAclAssociation.html>`_ in the *Amazon EC2 API Reference* .

    When ``AWS::EC2::SubnetNetworkAclAssociation`` resources are created during create or update operations, AWS CloudFormation adopts existing resources that share the same key properties (the properties that contribute to uniquely identify the resource). However, if the operation fails and rolls back, AWS CloudFormation deletes the previously out-of-band resources. You can protect against this behavior by using ``Retain`` deletion policies. For more information, see `DeletionPolicy Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html>`_ .

    :cloudformationResource: AWS::EC2::SubnetNetworkAclAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_subnet_network_acl_association = ec2.CfnSubnetNetworkAclAssociation(self, "MyCfnSubnetNetworkAclAssociation",
            network_acl_id="networkAclId",
            subnet_id="subnetId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_acl_id: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::SubnetNetworkAclAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param network_acl_id: The ID of the network ACL.
        :param subnet_id: The ID of the subnet.
        '''
        props = CfnSubnetNetworkAclAssociationProps(
            network_acl_id=network_acl_id, subnet_id=subnet_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrAssociationId")
    def attr_association_id(self) -> builtins.str:
        '''Returns the value of this object's `SubnetId <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html>`_ property.

        :cloudformationAttribute: AssociationId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrAssociationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAclId")
    def network_acl_id(self) -> builtins.str:
        '''The ID of the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkAclId"))

    @network_acl_id.setter
    def network_acl_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkAclId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html#cfn-ec2-subnetnetworkaclassociation-associationid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetNetworkAclAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"network_acl_id": "networkAclId", "subnet_id": "subnetId"},
)
class CfnSubnetNetworkAclAssociationProps:
    def __init__(
        self,
        *,
        network_acl_id: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnSubnetNetworkAclAssociation``.

        :param network_acl_id: The ID of the network ACL.
        :param subnet_id: The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_subnet_network_acl_association_props = ec2.CfnSubnetNetworkAclAssociationProps(
                network_acl_id="networkAclId",
                subnet_id="subnetId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "network_acl_id": network_acl_id,
            "subnet_id": subnet_id,
        }

    @builtins.property
    def network_acl_id(self) -> builtins.str:
        '''The ID of the network ACL.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html#cfn-ec2-subnetnetworkaclassociation-networkaclid
        '''
        result = self._values.get("network_acl_id")
        assert result is not None, "Required property 'network_acl_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-network-acl-assoc.html#cfn-ec2-subnetnetworkaclassociation-associationid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetNetworkAclAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "vpc_id": "vpcId",
        "assign_ipv6_address_on_creation": "assignIpv6AddressOnCreation",
        "availability_zone": "availabilityZone",
        "availability_zone_id": "availabilityZoneId",
        "enable_dns64": "enableDns64",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "ipv6_native": "ipv6Native",
        "map_public_ip_on_launch": "mapPublicIpOnLaunch",
        "outpost_arn": "outpostArn",
        "private_dns_name_options_on_launch": "privateDnsNameOptionsOnLaunch",
        "tags": "tags",
    },
)
class CfnSubnetProps:
    def __init__(
        self,
        *,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        assign_ipv6_address_on_creation: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        availability_zone_id: typing.Optional[builtins.str] = None,
        enable_dns64: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_native: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        map_public_ip_on_launch: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        private_dns_name_options_on_launch: typing.Optional[typing.Union[CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty, _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnSubnet``.

        :param cidr_block: The IPv4 CIDR block assigned to the subnet. If you update this property, we create a new subnet, and then delete the existing one.
        :param vpc_id: The ID of the VPC the subnet is in. If you update this property, you must also update the ``CidrBlock`` property.
        :param assign_ipv6_address_on_creation: Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` . If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` . If you specify ``AssignIpv6AddressOnCreation`` , you cannot specify ``MapPublicIpOnLaunch`` .
        :param availability_zone: The Availability Zone of the subnet. If you update this property, you must also update the ``CidrBlock`` property.
        :param availability_zone_id: The AZ ID of the subnet.
        :param enable_dns64: Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations. For more information, see `DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param ipv6_cidr_block: The IPv6 CIDR block. If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .
        :param ipv6_native: Indicates whether this is an IPv6 only subnet. For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .
        :param map_public_ip_on_launch: Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` . If you specify ``MapPublicIpOnLaunch`` , you cannot specify ``AssignIpv6AddressOnCreation`` .
        :param outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param private_dns_name_options_on_launch: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .
        :param tags: Any tags assigned to the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_subnet_props = ec2.CfnSubnetProps(
                cidr_block="cidrBlock",
                vpc_id="vpcId",
            
                # the properties below are optional
                assign_ipv6_address_on_creation=False,
                availability_zone="availabilityZone",
                availability_zone_id="availabilityZoneId",
                enable_dns64=False,
                ipv6_cidr_block="ipv6CidrBlock",
                ipv6_native=False,
                map_public_ip_on_launch=False,
                outpost_arn="outpostArn",
                private_dns_name_options_on_launch=ec2.CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty(
                    enable_resource_name_dns_aaaa_record=False,
                    enable_resource_name_dns_aRecord=False,
                    hostname_type="hostnameType"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr_block": cidr_block,
            "vpc_id": vpc_id,
        }
        if assign_ipv6_address_on_creation is not None:
            self._values["assign_ipv6_address_on_creation"] = assign_ipv6_address_on_creation
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if availability_zone_id is not None:
            self._values["availability_zone_id"] = availability_zone_id
        if enable_dns64 is not None:
            self._values["enable_dns64"] = enable_dns64
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if ipv6_native is not None:
            self._values["ipv6_native"] = ipv6_native
        if map_public_ip_on_launch is not None:
            self._values["map_public_ip_on_launch"] = map_public_ip_on_launch
        if outpost_arn is not None:
            self._values["outpost_arn"] = outpost_arn
        if private_dns_name_options_on_launch is not None:
            self._values["private_dns_name_options_on_launch"] = private_dns_name_options_on_launch
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def cidr_block(self) -> builtins.str:
        '''The IPv4 CIDR block assigned to the subnet.

        If you update this property, we create a new subnet, and then delete the existing one.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-cidrblock
        '''
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC the subnet is in.

        If you update this property, you must also update the ``CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-awsec2subnet-prop-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def assign_ipv6_address_on_creation(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether a network interface created in this subnet receives an IPv6 address. The default value is ``false`` .

        If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .

        If you specify ``AssignIpv6AddressOnCreation`` , you cannot specify ``MapPublicIpOnLaunch`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-assignipv6addressoncreation
        '''
        result = self._values.get("assign_ipv6_address_on_creation")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone of the subnet.

        If you update this property, you must also update the ``CidrBlock`` property.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzone
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def availability_zone_id(self) -> typing.Optional[builtins.str]:
        '''The AZ ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-availabilityzoneid
        '''
        result = self._values.get("availability_zone_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def enable_dns64(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether DNS queries made to the Amazon-provided DNS Resolver in this subnet should return synthetic IPv6 addresses for IPv4-only destinations.

        For more information, see `DNS64 and NAT64 <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html#nat-gateway-nat64-dns64>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-enabledns64
        '''
        result = self._values.get("enable_dns64")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv6 CIDR block.

        If you specify ``AssignIpv6AddressOnCreation`` , you must also specify ``Ipv6CidrBlock`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_native(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether this is an IPv6 only subnet.

        For more information, see `Subnet basics <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#subnet-basics>`_ in the *Amazon Virtual Private Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-ipv6native
        '''
        result = self._values.get("ipv6_native")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def map_public_ip_on_launch(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether instances launched in this subnet receive a public IPv4 address. The default value is ``false`` .

        If you specify ``MapPublicIpOnLaunch`` , you cannot specify ``AssignIpv6AddressOnCreation`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-mappubliciponlaunch
        '''
        result = self._values.get("map_public_ip_on_launch")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-outpostarn
        '''
        result = self._values.get("outpost_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_dns_name_options_on_launch(
        self,
    ) -> typing.Optional[typing.Union[CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty, _IResolvable_da3f097b]]:
        '''The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled.

        For more information, see `Amazon EC2 instance hostname types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-privatednsnameoptionsonlaunch
        '''
        result = self._values.get("private_dns_name_options_on_launch")
        return typing.cast(typing.Optional[typing.Union[CfnSubnet.PrivateDnsNameOptionsOnLaunchProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html#cfn-ec2-subnet-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnSubnetRouteTableAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetRouteTableAssociation",
):
    '''A CloudFormation ``AWS::EC2::SubnetRouteTableAssociation``.

    Associates a subnet with a route table. The subnet and route table must be in the same VPC. This association causes traffic originating from the subnet to be routed according to the routes in the route table. A route table can be associated with multiple subnets. If you want to associate a route table with a VPC, see `AWS::EC2::RouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route-table.html>`_ .

    :cloudformationResource: AWS::EC2::SubnetRouteTableAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_subnet_route_table_association = ec2.CfnSubnetRouteTableAssociation(self, "MyCfnSubnetRouteTableAssociation",
            route_table_id="routeTableId",
            subnet_id="subnetId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        route_table_id: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::SubnetRouteTableAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param route_table_id: The ID of the route table. The physical ID changes when the route table ID is changed.
        :param subnet_id: The ID of the subnet.
        '''
        props = CfnSubnetRouteTableAssociationProps(
            route_table_id=route_table_id, subnet_id=subnet_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the subnet route table association.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        The physical ID changes when the route table ID is changed.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "routeTableId"))

    @route_table_id.setter
    def route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "routeTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnSubnetRouteTableAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"route_table_id": "routeTableId", "subnet_id": "subnetId"},
)
class CfnSubnetRouteTableAssociationProps:
    def __init__(
        self,
        *,
        route_table_id: builtins.str,
        subnet_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnSubnetRouteTableAssociation``.

        :param route_table_id: The ID of the route table. The physical ID changes when the route table ID is changed.
        :param subnet_id: The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_subnet_route_table_association_props = ec2.CfnSubnetRouteTableAssociationProps(
                route_table_id="routeTableId",
                subnet_id="subnetId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "route_table_id": route_table_id,
            "subnet_id": subnet_id,
        }

    @builtins.property
    def route_table_id(self) -> builtins.str:
        '''The ID of the route table.

        The physical ID changes when the route table ID is changed.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-routetableid
        '''
        result = self._values.get("route_table_id")
        assert result is not None, "Required property 'route_table_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html#cfn-ec2-subnetroutetableassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnSubnetRouteTableAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTrafficMirrorFilter(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorFilter",
):
    '''A CloudFormation ``AWS::EC2::TrafficMirrorFilter``.

    Specifies a Traffic Mirror filter.

    A Traffic Mirror filter is a set of rules that defines the traffic to mirror.

    By default, no traffic is mirrored. To mirror traffic, use `AWS::EC2::TrafficMirrorFilterRule <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html>`_ to add Traffic Mirror rules to the filter. The rules you add define what traffic gets mirrored.

    :cloudformationResource: AWS::EC2::TrafficMirrorFilter
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_traffic_mirror_filter = ec2.CfnTrafficMirrorFilter(self, "MyCfnTrafficMirrorFilter",
            description="description",
            network_services=["networkServices"],
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        network_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TrafficMirrorFilter``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param description: The description of the Traffic Mirror filter.
        :param network_services: The network service traffic that is associated with the Traffic Mirror filter. Valid values are ``amazon-dns`` .
        :param tags: The tags to assign to a Traffic Mirror filter.
        '''
        props = CfnTrafficMirrorFilterProps(
            description=description, network_services=network_services, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to assign to a Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkServices")
    def network_services(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The network service traffic that is associated with the Traffic Mirror filter.

        Valid values are ``amazon-dns`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "networkServices"))

    @network_services.setter
    def network_services(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "networkServices", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorFilterProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "network_services": "networkServices",
        "tags": "tags",
    },
)
class CfnTrafficMirrorFilterProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        network_services: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTrafficMirrorFilter``.

        :param description: The description of the Traffic Mirror filter.
        :param network_services: The network service traffic that is associated with the Traffic Mirror filter. Valid values are ``amazon-dns`` .
        :param tags: The tags to assign to a Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_traffic_mirror_filter_props = ec2.CfnTrafficMirrorFilterProps(
                description="description",
                network_services=["networkServices"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if network_services is not None:
            self._values["network_services"] = network_services
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_services(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The network service traffic that is associated with the Traffic Mirror filter.

        Valid values are ``amazon-dns`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-networkservices
        '''
        result = self._values.get("network_services")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to assign to a Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilter.html#cfn-ec2-trafficmirrorfilter-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorFilterProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTrafficMirrorFilterRule(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorFilterRule",
):
    '''A CloudFormation ``AWS::EC2::TrafficMirrorFilterRule``.

    Creates a Traffic Mirror filter rule.

    A Traffic Mirror rule defines the Traffic Mirror source traffic to mirror.

    You need the Traffic Mirror filter ID when you create the rule.

    :cloudformationResource: AWS::EC2::TrafficMirrorFilterRule
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_traffic_mirror_filter_rule = ec2.CfnTrafficMirrorFilterRule(self, "MyCfnTrafficMirrorFilterRule",
            destination_cidr_block="destinationCidrBlock",
            rule_action="ruleAction",
            rule_number=123,
            source_cidr_block="sourceCidrBlock",
            traffic_direction="trafficDirection",
            traffic_mirror_filter_id="trafficMirrorFilterId",
        
            # the properties below are optional
            description="description",
            destination_port_range=ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(
                from_port=123,
                to_port=123
            ),
            protocol=123,
            source_port_range=ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(
                from_port=123,
                to_port=123
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        destination_cidr_block: builtins.str,
        rule_action: builtins.str,
        rule_number: jsii.Number,
        source_cidr_block: builtins.str,
        traffic_direction: builtins.str,
        traffic_mirror_filter_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_port_range: typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]] = None,
        protocol: typing.Optional[jsii.Number] = None,
        source_port_range: typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TrafficMirrorFilterRule``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param destination_cidr_block: The destination CIDR block to assign to the Traffic Mirror rule.
        :param rule_action: The action to take on the filtered traffic.
        :param rule_number: The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
        :param source_cidr_block: The source CIDR block to assign to the Traffic Mirror rule.
        :param traffic_direction: The type of traffic.
        :param traffic_mirror_filter_id: The ID of the filter that this rule is associated with.
        :param description: The description of the Traffic Mirror rule.
        :param destination_port_range: The destination port range.
        :param protocol: The protocol, for example UDP, to assign to the Traffic Mirror rule. For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.
        :param source_port_range: The source port range.
        '''
        props = CfnTrafficMirrorFilterRuleProps(
            destination_cidr_block=destination_cidr_block,
            rule_action=rule_action,
            rule_number=rule_number,
            source_cidr_block=source_cidr_block,
            traffic_direction=traffic_direction,
            traffic_mirror_filter_id=traffic_mirror_filter_id,
            description=description,
            destination_port_range=destination_port_range,
            protocol=protocol,
            source_port_range=source_port_range,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> builtins.str:
        '''The destination CIDR block to assign to the Traffic Mirror rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "destinationCidrBlock"))

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ruleAction")
    def rule_action(self) -> builtins.str:
        '''The action to take on the filtered traffic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
        '''
        return typing.cast(builtins.str, jsii.get(self, "ruleAction"))

    @rule_action.setter
    def rule_action(self, value: builtins.str) -> None:
        jsii.set(self, "ruleAction", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ruleNumber")
    def rule_number(self) -> jsii.Number:
        '''The number of the Traffic Mirror rule.

        This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
        '''
        return typing.cast(jsii.Number, jsii.get(self, "ruleNumber"))

    @rule_number.setter
    def rule_number(self, value: jsii.Number) -> None:
        jsii.set(self, "ruleNumber", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourceCidrBlock")
    def source_cidr_block(self) -> builtins.str:
        '''The source CIDR block to assign to the Traffic Mirror rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "sourceCidrBlock"))

    @source_cidr_block.setter
    def source_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "sourceCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="trafficDirection")
    def traffic_direction(self) -> builtins.str:
        '''The type of traffic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
        '''
        return typing.cast(builtins.str, jsii.get(self, "trafficDirection"))

    @traffic_direction.setter
    def traffic_direction(self, value: builtins.str) -> None:
        jsii.set(self, "trafficDirection", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="trafficMirrorFilterId")
    def traffic_mirror_filter_id(self) -> builtins.str:
        '''The ID of the filter that this rule is associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
        '''
        return typing.cast(builtins.str, jsii.get(self, "trafficMirrorFilterId"))

    @traffic_mirror_filter_id.setter
    def traffic_mirror_filter_id(self, value: builtins.str) -> None:
        jsii.set(self, "trafficMirrorFilterId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationPortRange")
    def destination_port_range(
        self,
    ) -> typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]]:
        '''The destination port range.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
        '''
        return typing.cast(typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]], jsii.get(self, "destinationPortRange"))

    @destination_port_range.setter
    def destination_port_range(
        self,
        value: typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "destinationPortRange", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="protocol")
    def protocol(self) -> typing.Optional[jsii.Number]:
        '''The protocol, for example UDP, to assign to the Traffic Mirror rule.

        For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "protocol"))

    @protocol.setter
    def protocol(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "protocol", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sourcePortRange")
    def source_port_range(
        self,
    ) -> typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]]:
        '''The source port range.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
        '''
        return typing.cast(typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]], jsii.get(self, "sourcePortRange"))

    @source_port_range.setter
    def source_port_range(
        self,
        value: typing.Optional[typing.Union["CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "sourcePortRange", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty",
        jsii_struct_bases=[],
        name_mapping={"from_port": "fromPort", "to_port": "toPort"},
    )
    class TrafficMirrorPortRangeProperty:
        def __init__(self, *, from_port: jsii.Number, to_port: jsii.Number) -> None:
            '''Describes the Traffic Mirror port range.

            :param from_port: The start of the Traffic Mirror port range. This applies to the TCP and UDP protocols.
            :param to_port: The end of the Traffic Mirror port range. This applies to the TCP and UDP protocols.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                traffic_mirror_port_range_property = ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {
                "from_port": from_port,
                "to_port": to_port,
            }

        @builtins.property
        def from_port(self) -> jsii.Number:
            '''The start of the Traffic Mirror port range.

            This applies to the TCP and UDP protocols.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-fromport
            '''
            result = self._values.get("from_port")
            assert result is not None, "Required property 'from_port' is missing"
            return typing.cast(jsii.Number, result)

        @builtins.property
        def to_port(self) -> jsii.Number:
            '''The end of the Traffic Mirror port range.

            This applies to the TCP and UDP protocols.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-trafficmirrorfilterrule-trafficmirrorportrange.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorportrange-toport
            '''
            result = self._values.get("to_port")
            assert result is not None, "Required property 'to_port' is missing"
            return typing.cast(jsii.Number, result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TrafficMirrorPortRangeProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorFilterRuleProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "rule_action": "ruleAction",
        "rule_number": "ruleNumber",
        "source_cidr_block": "sourceCidrBlock",
        "traffic_direction": "trafficDirection",
        "traffic_mirror_filter_id": "trafficMirrorFilterId",
        "description": "description",
        "destination_port_range": "destinationPortRange",
        "protocol": "protocol",
        "source_port_range": "sourcePortRange",
    },
)
class CfnTrafficMirrorFilterRuleProps:
    def __init__(
        self,
        *,
        destination_cidr_block: builtins.str,
        rule_action: builtins.str,
        rule_number: jsii.Number,
        source_cidr_block: builtins.str,
        traffic_direction: builtins.str,
        traffic_mirror_filter_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        destination_port_range: typing.Optional[typing.Union[CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty, _IResolvable_da3f097b]] = None,
        protocol: typing.Optional[jsii.Number] = None,
        source_port_range: typing.Optional[typing.Union[CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty, _IResolvable_da3f097b]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTrafficMirrorFilterRule``.

        :param destination_cidr_block: The destination CIDR block to assign to the Traffic Mirror rule.
        :param rule_action: The action to take on the filtered traffic.
        :param rule_number: The number of the Traffic Mirror rule. This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.
        :param source_cidr_block: The source CIDR block to assign to the Traffic Mirror rule.
        :param traffic_direction: The type of traffic.
        :param traffic_mirror_filter_id: The ID of the filter that this rule is associated with.
        :param description: The description of the Traffic Mirror rule.
        :param destination_port_range: The destination port range.
        :param protocol: The protocol, for example UDP, to assign to the Traffic Mirror rule. For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.
        :param source_port_range: The source port range.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_traffic_mirror_filter_rule_props = ec2.CfnTrafficMirrorFilterRuleProps(
                destination_cidr_block="destinationCidrBlock",
                rule_action="ruleAction",
                rule_number=123,
                source_cidr_block="sourceCidrBlock",
                traffic_direction="trafficDirection",
                traffic_mirror_filter_id="trafficMirrorFilterId",
            
                # the properties below are optional
                description="description",
                destination_port_range=ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(
                    from_port=123,
                    to_port=123
                ),
                protocol=123,
                source_port_range=ec2.CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty(
                    from_port=123,
                    to_port=123
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "destination_cidr_block": destination_cidr_block,
            "rule_action": rule_action,
            "rule_number": rule_number,
            "source_cidr_block": source_cidr_block,
            "traffic_direction": traffic_direction,
            "traffic_mirror_filter_id": traffic_mirror_filter_id,
        }
        if description is not None:
            self._values["description"] = description
        if destination_port_range is not None:
            self._values["destination_port_range"] = destination_port_range
        if protocol is not None:
            self._values["protocol"] = protocol
        if source_port_range is not None:
            self._values["source_port_range"] = source_port_range

    @builtins.property
    def destination_cidr_block(self) -> builtins.str:
        '''The destination CIDR block to assign to the Traffic Mirror rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        assert result is not None, "Required property 'destination_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule_action(self) -> builtins.str:
        '''The action to take on the filtered traffic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-ruleaction
        '''
        result = self._values.get("rule_action")
        assert result is not None, "Required property 'rule_action' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rule_number(self) -> jsii.Number:
        '''The number of the Traffic Mirror rule.

        This number must be unique for each Traffic Mirror rule in a given direction. The rules are processed in ascending order by rule number.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-rulenumber
        '''
        result = self._values.get("rule_number")
        assert result is not None, "Required property 'rule_number' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def source_cidr_block(self) -> builtins.str:
        '''The source CIDR block to assign to the Traffic Mirror rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourcecidrblock
        '''
        result = self._values.get("source_cidr_block")
        assert result is not None, "Required property 'source_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def traffic_direction(self) -> builtins.str:
        '''The type of traffic.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficdirection
        '''
        result = self._values.get("traffic_direction")
        assert result is not None, "Required property 'traffic_direction' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def traffic_mirror_filter_id(self) -> builtins.str:
        '''The ID of the filter that this rule is associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-trafficmirrorfilterid
        '''
        result = self._values.get("traffic_mirror_filter_id")
        assert result is not None, "Required property 'traffic_mirror_filter_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror rule.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def destination_port_range(
        self,
    ) -> typing.Optional[typing.Union[CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty, _IResolvable_da3f097b]]:
        '''The destination port range.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-destinationportrange
        '''
        result = self._values.get("destination_port_range")
        return typing.cast(typing.Optional[typing.Union[CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def protocol(self) -> typing.Optional[jsii.Number]:
        '''The protocol, for example UDP, to assign to the Traffic Mirror rule.

        For information about the protocol value, see `Protocol Numbers <https://docs.aws.amazon.com/https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml>`_ on the Internet Assigned Numbers Authority (IANA) website.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-protocol
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def source_port_range(
        self,
    ) -> typing.Optional[typing.Union[CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty, _IResolvable_da3f097b]]:
        '''The source port range.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html#cfn-ec2-trafficmirrorfilterrule-sourceportrange
        '''
        result = self._values.get("source_port_range")
        return typing.cast(typing.Optional[typing.Union[CfnTrafficMirrorFilterRule.TrafficMirrorPortRangeProperty, _IResolvable_da3f097b]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorFilterRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTrafficMirrorSession(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorSession",
):
    '''A CloudFormation ``AWS::EC2::TrafficMirrorSession``.

    Creates a Traffic Mirror session.

    A Traffic Mirror session actively copies packets from a Traffic Mirror source to a Traffic Mirror target. Create a filter, and then assign it to the session to define a subset of the traffic to mirror, for example all TCP traffic.

    The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in a different VPC connected via VPC peering or a transit gateway.

    By default, no traffic is mirrored. Use `AWS::EC2::TrafficMirrorFilterRule <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorfilterrule.html>`_ to specify filter rules that specify the traffic to mirror.

    :cloudformationResource: AWS::EC2::TrafficMirrorSession
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_traffic_mirror_session = ec2.CfnTrafficMirrorSession(self, "MyCfnTrafficMirrorSession",
            network_interface_id="networkInterfaceId",
            session_number=123,
            traffic_mirror_filter_id="trafficMirrorFilterId",
            traffic_mirror_target_id="trafficMirrorTargetId",
        
            # the properties below are optional
            description="description",
            packet_length=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            virtual_network_id=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_interface_id: builtins.str,
        session_number: jsii.Number,
        traffic_mirror_filter_id: builtins.str,
        traffic_mirror_target_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        packet_length: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        virtual_network_id: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TrafficMirrorSession``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param network_interface_id: The ID of the source network interface.
        :param session_number: The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets. Valid values are 1-32766.
        :param traffic_mirror_filter_id: The ID of the Traffic Mirror filter.
        :param traffic_mirror_target_id: The ID of the Traffic Mirror target.
        :param description: The description of the Traffic Mirror session.
        :param packet_length: The number of bytes in each packet to mirror. These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.
        :param tags: The tags to assign to a Traffic Mirror session.
        :param virtual_network_id: The VXLAN ID for the Traffic Mirror session. For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique id is chosen at random.
        '''
        props = CfnTrafficMirrorSessionProps(
            network_interface_id=network_interface_id,
            session_number=session_number,
            traffic_mirror_filter_id=traffic_mirror_filter_id,
            traffic_mirror_target_id=traffic_mirror_target_id,
            description=description,
            packet_length=packet_length,
            tags=tags,
            virtual_network_id=virtual_network_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to assign to a Traffic Mirror session.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        '''The ID of the source network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="sessionNumber")
    def session_number(self) -> jsii.Number:
        '''The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.

        The first session with a matching filter is the one that mirrors the packets.

        Valid values are 1-32766.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
        '''
        return typing.cast(jsii.Number, jsii.get(self, "sessionNumber"))

    @session_number.setter
    def session_number(self, value: jsii.Number) -> None:
        jsii.set(self, "sessionNumber", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="trafficMirrorFilterId")
    def traffic_mirror_filter_id(self) -> builtins.str:
        '''The ID of the Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
        '''
        return typing.cast(builtins.str, jsii.get(self, "trafficMirrorFilterId"))

    @traffic_mirror_filter_id.setter
    def traffic_mirror_filter_id(self, value: builtins.str) -> None:
        jsii.set(self, "trafficMirrorFilterId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="trafficMirrorTargetId")
    def traffic_mirror_target_id(self) -> builtins.str:
        '''The ID of the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "trafficMirrorTargetId"))

    @traffic_mirror_target_id.setter
    def traffic_mirror_target_id(self, value: builtins.str) -> None:
        jsii.set(self, "trafficMirrorTargetId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror session.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="packetLength")
    def packet_length(self) -> typing.Optional[jsii.Number]:
        '''The number of bytes in each packet to mirror.

        These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.

        If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "packetLength"))

    @packet_length.setter
    def packet_length(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "packetLength", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="virtualNetworkId")
    def virtual_network_id(self) -> typing.Optional[jsii.Number]:
        '''The VXLAN ID for the Traffic Mirror session.

        For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique id is chosen at random.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "virtualNetworkId"))

    @virtual_network_id.setter
    def virtual_network_id(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "virtualNetworkId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorSessionProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_interface_id": "networkInterfaceId",
        "session_number": "sessionNumber",
        "traffic_mirror_filter_id": "trafficMirrorFilterId",
        "traffic_mirror_target_id": "trafficMirrorTargetId",
        "description": "description",
        "packet_length": "packetLength",
        "tags": "tags",
        "virtual_network_id": "virtualNetworkId",
    },
)
class CfnTrafficMirrorSessionProps:
    def __init__(
        self,
        *,
        network_interface_id: builtins.str,
        session_number: jsii.Number,
        traffic_mirror_filter_id: builtins.str,
        traffic_mirror_target_id: builtins.str,
        description: typing.Optional[builtins.str] = None,
        packet_length: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        virtual_network_id: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties for defining a ``CfnTrafficMirrorSession``.

        :param network_interface_id: The ID of the source network interface.
        :param session_number: The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets. Valid values are 1-32766.
        :param traffic_mirror_filter_id: The ID of the Traffic Mirror filter.
        :param traffic_mirror_target_id: The ID of the Traffic Mirror target.
        :param description: The description of the Traffic Mirror session.
        :param packet_length: The number of bytes in each packet to mirror. These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.
        :param tags: The tags to assign to a Traffic Mirror session.
        :param virtual_network_id: The VXLAN ID for the Traffic Mirror session. For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique id is chosen at random.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_traffic_mirror_session_props = ec2.CfnTrafficMirrorSessionProps(
                network_interface_id="networkInterfaceId",
                session_number=123,
                traffic_mirror_filter_id="trafficMirrorFilterId",
                traffic_mirror_target_id="trafficMirrorTargetId",
            
                # the properties below are optional
                description="description",
                packet_length=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                virtual_network_id=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "network_interface_id": network_interface_id,
            "session_number": session_number,
            "traffic_mirror_filter_id": traffic_mirror_filter_id,
            "traffic_mirror_target_id": traffic_mirror_target_id,
        }
        if description is not None:
            self._values["description"] = description
        if packet_length is not None:
            self._values["packet_length"] = packet_length
        if tags is not None:
            self._values["tags"] = tags
        if virtual_network_id is not None:
            self._values["virtual_network_id"] = virtual_network_id

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        '''The ID of the source network interface.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def session_number(self) -> jsii.Number:
        '''The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions.

        The first session with a matching filter is the one that mirrors the packets.

        Valid values are 1-32766.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-sessionnumber
        '''
        result = self._values.get("session_number")
        assert result is not None, "Required property 'session_number' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def traffic_mirror_filter_id(self) -> builtins.str:
        '''The ID of the Traffic Mirror filter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrorfilterid
        '''
        result = self._values.get("traffic_mirror_filter_id")
        assert result is not None, "Required property 'traffic_mirror_filter_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def traffic_mirror_target_id(self) -> builtins.str:
        '''The ID of the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-trafficmirrortargetid
        '''
        result = self._values.get("traffic_mirror_target_id")
        assert result is not None, "Required property 'traffic_mirror_target_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror session.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def packet_length(self) -> typing.Optional[jsii.Number]:
        '''The number of bytes in each packet to mirror.

        These are bytes after the VXLAN header. Do not specify this parameter when you want to mirror the entire packet. To mirror a subset of the packet, set this to the length (in bytes) that you want to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target.

        If you do not want to mirror the entire packet, use the ``PacketLength`` parameter to specify the number of bytes in each packet to mirror.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-packetlength
        '''
        result = self._values.get("packet_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to assign to a Traffic Mirror session.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def virtual_network_id(self) -> typing.Optional[jsii.Number]:
        '''The VXLAN ID for the Traffic Mirror session.

        For more information about the VXLAN protocol, see `RFC 7348 <https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc7348>`_ . If you do not specify a ``VirtualNetworkId`` , an account-wide unique id is chosen at random.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html#cfn-ec2-trafficmirrorsession-virtualnetworkid
        '''
        result = self._values.get("virtual_network_id")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorSessionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTrafficMirrorTarget(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorTarget",
):
    '''A CloudFormation ``AWS::EC2::TrafficMirrorTarget``.

    Specifies a target for your Traffic Mirror session.

    A Traffic Mirror target is the destination for mirrored traffic. The Traffic Mirror source and the Traffic Mirror target (monitoring appliances) can be in the same VPC, or in different VPCs connected via VPC peering or a transit gateway.

    A Traffic Mirror target can be a network interface, or a Network Load Balancer.

    To use the target in a Traffic Mirror session, use `AWS::EC2::TrafficMirrorSession <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrorsession.html>`_ .

    :cloudformationResource: AWS::EC2::TrafficMirrorTarget
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_traffic_mirror_target = ec2.CfnTrafficMirrorTarget(self, "MyCfnTrafficMirrorTarget",
            description="description",
            network_interface_id="networkInterfaceId",
            network_load_balancer_arn="networkLoadBalancerArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        description: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        network_load_balancer_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TrafficMirrorTarget``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param description: The description of the Traffic Mirror target.
        :param network_interface_id: The network interface ID that is associated with the target.
        :param network_load_balancer_arn: The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
        :param tags: The tags to assign to the Traffic Mirror target.
        '''
        props = CfnTrafficMirrorTargetProps(
            description=description,
            network_interface_id=network_interface_id,
            network_load_balancer_arn=network_load_balancer_arn,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to assign to the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The network interface ID that is associated with the target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkLoadBalancerArn")
    def network_load_balancer_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "networkLoadBalancerArn"))

    @network_load_balancer_arn.setter
    def network_load_balancer_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "networkLoadBalancerArn", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTrafficMirrorTargetProps",
    jsii_struct_bases=[],
    name_mapping={
        "description": "description",
        "network_interface_id": "networkInterfaceId",
        "network_load_balancer_arn": "networkLoadBalancerArn",
        "tags": "tags",
    },
)
class CfnTrafficMirrorTargetProps:
    def __init__(
        self,
        *,
        description: typing.Optional[builtins.str] = None,
        network_interface_id: typing.Optional[builtins.str] = None,
        network_load_balancer_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTrafficMirrorTarget``.

        :param description: The description of the Traffic Mirror target.
        :param network_interface_id: The network interface ID that is associated with the target.
        :param network_load_balancer_arn: The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.
        :param tags: The tags to assign to the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_traffic_mirror_target_props = ec2.CfnTrafficMirrorTargetProps(
                description="description",
                network_interface_id="networkInterfaceId",
                network_load_balancer_arn="networkLoadBalancerArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if description is not None:
            self._values["description"] = description
        if network_interface_id is not None:
            self._values["network_interface_id"] = network_interface_id
        if network_load_balancer_arn is not None:
            self._values["network_load_balancer_arn"] = network_load_balancer_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_interface_id(self) -> typing.Optional[builtins.str]:
        '''The network interface ID that is associated with the target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def network_load_balancer_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Network Load Balancer that is associated with the target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-networkloadbalancerarn
        '''
        result = self._values.get("network_load_balancer_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to assign to the Traffic Mirror target.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-trafficmirrortarget.html#cfn-ec2-trafficmirrortarget-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTrafficMirrorTargetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGateway",
):
    '''A CloudFormation ``AWS::EC2::TransitGateway``.

    Specifies a transit gateway.

    You can use a transit gateway to interconnect your virtual private clouds (VPC) and on-premises networks. After the transit gateway enters the ``available`` state, you can attach your VPCs and VPN connections to the transit gateway.

    To attach your VPCs, use `AWS::EC2::TransitGatewayAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html>`_ .

    To attach a VPN connection, use `AWS::EC2::CustomerGateway <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-customer-gateway.html>`_ to create a customer gateway and specify the ID of the customer gateway and the ID of the transit gateway in a call to `AWS::EC2::VPNConnection <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html>`_ .

    When you create a transit gateway, we create a default transit gateway route table and use it as the default association route table and the default propagation route table. You can use `AWS::EC2::TransitGatewayRouteTable <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html>`_ to create additional transit gateway route tables. If you disable automatic route propagation, we do not create a default transit gateway route table. You can use `AWS::EC2::TransitGatewayRouteTablePropagation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html>`_ to propagate routes from a resource attachment to a transit gateway route table. If you disable automatic associations, you can use `AWS::EC2::TransitGatewayRouteTableAssociation <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html>`_ to associate a resource attachment with a transit gateway route table.

    :cloudformationResource: AWS::EC2::TransitGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway = ec2.CfnTransitGateway(self, "MyCfnTransitGateway",
            amazon_side_asn=123,
            association_default_route_table_id="associationDefaultRouteTableId",
            auto_accept_shared_attachments="autoAcceptSharedAttachments",
            default_route_table_association="defaultRouteTableAssociation",
            default_route_table_propagation="defaultRouteTablePropagation",
            description="description",
            dns_support="dnsSupport",
            multicast_support="multicastSupport",
            propagation_default_route_table_id="propagationDefaultRouteTableId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_cidr_blocks=["transitGatewayCidrBlocks"],
            vpn_ecmp_support="vpnEcmpSupport"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        association_default_route_table_id: typing.Optional[builtins.str] = None,
        auto_accept_shared_attachments: typing.Optional[builtins.str] = None,
        default_route_table_association: typing.Optional[builtins.str] = None,
        default_route_table_propagation: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_support: typing.Optional[builtins.str] = None,
        multicast_support: typing.Optional[builtins.str] = None,
        propagation_default_route_table_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        transit_gateway_cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpn_ecmp_support: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param amazon_side_asn: A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
        :param association_default_route_table_id: The ID of the default association route table.
        :param auto_accept_shared_attachments: Enable or disable automatic acceptance of attachment requests. Disabled by default.
        :param default_route_table_association: Enable or disable automatic association with the default association route table. Enabled by default.
        :param default_route_table_propagation: Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default.
        :param description: The description of the transit gateway.
        :param dns_support: Enable or disable DNS support. Enabled by default.
        :param multicast_support: Indicates whether multicast is enabled on the transit gateway.
        :param propagation_default_route_table_id: The ID of the default propagation route table.
        :param tags: The tags for the transit gateway.
        :param transit_gateway_cidr_blocks: The transit gateway CIDR blocks.
        :param vpn_ecmp_support: Enable or disable Equal Cost Multipath Protocol support. Enabled by default.
        '''
        props = CfnTransitGatewayProps(
            amazon_side_asn=amazon_side_asn,
            association_default_route_table_id=association_default_route_table_id,
            auto_accept_shared_attachments=auto_accept_shared_attachments,
            default_route_table_association=default_route_table_association,
            default_route_table_propagation=default_route_table_propagation,
            description=description,
            dns_support=dns_support,
            multicast_support=multicast_support,
            propagation_default_route_table_id=propagation_default_route_table_id,
            tags=tags,
            transit_gateway_cidr_blocks=transit_gateway_cidr_blocks,
            vpn_ecmp_support=vpn_ecmp_support,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="amazonSideAsn")
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''A private Autonomous System Number (ASN) for the Amazon side of a BGP session.

        The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "amazonSideAsn"))

    @amazon_side_asn.setter
    def amazon_side_asn(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "amazonSideAsn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="associationDefaultRouteTableId")
    def association_default_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the default association route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "associationDefaultRouteTableId"))

    @association_default_route_table_id.setter
    def association_default_route_table_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "associationDefaultRouteTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="autoAcceptSharedAttachments")
    def auto_accept_shared_attachments(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic acceptance of attachment requests.

        Disabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "autoAcceptSharedAttachments"))

    @auto_accept_shared_attachments.setter
    def auto_accept_shared_attachments(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "autoAcceptSharedAttachments", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultRouteTableAssociation")
    def default_route_table_association(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic association with the default association route table.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultRouteTableAssociation"))

    @default_route_table_association.setter
    def default_route_table_association(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "defaultRouteTableAssociation", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultRouteTablePropagation")
    def default_route_table_propagation(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic propagation of routes to the default propagation route table.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "defaultRouteTablePropagation"))

    @default_route_table_propagation.setter
    def default_route_table_propagation(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "defaultRouteTablePropagation", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @description.setter
    def description(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "description", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dnsSupport")
    def dns_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable DNS support.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "dnsSupport"))

    @dns_support.setter
    def dns_support(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "dnsSupport", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="multicastSupport")
    def multicast_support(self) -> typing.Optional[builtins.str]:
        '''Indicates whether multicast is enabled on the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "multicastSupport"))

    @multicast_support.setter
    def multicast_support(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "multicastSupport", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="propagationDefaultRouteTableId")
    def propagation_default_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the default propagation route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "propagationDefaultRouteTableId"))

    @propagation_default_route_table_id.setter
    def propagation_default_route_table_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "propagationDefaultRouteTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayCidrBlocks")
    def transit_gateway_cidr_blocks(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The transit gateway CIDR blocks.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "transitGatewayCidrBlocks"))

    @transit_gateway_cidr_blocks.setter
    def transit_gateway_cidr_blocks(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "transitGatewayCidrBlocks", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnEcmpSupport")
    def vpn_ecmp_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable Equal Cost Multipath Protocol support.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpnEcmpSupport"))

    @vpn_ecmp_support.setter
    def vpn_ecmp_support(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpnEcmpSupport", value)


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayAttachment(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayAttachment",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayAttachment``.

    Attaches a VPC to a transit gateway.

    If you attach a VPC with a CIDR range that overlaps the CIDR range of a VPC that is already attached, the new VPC CIDR range is not propagated to the default propagation route table.

    To send VPC traffic to an attached transit gateway, add a route to the VPC route table using `AWS::EC2::Route <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html>`_ .

    :cloudformationResource: AWS::EC2::TransitGatewayAttachment
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_attachment = ec2.CfnTransitGatewayAttachment(self, "MyCfnTransitGatewayAttachment",
            subnet_ids=["subnetIds"],
            transit_gateway_id="transitGatewayId",
            vpc_id="vpcId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_ids: typing.Sequence[builtins.str],
        transit_gateway_id: builtins.str,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param subnet_ids: The IDs of one or more subnets. You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
        :param transit_gateway_id: The ID of the transit gateway.
        :param vpc_id: The ID of the VPC.
        :param tags: The tags for the attachment.
        '''
        props = CfnTransitGatewayAttachmentProps(
            subnet_ids=subnet_ids,
            transit_gateway_id=transit_gateway_id,
            vpc_id=vpc_id,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetIds")
    def subnet_ids(self) -> typing.List[builtins.str]:
        '''The IDs of one or more subnets.

        You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "subnetIds"))

    @subnet_ids.setter
    def subnet_ids(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "subnetIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "subnet_ids": "subnetIds",
        "transit_gateway_id": "transitGatewayId",
        "vpc_id": "vpcId",
        "tags": "tags",
    },
)
class CfnTransitGatewayAttachmentProps:
    def __init__(
        self,
        *,
        subnet_ids: typing.Sequence[builtins.str],
        transit_gateway_id: builtins.str,
        vpc_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayAttachment``.

        :param subnet_ids: The IDs of one or more subnets. You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.
        :param transit_gateway_id: The ID of the transit gateway.
        :param vpc_id: The ID of the VPC.
        :param tags: The tags for the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_attachment_props = ec2.CfnTransitGatewayAttachmentProps(
                subnet_ids=["subnetIds"],
                transit_gateway_id="transitGatewayId",
                vpc_id="vpcId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_ids": subnet_ids,
            "transit_gateway_id": transit_gateway_id,
            "vpc_id": vpc_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def subnet_ids(self) -> typing.List[builtins.str]:
        '''The IDs of one or more subnets.

        You can specify only one subnet per Availability Zone. You must specify at least one subnet, but we recommend that you specify two subnets for better availability. The transit gateway uses one IP address from each specified subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-subnetids
        '''
        result = self._values.get("subnet_ids")
        assert result is not None, "Required property 'subnet_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        assert result is not None, "Required property 'transit_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayattachment.html#cfn-ec2-transitgatewayattachment-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayConnect(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayConnect",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayConnect``.

    Creates a Connect attachment from a specified transit gateway attachment. A Connect attachment is a GRE-based tunnel attachment that you can use to establish a connection between a transit gateway and an appliance.

    A Connect attachment uses an existing VPC or AWS Direct Connect attachment as the underlying transport mechanism.

    :cloudformationResource: AWS::EC2::TransitGatewayConnect
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_connect = ec2.CfnTransitGatewayConnect(self, "MyCfnTransitGatewayConnect",
            options=ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty(
                protocol="protocol"
            ),
            transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        options: typing.Union["CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty", _IResolvable_da3f097b],
        transport_transit_gateway_attachment_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayConnect``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param options: The Connect attachment options. - protocol (gre)
        :param transport_transit_gateway_attachment_id: The ID of the attachment from which the Connect attachment was created.
        :param tags: The tags for the attachment.
        '''
        props = CfnTransitGatewayConnectProps(
            options=options,
            transport_transit_gateway_attachment_id=transport_transit_gateway_attachment_id,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCreationTime")
    def attr_creation_time(self) -> builtins.str:
        '''The creation time.

        :cloudformationAttribute: CreationTime
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCreationTime"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the attachment.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayAttachmentId")
    def attr_transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the transit gateway attachment.

        :cloudformationAttribute: TransitGatewayAttachmentId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayAttachmentId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayId")
    def attr_transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :cloudformationAttribute: TransitGatewayId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="options")
    def options(
        self,
    ) -> typing.Union["CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty", _IResolvable_da3f097b]:
        '''The Connect attachment options.

        - protocol (gre)

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
        '''
        return typing.cast(typing.Union["CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty", _IResolvable_da3f097b], jsii.get(self, "options"))

    @options.setter
    def options(
        self,
        value: typing.Union["CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty", _IResolvable_da3f097b],
    ) -> None:
        jsii.set(self, "options", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transportTransitGatewayAttachmentId")
    def transport_transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the attachment from which the Connect attachment was created.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transportTransitGatewayAttachmentId"))

    @transport_transit_gateway_attachment_id.setter
    def transport_transit_gateway_attachment_id(self, value: builtins.str) -> None:
        jsii.set(self, "transportTransitGatewayAttachmentId", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"protocol": "protocol"},
    )
    class TransitGatewayConnectOptionsProperty:
        def __init__(self, *, protocol: typing.Optional[builtins.str] = None) -> None:
            '''Describes the Connect attachment options.

            :param protocol: The tunnel protocol.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                transit_gateway_connect_options_property = ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty(
                    protocol="protocol"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if protocol is not None:
                self._values["protocol"] = protocol

        @builtins.property
        def protocol(self) -> typing.Optional[builtins.str]:
            '''The tunnel protocol.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewayconnect-transitgatewayconnectoptions.html#cfn-ec2-transitgatewayconnect-transitgatewayconnectoptions-protocol
            '''
            result = self._values.get("protocol")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransitGatewayConnectOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayConnectProps",
    jsii_struct_bases=[],
    name_mapping={
        "options": "options",
        "transport_transit_gateway_attachment_id": "transportTransitGatewayAttachmentId",
        "tags": "tags",
    },
)
class CfnTransitGatewayConnectProps:
    def __init__(
        self,
        *,
        options: typing.Union[CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty, _IResolvable_da3f097b],
        transport_transit_gateway_attachment_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayConnect``.

        :param options: The Connect attachment options. - protocol (gre)
        :param transport_transit_gateway_attachment_id: The ID of the attachment from which the Connect attachment was created.
        :param tags: The tags for the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_connect_props = ec2.CfnTransitGatewayConnectProps(
                options=ec2.CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty(
                    protocol="protocol"
                ),
                transport_transit_gateway_attachment_id="transportTransitGatewayAttachmentId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "options": options,
            "transport_transit_gateway_attachment_id": transport_transit_gateway_attachment_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def options(
        self,
    ) -> typing.Union[CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty, _IResolvable_da3f097b]:
        '''The Connect attachment options.

        - protocol (gre)

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-options
        '''
        result = self._values.get("options")
        assert result is not None, "Required property 'options' is missing"
        return typing.cast(typing.Union[CfnTransitGatewayConnect.TransitGatewayConnectOptionsProperty, _IResolvable_da3f097b], result)

    @builtins.property
    def transport_transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the attachment from which the Connect attachment was created.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-transporttransitgatewayattachmentid
        '''
        result = self._values.get("transport_transit_gateway_attachment_id")
        assert result is not None, "Required property 'transport_transit_gateway_attachment_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayconnect.html#cfn-ec2-transitgatewayconnect-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayConnectProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayMulticastDomain(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastDomain",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayMulticastDomain``.

    Creates a multicast domain using the specified transit gateway.

    The transit gateway must be in the available state before you create a domain.

    :cloudformationResource: AWS::EC2::TransitGatewayMulticastDomain
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # options: Any
        
        cfn_transit_gateway_multicast_domain = ec2.CfnTransitGatewayMulticastDomain(self, "MyCfnTransitGatewayMulticastDomain",
            transit_gateway_id="transitGatewayId",
        
            # the properties below are optional
            options=options,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        transit_gateway_id: builtins.str,
        options: typing.Any = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayMulticastDomain``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param transit_gateway_id: The ID of the transit gateway.
        :param options: The options for the transit gateway multicast domain. - AutoAcceptSharedAssociations (enable | disable) - Igmpv2Support (enable | disable) - StaticSourcesSupport (enable | disable)
        :param tags: The tags for the transit gateway multicast domain.
        '''
        props = CfnTransitGatewayMulticastDomainProps(
            transit_gateway_id=transit_gateway_id, options=options, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCreationTime")
    def attr_creation_time(self) -> builtins.str:
        '''The time the multicast domain was created.

        :cloudformationAttribute: CreationTime
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCreationTime"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the multicast domain.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayMulticastDomainArn")
    def attr_transit_gateway_multicast_domain_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the multicast domain.

        :cloudformationAttribute: TransitGatewayMulticastDomainArn
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayMulticastDomainArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayMulticastDomainId")
    def attr_transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the multicast domain.

        :cloudformationAttribute: TransitGatewayMulticastDomainId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayMulticastDomainId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="options")
    def options(self) -> typing.Any:
        '''The options for the transit gateway multicast domain.

        - AutoAcceptSharedAssociations (enable | disable)
        - Igmpv2Support (enable | disable)
        - StaticSourcesSupport (enable | disable)

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
        '''
        return typing.cast(typing.Any, jsii.get(self, "options"))

    @options.setter
    def options(self, value: typing.Any) -> None:
        jsii.set(self, "options", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayId", value)


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayMulticastDomainAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastDomainAssociation",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayMulticastDomainAssociation``.

    Associates the specified subnets and transit gateway attachments with the specified transit gateway multicast domain.

    The transit gateway attachment must be in the available state before you can add a resource.

    :cloudformationResource: AWS::EC2::TransitGatewayMulticastDomainAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_multicast_domain_association = ec2.CfnTransitGatewayMulticastDomainAssociation(self, "MyCfnTransitGatewayMulticastDomainAssociation",
            subnet_id="subnetId",
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_id: builtins.str,
        transit_gateway_attachment_id: builtins.str,
        transit_gateway_multicast_domain_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayMulticastDomainAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param subnet_id: The IDs of the subnets to associate with the transit gateway multicast domain.
        :param transit_gateway_attachment_id: The ID of the transit gateway attachment.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.
        '''
        props = CfnTransitGatewayMulticastDomainAssociationProps(
            subnet_id=subnet_id,
            transit_gateway_attachment_id=transit_gateway_attachment_id,
            transit_gateway_multicast_domain_id=transit_gateway_multicast_domain_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrResourceId")
    def attr_resource_id(self) -> builtins.str:
        '''The ID of the resource.

        :cloudformationAttribute: ResourceId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrResourceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrResourceType")
    def attr_resource_type(self) -> builtins.str:
        '''The type of resource, for example a VPC attachment.

        :cloudformationAttribute: ResourceType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrResourceType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the resource.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The IDs of the subnets to associate with the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @subnet_id.setter
    def subnet_id(self, value: builtins.str) -> None:
        jsii.set(self, "subnetId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the transit gateway attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))

    @transit_gateway_attachment_id.setter
    def transit_gateway_attachment_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayAttachmentId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayMulticastDomainId")
    def transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayMulticastDomainId"))

    @transit_gateway_multicast_domain_id.setter
    def transit_gateway_multicast_domain_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayMulticastDomainId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastDomainAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "subnet_id": "subnetId",
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_multicast_domain_id": "transitGatewayMulticastDomainId",
    },
)
class CfnTransitGatewayMulticastDomainAssociationProps:
    def __init__(
        self,
        *,
        subnet_id: builtins.str,
        transit_gateway_attachment_id: builtins.str,
        transit_gateway_multicast_domain_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayMulticastDomainAssociation``.

        :param subnet_id: The IDs of the subnets to associate with the transit gateway multicast domain.
        :param transit_gateway_attachment_id: The ID of the transit gateway attachment.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_multicast_domain_association_props = ec2.CfnTransitGatewayMulticastDomainAssociationProps(
                subnet_id="subnetId",
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_id": subnet_id,
            "transit_gateway_attachment_id": transit_gateway_attachment_id,
            "transit_gateway_multicast_domain_id": transit_gateway_multicast_domain_id,
        }

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The IDs of the subnets to associate with the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-subnetid
        '''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the transit gateway attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        assert result is not None, "Required property 'transit_gateway_attachment_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomainassociation.html#cfn-ec2-transitgatewaymulticastdomainassociation-transitgatewaymulticastdomainid
        '''
        result = self._values.get("transit_gateway_multicast_domain_id")
        assert result is not None, "Required property 'transit_gateway_multicast_domain_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastDomainAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastDomainProps",
    jsii_struct_bases=[],
    name_mapping={
        "transit_gateway_id": "transitGatewayId",
        "options": "options",
        "tags": "tags",
    },
)
class CfnTransitGatewayMulticastDomainProps:
    def __init__(
        self,
        *,
        transit_gateway_id: builtins.str,
        options: typing.Any = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayMulticastDomain``.

        :param transit_gateway_id: The ID of the transit gateway.
        :param options: The options for the transit gateway multicast domain. - AutoAcceptSharedAssociations (enable | disable) - Igmpv2Support (enable | disable) - StaticSourcesSupport (enable | disable)
        :param tags: The tags for the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # options: Any
            
            cfn_transit_gateway_multicast_domain_props = ec2.CfnTransitGatewayMulticastDomainProps(
                transit_gateway_id="transitGatewayId",
            
                # the properties below are optional
                options=options,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "transit_gateway_id": transit_gateway_id,
        }
        if options is not None:
            self._values["options"] = options
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        assert result is not None, "Required property 'transit_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def options(self) -> typing.Any:
        '''The options for the transit gateway multicast domain.

        - AutoAcceptSharedAssociations (enable | disable)
        - Igmpv2Support (enable | disable)
        - StaticSourcesSupport (enable | disable)

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastdomain.html#cfn-ec2-transitgatewaymulticastdomain-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastDomainProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayMulticastGroupMember(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastGroupMember",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayMulticastGroupMember``.

    Registers members (network interfaces) with the transit gateway multicast group. A member is a network interface associated with a supported EC2 instance that receives multicast traffic. For information about supported instances, see `Multicast Consideration <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits>`_ in *Amazon VPC Transit Gateways* .

    :cloudformationResource: AWS::EC2::TransitGatewayMulticastGroupMember
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_multicast_group_member = ec2.CfnTransitGatewayMulticastGroupMember(self, "MyCfnTransitGatewayMulticastGroupMember",
            group_ip_address="groupIpAddress",
            network_interface_id="networkInterfaceId",
            transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        group_ip_address: builtins.str,
        network_interface_id: builtins.str,
        transit_gateway_multicast_domain_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayMulticastGroupMember``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param group_ip_address: The IP address assigned to the transit gateway multicast group.
        :param network_interface_id: The group members' network interface IDs to register with the transit gateway multicast group.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.
        '''
        props = CfnTransitGatewayMulticastGroupMemberProps(
            group_ip_address=group_ip_address,
            network_interface_id=network_interface_id,
            transit_gateway_multicast_domain_id=transit_gateway_multicast_domain_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrGroupMember")
    def attr_group_member(self) -> _IResolvable_da3f097b:
        '''Information about the registered transit gateway multicast domain group members.

        :cloudformationAttribute: GroupMember
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrGroupMember"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrGroupSource")
    def attr_group_source(self) -> _IResolvable_da3f097b:
        '''Indicates that the resource is a transit gateway multicast domain group member.

        :cloudformationAttribute: GroupSource
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrGroupSource"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrMemberType")
    def attr_member_type(self) -> builtins.str:
        '''The type of group member, for example static.

        :cloudformationAttribute: MemberType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrMemberType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrResourceId")
    def attr_resource_id(self) -> builtins.str:
        '''The ID of the resource.

        :cloudformationAttribute: ResourceId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrResourceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrResourceType")
    def attr_resource_type(self) -> builtins.str:
        '''The type of resource, for example a VPC attachment.

        :cloudformationAttribute: ResourceType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrResourceType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrSourceType")
    def attr_source_type(self) -> builtins.str:
        '''The type of source.

        :cloudformationAttribute: SourceType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrSourceType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrSubnetId")
    def attr_subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :cloudformationAttribute: SubnetId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrSubnetId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayAttachmentId")
    def attr_transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the transit gateway attachment.

        :cloudformationAttribute: TransitGatewayAttachmentId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayAttachmentId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupIpAddress")
    def group_ip_address(self) -> builtins.str:
        '''The IP address assigned to the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
        '''
        return typing.cast(builtins.str, jsii.get(self, "groupIpAddress"))

    @group_ip_address.setter
    def group_ip_address(self, value: builtins.str) -> None:
        jsii.set(self, "groupIpAddress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        '''The group members' network interface IDs to register with the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayMulticastDomainId")
    def transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayMulticastDomainId"))

    @transit_gateway_multicast_domain_id.setter
    def transit_gateway_multicast_domain_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayMulticastDomainId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastGroupMemberProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_ip_address": "groupIpAddress",
        "network_interface_id": "networkInterfaceId",
        "transit_gateway_multicast_domain_id": "transitGatewayMulticastDomainId",
    },
)
class CfnTransitGatewayMulticastGroupMemberProps:
    def __init__(
        self,
        *,
        group_ip_address: builtins.str,
        network_interface_id: builtins.str,
        transit_gateway_multicast_domain_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayMulticastGroupMember``.

        :param group_ip_address: The IP address assigned to the transit gateway multicast group.
        :param network_interface_id: The group members' network interface IDs to register with the transit gateway multicast group.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_multicast_group_member_props = ec2.CfnTransitGatewayMulticastGroupMemberProps(
                group_ip_address="groupIpAddress",
                network_interface_id="networkInterfaceId",
                transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "group_ip_address": group_ip_address,
            "network_interface_id": network_interface_id,
            "transit_gateway_multicast_domain_id": transit_gateway_multicast_domain_id,
        }

    @builtins.property
    def group_ip_address(self) -> builtins.str:
        '''The IP address assigned to the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-groupipaddress
        '''
        result = self._values.get("group_ip_address")
        assert result is not None, "Required property 'group_ip_address' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        '''The group members' network interface IDs to register with the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupmember.html#cfn-ec2-transitgatewaymulticastgroupmember-transitgatewaymulticastdomainid
        '''
        result = self._values.get("transit_gateway_multicast_domain_id")
        assert result is not None, "Required property 'transit_gateway_multicast_domain_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastGroupMemberProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayMulticastGroupSource(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastGroupSource",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayMulticastGroupSource``.

    Registers sources (network interfaces) with the specified transit gateway multicast domain.

    A multicast source is a network interface attached to a supported instance that sends multicast traffic. For information about supported instances, see `Multicast Considerations <https://docs.aws.amazon.com/vpc/latest/tgw/transit-gateway-limits.html#multicast-limits>`_ in *Amazon VPC Transit Gateways* .

    :cloudformationResource: AWS::EC2::TransitGatewayMulticastGroupSource
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_multicast_group_source = ec2.CfnTransitGatewayMulticastGroupSource(self, "MyCfnTransitGatewayMulticastGroupSource",
            group_ip_address="groupIpAddress",
            network_interface_id="networkInterfaceId",
            transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        group_ip_address: builtins.str,
        network_interface_id: builtins.str,
        transit_gateway_multicast_domain_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayMulticastGroupSource``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param group_ip_address: The IP address assigned to the transit gateway multicast group.
        :param network_interface_id: The group sources' network interface IDs to register with the transit gateway multicast group.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.
        '''
        props = CfnTransitGatewayMulticastGroupSourceProps(
            group_ip_address=group_ip_address,
            network_interface_id=network_interface_id,
            transit_gateway_multicast_domain_id=transit_gateway_multicast_domain_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrGroupMember")
    def attr_group_member(self) -> _IResolvable_da3f097b:
        '''Information about the registered transit gateway multicast domain group members.

        :cloudformationAttribute: GroupMember
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrGroupMember"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrGroupSource")
    def attr_group_source(self) -> _IResolvable_da3f097b:
        '''Indicates that the resource is a transit gateway group member.

        :cloudformationAttribute: GroupSource
        '''
        return typing.cast(_IResolvable_da3f097b, jsii.get(self, "attrGroupSource"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrMemberType")
    def attr_member_type(self) -> builtins.str:
        '''The type of group member, for example static.

        :cloudformationAttribute: MemberType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrMemberType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrResourceId")
    def attr_resource_id(self) -> builtins.str:
        '''The ID of the resource.

        :cloudformationAttribute: ResourceId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrResourceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrResourceType")
    def attr_resource_type(self) -> builtins.str:
        '''The type of resource, for example a VPC attachment.

        :cloudformationAttribute: ResourceType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrResourceType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrSourceType")
    def attr_source_type(self) -> builtins.str:
        '''The type of source.

        :cloudformationAttribute: SourceType
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrSourceType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrSubnetId")
    def attr_subnet_id(self) -> builtins.str:
        '''The ID of the subnet.

        :cloudformationAttribute: SubnetId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrSubnetId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayAttachmentId")
    def attr_transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the transit gateway attachment.

        :cloudformationAttribute: TransitGatewayAttachmentId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayAttachmentId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="groupIpAddress")
    def group_ip_address(self) -> builtins.str:
        '''The IP address assigned to the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
        '''
        return typing.cast(builtins.str, jsii.get(self, "groupIpAddress"))

    @group_ip_address.setter
    def group_ip_address(self, value: builtins.str) -> None:
        jsii.set(self, "groupIpAddress", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkInterfaceId")
    def network_interface_id(self) -> builtins.str:
        '''The group sources' network interface IDs to register with the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkInterfaceId"))

    @network_interface_id.setter
    def network_interface_id(self, value: builtins.str) -> None:
        jsii.set(self, "networkInterfaceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayMulticastDomainId")
    def transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayMulticastDomainId"))

    @transit_gateway_multicast_domain_id.setter
    def transit_gateway_multicast_domain_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayMulticastDomainId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayMulticastGroupSourceProps",
    jsii_struct_bases=[],
    name_mapping={
        "group_ip_address": "groupIpAddress",
        "network_interface_id": "networkInterfaceId",
        "transit_gateway_multicast_domain_id": "transitGatewayMulticastDomainId",
    },
)
class CfnTransitGatewayMulticastGroupSourceProps:
    def __init__(
        self,
        *,
        group_ip_address: builtins.str,
        network_interface_id: builtins.str,
        transit_gateway_multicast_domain_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayMulticastGroupSource``.

        :param group_ip_address: The IP address assigned to the transit gateway multicast group.
        :param network_interface_id: The group sources' network interface IDs to register with the transit gateway multicast group.
        :param transit_gateway_multicast_domain_id: The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_multicast_group_source_props = ec2.CfnTransitGatewayMulticastGroupSourceProps(
                group_ip_address="groupIpAddress",
                network_interface_id="networkInterfaceId",
                transit_gateway_multicast_domain_id="transitGatewayMulticastDomainId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "group_ip_address": group_ip_address,
            "network_interface_id": network_interface_id,
            "transit_gateway_multicast_domain_id": transit_gateway_multicast_domain_id,
        }

    @builtins.property
    def group_ip_address(self) -> builtins.str:
        '''The IP address assigned to the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-groupipaddress
        '''
        result = self._values.get("group_ip_address")
        assert result is not None, "Required property 'group_ip_address' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def network_interface_id(self) -> builtins.str:
        '''The group sources' network interface IDs to register with the transit gateway multicast group.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-networkinterfaceid
        '''
        result = self._values.get("network_interface_id")
        assert result is not None, "Required property 'network_interface_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_multicast_domain_id(self) -> builtins.str:
        '''The ID of the transit gateway multicast domain.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaymulticastgroupsource.html#cfn-ec2-transitgatewaymulticastgroupsource-transitgatewaymulticastdomainid
        '''
        result = self._values.get("transit_gateway_multicast_domain_id")
        assert result is not None, "Required property 'transit_gateway_multicast_domain_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayMulticastGroupSourceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayPeeringAttachment(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayPeeringAttachment",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayPeeringAttachment``.

    Requests a transit gateway peering attachment between the specified transit gateway (requester) and a peer transit gateway (accepter). The transit gateways must be in different Regions. The peer transit gateway can be in your account or a different AWS account .

    After you create the peering attachment, the owner of the accepter transit gateway must accept the attachment request.

    :cloudformationResource: AWS::EC2::TransitGatewayPeeringAttachment
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_peering_attachment = ec2.CfnTransitGatewayPeeringAttachment(self, "MyCfnTransitGatewayPeeringAttachment",
            peer_account_id="peerAccountId",
            peer_region="peerRegion",
            peer_transit_gateway_id="peerTransitGatewayId",
            transit_gateway_id="transitGatewayId",
        
            # the properties below are optional
            options=ec2.CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty(
                dynamic_routing="dynamicRouting"
            ),
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        peer_account_id: builtins.str,
        peer_region: builtins.str,
        peer_transit_gateway_id: builtins.str,
        transit_gateway_id: builtins.str,
        options: typing.Optional[typing.Union["CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty", _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayPeeringAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param peer_account_id: The ID of the AWS account that owns the transit gateway.
        :param peer_region: The Region of the transit gateway.
        :param peer_transit_gateway_id: The ID of the transit gateway.
        :param transit_gateway_id: The ID of the transit gateway peering attachment.
        :param options: ``AWS::EC2::TransitGatewayPeeringAttachment.Options``.
        :param tags: The tags for the transit gateway peering attachment.
        '''
        props = CfnTransitGatewayPeeringAttachmentProps(
            peer_account_id=peer_account_id,
            peer_region=peer_region,
            peer_transit_gateway_id=peer_transit_gateway_id,
            transit_gateway_id=transit_gateway_id,
            options=options,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCreationTime")
    def attr_creation_time(self) -> builtins.str:
        '''The time the transit gateway peering attachment was created.

        :cloudformationAttribute: CreationTime
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCreationTime"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrState")
    def attr_state(self) -> builtins.str:
        '''The state of the transit gateway peering attachment.

        Note that the ``initiating`` state has been deprecated.

        :cloudformationAttribute: State
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrState"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrTransitGatewayAttachmentId")
    def attr_transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the transit gateway peering attachment.

        :cloudformationAttribute: TransitGatewayAttachmentId
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrTransitGatewayAttachmentId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the transit gateway peering attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerAccountId")
    def peer_account_id(self) -> builtins.str:
        '''The ID of the AWS account that owns the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
        '''
        return typing.cast(builtins.str, jsii.get(self, "peerAccountId"))

    @peer_account_id.setter
    def peer_account_id(self, value: builtins.str) -> None:
        jsii.set(self, "peerAccountId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerRegion")
    def peer_region(self) -> builtins.str:
        '''The Region of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
        '''
        return typing.cast(builtins.str, jsii.get(self, "peerRegion"))

    @peer_region.setter
    def peer_region(self, value: builtins.str) -> None:
        jsii.set(self, "peerRegion", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerTransitGatewayId")
    def peer_transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "peerTransitGatewayId"))

    @peer_transit_gateway_id.setter
    def peer_transit_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "peerTransitGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway peering attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="options")
    def options(
        self,
    ) -> typing.Optional[typing.Union["CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty", _IResolvable_da3f097b]]:
        '''``AWS::EC2::TransitGatewayPeeringAttachment.Options``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-options
        '''
        return typing.cast(typing.Optional[typing.Union["CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty", _IResolvable_da3f097b]], jsii.get(self, "options"))

    @options.setter
    def options(
        self,
        value: typing.Optional[typing.Union["CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty", _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "options", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty",
        jsii_struct_bases=[],
        name_mapping={"dynamic_routing": "dynamicRouting"},
    )
    class TransitGatewayPeeringAttachmentOptionsProperty:
        def __init__(
            self,
            *,
            dynamic_routing: typing.Optional[builtins.str] = None,
        ) -> None:
            '''
            :param dynamic_routing: ``CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty.DynamicRouting``.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-transitgatewaypeeringattachmentoptions.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                transit_gateway_peering_attachment_options_property = ec2.CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty(
                    dynamic_routing="dynamicRouting"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if dynamic_routing is not None:
                self._values["dynamic_routing"] = dynamic_routing

        @builtins.property
        def dynamic_routing(self) -> typing.Optional[builtins.str]:
            '''``CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty.DynamicRouting``.

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-transitgatewaypeeringattachment-transitgatewaypeeringattachmentoptions.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewaypeeringattachmentoptions-dynamicrouting
            '''
            result = self._values.get("dynamic_routing")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "TransitGatewayPeeringAttachmentOptionsProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayPeeringAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "peer_account_id": "peerAccountId",
        "peer_region": "peerRegion",
        "peer_transit_gateway_id": "peerTransitGatewayId",
        "transit_gateway_id": "transitGatewayId",
        "options": "options",
        "tags": "tags",
    },
)
class CfnTransitGatewayPeeringAttachmentProps:
    def __init__(
        self,
        *,
        peer_account_id: builtins.str,
        peer_region: builtins.str,
        peer_transit_gateway_id: builtins.str,
        transit_gateway_id: builtins.str,
        options: typing.Optional[typing.Union[CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty, _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayPeeringAttachment``.

        :param peer_account_id: The ID of the AWS account that owns the transit gateway.
        :param peer_region: The Region of the transit gateway.
        :param peer_transit_gateway_id: The ID of the transit gateway.
        :param transit_gateway_id: The ID of the transit gateway peering attachment.
        :param options: ``AWS::EC2::TransitGatewayPeeringAttachment.Options``.
        :param tags: The tags for the transit gateway peering attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_peering_attachment_props = ec2.CfnTransitGatewayPeeringAttachmentProps(
                peer_account_id="peerAccountId",
                peer_region="peerRegion",
                peer_transit_gateway_id="peerTransitGatewayId",
                transit_gateway_id="transitGatewayId",
            
                # the properties below are optional
                options=ec2.CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty(
                    dynamic_routing="dynamicRouting"
                ),
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "peer_account_id": peer_account_id,
            "peer_region": peer_region,
            "peer_transit_gateway_id": peer_transit_gateway_id,
            "transit_gateway_id": transit_gateway_id,
        }
        if options is not None:
            self._values["options"] = options
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def peer_account_id(self) -> builtins.str:
        '''The ID of the AWS account that owns the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peeraccountid
        '''
        result = self._values.get("peer_account_id")
        assert result is not None, "Required property 'peer_account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def peer_region(self) -> builtins.str:
        '''The Region of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peerregion
        '''
        result = self._values.get("peer_region")
        assert result is not None, "Required property 'peer_region' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def peer_transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-peertransitgatewayid
        '''
        result = self._values.get("peer_transit_gateway_id")
        assert result is not None, "Required property 'peer_transit_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway peering attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        assert result is not None, "Required property 'transit_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def options(
        self,
    ) -> typing.Optional[typing.Union[CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty, _IResolvable_da3f097b]]:
        '''``AWS::EC2::TransitGatewayPeeringAttachment.Options``.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Optional[typing.Union[CfnTransitGatewayPeeringAttachment.TransitGatewayPeeringAttachmentOptionsProperty, _IResolvable_da3f097b]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the transit gateway peering attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewaypeeringattachment.html#cfn-ec2-transitgatewaypeeringattachment-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayPeeringAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayProps",
    jsii_struct_bases=[],
    name_mapping={
        "amazon_side_asn": "amazonSideAsn",
        "association_default_route_table_id": "associationDefaultRouteTableId",
        "auto_accept_shared_attachments": "autoAcceptSharedAttachments",
        "default_route_table_association": "defaultRouteTableAssociation",
        "default_route_table_propagation": "defaultRouteTablePropagation",
        "description": "description",
        "dns_support": "dnsSupport",
        "multicast_support": "multicastSupport",
        "propagation_default_route_table_id": "propagationDefaultRouteTableId",
        "tags": "tags",
        "transit_gateway_cidr_blocks": "transitGatewayCidrBlocks",
        "vpn_ecmp_support": "vpnEcmpSupport",
    },
)
class CfnTransitGatewayProps:
    def __init__(
        self,
        *,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        association_default_route_table_id: typing.Optional[builtins.str] = None,
        auto_accept_shared_attachments: typing.Optional[builtins.str] = None,
        default_route_table_association: typing.Optional[builtins.str] = None,
        default_route_table_propagation: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_support: typing.Optional[builtins.str] = None,
        multicast_support: typing.Optional[builtins.str] = None,
        propagation_default_route_table_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        transit_gateway_cidr_blocks: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpn_ecmp_support: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGateway``.

        :param amazon_side_asn: A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.
        :param association_default_route_table_id: The ID of the default association route table.
        :param auto_accept_shared_attachments: Enable or disable automatic acceptance of attachment requests. Disabled by default.
        :param default_route_table_association: Enable or disable automatic association with the default association route table. Enabled by default.
        :param default_route_table_propagation: Enable or disable automatic propagation of routes to the default propagation route table. Enabled by default.
        :param description: The description of the transit gateway.
        :param dns_support: Enable or disable DNS support. Enabled by default.
        :param multicast_support: Indicates whether multicast is enabled on the transit gateway.
        :param propagation_default_route_table_id: The ID of the default propagation route table.
        :param tags: The tags for the transit gateway.
        :param transit_gateway_cidr_blocks: The transit gateway CIDR blocks.
        :param vpn_ecmp_support: Enable or disable Equal Cost Multipath Protocol support. Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_props = ec2.CfnTransitGatewayProps(
                amazon_side_asn=123,
                association_default_route_table_id="associationDefaultRouteTableId",
                auto_accept_shared_attachments="autoAcceptSharedAttachments",
                default_route_table_association="defaultRouteTableAssociation",
                default_route_table_propagation="defaultRouteTablePropagation",
                description="description",
                dns_support="dnsSupport",
                multicast_support="multicastSupport",
                propagation_default_route_table_id="propagationDefaultRouteTableId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_cidr_blocks=["transitGatewayCidrBlocks"],
                vpn_ecmp_support="vpnEcmpSupport"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn
        if association_default_route_table_id is not None:
            self._values["association_default_route_table_id"] = association_default_route_table_id
        if auto_accept_shared_attachments is not None:
            self._values["auto_accept_shared_attachments"] = auto_accept_shared_attachments
        if default_route_table_association is not None:
            self._values["default_route_table_association"] = default_route_table_association
        if default_route_table_propagation is not None:
            self._values["default_route_table_propagation"] = default_route_table_propagation
        if description is not None:
            self._values["description"] = description
        if dns_support is not None:
            self._values["dns_support"] = dns_support
        if multicast_support is not None:
            self._values["multicast_support"] = multicast_support
        if propagation_default_route_table_id is not None:
            self._values["propagation_default_route_table_id"] = propagation_default_route_table_id
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_cidr_blocks is not None:
            self._values["transit_gateway_cidr_blocks"] = transit_gateway_cidr_blocks
        if vpn_ecmp_support is not None:
            self._values["vpn_ecmp_support"] = vpn_ecmp_support

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''A private Autonomous System Number (ASN) for the Amazon side of a BGP session.

        The range is 64512 to 65534 for 16-bit ASNs. The default is 64512.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-amazonsideasn
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def association_default_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the default association route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-associationdefaultroutetableid
        '''
        result = self._values.get("association_default_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def auto_accept_shared_attachments(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic acceptance of attachment requests.

        Disabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-autoacceptsharedattachments
        '''
        result = self._values.get("auto_accept_shared_attachments")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_route_table_association(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic association with the default association route table.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetableassociation
        '''
        result = self._values.get("default_route_table_association")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_route_table_propagation(self) -> typing.Optional[builtins.str]:
        '''Enable or disable automatic propagation of routes to the default propagation route table.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-defaultroutetablepropagation
        '''
        result = self._values.get("default_route_table_propagation")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''The description of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable DNS support.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-dnssupport
        '''
        result = self._values.get("dns_support")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def multicast_support(self) -> typing.Optional[builtins.str]:
        '''Indicates whether multicast is enabled on the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-multicastsupport
        '''
        result = self._values.get("multicast_support")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def propagation_default_route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the default propagation route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-propagationdefaultroutetableid
        '''
        result = self._values.get("propagation_default_route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def transit_gateway_cidr_blocks(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The transit gateway CIDR blocks.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-transitgatewaycidrblocks
        '''
        result = self._values.get("transit_gateway_cidr_blocks")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpn_ecmp_support(self) -> typing.Optional[builtins.str]:
        '''Enable or disable Equal Cost Multipath Protocol support.

        Enabled by default.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgateway.html#cfn-ec2-transitgateway-vpnecmpsupport
        '''
        result = self._values.get("vpn_ecmp_support")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayRoute(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRoute",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayRoute``.

    Specifies a static route for a transit gateway route table.

    :cloudformationResource: AWS::EC2::TransitGatewayRoute
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_route = ec2.CfnTransitGatewayRoute(self, "MyCfnTransitGatewayRoute",
            transit_gateway_route_table_id="transitGatewayRouteTableId",
        
            # the properties below are optional
            blackhole=False,
            destination_cidr_block="destinationCidrBlock",
            transit_gateway_attachment_id="transitGatewayAttachmentId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        transit_gateway_route_table_id: builtins.str,
        blackhole: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayRoute``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param transit_gateway_route_table_id: The ID of the transit gateway route table.
        :param blackhole: Indicates whether to drop traffic that matches this route.
        :param destination_cidr_block: The CIDR block used for destination matches.
        :param transit_gateway_attachment_id: The ID of the attachment.
        '''
        props = CfnTransitGatewayRouteProps(
            transit_gateway_route_table_id=transit_gateway_route_table_id,
            blackhole=blackhole,
            destination_cidr_block=destination_cidr_block,
            transit_gateway_attachment_id=transit_gateway_attachment_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayRouteTableId")
    def transit_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the transit gateway route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))

    @transit_gateway_route_table_id.setter
    def transit_gateway_route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayRouteTableId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="blackhole")
    def blackhole(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether to drop traffic that matches this route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "blackhole"))

    @blackhole.setter
    def blackhole(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "blackhole", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The CIDR block used for destination matches.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "destinationCidrBlock"))

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transitGatewayAttachmentId"))

    @transit_gateway_attachment_id.setter
    def transit_gateway_attachment_id(
        self,
        value: typing.Optional[builtins.str],
    ) -> None:
        jsii.set(self, "transitGatewayAttachmentId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "transit_gateway_route_table_id": "transitGatewayRouteTableId",
        "blackhole": "blackhole",
        "destination_cidr_block": "destinationCidrBlock",
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
    },
)
class CfnTransitGatewayRouteProps:
    def __init__(
        self,
        *,
        transit_gateway_route_table_id: builtins.str,
        blackhole: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayRoute``.

        :param transit_gateway_route_table_id: The ID of the transit gateway route table.
        :param blackhole: Indicates whether to drop traffic that matches this route.
        :param destination_cidr_block: The CIDR block used for destination matches.
        :param transit_gateway_attachment_id: The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_route_props = ec2.CfnTransitGatewayRouteProps(
                transit_gateway_route_table_id="transitGatewayRouteTableId",
            
                # the properties below are optional
                blackhole=False,
                destination_cidr_block="destinationCidrBlock",
                transit_gateway_attachment_id="transitGatewayAttachmentId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "transit_gateway_route_table_id": transit_gateway_route_table_id,
        }
        if blackhole is not None:
            self._values["blackhole"] = blackhole
        if destination_cidr_block is not None:
            self._values["destination_cidr_block"] = destination_cidr_block
        if transit_gateway_attachment_id is not None:
            self._values["transit_gateway_attachment_id"] = transit_gateway_attachment_id

    @builtins.property
    def transit_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the transit gateway route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayroutetableid
        '''
        result = self._values.get("transit_gateway_route_table_id")
        assert result is not None, "Required property 'transit_gateway_route_table_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def blackhole(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether to drop traffic that matches this route.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-blackhole
        '''
        result = self._values.get("blackhole")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def destination_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The CIDR block used for destination matches.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-destinationcidrblock
        '''
        result = self._values.get("destination_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transit_gateway_attachment_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroute.html#cfn-ec2-transitgatewayroute-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayRouteTable(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteTable",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayRouteTable``.

    Specifies a route table for a transit gateway.

    :cloudformationResource: AWS::EC2::TransitGatewayRouteTable
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_route_table = ec2.CfnTransitGatewayRouteTable(self, "MyCfnTransitGatewayRouteTable",
            transit_gateway_id="transitGatewayId",
        
            # the properties below are optional
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        transit_gateway_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayRouteTable``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param transit_gateway_id: The ID of the transit gateway.
        :param tags: Any tags assigned to the route table.
        '''
        props = CfnTransitGatewayRouteTableProps(
            transit_gateway_id=transit_gateway_id, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayId", value)


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayRouteTableAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteTableAssociation",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayRouteTableAssociation``.

    Associates the specified attachment with the specified transit gateway route table. You can associate one route table with an attachment.

    Before you can update the route table associated with an attachment, you must disassociate the transit gateway route table that is currently associated with the attachment. First update the stack to remove the associated transit gateway route table, and then update the stack with the ID of the new transit gateway route table to associate.

    :cloudformationResource: AWS::EC2::TransitGatewayRouteTableAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_route_table_association = ec2.CfnTransitGatewayRouteTableAssociation(self, "MyCfnTransitGatewayRouteTableAssociation",
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_route_table_id="transitGatewayRouteTableId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        transit_gateway_attachment_id: builtins.str,
        transit_gateway_route_table_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayRouteTableAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the route table for the transit gateway.
        '''
        props = CfnTransitGatewayRouteTableAssociationProps(
            transit_gateway_attachment_id=transit_gateway_attachment_id,
            transit_gateway_route_table_id=transit_gateway_route_table_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))

    @transit_gateway_attachment_id.setter
    def transit_gateway_attachment_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayAttachmentId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayRouteTableId")
    def transit_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the route table for the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))

    @transit_gateway_route_table_id.setter
    def transit_gateway_route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayRouteTableId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteTableAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_route_table_id": "transitGatewayRouteTableId",
    },
)
class CfnTransitGatewayRouteTableAssociationProps:
    def __init__(
        self,
        *,
        transit_gateway_attachment_id: builtins.str,
        transit_gateway_route_table_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayRouteTableAssociation``.

        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the route table for the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_route_table_association_props = ec2.CfnTransitGatewayRouteTableAssociationProps(
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_route_table_id="transitGatewayRouteTableId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "transit_gateway_attachment_id": transit_gateway_attachment_id,
            "transit_gateway_route_table_id": transit_gateway_route_table_id,
        }

    @builtins.property
    def transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        assert result is not None, "Required property 'transit_gateway_attachment_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the route table for the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetableassociation.html#cfn-ec2-transitgatewayroutetableassociation-transitgatewayroutetableid
        '''
        result = self._values.get("transit_gateway_route_table_id")
        assert result is not None, "Required property 'transit_gateway_route_table_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteTableAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayRouteTablePropagation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteTablePropagation",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayRouteTablePropagation``.

    Enables the specified attachment to propagate routes to the specified propagation route table.

    For more information about enabling transit gateway route propagation, see `EnableTransitGatewayRouteTablePropagation <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableTransitGatewayRouteTablePropagation.html>`_ in the *Amazon EC2 API Reference* .

    :cloudformationResource: AWS::EC2::TransitGatewayRouteTablePropagation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_transit_gateway_route_table_propagation = ec2.CfnTransitGatewayRouteTablePropagation(self, "MyCfnTransitGatewayRouteTablePropagation",
            transit_gateway_attachment_id="transitGatewayAttachmentId",
            transit_gateway_route_table_id="transitGatewayRouteTableId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        transit_gateway_attachment_id: builtins.str,
        transit_gateway_route_table_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayRouteTablePropagation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the propagation route table.
        '''
        props = CfnTransitGatewayRouteTablePropagationProps(
            transit_gateway_attachment_id=transit_gateway_attachment_id,
            transit_gateway_route_table_id=transit_gateway_route_table_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayAttachmentId")
    def transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayAttachmentId"))

    @transit_gateway_attachment_id.setter
    def transit_gateway_attachment_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayAttachmentId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayRouteTableId")
    def transit_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the propagation route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
        '''
        return typing.cast(builtins.str, jsii.get(self, "transitGatewayRouteTableId"))

    @transit_gateway_route_table_id.setter
    def transit_gateway_route_table_id(self, value: builtins.str) -> None:
        jsii.set(self, "transitGatewayRouteTableId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteTablePropagationProps",
    jsii_struct_bases=[],
    name_mapping={
        "transit_gateway_attachment_id": "transitGatewayAttachmentId",
        "transit_gateway_route_table_id": "transitGatewayRouteTableId",
    },
)
class CfnTransitGatewayRouteTablePropagationProps:
    def __init__(
        self,
        *,
        transit_gateway_attachment_id: builtins.str,
        transit_gateway_route_table_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayRouteTablePropagation``.

        :param transit_gateway_attachment_id: The ID of the attachment.
        :param transit_gateway_route_table_id: The ID of the propagation route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_route_table_propagation_props = ec2.CfnTransitGatewayRouteTablePropagationProps(
                transit_gateway_attachment_id="transitGatewayAttachmentId",
                transit_gateway_route_table_id="transitGatewayRouteTableId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "transit_gateway_attachment_id": transit_gateway_attachment_id,
            "transit_gateway_route_table_id": transit_gateway_route_table_id,
        }

    @builtins.property
    def transit_gateway_attachment_id(self) -> builtins.str:
        '''The ID of the attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayattachmentid
        '''
        result = self._values.get("transit_gateway_attachment_id")
        assert result is not None, "Required property 'transit_gateway_attachment_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def transit_gateway_route_table_id(self) -> builtins.str:
        '''The ID of the propagation route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetablepropagation.html#cfn-ec2-transitgatewayroutetablepropagation-transitgatewayroutetableid
        '''
        result = self._values.get("transit_gateway_route_table_id")
        assert result is not None, "Required property 'transit_gateway_route_table_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteTablePropagationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayRouteTableProps",
    jsii_struct_bases=[],
    name_mapping={"transit_gateway_id": "transitGatewayId", "tags": "tags"},
)
class CfnTransitGatewayRouteTableProps:
    def __init__(
        self,
        *,
        transit_gateway_id: builtins.str,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayRouteTable``.

        :param transit_gateway_id: The ID of the transit gateway.
        :param tags: Any tags assigned to the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_transit_gateway_route_table_props = ec2.CfnTransitGatewayRouteTableProps(
                transit_gateway_id="transitGatewayId",
            
                # the properties below are optional
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "transit_gateway_id": transit_gateway_id,
        }
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def transit_gateway_id(self) -> builtins.str:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        assert result is not None, "Required property 'transit_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the route table.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayroutetable.html#cfn-ec2-transitgatewayroutetable-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayRouteTableProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnTransitGatewayVpcAttachment(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayVpcAttachment",
):
    '''A CloudFormation ``AWS::EC2::TransitGatewayVpcAttachment``.

    Specifies a VPC attachment.

    :cloudformationResource: AWS::EC2::TransitGatewayVpcAttachment
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # options: Any
        
        cfn_transit_gateway_vpc_attachment = ec2.CfnTransitGatewayVpcAttachment(self, "MyCfnTransitGatewayVpcAttachment",
            add_subnet_ids=["addSubnetIds"],
            options=options,
            remove_subnet_ids=["removeSubnetIds"],
            subnet_ids=["subnetIds"],
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId",
            vpc_id="vpcId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        add_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        options: typing.Any = None,
        remove_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::TransitGatewayVpcAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param add_subnet_ids: The IDs of one or more subnets to add. You can specify at most one subnet per Availability Zone.
        :param options: The VPC attachment options in JSON or YAML. - DnsSupport (enable | disable) - Ipv6Support (enable| disable) - ApplianceModeSupport (enable | disable)
        :param remove_subnet_ids: The IDs of one or more subnets to remove.
        :param subnet_ids: The IDs of the subnets.
        :param tags: The tags for the VPC attachment.
        :param transit_gateway_id: The ID of the transit gateway.
        :param vpc_id: The ID of the VPC.
        '''
        props = CfnTransitGatewayVpcAttachmentProps(
            add_subnet_ids=add_subnet_ids,
            options=options,
            remove_subnet_ids=remove_subnet_ids,
            subnet_ids=subnet_ids,
            tags=tags,
            transit_gateway_id=transit_gateway_id,
            vpc_id=vpc_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the attachment.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the VPC attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="options")
    def options(self) -> typing.Any:
        '''The VPC attachment options in JSON or YAML.

        - DnsSupport (enable | disable)
        - Ipv6Support (enable| disable)
        - ApplianceModeSupport (enable | disable)

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
        '''
        return typing.cast(typing.Any, jsii.get(self, "options"))

    @options.setter
    def options(self, value: typing.Any) -> None:
        jsii.set(self, "options", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="addSubnetIds")
    def add_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets to add.

        You can specify at most one subnet per Availability Zone.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "addSubnetIds"))

    @add_subnet_ids.setter
    def add_subnet_ids(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "addSubnetIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="removeSubnetIds")
    def remove_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets to remove.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "removeSubnetIds"))

    @remove_subnet_ids.setter
    def remove_subnet_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "removeSubnetIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetIds")
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the subnets.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "subnetIds"))

    @subnet_ids.setter
    def subnet_ids(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "subnetIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "transitGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnTransitGatewayVpcAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "add_subnet_ids": "addSubnetIds",
        "options": "options",
        "remove_subnet_ids": "removeSubnetIds",
        "subnet_ids": "subnetIds",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
        "vpc_id": "vpcId",
    },
)
class CfnTransitGatewayVpcAttachmentProps:
    def __init__(
        self,
        *,
        add_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        options: typing.Any = None,
        remove_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpc_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnTransitGatewayVpcAttachment``.

        :param add_subnet_ids: The IDs of one or more subnets to add. You can specify at most one subnet per Availability Zone.
        :param options: The VPC attachment options in JSON or YAML. - DnsSupport (enable | disable) - Ipv6Support (enable| disable) - ApplianceModeSupport (enable | disable)
        :param remove_subnet_ids: The IDs of one or more subnets to remove.
        :param subnet_ids: The IDs of the subnets.
        :param tags: The tags for the VPC attachment.
        :param transit_gateway_id: The ID of the transit gateway.
        :param vpc_id: The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # options: Any
            
            cfn_transit_gateway_vpc_attachment_props = ec2.CfnTransitGatewayVpcAttachmentProps(
                add_subnet_ids=["addSubnetIds"],
                options=options,
                remove_subnet_ids=["removeSubnetIds"],
                subnet_ids=["subnetIds"],
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId",
                vpc_id="vpcId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if add_subnet_ids is not None:
            self._values["add_subnet_ids"] = add_subnet_ids
        if options is not None:
            self._values["options"] = options
        if remove_subnet_ids is not None:
            self._values["remove_subnet_ids"] = remove_subnet_ids
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id

    @builtins.property
    def add_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets to add.

        You can specify at most one subnet per Availability Zone.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-addsubnetids
        '''
        result = self._values.get("add_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def options(self) -> typing.Any:
        '''The VPC attachment options in JSON or YAML.

        - DnsSupport (enable | disable)
        - Ipv6Support (enable| disable)
        - ApplianceModeSupport (enable | disable)

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-options
        '''
        result = self._values.get("options")
        return typing.cast(typing.Any, result)

    @builtins.property
    def remove_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of one or more subnets to remove.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-removesubnetids
        '''
        result = self._values.get("remove_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the subnets.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-subnetids
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the VPC attachment.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-transitgatewayvpcattachment.html#cfn-ec2-transitgatewayvpcattachment-vpcid
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnTransitGatewayVpcAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPC(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPC",
):
    '''A CloudFormation ``AWS::EC2::VPC``.

    Specifies a VPC with the specified IPv4 CIDR block. The smallest VPC you can create uses a /28 netmask (16 IPv4 addresses), and the largest uses a /16 netmask (65,536 IPv4 addresses). For more information about how large to make your VPC, see `Overview of VPCs and subnets <https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html>`_ in the *Amazon Virtual Private Cloud User Guide* .

    :cloudformationResource: AWS::EC2::VPC
    :exampleMetadata: infused
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html

    Example::

        # cfn_template: cfn_inc.CfnInclude
        
        # using from*Attributes()
        # private_cfn_subnet1: ec2.CfnSubnet
        # private_cfn_subnet2: ec2.CfnSubnet
        
        
        # using from*Name()
        cfn_bucket = cfn_template.get_resource("Bucket")
        bucket = s3.Bucket.from_bucket_name(self, "L2Bucket", cfn_bucket.ref)
        
        # using from*Arn()
        cfn_key = cfn_template.get_resource("Key")
        key = kms.Key.from_key_arn(self, "L2Key", cfn_key.attr_arn)
        cfn_vpc = cfn_template.get_resource("Vpc")
        vpc = ec2.Vpc.from_vpc_attributes(self, "L2Vpc",
            vpc_id=cfn_vpc.ref,
            availability_zones=core.Fn.get_azs(),
            private_subnet_ids=[private_cfn_subnet1.ref, private_cfn_subnet2.ref]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cidr_block: builtins.str,
        enable_dns_hostnames: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        enable_dns_support: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        instance_tenancy: typing.Optional[builtins.str] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPC``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param cidr_block: The primary IPv4 CIDR block for the VPC.
        :param enable_dns_hostnames: Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ . You can only enable DNS hostnames if you've enabled DNS support.
        :param enable_dns_support: Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .
        :param instance_tenancy: The allowed tenancy of instances launched into the VPC. - ``"default"`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch. - ``"dedicated"`` : An instance launched into the VPC is a Dedicated Instance by default, unless you explicitly specify a tenancy of host during instance launch. You cannot specify a tenancy of default during instance launch. Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``"dedicated"`` to ``"default"`` . Updating ``InstanceTenancy`` from ``"default"`` to ``"dedicated"`` requires replacement.
        :param ipv4_ipam_pool_id: The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv4_netmask_length: The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param tags: The tags for the VPC.
        '''
        props = CfnVPCProps(
            cidr_block=cidr_block,
            enable_dns_hostnames=enable_dns_hostnames,
            enable_dns_support=enable_dns_support,
            instance_tenancy=instance_tenancy,
            ipv4_ipam_pool_id=ipv4_ipam_pool_id,
            ipv4_netmask_length=ipv4_netmask_length,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCidrBlock")
    def attr_cidr_block(self) -> builtins.str:
        '''The set of IP addresses for the VPC.

        For example, ``10.0.0.0/16`` .

        :cloudformationAttribute: CidrBlock
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCidrBlock"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCidrBlockAssociations")
    def attr_cidr_block_associations(self) -> typing.List[builtins.str]:
        '''The IPv4 CIDR block association IDs for the VPC.

        For example, ``[ vpc-cidr-assoc-0280ab6b ]`` .

        :cloudformationAttribute: CidrBlockAssociations
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "attrCidrBlockAssociations"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrDefaultNetworkAcl")
    def attr_default_network_acl(self) -> builtins.str:
        '''The default network ACL ID that is associated with the VPC.

        For example, ``acl-814dafe3`` .

        :cloudformationAttribute: DefaultNetworkAcl
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDefaultNetworkAcl"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrDefaultSecurityGroup")
    def attr_default_security_group(self) -> builtins.str:
        '''The default security group ID that is associated with the VPC.

        For example, ``sg-b178e0d3`` .

        :cloudformationAttribute: DefaultSecurityGroup
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrDefaultSecurityGroup"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrIpv6CidrBlocks")
    def attr_ipv6_cidr_blocks(self) -> typing.List[builtins.str]:
        '''The IPv6 CIDR blocks that are associated with the VPC, such as ``[ 2001:db8:1234:1a00::/56 ]`` .

        :cloudformationAttribute: Ipv6CidrBlocks
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "attrIpv6CidrBlocks"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> builtins.str:
        '''The primary IPv4 CIDR block for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-cidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "cidrBlock"))

    @cidr_block.setter
    def cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "cidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enableDnsHostnames")
    def enable_dns_hostnames(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the instances launched in the VPC get DNS hostnames.

        If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .

        You can only enable DNS hostnames if you've enabled DNS support.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-EnableDnsHostnames
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "enableDnsHostnames"))

    @enable_dns_hostnames.setter
    def enable_dns_hostnames(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "enableDnsHostnames", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="enableDnsSupport")
    def enable_dns_support(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the DNS resolution is supported for the VPC.

        If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-EnableDnsSupport
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "enableDnsSupport"))

    @enable_dns_support.setter
    def enable_dns_support(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "enableDnsSupport", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceTenancy")
    def instance_tenancy(self) -> typing.Optional[builtins.str]:
        '''The allowed tenancy of instances launched into the VPC.

        - ``"default"`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
        - ``"dedicated"`` : An instance launched into the VPC is a Dedicated Instance by default, unless you explicitly specify a tenancy of host during instance launch. You cannot specify a tenancy of default during instance launch.

        Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``"dedicated"`` to ``"default"`` . Updating ``InstanceTenancy`` from ``"default"`` to ``"dedicated"`` requires replacement.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-instancetenancy
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "instanceTenancy"))

    @instance_tenancy.setter
    def instance_tenancy(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "instanceTenancy", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4IpamPoolId")
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.

        For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv4IpamPoolId"))

    @ipv4_ipam_pool_id.setter
    def ipv4_ipam_pool_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv4IpamPoolId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4NetmaskLength")
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "ipv4NetmaskLength"))

    @ipv4_netmask_length.setter
    def ipv4_netmask_length(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv4NetmaskLength", value)


@jsii.implements(_IInspectable_c2943556)
class CfnVPCCidrBlock(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCCidrBlock",
):
    '''A CloudFormation ``AWS::EC2::VPCCidrBlock``.

    Associates a CIDR block with your VPC. You can only associate a single IPv6 CIDR block with your VPC. The IPv6 CIDR block size is fixed at /56.

    For more information about associating CIDR blocks with your VPC and applicable restrictions, see `VPC and Subnet Sizing <https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Subnets.html#VPC_Sizing>`_ in the *Amazon Virtual Private Cloud User Guide* .

    :cloudformationResource: AWS::EC2::VPCCidrBlock
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCCidr_block = ec2.CfnVPCCidrBlock(self, "MyCfnVPCCidrBlock",
            vpc_id="vpcId",
        
            # the properties below are optional
            amazon_provided_ipv6_cidr_block=False,
            cidr_block="cidrBlock",
            ipv4_ipam_pool_id="ipv4IpamPoolId",
            ipv4_netmask_length=123,
            ipv6_cidr_block="ipv6CidrBlock",
            ipv6_ipam_pool_id="ipv6IpamPoolId",
            ipv6_netmask_length=123,
            ipv6_pool="ipv6Pool"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_id: builtins.str,
        amazon_provided_ipv6_cidr_block: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        cidr_block: typing.Optional[builtins.str] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv6_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_pool: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCCidrBlock``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param vpc_id: The ID of the VPC.
        :param amazon_provided_ipv6_cidr_block: Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
        :param cidr_block: An IPv4 CIDR block to associate with the VPC.
        :param ipv4_ipam_pool_id: Associate a CIDR allocated from an IPv4 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv4_netmask_length: The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_cidr_block: An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request. To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
        :param ipv6_ipam_pool_id: Associates a CIDR allocated from an IPv6 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_netmask_length: The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_pool: The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.
        '''
        props = CfnVPCCidrBlockProps(
            vpc_id=vpc_id,
            amazon_provided_ipv6_cidr_block=amazon_provided_ipv6_cidr_block,
            cidr_block=cidr_block,
            ipv4_ipam_pool_id=ipv4_ipam_pool_id,
            ipv4_netmask_length=ipv4_netmask_length,
            ipv6_cidr_block=ipv6_cidr_block,
            ipv6_ipam_pool_id=ipv6_ipam_pool_id,
            ipv6_netmask_length=ipv6_netmask_length,
            ipv6_pool=ipv6_pool,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="amazonProvidedIpv6CidrBlock")
    def amazon_provided_ipv6_cidr_block(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.

        You cannot specify the range of IPv6 addresses, or the size of the CIDR block.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "amazonProvidedIpv6CidrBlock"))

    @amazon_provided_ipv6_cidr_block.setter
    def amazon_provided_ipv6_cidr_block(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "amazonProvidedIpv6CidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cidrBlock")
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''An IPv4 CIDR block to associate with the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "cidrBlock"))

    @cidr_block.setter
    def cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "cidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4IpamPoolId")
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.

        For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv4IpamPoolId"))

    @ipv4_ipam_pool_id.setter
    def ipv4_ipam_pool_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv4IpamPoolId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4NetmaskLength")
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "ipv4NetmaskLength"))

    @ipv4_netmask_length.setter
    def ipv4_netmask_length(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv4NetmaskLength", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6CidrBlock")
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request.

        To let Amazon choose the IPv6 CIDR block for you, omit this parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv6CidrBlock"))

    @ipv6_cidr_block.setter
    def ipv6_cidr_block(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6CidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6IpamPoolId")
    def ipv6_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.

        For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv6IpamPoolId"))

    @ipv6_ipam_pool_id.setter
    def ipv6_ipam_pool_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6IpamPoolId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6NetmaskLength")
    def ipv6_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "ipv6NetmaskLength"))

    @ipv6_netmask_length.setter
    def ipv6_netmask_length(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "ipv6NetmaskLength", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv6Pool")
    def ipv6_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "ipv6Pool"))

    @ipv6_pool.setter
    def ipv6_pool(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "ipv6Pool", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCCidrBlockProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "amazon_provided_ipv6_cidr_block": "amazonProvidedIpv6CidrBlock",
        "cidr_block": "cidrBlock",
        "ipv4_ipam_pool_id": "ipv4IpamPoolId",
        "ipv4_netmask_length": "ipv4NetmaskLength",
        "ipv6_cidr_block": "ipv6CidrBlock",
        "ipv6_ipam_pool_id": "ipv6IpamPoolId",
        "ipv6_netmask_length": "ipv6NetmaskLength",
        "ipv6_pool": "ipv6Pool",
    },
)
class CfnVPCCidrBlockProps:
    def __init__(
        self,
        *,
        vpc_id: builtins.str,
        amazon_provided_ipv6_cidr_block: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        cidr_block: typing.Optional[builtins.str] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_cidr_block: typing.Optional[builtins.str] = None,
        ipv6_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv6_netmask_length: typing.Optional[jsii.Number] = None,
        ipv6_pool: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCCidrBlock``.

        :param vpc_id: The ID of the VPC.
        :param amazon_provided_ipv6_cidr_block: Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.
        :param cidr_block: An IPv4 CIDR block to associate with the VPC.
        :param ipv4_ipam_pool_id: Associate a CIDR allocated from an IPv4 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv4_netmask_length: The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_cidr_block: An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request. To let Amazon choose the IPv6 CIDR block for you, omit this parameter.
        :param ipv6_ipam_pool_id: Associates a CIDR allocated from an IPv6 IPAM pool to a VPC. For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_netmask_length: The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv6_pool: The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCCidr_block_props = ec2.CfnVPCCidrBlockProps(
                vpc_id="vpcId",
            
                # the properties below are optional
                amazon_provided_ipv6_cidr_block=False,
                cidr_block="cidrBlock",
                ipv4_ipam_pool_id="ipv4IpamPoolId",
                ipv4_netmask_length=123,
                ipv6_cidr_block="ipv6CidrBlock",
                ipv6_ipam_pool_id="ipv6IpamPoolId",
                ipv6_netmask_length=123,
                ipv6_pool="ipv6Pool"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if amazon_provided_ipv6_cidr_block is not None:
            self._values["amazon_provided_ipv6_cidr_block"] = amazon_provided_ipv6_cidr_block
        if cidr_block is not None:
            self._values["cidr_block"] = cidr_block
        if ipv4_ipam_pool_id is not None:
            self._values["ipv4_ipam_pool_id"] = ipv4_ipam_pool_id
        if ipv4_netmask_length is not None:
            self._values["ipv4_netmask_length"] = ipv4_netmask_length
        if ipv6_cidr_block is not None:
            self._values["ipv6_cidr_block"] = ipv6_cidr_block
        if ipv6_ipam_pool_id is not None:
            self._values["ipv6_ipam_pool_id"] = ipv6_ipam_pool_id
        if ipv6_netmask_length is not None:
            self._values["ipv6_netmask_length"] = ipv6_netmask_length
        if ipv6_pool is not None:
            self._values["ipv6_pool"] = ipv6_pool

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def amazon_provided_ipv6_cidr_block(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC.

        You cannot specify the range of IPv6 addresses, or the size of the CIDR block.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-amazonprovidedipv6cidrblock
        '''
        result = self._values.get("amazon_provided_ipv6_cidr_block")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def cidr_block(self) -> typing.Optional[builtins.str]:
        '''An IPv4 CIDR block to associate with the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-cidrblock
        '''
        result = self._values.get("cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''Associate a CIDR allocated from an IPv4 IPAM pool to a VPC.

        For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4ipampoolid
        '''
        result = self._values.get("ipv4_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv4 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv4netmasklength
        '''
        result = self._values.get("ipv4_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_cidr_block(self) -> typing.Optional[builtins.str]:
        '''An IPv6 CIDR block from the IPv6 address pool. You must also specify ``Ipv6Pool`` in the request.

        To let Amazon choose the IPv6 CIDR block for you, omit this parameter.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6cidrblock
        '''
        result = self._values.get("ipv6_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''Associates a CIDR allocated from an IPv6 IPAM pool to a VPC.

        For more information about Amazon VPC IP Address Manager (IPAM), see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6ipampoolid
        '''
        result = self._values.get("ipv6_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv6_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv6 CIDR you would like to associate from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6netmasklength
        '''
        result = self._values.get("ipv6_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ipv6_pool(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPv6 address pool from which to allocate the IPv6 CIDR block.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpccidrblock.html#cfn-ec2-vpccidrblock-ipv6pool
        '''
        result = self._values.get("ipv6_pool")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCCidrBlockProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPCDHCPOptionsAssociation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCDHCPOptionsAssociation",
):
    '''A CloudFormation ``AWS::EC2::VPCDHCPOptionsAssociation``.

    Associates a set of DHCP options with a VPC, or associates no DHCP options with the VPC.

    After you associate the options with the VPC, any existing instances and all new instances that you launch in that VPC use the options. You don't need to restart or relaunch the instances. They automatically pick up the changes within a few hours, depending on how frequently the instance renews its DHCP lease. You can explicitly renew the lease using the operating system on the instance.

    :cloudformationResource: AWS::EC2::VPCDHCPOptionsAssociation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCDHCPOptions_association = ec2.CfnVPCDHCPOptionsAssociation(self, "MyCfnVPCDHCPOptionsAssociation",
            dhcp_options_id="dhcpOptionsId",
            vpc_id="vpcId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        dhcp_options_id: builtins.str,
        vpc_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCDHCPOptionsAssociation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param dhcp_options_id: The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.
        :param vpc_id: The ID of the VPC.
        '''
        props = CfnVPCDHCPOptionsAssociationProps(
            dhcp_options_id=dhcp_options_id, vpc_id=vpc_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the DHCP options set.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dhcpOptionsId")
    def dhcp_options_id(self) -> builtins.str:
        '''The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
        '''
        return typing.cast(builtins.str, jsii.get(self, "dhcpOptionsId"))

    @dhcp_options_id.setter
    def dhcp_options_id(self, value: builtins.str) -> None:
        jsii.set(self, "dhcpOptionsId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCDHCPOptionsAssociationProps",
    jsii_struct_bases=[],
    name_mapping={"dhcp_options_id": "dhcpOptionsId", "vpc_id": "vpcId"},
)
class CfnVPCDHCPOptionsAssociationProps:
    def __init__(self, *, dhcp_options_id: builtins.str, vpc_id: builtins.str) -> None:
        '''Properties for defining a ``CfnVPCDHCPOptionsAssociation``.

        :param dhcp_options_id: The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.
        :param vpc_id: The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCDHCPOptions_association_props = ec2.CfnVPCDHCPOptionsAssociationProps(
                dhcp_options_id="dhcpOptionsId",
                vpc_id="vpcId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "dhcp_options_id": dhcp_options_id,
            "vpc_id": vpc_id,
        }

    @builtins.property
    def dhcp_options_id(self) -> builtins.str:
        '''The ID of the DHCP options set, or ``default`` to associate no DHCP options with the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-dhcpoptionsid
        '''
        result = self._values.get("dhcp_options_id")
        assert result is not None, "Required property 'dhcp_options_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcdhcpoptionsassociation.html#cfn-ec2-vpcdhcpoptionsassociation-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCDHCPOptionsAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPCEndpoint(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpoint",
):
    '''A CloudFormation ``AWS::EC2::VPCEndpoint``.

    Specifies a VPC endpoint for a service. An endpoint enables you to create a private connection between your VPC and the service. The service may be provided by AWS , an AWS Marketplace Partner, or another AWS account. For more information, see the `AWS PrivateLink User Guide <https://docs.aws.amazon.com/vpc/latest/privatelink/>`_ .

    An interface endpoint establishes connections between the subnets in your VPC and an AWS service, your own service, or a service hosted by another AWS account . You can specify the subnets in which to create the endpoint and the security groups to associate with the endpoint network interface.

    A gateway endpoint serves as a target for a route in your route table for traffic destined for Amazon S3 or Amazon DynamoDB. You can specify an endpoint policy for the endpoint, which controls access to the service from your VPC. You can also specify the VPC route tables that use the endpoint. For information about connectivity to Amazon S3, see `Why canâ€™t I connect to an S3 bucket using a gateway VPC endpoint? <https://docs.aws.amazon.com/premiumsupport/knowledge-center/connect-s3-vpc-endpoint>`_

    A Gateway Load Balancer endpoint provides private connectivity between your VPC and virtual appliances from a service provider.

    :cloudformationResource: AWS::EC2::VPCEndpoint
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # policy_document: Any
        
        cfn_vPCEndpoint = ec2.CfnVPCEndpoint(self, "MyCfnVPCEndpoint",
            service_name="serviceName",
            vpc_id="vpcId",
        
            # the properties below are optional
            policy_document=policy_document,
            private_dns_enabled=False,
            route_table_ids=["routeTableIds"],
            security_group_ids=["securityGroupIds"],
            subnet_ids=["subnetIds"],
            vpc_endpoint_type="vpcEndpointType"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        service_name: builtins.str,
        vpc_id: builtins.str,
        policy_document: typing.Any = None,
        private_dns_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpc_endpoint_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCEndpoint``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param service_name: The service name. To list the available services, use `DescribeVpcEndpointServices <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html>`_ . Otherwise, get the name from the service provider.
        :param vpc_id: The ID of the VPC in which the endpoint will be used.
        :param policy_document: A policy that controls access to the service from the VPC. If this parameter is not specified, the default policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
        :param private_dns_enabled: Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` . This property is supported only for interface endpoints. Default: ``false``
        :param route_table_ids: The route table IDs. Routing is supported only for gateway endpoints.
        :param security_group_ids: The IDs of the security groups to associate with the endpoint network interface. Security groups are supported only for interface endpoints.
        :param subnet_ids: The ID of the subnets in which to create an endpoint network interface. You must specify this property for an interface endpoints or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
        :param vpc_endpoint_type: The type of endpoint. Default: Gateway
        '''
        props = CfnVPCEndpointProps(
            service_name=service_name,
            vpc_id=vpc_id,
            policy_document=policy_document,
            private_dns_enabled=private_dns_enabled,
            route_table_ids=route_table_ids,
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
            vpc_endpoint_type=vpc_endpoint_type,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrCreationTimestamp")
    def attr_creation_timestamp(self) -> builtins.str:
        '''The date and time the VPC endpoint was created.

        For example: ``Fri Sep 28 23:34:36 UTC 2018.``

        :cloudformationAttribute: CreationTimestamp
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrCreationTimestamp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrDnsEntries")
    def attr_dns_entries(self) -> typing.List[builtins.str]:
        '''(Interface endpoints) The DNS entries for the endpoint.

        Each entry is a combination of the hosted zone ID and the DNS name. The entries are ordered as follows: regional public DNS, zonal public DNS, private DNS, and wildcard DNS. This order is not enforced for AWS Marketplace services.

        The following is an example. In the first entry, the hosted zone ID is Z1HUB23UULQXV and the DNS name is vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com.

        ["Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3.ec2.us-east-1.vpce.amazonaws.com", "Z1HUB23UULQXV:vpce-01abc23456de78f9g-12abccd3-us-east-1a.ec2.us-east-1.vpce.amazonaws.com", "Z1C12344VYDITB0:ec2.us-east-1.amazonaws.com"]

        If you update the ``PrivateDnsEnabled`` or ``SubnetIds`` properties, the DNS entries in the list will change.

        :cloudformationAttribute: DnsEntries
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "attrDnsEntries"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrNetworkInterfaceIds")
    def attr_network_interface_ids(self) -> typing.List[builtins.str]:
        '''(Interface endpoints) One or more network interface IDs.

        If you update the ``PrivateDnsEnabled`` or ``SubnetIds`` properties, the items in this list might change.

        :cloudformationAttribute: NetworkInterfaceIds
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "attrNetworkInterfaceIds"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="policyDocument")
    def policy_document(self) -> typing.Any:
        '''A policy that controls access to the service from the VPC.

        If this parameter is not specified, the default policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints.

        For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
        '''
        return typing.cast(typing.Any, jsii.get(self, "policyDocument"))

    @policy_document.setter
    def policy_document(self, value: typing.Any) -> None:
        jsii.set(self, "policyDocument", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceName")
    def service_name(self) -> builtins.str:
        '''The service name.

        To list the available services, use `DescribeVpcEndpointServices <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html>`_ . Otherwise, get the name from the service provider.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
        '''
        return typing.cast(builtins.str, jsii.get(self, "serviceName"))

    @service_name.setter
    def service_name(self, value: builtins.str) -> None:
        jsii.set(self, "serviceName", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC in which the endpoint will be used.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsEnabled")
    def private_dns_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicate whether to associate a private hosted zone with the specified VPC.

        The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.

        To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` .

        This property is supported only for interface endpoints.

        Default: ``false``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "privateDnsEnabled"))

    @private_dns_enabled.setter
    def private_dns_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "privateDnsEnabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableIds")
    def route_table_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The route table IDs.

        Routing is supported only for gateway endpoints.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "routeTableIds"))

    @route_table_ids.setter
    def route_table_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "routeTableIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupIds")
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups to associate with the endpoint network interface.

        Security groups are supported only for interface endpoints.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "securityGroupIds"))

    @security_group_ids.setter
    def security_group_ids(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "securityGroupIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetIds")
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The ID of the subnets in which to create an endpoint network interface.

        You must specify this property for an interface endpoints or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "subnetIds"))

    @subnet_ids.setter
    def subnet_ids(self, value: typing.Optional[typing.List[builtins.str]]) -> None:
        jsii.set(self, "subnetIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointType")
    def vpc_endpoint_type(self) -> typing.Optional[builtins.str]:
        '''The type of endpoint.

        Default: Gateway

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcEndpointType"))

    @vpc_endpoint_type.setter
    def vpc_endpoint_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcEndpointType", value)


@jsii.implements(_IInspectable_c2943556)
class CfnVPCEndpointConnectionNotification(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointConnectionNotification",
):
    '''A CloudFormation ``AWS::EC2::VPCEndpointConnectionNotification``.

    Specifies a connection notification for a VPC endpoint or VPC endpoint service. A connection notification notifies you of specific endpoint events. You must create an SNS topic to receive notifications. For more information, see `Create a Topic <https://docs.aws.amazon.com/sns/latest/dg/CreateTopic.html>`_ in the *Amazon Simple Notification Service Developer Guide* .

    You can create a connection notification for interface endpoints only.

    :cloudformationResource: AWS::EC2::VPCEndpointConnectionNotification
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCEndpoint_connection_notification = ec2.CfnVPCEndpointConnectionNotification(self, "MyCfnVPCEndpointConnectionNotification",
            connection_events=["connectionEvents"],
            connection_notification_arn="connectionNotificationArn",
        
            # the properties below are optional
            service_id="serviceId",
            vpc_endpoint_id="vpcEndpointId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        connection_events: typing.Sequence[builtins.str],
        connection_notification_arn: builtins.str,
        service_id: typing.Optional[builtins.str] = None,
        vpc_endpoint_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCEndpointConnectionNotification``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param connection_events: One or more endpoint events for which to receive notifications. Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .
        :param connection_notification_arn: The ARN of the SNS topic for the notifications.
        :param service_id: The ID of the endpoint service.
        :param vpc_endpoint_id: The ID of the endpoint.
        '''
        props = CfnVPCEndpointConnectionNotificationProps(
            connection_events=connection_events,
            connection_notification_arn=connection_notification_arn,
            service_id=service_id,
            vpc_endpoint_id=vpc_endpoint_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connectionEvents")
    def connection_events(self) -> typing.List[builtins.str]:
        '''One or more endpoint events for which to receive notifications.

        Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "connectionEvents"))

    @connection_events.setter
    def connection_events(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "connectionEvents", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connectionNotificationArn")
    def connection_notification_arn(self) -> builtins.str:
        '''The ARN of the SNS topic for the notifications.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
        '''
        return typing.cast(builtins.str, jsii.get(self, "connectionNotificationArn"))

    @connection_notification_arn.setter
    def connection_notification_arn(self, value: builtins.str) -> None:
        jsii.set(self, "connectionNotificationArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceId")
    def service_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the endpoint service.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "serviceId"))

    @service_id.setter
    def service_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "serviceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpcEndpointId"))

    @vpc_endpoint_id.setter
    def vpc_endpoint_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpcEndpointId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointConnectionNotificationProps",
    jsii_struct_bases=[],
    name_mapping={
        "connection_events": "connectionEvents",
        "connection_notification_arn": "connectionNotificationArn",
        "service_id": "serviceId",
        "vpc_endpoint_id": "vpcEndpointId",
    },
)
class CfnVPCEndpointConnectionNotificationProps:
    def __init__(
        self,
        *,
        connection_events: typing.Sequence[builtins.str],
        connection_notification_arn: builtins.str,
        service_id: typing.Optional[builtins.str] = None,
        vpc_endpoint_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCEndpointConnectionNotification``.

        :param connection_events: One or more endpoint events for which to receive notifications. Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .
        :param connection_notification_arn: The ARN of the SNS topic for the notifications.
        :param service_id: The ID of the endpoint service.
        :param vpc_endpoint_id: The ID of the endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCEndpoint_connection_notification_props = ec2.CfnVPCEndpointConnectionNotificationProps(
                connection_events=["connectionEvents"],
                connection_notification_arn="connectionNotificationArn",
            
                # the properties below are optional
                service_id="serviceId",
                vpc_endpoint_id="vpcEndpointId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "connection_events": connection_events,
            "connection_notification_arn": connection_notification_arn,
        }
        if service_id is not None:
            self._values["service_id"] = service_id
        if vpc_endpoint_id is not None:
            self._values["vpc_endpoint_id"] = vpc_endpoint_id

    @builtins.property
    def connection_events(self) -> typing.List[builtins.str]:
        '''One or more endpoint events for which to receive notifications.

        Valid values are ``Accept`` , ``Connect`` , ``Delete`` , and ``Reject`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionevents
        '''
        result = self._values.get("connection_events")
        assert result is not None, "Required property 'connection_events' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def connection_notification_arn(self) -> builtins.str:
        '''The ARN of the SNS topic for the notifications.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-connectionnotificationarn
        '''
        result = self._values.get("connection_notification_arn")
        assert result is not None, "Required property 'connection_notification_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the endpoint service.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-serviceid
        '''
        result = self._values.get("service_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_endpoint_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointconnectionnotification.html#cfn-ec2-vpcendpointconnectionnotification-vpcendpointid
        '''
        result = self._values.get("vpc_endpoint_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointConnectionNotificationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointProps",
    jsii_struct_bases=[],
    name_mapping={
        "service_name": "serviceName",
        "vpc_id": "vpcId",
        "policy_document": "policyDocument",
        "private_dns_enabled": "privateDnsEnabled",
        "route_table_ids": "routeTableIds",
        "security_group_ids": "securityGroupIds",
        "subnet_ids": "subnetIds",
        "vpc_endpoint_type": "vpcEndpointType",
    },
)
class CfnVPCEndpointProps:
    def __init__(
        self,
        *,
        service_name: builtins.str,
        vpc_id: builtins.str,
        policy_document: typing.Any = None,
        private_dns_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpc_endpoint_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCEndpoint``.

        :param service_name: The service name. To list the available services, use `DescribeVpcEndpointServices <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html>`_ . Otherwise, get the name from the service provider.
        :param vpc_id: The ID of the VPC in which the endpoint will be used.
        :param policy_document: A policy that controls access to the service from the VPC. If this parameter is not specified, the default policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints. For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.
        :param private_dns_enabled: Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service. To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` . This property is supported only for interface endpoints. Default: ``false``
        :param route_table_ids: The route table IDs. Routing is supported only for gateway endpoints.
        :param security_group_ids: The IDs of the security groups to associate with the endpoint network interface. Security groups are supported only for interface endpoints.
        :param subnet_ids: The ID of the subnets in which to create an endpoint network interface. You must specify this property for an interface endpoints or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.
        :param vpc_endpoint_type: The type of endpoint. Default: Gateway

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # policy_document: Any
            
            cfn_vPCEndpoint_props = ec2.CfnVPCEndpointProps(
                service_name="serviceName",
                vpc_id="vpcId",
            
                # the properties below are optional
                policy_document=policy_document,
                private_dns_enabled=False,
                route_table_ids=["routeTableIds"],
                security_group_ids=["securityGroupIds"],
                subnet_ids=["subnetIds"],
                vpc_endpoint_type="vpcEndpointType"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "service_name": service_name,
            "vpc_id": vpc_id,
        }
        if policy_document is not None:
            self._values["policy_document"] = policy_document
        if private_dns_enabled is not None:
            self._values["private_dns_enabled"] = private_dns_enabled
        if route_table_ids is not None:
            self._values["route_table_ids"] = route_table_ids
        if security_group_ids is not None:
            self._values["security_group_ids"] = security_group_ids
        if subnet_ids is not None:
            self._values["subnet_ids"] = subnet_ids
        if vpc_endpoint_type is not None:
            self._values["vpc_endpoint_type"] = vpc_endpoint_type

    @builtins.property
    def service_name(self) -> builtins.str:
        '''The service name.

        To list the available services, use `DescribeVpcEndpointServices <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpointServices.html>`_ . Otherwise, get the name from the service provider.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-servicename
        '''
        result = self._values.get("service_name")
        assert result is not None, "Required property 'service_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC in which the endpoint will be used.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def policy_document(self) -> typing.Any:
        '''A policy that controls access to the service from the VPC.

        If this parameter is not specified, the default policy allows full access to the service. Endpoint policies are supported only for gateway and interface endpoints.

        For CloudFormation templates in YAML, you can provide the policy in JSON or YAML format. AWS CloudFormation converts YAML policies to JSON format before calling the API to create or modify the VPC endpoint.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-policydocument
        '''
        result = self._values.get("policy_document")
        return typing.cast(typing.Any, result)

    @builtins.property
    def private_dns_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicate whether to associate a private hosted zone with the specified VPC.

        The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, ``kinesis.us-east-1.amazonaws.com`` ), which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.

        To use a private hosted zone, you must set the following VPC attributes to ``true`` : ``enableDnsHostnames`` and ``enableDnsSupport`` .

        This property is supported only for interface endpoints.

        Default: ``false``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-privatednsenabled
        '''
        result = self._values.get("private_dns_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def route_table_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The route table IDs.

        Routing is supported only for gateway endpoints.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-routetableids
        '''
        result = self._values.get("route_table_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def security_group_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The IDs of the security groups to associate with the endpoint network interface.

        Security groups are supported only for interface endpoints.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-securitygroupids
        '''
        result = self._values.get("security_group_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The ID of the subnets in which to create an endpoint network interface.

        You must specify this property for an interface endpoints or a Gateway Load Balancer endpoint. You can't specify this property for a gateway endpoint. For a Gateway Load Balancer endpoint, you can specify only one subnet.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-subnetids
        '''
        result = self._values.get("subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpc_endpoint_type(self) -> typing.Optional[builtins.str]:
        '''The type of endpoint.

        Default: Gateway

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpoint.html#cfn-ec2-vpcendpoint-vpcendpointtype
        '''
        result = self._values.get("vpc_endpoint_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPCEndpointService(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointService",
):
    '''A CloudFormation ``AWS::EC2::VPCEndpointService``.

    Creates a VPC endpoint service configuration to which service consumers ( AWS accounts, IAM users, and IAM roles) can connect.

    To create an endpoint service configuration, you must first create one of the following for your service:

    - A `Network Load Balancer <https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html>`_ . Service consumers connect to your service using an interface endpoint.
    - A `Gateway Load Balancer <https://docs.aws.amazon.com/elasticloadbalancing/latest/gateway/introduction.html>`_ . Service consumers connect to your service using a Gateway Load Balancer endpoint.

    For more information, see the `AWS PrivateLink User Guide <https://docs.aws.amazon.com/vpc/latest/privatelink/>`_ .

    :cloudformationResource: AWS::EC2::VPCEndpointService
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCEndpoint_service = ec2.CfnVPCEndpointService(self, "MyCfnVPCEndpointService",
            acceptance_required=False,
            gateway_load_balancer_arns=["gatewayLoadBalancerArns"],
            network_load_balancer_arns=["networkLoadBalancerArns"],
            payer_responsibility="payerResponsibility"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        acceptance_required: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        gateway_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        network_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        payer_responsibility: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCEndpointService``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param acceptance_required: Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
        :param gateway_load_balancer_arns: The Amazon Resource Names (ARNs) of one or more Gateway Load Balancers.
        :param network_load_balancer_arns: The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your service.
        :param payer_responsibility: The entity that is responsible for the endpoint costs. The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.
        '''
        props = CfnVPCEndpointServiceProps(
            acceptance_required=acceptance_required,
            gateway_load_balancer_arns=gateway_load_balancer_arns,
            network_load_balancer_arns=network_load_balancer_arns,
            payer_responsibility=payer_responsibility,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="acceptanceRequired")
    def acceptance_required(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether requests from service consumers to create an endpoint to your service must be accepted.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "acceptanceRequired"))

    @acceptance_required.setter
    def acceptance_required(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "acceptanceRequired", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gatewayLoadBalancerArns")
    def gateway_load_balancer_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARNs) of one or more Gateway Load Balancers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "gatewayLoadBalancerArns"))

    @gateway_load_balancer_arns.setter
    def gateway_load_balancer_arns(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "gatewayLoadBalancerArns", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkLoadBalancerArns")
    def network_load_balancer_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your service.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "networkLoadBalancerArns"))

    @network_load_balancer_arns.setter
    def network_load_balancer_arns(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "networkLoadBalancerArns", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="payerResponsibility")
    def payer_responsibility(self) -> typing.Optional[builtins.str]:
        '''The entity that is responsible for the endpoint costs.

        The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "payerResponsibility"))

    @payer_responsibility.setter
    def payer_responsibility(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "payerResponsibility", value)


@jsii.implements(_IInspectable_c2943556)
class CfnVPCEndpointServicePermissions(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointServicePermissions",
):
    '''A CloudFormation ``AWS::EC2::VPCEndpointServicePermissions``.

    Grant or revoke permissions for service consumers (IAM users, IAM roles, and AWS accounts) to connect to a VPC endpoint service.

    If you grant permissions to all principals, the service is public. Any users who know the name of a public service can send a request to attach an endpoint. If the service does not require manual approval, attachments are automatically approved.

    :cloudformationResource: AWS::EC2::VPCEndpointServicePermissions
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCEndpoint_service_permissions = ec2.CfnVPCEndpointServicePermissions(self, "MyCfnVPCEndpointServicePermissions",
            service_id="serviceId",
        
            # the properties below are optional
            allowed_principals=["allowedPrincipals"]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        service_id: builtins.str,
        allowed_principals: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCEndpointServicePermissions``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param service_id: The ID of the service.
        :param allowed_principals: The Amazon Resource Names (ARN) of one or more principals (IAM users, IAM roles, and AWS accounts). Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.
        '''
        props = CfnVPCEndpointServicePermissionsProps(
            service_id=service_id, allowed_principals=allowed_principals
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="serviceId")
    def service_id(self) -> builtins.str:
        '''The ID of the service.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "serviceId"))

    @service_id.setter
    def service_id(self, value: builtins.str) -> None:
        jsii.set(self, "serviceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allowedPrincipals")
    def allowed_principals(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of one or more principals (IAM users, IAM roles, and AWS accounts).

        Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
        '''
        return typing.cast(typing.Optional[typing.List[builtins.str]], jsii.get(self, "allowedPrincipals"))

    @allowed_principals.setter
    def allowed_principals(
        self,
        value: typing.Optional[typing.List[builtins.str]],
    ) -> None:
        jsii.set(self, "allowedPrincipals", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointServicePermissionsProps",
    jsii_struct_bases=[],
    name_mapping={
        "service_id": "serviceId",
        "allowed_principals": "allowedPrincipals",
    },
)
class CfnVPCEndpointServicePermissionsProps:
    def __init__(
        self,
        *,
        service_id: builtins.str,
        allowed_principals: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCEndpointServicePermissions``.

        :param service_id: The ID of the service.
        :param allowed_principals: The Amazon Resource Names (ARN) of one or more principals (IAM users, IAM roles, and AWS accounts). Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCEndpoint_service_permissions_props = ec2.CfnVPCEndpointServicePermissionsProps(
                service_id="serviceId",
            
                # the properties below are optional
                allowed_principals=["allowedPrincipals"]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "service_id": service_id,
        }
        if allowed_principals is not None:
            self._values["allowed_principals"] = allowed_principals

    @builtins.property
    def service_id(self) -> builtins.str:
        '''The ID of the service.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-serviceid
        '''
        result = self._values.get("service_id")
        assert result is not None, "Required property 'service_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def allowed_principals(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARN) of one or more principals (IAM users, IAM roles, and AWS accounts).

        Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*). Permissions are revoked for principals not in this list. If the list is empty, then all permissions are revoked.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservicepermissions.html#cfn-ec2-vpcendpointservicepermissions-allowedprincipals
        '''
        result = self._values.get("allowed_principals")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointServicePermissionsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCEndpointServiceProps",
    jsii_struct_bases=[],
    name_mapping={
        "acceptance_required": "acceptanceRequired",
        "gateway_load_balancer_arns": "gatewayLoadBalancerArns",
        "network_load_balancer_arns": "networkLoadBalancerArns",
        "payer_responsibility": "payerResponsibility",
    },
)
class CfnVPCEndpointServiceProps:
    def __init__(
        self,
        *,
        acceptance_required: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        gateway_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        network_load_balancer_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        payer_responsibility: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCEndpointService``.

        :param acceptance_required: Indicates whether requests from service consumers to create an endpoint to your service must be accepted.
        :param gateway_load_balancer_arns: The Amazon Resource Names (ARNs) of one or more Gateway Load Balancers.
        :param network_load_balancer_arns: The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your service.
        :param payer_responsibility: The entity that is responsible for the endpoint costs. The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCEndpoint_service_props = ec2.CfnVPCEndpointServiceProps(
                acceptance_required=False,
                gateway_load_balancer_arns=["gatewayLoadBalancerArns"],
                network_load_balancer_arns=["networkLoadBalancerArns"],
                payer_responsibility="payerResponsibility"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if acceptance_required is not None:
            self._values["acceptance_required"] = acceptance_required
        if gateway_load_balancer_arns is not None:
            self._values["gateway_load_balancer_arns"] = gateway_load_balancer_arns
        if network_load_balancer_arns is not None:
            self._values["network_load_balancer_arns"] = network_load_balancer_arns
        if payer_responsibility is not None:
            self._values["payer_responsibility"] = payer_responsibility

    @builtins.property
    def acceptance_required(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether requests from service consumers to create an endpoint to your service must be accepted.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-acceptancerequired
        '''
        result = self._values.get("acceptance_required")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def gateway_load_balancer_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARNs) of one or more Gateway Load Balancers.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-gatewayloadbalancerarns
        '''
        result = self._values.get("gateway_load_balancer_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def network_load_balancer_arns(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your service.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-networkloadbalancerarns
        '''
        result = self._values.get("network_load_balancer_arns")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def payer_responsibility(self) -> typing.Optional[builtins.str]:
        '''The entity that is responsible for the endpoint costs.

        The default is the endpoint owner. If you set the payer responsibility to the service owner, you cannot set it back to the endpoint owner.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcendpointservice.html#cfn-ec2-vpcendpointservice-payerresponsibility
        '''
        result = self._values.get("payer_responsibility")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCEndpointServiceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPCGatewayAttachment(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCGatewayAttachment",
):
    '''A CloudFormation ``AWS::EC2::VPCGatewayAttachment``.

    Attaches an internet gateway, or a virtual private gateway to a VPC, enabling connectivity between the internet and the VPC.

    :cloudformationResource: AWS::EC2::VPCGatewayAttachment
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCGateway_attachment = ec2.CfnVPCGatewayAttachment(self, "MyCfnVPCGatewayAttachment",
            vpc_id="vpcId",
        
            # the properties below are optional
            internet_gateway_id="internetGatewayId",
            vpn_gateway_id="vpnGatewayId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_id: builtins.str,
        internet_gateway_id: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCGatewayAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param vpc_id: The ID of the VPC.
        :param internet_gateway_id: The ID of the internet gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_gateway_id: The ID of the virtual private gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.
        '''
        props = CfnVPCGatewayAttachmentProps(
            vpc_id=vpc_id,
            internet_gateway_id=internet_gateway_id,
            vpn_gateway_id=vpn_gateway_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html#cfn-ec2-vpcgatewayattachment-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetGatewayId")
    def internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the internet gateway.

        You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "internetGatewayId"))

    @internet_gateway_id.setter
    def internet_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "internetGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway.

        You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpnGatewayId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCGatewayAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_id": "vpcId",
        "internet_gateway_id": "internetGatewayId",
        "vpn_gateway_id": "vpnGatewayId",
    },
)
class CfnVPCGatewayAttachmentProps:
    def __init__(
        self,
        *,
        vpc_id: builtins.str,
        internet_gateway_id: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCGatewayAttachment``.

        :param vpc_id: The ID of the VPC.
        :param internet_gateway_id: The ID of the internet gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_gateway_id: The ID of the virtual private gateway. You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCGateway_attachment_props = ec2.CfnVPCGatewayAttachmentProps(
                vpc_id="vpcId",
            
                # the properties below are optional
                internet_gateway_id="internetGatewayId",
                vpn_gateway_id="vpnGatewayId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_id": vpc_id,
        }
        if internet_gateway_id is not None:
            self._values["internet_gateway_id"] = internet_gateway_id
        if vpn_gateway_id is not None:
            self._values["vpn_gateway_id"] = vpn_gateway_id

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html#cfn-ec2-vpcgatewayattachment-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the internet gateway.

        You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html#cfn-ec2-vpcgatewayattachment-internetgatewayid
        '''
        result = self._values.get("internet_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway.

        You must specify either ``InternetGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html#cfn-ec2-vpcgatewayattachment-vpngatewayid
        '''
        result = self._values.get("vpn_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCGatewayAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPCPeeringConnection(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCPeeringConnection",
):
    '''A CloudFormation ``AWS::EC2::VPCPeeringConnection``.

    Requests a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection. The accepter VPC can belong to another AWS account and can be in a different Region to the requester VPC.

    The requester VPC and accepter VPC cannot have overlapping CIDR blocks. If you create a VPC peering connection request between VPCs with overlapping CIDR blocks, the VPC peering connection has a status of ``failed`` .

    For more information, see `Walkthough: Peer with a VPC in another AWS account <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/peer-with-vpc-in-another-account.html>`_ .

    :cloudformationResource: AWS::EC2::VPCPeeringConnection
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPCPeering_connection = ec2.CfnVPCPeeringConnection(self, "MyCfnVPCPeeringConnection",
            peer_vpc_id="peerVpcId",
            vpc_id="vpcId",
        
            # the properties below are optional
            peer_owner_id="peerOwnerId",
            peer_region="peerRegion",
            peer_role_arn="peerRoleArn",
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        peer_vpc_id: builtins.str,
        vpc_id: builtins.str,
        peer_owner_id: typing.Optional[builtins.str] = None,
        peer_region: typing.Optional[builtins.str] = None,
        peer_role_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPCPeeringConnection``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param peer_vpc_id: The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.
        :param vpc_id: The ID of the VPC.
        :param peer_owner_id: The AWS account ID of the owner of the accepter VPC. Default: Your AWS account ID
        :param peer_region: The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request. Default: The Region in which you make the request.
        :param peer_role_arn: The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account. This is required when you are peering a VPC in a different AWS account.
        :param tags: Any tags assigned to the resource.
        '''
        props = CfnVPCPeeringConnectionProps(
            peer_vpc_id=peer_vpc_id,
            vpc_id=vpc_id,
            peer_owner_id=peer_owner_id,
            peer_region=peer_region,
            peer_role_arn=peer_role_arn,
            tags=tags,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerVpcId")
    def peer_vpc_id(self) -> builtins.str:
        '''The ID of the VPC with which you are creating the VPC peering connection.

        You must specify this parameter in the request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "peerVpcId"))

    @peer_vpc_id.setter
    def peer_vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "peerVpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @vpc_id.setter
    def vpc_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpcId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerOwnerId")
    def peer_owner_id(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID of the owner of the accepter VPC.

        Default: Your AWS account ID

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerOwnerId"))

    @peer_owner_id.setter
    def peer_owner_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "peerOwnerId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerRegion")
    def peer_region(self) -> typing.Optional[builtins.str]:
        '''The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.

        Default: The Region in which you make the request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerRegion"))

    @peer_region.setter
    def peer_region(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "peerRegion", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="peerRoleArn")
    def peer_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.

        This is required when you are peering a VPC in a different AWS account.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "peerRoleArn"))

    @peer_role_arn.setter
    def peer_role_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "peerRoleArn", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCPeeringConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "peer_vpc_id": "peerVpcId",
        "vpc_id": "vpcId",
        "peer_owner_id": "peerOwnerId",
        "peer_region": "peerRegion",
        "peer_role_arn": "peerRoleArn",
        "tags": "tags",
    },
)
class CfnVPCPeeringConnectionProps:
    def __init__(
        self,
        *,
        peer_vpc_id: builtins.str,
        vpc_id: builtins.str,
        peer_owner_id: typing.Optional[builtins.str] = None,
        peer_region: typing.Optional[builtins.str] = None,
        peer_role_arn: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPCPeeringConnection``.

        :param peer_vpc_id: The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.
        :param vpc_id: The ID of the VPC.
        :param peer_owner_id: The AWS account ID of the owner of the accepter VPC. Default: Your AWS account ID
        :param peer_region: The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request. Default: The Region in which you make the request.
        :param peer_role_arn: The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account. This is required when you are peering a VPC in a different AWS account.
        :param tags: Any tags assigned to the resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCPeering_connection_props = ec2.CfnVPCPeeringConnectionProps(
                peer_vpc_id="peerVpcId",
                vpc_id="vpcId",
            
                # the properties below are optional
                peer_owner_id="peerOwnerId",
                peer_region="peerRegion",
                peer_role_arn="peerRoleArn",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "peer_vpc_id": peer_vpc_id,
            "vpc_id": vpc_id,
        }
        if peer_owner_id is not None:
            self._values["peer_owner_id"] = peer_owner_id
        if peer_region is not None:
            self._values["peer_region"] = peer_region
        if peer_role_arn is not None:
            self._values["peer_role_arn"] = peer_role_arn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def peer_vpc_id(self) -> builtins.str:
        '''The ID of the VPC with which you are creating the VPC peering connection.

        You must specify this parameter in the request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peervpcid
        '''
        result = self._values.get("peer_vpc_id")
        assert result is not None, "Required property 'peer_vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The ID of the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-vpcid
        '''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def peer_owner_id(self) -> typing.Optional[builtins.str]:
        '''The AWS account ID of the owner of the accepter VPC.

        Default: Your AWS account ID

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerownerid
        '''
        result = self._values.get("peer_owner_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_region(self) -> typing.Optional[builtins.str]:
        '''The Region code for the accepter VPC, if the accepter VPC is located in a Region other than the Region in which you make the request.

        Default: The Region in which you make the request.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerregion
        '''
        result = self._values.get("peer_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def peer_role_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the VPC peer role for the peering connection in another AWS account.

        This is required when you are peering a VPC in a different AWS account.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-peerrolearn
        '''
        result = self._values.get("peer_role_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the resource.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpcpeeringconnection.html#cfn-ec2-vpcpeeringconnection-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCPeeringConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPCProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr_block": "cidrBlock",
        "enable_dns_hostnames": "enableDnsHostnames",
        "enable_dns_support": "enableDnsSupport",
        "instance_tenancy": "instanceTenancy",
        "ipv4_ipam_pool_id": "ipv4IpamPoolId",
        "ipv4_netmask_length": "ipv4NetmaskLength",
        "tags": "tags",
    },
)
class CfnVPCProps:
    def __init__(
        self,
        *,
        cidr_block: builtins.str,
        enable_dns_hostnames: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        enable_dns_support: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        instance_tenancy: typing.Optional[builtins.str] = None,
        ipv4_ipam_pool_id: typing.Optional[builtins.str] = None,
        ipv4_netmask_length: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPC``.

        :param cidr_block: The primary IPv4 CIDR block for the VPC.
        :param enable_dns_hostnames: Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ . You can only enable DNS hostnames if you've enabled DNS support.
        :param enable_dns_support: Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .
        :param instance_tenancy: The allowed tenancy of instances launched into the VPC. - ``"default"`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch. - ``"dedicated"`` : An instance launched into the VPC is a Dedicated Instance by default, unless you explicitly specify a tenancy of host during instance launch. You cannot specify a tenancy of default during instance launch. Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``"dedicated"`` to ``"default"`` . Updating ``InstanceTenancy`` from ``"default"`` to ``"dedicated"`` requires replacement.
        :param ipv4_ipam_pool_id: The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param ipv4_netmask_length: The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool. For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .
        :param tags: The tags for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPCProps = ec2.CfnVPCProps(
                cidr_block="cidrBlock",
            
                # the properties below are optional
                enable_dns_hostnames=False,
                enable_dns_support=False,
                instance_tenancy="instanceTenancy",
                ipv4_ipam_pool_id="ipv4IpamPoolId",
                ipv4_netmask_length=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr_block": cidr_block,
        }
        if enable_dns_hostnames is not None:
            self._values["enable_dns_hostnames"] = enable_dns_hostnames
        if enable_dns_support is not None:
            self._values["enable_dns_support"] = enable_dns_support
        if instance_tenancy is not None:
            self._values["instance_tenancy"] = instance_tenancy
        if ipv4_ipam_pool_id is not None:
            self._values["ipv4_ipam_pool_id"] = ipv4_ipam_pool_id
        if ipv4_netmask_length is not None:
            self._values["ipv4_netmask_length"] = ipv4_netmask_length
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def cidr_block(self) -> builtins.str:
        '''The primary IPv4 CIDR block for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-cidrblock
        '''
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def enable_dns_hostnames(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the instances launched in the VPC get DNS hostnames.

        If enabled, instances in the VPC get DNS hostnames; otherwise, they do not. Disabled by default for nondefault VPCs. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .

        You can only enable DNS hostnames if you've enabled DNS support.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-EnableDnsHostnames
        '''
        result = self._values.get("enable_dns_hostnames")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def enable_dns_support(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the DNS resolution is supported for the VPC.

        If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled. Enabled by default. For more information, see `DNS attributes in your VPC <https://docs.aws.amazon.com/vpc/latest/userguide/vpc-dns.html#vpc-dns-support>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-EnableDnsSupport
        '''
        result = self._values.get("enable_dns_support")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def instance_tenancy(self) -> typing.Optional[builtins.str]:
        '''The allowed tenancy of instances launched into the VPC.

        - ``"default"`` : An instance launched into the VPC runs on shared hardware by default, unless you explicitly specify a different tenancy during instance launch.
        - ``"dedicated"`` : An instance launched into the VPC is a Dedicated Instance by default, unless you explicitly specify a tenancy of host during instance launch. You cannot specify a tenancy of default during instance launch.

        Updating ``InstanceTenancy`` requires no replacement only if you are updating its value from ``"dedicated"`` to ``"default"`` . Updating ``InstanceTenancy`` from ``"default"`` to ``"dedicated"`` requires replacement.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-instancetenancy
        '''
        result = self._values.get("instance_tenancy")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_ipam_pool_id(self) -> typing.Optional[builtins.str]:
        '''The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR.

        For more information, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4ipampoolid
        '''
        result = self._values.get("ipv4_ipam_pool_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_netmask_length(self) -> typing.Optional[jsii.Number]:
        '''The netmask length of the IPv4 CIDR you want to allocate to this VPC from an Amazon VPC IP Address Manager (IPAM) pool.

        For more information about IPAM, see `What is IPAM? <https://docs.aws.amazon.com//vpc/latest/ipam/what-is-it-ipam.html>`_ in the *Amazon VPC IPAM User Guide* .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-ec2-vpc-ipv4netmasklength
        '''
        result = self._values.get("ipv4_netmask_length")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags for the VPC.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html#cfn-aws-ec2-vpc-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPCProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPNConnection(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNConnection",
):
    '''A CloudFormation ``AWS::EC2::VPNConnection``.

    Specifies a VPN connection between a virtual private gateway and a VPN customer gateway or a transit gateway and a VPN customer gateway.

    To specify a VPN connection between a transit gateway and customer gateway, use the ``TransitGatewayId`` and ``CustomerGatewayId`` properties.

    To specify a VPN connection between a virtual private gateway and customer gateway, use the ``VpnGatewayId`` and ``CustomerGatewayId`` properties.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :cloudformationResource: AWS::EC2::VPNConnection
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPNConnection = ec2.CfnVPNConnection(self, "MyCfnVPNConnection",
            customer_gateway_id="customerGatewayId",
            type="type",
        
            # the properties below are optional
            static_routes_only=False,
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            transit_gateway_id="transitGatewayId",
            vpn_gateway_id="vpnGatewayId",
            vpn_tunnel_options_specifications=[ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty(
                pre_shared_key="preSharedKey",
                tunnel_inside_cidr="tunnelInsideCidr"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        customer_gateway_id: builtins.str,
        type: builtins.str,
        static_routes_only: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
        vpn_tunnel_options_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union["CfnVPNConnection.VpnTunnelOptionsSpecificationProperty", _IResolvable_da3f097b]]]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPNConnection``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param customer_gateway_id: The ID of the customer gateway at your end of the VPN connection.
        :param type: The type of VPN connection.
        :param static_routes_only: Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP. If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .
        :param tags: Any tags assigned to the VPN connection.
        :param transit_gateway_id: The ID of the transit gateway associated with the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_gateway_id: The ID of the virtual private gateway at the AWS side of the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_tunnel_options_specifications: The tunnel options for the VPN connection.
        '''
        props = CfnVPNConnectionProps(
            customer_gateway_id=customer_gateway_id,
            type=type,
            static_routes_only=static_routes_only,
            tags=tags,
            transit_gateway_id=transit_gateway_id,
            vpn_gateway_id=vpn_gateway_id,
            vpn_tunnel_options_specifications=vpn_tunnel_options_specifications,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayId")
    def customer_gateway_id(self) -> builtins.str:
        '''The ID of the customer gateway at your end of the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-customergatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))

    @customer_gateway_id.setter
    def customer_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "customerGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        '''The type of VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-type
        '''
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="staticRoutesOnly")
    def static_routes_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the VPN connection uses static routes only.

        Static routes must be used for devices that don't support BGP.

        If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-StaticRoutesOnly
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "staticRoutesOnly"))

    @static_routes_only.setter
    def static_routes_only(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "staticRoutesOnly", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="transitGatewayId")
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway associated with the VPN connection.

        You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-transitgatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "transitGatewayId"))

    @transit_gateway_id.setter
    def transit_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "transitGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway at the AWS side of the VPN connection.

        You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-vpngatewayid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "vpnGatewayId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnTunnelOptionsSpecifications")
    def vpn_tunnel_options_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnVPNConnection.VpnTunnelOptionsSpecificationProperty", _IResolvable_da3f097b]]]]:
        '''The tunnel options for the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
        '''
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnVPNConnection.VpnTunnelOptionsSpecificationProperty", _IResolvable_da3f097b]]]], jsii.get(self, "vpnTunnelOptionsSpecifications"))

    @vpn_tunnel_options_specifications.setter
    def vpn_tunnel_options_specifications(
        self,
        value: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union["CfnVPNConnection.VpnTunnelOptionsSpecificationProperty", _IResolvable_da3f097b]]]],
    ) -> None:
        jsii.set(self, "vpnTunnelOptionsSpecifications", value)

    @jsii.data_type(
        jsii_type="aws-cdk-lib.aws_ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty",
        jsii_struct_bases=[],
        name_mapping={
            "pre_shared_key": "preSharedKey",
            "tunnel_inside_cidr": "tunnelInsideCidr",
        },
    )
    class VpnTunnelOptionsSpecificationProperty:
        def __init__(
            self,
            *,
            pre_shared_key: typing.Optional[builtins.str] = None,
            tunnel_inside_cidr: typing.Optional[builtins.str] = None,
        ) -> None:
            '''The tunnel options for a single VPN tunnel.

            :param pre_shared_key: The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway. Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
            :param tunnel_inside_cidr: The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used: - ``169.254.0.0/30`` - ``169.254.1.0/30`` - ``169.254.2.0/30`` - ``169.254.3.0/30`` - ``169.254.4.0/30`` - ``169.254.5.0/30`` - ``169.254.169.252/30``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html
            :exampleMetadata: fixture=_generated

            Example::

                # The code below shows an example of how to instantiate this type.
                # The values are placeholders you should change.
                from aws_cdk import aws_ec2 as ec2
                
                vpn_tunnel_options_specification_property = ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty(
                    pre_shared_key="preSharedKey",
                    tunnel_inside_cidr="tunnelInsideCidr"
                )
            '''
            self._values: typing.Dict[str, typing.Any] = {}
            if pre_shared_key is not None:
                self._values["pre_shared_key"] = pre_shared_key
            if tunnel_inside_cidr is not None:
                self._values["tunnel_inside_cidr"] = tunnel_inside_cidr

        @builtins.property
        def pre_shared_key(self) -> typing.Optional[builtins.str]:
            '''The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.

            Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-presharedkey
            '''
            result = self._values.get("pre_shared_key")
            return typing.cast(typing.Optional[builtins.str], result)

        @builtins.property
        def tunnel_inside_cidr(self) -> typing.Optional[builtins.str]:
            '''The range of inside IP addresses for the tunnel.

            Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway.

            Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:

            - ``169.254.0.0/30``
            - ``169.254.1.0/30``
            - ``169.254.2.0/30``
            - ``169.254.3.0/30``
            - ``169.254.4.0/30``
            - ``169.254.5.0/30``
            - ``169.254.169.252/30``

            :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-vpnconnection-vpntunneloptionsspecification.html#cfn-ec2-vpnconnection-vpntunneloptionsspecification-tunnelinsidecidr
            '''
            result = self._values.get("tunnel_inside_cidr")
            return typing.cast(typing.Optional[builtins.str], result)

        def __eq__(self, rhs: typing.Any) -> builtins.bool:
            return isinstance(rhs, self.__class__) and rhs._values == self._values

        def __ne__(self, rhs: typing.Any) -> builtins.bool:
            return not (rhs == self)

        def __repr__(self) -> str:
            return "VpnTunnelOptionsSpecificationProperty(%s)" % ", ".join(
                k + "=" + repr(v) for k, v in self._values.items()
            )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNConnectionProps",
    jsii_struct_bases=[],
    name_mapping={
        "customer_gateway_id": "customerGatewayId",
        "type": "type",
        "static_routes_only": "staticRoutesOnly",
        "tags": "tags",
        "transit_gateway_id": "transitGatewayId",
        "vpn_gateway_id": "vpnGatewayId",
        "vpn_tunnel_options_specifications": "vpnTunnelOptionsSpecifications",
    },
)
class CfnVPNConnectionProps:
    def __init__(
        self,
        *,
        customer_gateway_id: builtins.str,
        type: builtins.str,
        static_routes_only: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
        vpn_tunnel_options_specifications: typing.Optional[typing.Union[_IResolvable_da3f097b, typing.Sequence[typing.Union[CfnVPNConnection.VpnTunnelOptionsSpecificationProperty, _IResolvable_da3f097b]]]] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPNConnection``.

        :param customer_gateway_id: The ID of the customer gateway at your end of the VPN connection.
        :param type: The type of VPN connection.
        :param static_routes_only: Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP. If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .
        :param tags: Any tags assigned to the VPN connection.
        :param transit_gateway_id: The ID of the transit gateway associated with the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_gateway_id: The ID of the virtual private gateway at the AWS side of the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_tunnel_options_specifications: The tunnel options for the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPNConnection_props = ec2.CfnVPNConnectionProps(
                customer_gateway_id="customerGatewayId",
                type="type",
            
                # the properties below are optional
                static_routes_only=False,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                transit_gateway_id="transitGatewayId",
                vpn_gateway_id="vpnGatewayId",
                vpn_tunnel_options_specifications=[ec2.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty(
                    pre_shared_key="preSharedKey",
                    tunnel_inside_cidr="tunnelInsideCidr"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "customer_gateway_id": customer_gateway_id,
            "type": type,
        }
        if static_routes_only is not None:
            self._values["static_routes_only"] = static_routes_only
        if tags is not None:
            self._values["tags"] = tags
        if transit_gateway_id is not None:
            self._values["transit_gateway_id"] = transit_gateway_id
        if vpn_gateway_id is not None:
            self._values["vpn_gateway_id"] = vpn_gateway_id
        if vpn_tunnel_options_specifications is not None:
            self._values["vpn_tunnel_options_specifications"] = vpn_tunnel_options_specifications

    @builtins.property
    def customer_gateway_id(self) -> builtins.str:
        '''The ID of the customer gateway at your end of the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-customergatewayid
        '''
        result = self._values.get("customer_gateway_id")
        assert result is not None, "Required property 'customer_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def static_routes_only(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the VPN connection uses static routes only.

        Static routes must be used for devices that don't support BGP.

        If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-StaticRoutesOnly
        '''
        result = self._values.get("static_routes_only")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def transit_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the transit gateway associated with the VPN connection.

        You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-transitgatewayid
        '''
        result = self._values.get("transit_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the virtual private gateway at the AWS side of the VPN connection.

        You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-vpngatewayid
        '''
        result = self._values.get("vpn_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_tunnel_options_specifications(
        self,
    ) -> typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnVPNConnection.VpnTunnelOptionsSpecificationProperty, _IResolvable_da3f097b]]]]:
        '''The tunnel options for the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection.html#cfn-ec2-vpnconnection-vpntunneloptionsspecifications
        '''
        result = self._values.get("vpn_tunnel_options_specifications")
        return typing.cast(typing.Optional[typing.Union[_IResolvable_da3f097b, typing.List[typing.Union[CfnVPNConnection.VpnTunnelOptionsSpecificationProperty, _IResolvable_da3f097b]]]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPNConnectionRoute(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNConnectionRoute",
):
    '''A CloudFormation ``AWS::EC2::VPNConnectionRoute``.

    Specifies a static route for a VPN connection between an existing virtual private gateway and a VPN customer gateway. The static route allows traffic to be routed from the virtual private gateway to the VPN customer gateway.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :cloudformationResource: AWS::EC2::VPNConnectionRoute
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection-route.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPNConnection_route = ec2.CfnVPNConnectionRoute(self, "MyCfnVPNConnectionRoute",
            destination_cidr_block="destinationCidrBlock",
            vpn_connection_id="vpnConnectionId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        destination_cidr_block: builtins.str,
        vpn_connection_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::VPNConnectionRoute``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param destination_cidr_block: The CIDR block associated with the local subnet of the customer network.
        :param vpn_connection_id: The ID of the VPN connection.
        '''
        props = CfnVPNConnectionRouteProps(
            destination_cidr_block=destination_cidr_block,
            vpn_connection_id=vpn_connection_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="destinationCidrBlock")
    def destination_cidr_block(self) -> builtins.str:
        '''The CIDR block associated with the local subnet of the customer network.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection-route.html#cfn-ec2-vpnconnectionroute-cidrblock
        '''
        return typing.cast(builtins.str, jsii.get(self, "destinationCidrBlock"))

    @destination_cidr_block.setter
    def destination_cidr_block(self, value: builtins.str) -> None:
        jsii.set(self, "destinationCidrBlock", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnConnectionId")
    def vpn_connection_id(self) -> builtins.str:
        '''The ID of the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection-route.html#cfn-ec2-vpnconnectionroute-connectionid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpnConnectionId"))

    @vpn_connection_id.setter
    def vpn_connection_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpnConnectionId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNConnectionRouteProps",
    jsii_struct_bases=[],
    name_mapping={
        "destination_cidr_block": "destinationCidrBlock",
        "vpn_connection_id": "vpnConnectionId",
    },
)
class CfnVPNConnectionRouteProps:
    def __init__(
        self,
        *,
        destination_cidr_block: builtins.str,
        vpn_connection_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnVPNConnectionRoute``.

        :param destination_cidr_block: The CIDR block associated with the local subnet of the customer network.
        :param vpn_connection_id: The ID of the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection-route.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPNConnection_route_props = ec2.CfnVPNConnectionRouteProps(
                destination_cidr_block="destinationCidrBlock",
                vpn_connection_id="vpnConnectionId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "destination_cidr_block": destination_cidr_block,
            "vpn_connection_id": vpn_connection_id,
        }

    @builtins.property
    def destination_cidr_block(self) -> builtins.str:
        '''The CIDR block associated with the local subnet of the customer network.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection-route.html#cfn-ec2-vpnconnectionroute-cidrblock
        '''
        result = self._values.get("destination_cidr_block")
        assert result is not None, "Required property 'destination_cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpn_connection_id(self) -> builtins.str:
        '''The ID of the VPN connection.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-connection-route.html#cfn-ec2-vpnconnectionroute-connectionid
        '''
        result = self._values.get("vpn_connection_id")
        assert result is not None, "Required property 'vpn_connection_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNConnectionRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPNGateway(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNGateway",
):
    '''A CloudFormation ``AWS::EC2::VPNGateway``.

    Specifies a virtual private gateway. A virtual private gateway is the endpoint on the VPC side of your VPN connection. You can create a virtual private gateway before creating the VPC itself.

    For more information, see `AWS Site-to-Site VPN <https://docs.aws.amazon.com/vpn/latest/s2svpn/VPC_VPN.html>`_ in the *AWS Site-to-Site VPN User Guide* .

    :cloudformationResource: AWS::EC2::VPNGateway
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPNGateway = ec2.CfnVPNGateway(self, "MyCfnVPNGateway",
            type="type",
        
            # the properties below are optional
            amazon_side_asn=123,
            tags=[CfnTag(
                key="key",
                value="value"
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::VPNGateway``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param type: The type of VPN connection the virtual private gateway supports.
        :param amazon_side_asn: The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        :param tags: Any tags assigned to the virtual private gateway.
        '''
        props = CfnVPNGatewayProps(
            type=type, amazon_side_asn=amazon_side_asn, tags=tags
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''Any tags assigned to the virtual private gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html#cfn-ec2-vpngateway-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="type")
    def type(self) -> builtins.str:
        '''The type of VPN connection the virtual private gateway supports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html#cfn-ec2-vpngateway-type
        '''
        return typing.cast(builtins.str, jsii.get(self, "type"))

    @type.setter
    def type(self, value: builtins.str) -> None:
        jsii.set(self, "type", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="amazonSideAsn")
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''The private Autonomous System Number (ASN) for the Amazon side of a BGP session.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html#cfn-ec2-vpngateway-amazonsideasn
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "amazonSideAsn"))

    @amazon_side_asn.setter
    def amazon_side_asn(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "amazonSideAsn", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNGatewayProps",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "amazon_side_asn": "amazonSideAsn", "tags": "tags"},
)
class CfnVPNGatewayProps:
    def __init__(
        self,
        *,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
    ) -> None:
        '''Properties for defining a ``CfnVPNGateway``.

        :param type: The type of VPN connection the virtual private gateway supports.
        :param amazon_side_asn: The private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        :param tags: Any tags assigned to the virtual private gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPNGateway_props = ec2.CfnVPNGatewayProps(
                type="type",
            
                # the properties below are optional
                amazon_side_asn=123,
                tags=[CfnTag(
                    key="key",
                    value="value"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn
        if tags is not None:
            self._values["tags"] = tags

    @builtins.property
    def type(self) -> builtins.str:
        '''The type of VPN connection the virtual private gateway supports.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html#cfn-ec2-vpngateway-type
        '''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''The private Autonomous System Number (ASN) for the Amazon side of a BGP session.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html#cfn-ec2-vpngateway-amazonsideasn
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''Any tags assigned to the virtual private gateway.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gateway.html#cfn-ec2-vpngateway-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVPNGatewayRoutePropagation(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNGatewayRoutePropagation",
):
    '''A CloudFormation ``AWS::EC2::VPNGatewayRoutePropagation``.

    Enables a virtual private gateway (VGW) to propagate routes to the specified route table of a VPC.

    If you reference a VPN gateway that is in the same template as your VPN gateway route propagation, you must explicitly declare a dependency on the VPN gateway attachment. The ``AWS::EC2::VPNGatewayRoutePropagation`` resource cannot use the VPN gateway until it has successfully attached to the VPC. Add a `DependsOn Attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html>`_ in the ``AWS::EC2::VPNGatewayRoutePropagation`` resource to explicitly declare a dependency on the VPN gateway attachment.

    :cloudformationResource: AWS::EC2::VPNGatewayRoutePropagation
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_vPNGateway_route_propagation = ec2.CfnVPNGatewayRoutePropagation(self, "MyCfnVPNGatewayRoutePropagation",
            route_table_ids=["routeTableIds"],
            vpn_gateway_id="vpnGatewayId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        route_table_ids: typing.Sequence[builtins.str],
        vpn_gateway_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::VPNGatewayRoutePropagation``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param route_table_ids: The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.
        :param vpn_gateway_id: The ID of the virtual private gateway that is attached to a VPC. The virtual private gateway must be attached to the same VPC that the routing tables are associated with.
        '''
        props = CfnVPNGatewayRoutePropagationProps(
            route_table_ids=route_table_ids, vpn_gateway_id=vpn_gateway_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="attrId")
    def attr_id(self) -> builtins.str:
        '''The ID of the VPN gateway.

        :cloudformationAttribute: Id
        '''
        return typing.cast(builtins.str, jsii.get(self, "attrId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableIds")
    def route_table_ids(self) -> typing.List[builtins.str]:
        '''The ID of the route table.

        The routing table must be associated with the same VPC that the virtual private gateway is attached to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "routeTableIds"))

    @route_table_ids.setter
    def route_table_ids(self, value: typing.List[builtins.str]) -> None:
        jsii.set(self, "routeTableIds", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(self) -> builtins.str:
        '''The ID of the virtual private gateway that is attached to a VPC.

        The virtual private gateway must be attached to the same VPC that the routing tables are associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpnGatewayId"))

    @vpn_gateway_id.setter
    def vpn_gateway_id(self, value: builtins.str) -> None:
        jsii.set(self, "vpnGatewayId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVPNGatewayRoutePropagationProps",
    jsii_struct_bases=[],
    name_mapping={
        "route_table_ids": "routeTableIds",
        "vpn_gateway_id": "vpnGatewayId",
    },
)
class CfnVPNGatewayRoutePropagationProps:
    def __init__(
        self,
        *,
        route_table_ids: typing.Sequence[builtins.str],
        vpn_gateway_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnVPNGatewayRoutePropagation``.

        :param route_table_ids: The ID of the route table. The routing table must be associated with the same VPC that the virtual private gateway is attached to.
        :param vpn_gateway_id: The ID of the virtual private gateway that is attached to a VPC. The virtual private gateway must be attached to the same VPC that the routing tables are associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_vPNGateway_route_propagation_props = ec2.CfnVPNGatewayRoutePropagationProps(
                route_table_ids=["routeTableIds"],
                vpn_gateway_id="vpnGatewayId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "route_table_ids": route_table_ids,
            "vpn_gateway_id": vpn_gateway_id,
        }

    @builtins.property
    def route_table_ids(self) -> typing.List[builtins.str]:
        '''The ID of the route table.

        The routing table must be associated with the same VPC that the virtual private gateway is attached to.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-routetableids
        '''
        result = self._values.get("route_table_ids")
        assert result is not None, "Required property 'route_table_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def vpn_gateway_id(self) -> builtins.str:
        '''The ID of the virtual private gateway that is attached to a VPC.

        The virtual private gateway must be attached to the same VPC that the routing tables are associated with.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpngatewayroutepropagation.html#cfn-ec2-vpngatewayroutepropagation-vpngatewayid
        '''
        result = self._values.get("vpn_gateway_id")
        assert result is not None, "Required property 'vpn_gateway_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVPNGatewayRoutePropagationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IInspectable_c2943556)
class CfnVolume(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVolume",
):
    '''A CloudFormation ``AWS::EC2::Volume``.

    Specifies an Amazon Elastic Block Store (Amazon EBS) volume. You can attach the volume to an instance in the same Availability Zone using `AWS::EC2::VolumeAttachment <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html>`_ .

    When you use AWS CloudFormation to update an Amazon EBS volume that modifies ``Iops`` , ``Size`` , or ``VolumeType`` , there is a cooldown period before another operation can occur. This can cause your stack to report being in ``UPDATE_IN_PROGRESS`` or ``UPDATE_ROLLBACK_IN_PROGRESS`` for long periods of time.

    Amazon EBS does not support sizing down an Amazon EBS volume. AWS CloudFormation does not attempt to modify an Amazon EBS volume to a smaller size on rollback.

    Some common scenarios when you might encounter a cooldown period for Amazon EBS include:

    - You successfully update an Amazon EBS volume and the update succeeds. When you attempt another update within the cooldown window, that update will be subject to a cooldown period.
    - You successfully update an Amazon EBS volume and the update succeeds but another change in your ``update-stack`` call fails. The rollback will be subject to a cooldown period.

    For more information on the cooldown period, see `Requirements when modifying volumes <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/modify-volume-requirements.html>`_ .

    *DeletionPolicy attribute*

    To control how AWS CloudFormation handles the volume when the stack is deleted, set a deletion policy for your volume. You can choose to retain the volume, to delete the volume, or to create a snapshot of the volume. For more information, see `DeletionPolicy attribute <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html>`_ .
    .. epigraph::

       If you set a deletion policy that creates a snapshot, all tags on the volume are included in the snapshot.

    :cloudformationResource: AWS::EC2::Volume
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_volume = ec2.CfnVolume(self, "MyCfnVolume",
            availability_zone="availabilityZone",
        
            # the properties below are optional
            auto_enable_io=False,
            encrypted=False,
            iops=123,
            kms_key_id="kmsKeyId",
            multi_attach_enabled=False,
            outpost_arn="outpostArn",
            size=123,
            snapshot_id="snapshotId",
            tags=[CfnTag(
                key="key",
                value="value"
            )],
            throughput=123,
            volume_type="volumeType"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        auto_enable_io: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        multi_attach_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        size: typing.Optional[jsii.Number] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        throughput: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Create a new ``AWS::EC2::Volume``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param availability_zone: The Availability Zone in which to create the volume.
        :param auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
        :param encrypted: Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .
        :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS ``io1`` and ``io2`` volumes support up to 64,000 IOPS only on `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families support performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.
        :param kms_key_id: The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key . Alternatively, if you want to specify a different key, you can specify one of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` . - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
        :param multi_attach_enabled: Indicates whether Amazon EBS Multi-Attach is enabled. AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
        :param outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` : 1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024
        :param snapshot_id: The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.
        :param tags: The tags to apply to the volume during creation.
        :param throughput: The throughput that the volume supports, in MiB/s.
        :param volume_type: The volume type. This parameter can be one of the following values:. - General Purpose SSD: ``gp2`` | ``gp3`` - Provisioned IOPS SSD: ``io1`` | ``io2`` - Throughput Optimized HDD: ``st1`` - Cold HDD: ``sc1`` - Magnetic: ``standard`` For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Default: ``gp2``
        '''
        props = CfnVolumeProps(
            availability_zone=availability_zone,
            auto_enable_io=auto_enable_io,
            encrypted=encrypted,
            iops=iops,
            kms_key_id=kms_key_id,
            multi_attach_enabled=multi_attach_enabled,
            outpost_arn=outpost_arn,
            size=size,
            snapshot_id=snapshot_id,
            tags=tags,
            throughput=throughput,
            volume_type=volume_type,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def tags(self) -> _TagManager_0a598cb3:
        '''The tags to apply to the volume during creation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-tags
        '''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to create the volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-availabilityzone
        '''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @availability_zone.setter
    def availability_zone(self, value: builtins.str) -> None:
        jsii.set(self, "availabilityZone", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="autoEnableIo")
    def auto_enable_io(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the volume is auto-enabled for I/O operations.

        By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-autoenableio
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "autoEnableIo"))

    @auto_enable_io.setter
    def auto_enable_io(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "autoEnableIo", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="encrypted")
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the volume should be encrypted.

        The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-encrypted
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "encrypted"))

    @encrypted.setter
    def encrypted(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "encrypted", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="iops")
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS).

        For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - ``gp3`` : 3,000-16,000 IOPS
        - ``io1`` : 100-64,000 IOPS
        - ``io2`` : 100-64,000 IOPS

        ``io1`` and ``io2`` volumes support up to 64,000 IOPS only on `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families support performance up to 32,000 IOPS.

        This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-iops
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "iops"))

    @iops.setter
    def iops(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "iops", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="kmsKeyId")
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the AWS KMS key to use for Amazon EBS encryption.

        If ``KmsKeyId`` is specified, the encrypted state must be ``true`` .

        If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .

        Alternatively, if you want to specify a different key, you can specify one of the following:

        - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
        - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` .
        - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-kmskeyid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kmsKeyId"))

    @kms_key_id.setter
    def kms_key_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "kmsKeyId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="multiAttachEnabled")
    def multi_attach_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether Amazon EBS Multi-Attach is enabled.

        AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-multiattachenabled
        '''
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], jsii.get(self, "multiAttachEnabled"))

    @multi_attach_enabled.setter
    def multi_attach_enabled(
        self,
        value: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]],
    ) -> None:
        jsii.set(self, "multiAttachEnabled", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="outpostArn")
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-outpostarn
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "outpostArn"))

    @outpost_arn.setter
    def outpost_arn(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "outpostArn", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="size")
    def size(self) -> typing.Optional[jsii.Number]:
        '''The size of the volume, in GiBs.

        You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported volumes sizes for each volume type:

        - ``gp2`` and ``gp3`` : 1-16,384
        - ``io1`` and ``io2`` : 4-16,384
        - ``st1`` and ``sc1`` : 125-16,384
        - ``standard`` : 1-1,024

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-size
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "size"))

    @size.setter
    def size(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "size", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="snapshotId")
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        '''The snapshot from which to create the volume.

        You must specify either a snapshot ID or a volume size.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-snapshotid
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "snapshotId"))

    @snapshot_id.setter
    def snapshot_id(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "snapshotId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="throughput")
    def throughput(self) -> typing.Optional[jsii.Number]:
        '''The throughput that the volume supports, in MiB/s.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-throughput
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "throughput"))

    @throughput.setter
    def throughput(self, value: typing.Optional[jsii.Number]) -> None:
        jsii.set(self, "throughput", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="volumeType")
    def volume_type(self) -> typing.Optional[builtins.str]:
        '''The volume type. This parameter can be one of the following values:.

        - General Purpose SSD: ``gp2`` | ``gp3``
        - Provisioned IOPS SSD: ``io1`` | ``io2``
        - Throughput Optimized HDD: ``st1``
        - Cold HDD: ``sc1``
        - Magnetic: ``standard``

        For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        Default: ``gp2``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-volumetype
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "volumeType"))

    @volume_type.setter
    def volume_type(self, value: typing.Optional[builtins.str]) -> None:
        jsii.set(self, "volumeType", value)


@jsii.implements(_IInspectable_c2943556)
class CfnVolumeAttachment(
    _CfnResource_9df397a6,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CfnVolumeAttachment",
):
    '''A CloudFormation ``AWS::EC2::VolumeAttachment``.

    Attaches an Amazon EBS volume to a running instance and exposes it to the instance with the specified device name.

    Before this resource can be deleted (and therefore the volume detached), you must first unmount the volume in the instance. Failure to do so results in the volume being stuck in the busy state while it is trying to detach, which could possibly damage the file system or the data it contains.

    If an Amazon EBS volume is the root device of an instance, it cannot be detached while the instance is in the "running" state. To detach the root volume, stop the instance first.

    If the root volume is detached from an instance with an AWS Marketplace product code, then the product codes from that volume are no longer associated with the instance.

    :cloudformationResource: AWS::EC2::VolumeAttachment
    :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        cfn_volume_attachment = ec2.CfnVolumeAttachment(self, "MyCfnVolumeAttachment",
            device="device",
            instance_id="instanceId",
            volume_id="volumeId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        device: builtins.str,
        instance_id: builtins.str,
        volume_id: builtins.str,
    ) -> None:
        '''Create a new ``AWS::EC2::VolumeAttachment``.

        :param scope: - scope in which this resource is defined.
        :param id: - scoped id of the resource.
        :param device: The device name (for example, ``/dev/sdh`` or ``xvdh`` ).
        :param instance_id: The ID of the instance to which the volume attaches. This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.
        :param volume_id: The ID of the Amazon EBS volume. The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.
        '''
        props = CfnVolumeAttachmentProps(
            device=device, instance_id=instance_id, volume_id=volume_id
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="inspect")
    def inspect(self, inspector: _TreeInspector_488e0dd5) -> None:
        '''Examines the CloudFormation resource and discloses attributes.

        :param inspector: - tree inspector to collect and process attributes.
        '''
        return typing.cast(None, jsii.invoke(self, "inspect", [inspector]))

    @jsii.member(jsii_name="renderProperties")
    def _render_properties(
        self,
        props: typing.Mapping[builtins.str, typing.Any],
    ) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :param props: -
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.invoke(self, "renderProperties", [props]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CFN_RESOURCE_TYPE_NAME")
    def CFN_RESOURCE_TYPE_NAME(cls) -> builtins.str:
        '''The CloudFormation resource type name for this resource class.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CFN_RESOURCE_TYPE_NAME"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="cfnProperties")
    def _cfn_properties(self) -> typing.Mapping[builtins.str, typing.Any]:
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "cfnProperties"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="device")
    def device(self) -> builtins.str:
        '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html#cfn-ec2-ebs-volumeattachment-device
        '''
        return typing.cast(builtins.str, jsii.get(self, "device"))

    @device.setter
    def device(self, value: builtins.str) -> None:
        jsii.set(self, "device", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        '''The ID of the instance to which the volume attaches.

        This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html#cfn-ec2-ebs-volumeattachment-instanceid
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceId"))

    @instance_id.setter
    def instance_id(self, value: builtins.str) -> None:
        jsii.set(self, "instanceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="volumeId")
    def volume_id(self) -> builtins.str:
        '''The ID of the Amazon EBS volume.

        The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html#cfn-ec2-ebs-volumeattachment-volumeid
        '''
        return typing.cast(builtins.str, jsii.get(self, "volumeId"))

    @volume_id.setter
    def volume_id(self, value: builtins.str) -> None:
        jsii.set(self, "volumeId", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVolumeAttachmentProps",
    jsii_struct_bases=[],
    name_mapping={
        "device": "device",
        "instance_id": "instanceId",
        "volume_id": "volumeId",
    },
)
class CfnVolumeAttachmentProps:
    def __init__(
        self,
        *,
        device: builtins.str,
        instance_id: builtins.str,
        volume_id: builtins.str,
    ) -> None:
        '''Properties for defining a ``CfnVolumeAttachment``.

        :param device: The device name (for example, ``/dev/sdh`` or ``xvdh`` ).
        :param instance_id: The ID of the instance to which the volume attaches. This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.
        :param volume_id: The ID of the Amazon EBS volume. The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_volume_attachment_props = ec2.CfnVolumeAttachmentProps(
                device="device",
                instance_id="instanceId",
                volume_id="volumeId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "device": device,
            "instance_id": instance_id,
            "volume_id": volume_id,
        }

    @builtins.property
    def device(self) -> builtins.str:
        '''The device name (for example, ``/dev/sdh`` or ``xvdh`` ).

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html#cfn-ec2-ebs-volumeattachment-device
        '''
        result = self._values.get("device")
        assert result is not None, "Required property 'device' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def instance_id(self) -> builtins.str:
        '''The ID of the instance to which the volume attaches.

        This value can be a reference to an ```AWS::EC2::Instance`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html>`_ resource, or it can be the physical ID of an existing EC2 instance.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html#cfn-ec2-ebs-volumeattachment-instanceid
        '''
        result = self._values.get("instance_id")
        assert result is not None, "Required property 'instance_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''The ID of the Amazon EBS volume.

        The volume and instance must be within the same Availability Zone. This value can be a reference to an ```AWS::EC2::Volume`` <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html>`_ resource, or it can be the volume ID of an existing Amazon EBS volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volumeattachment.html#cfn-ec2-ebs-volumeattachment-volumeid
        '''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVolumeAttachmentProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CfnVolumeProps",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "auto_enable_io": "autoEnableIo",
        "encrypted": "encrypted",
        "iops": "iops",
        "kms_key_id": "kmsKeyId",
        "multi_attach_enabled": "multiAttachEnabled",
        "outpost_arn": "outpostArn",
        "size": "size",
        "snapshot_id": "snapshotId",
        "tags": "tags",
        "throughput": "throughput",
        "volume_type": "volumeType",
    },
)
class CfnVolumeProps:
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        auto_enable_io: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        encrypted: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        iops: typing.Optional[jsii.Number] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        multi_attach_enabled: typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]] = None,
        outpost_arn: typing.Optional[builtins.str] = None,
        size: typing.Optional[jsii.Number] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[_CfnTag_f6864754]] = None,
        throughput: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for defining a ``CfnVolume``.

        :param availability_zone: The Availability Zone in which to create the volume.
        :param auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.
        :param encrypted: Indicates whether the volume should be encrypted. The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* . Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .
        :param iops: The number of I/O operations per second (IOPS). For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. The following are the supported values for each volume type: - ``gp3`` : 3,000-16,000 IOPS - ``io1`` : 100-64,000 IOPS - ``io2`` : 100-64,000 IOPS ``io1`` and ``io2`` volumes support up to 64,000 IOPS only on `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families support performance up to 32,000 IOPS. This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.
        :param kms_key_id: The identifier of the AWS KMS key to use for Amazon EBS encryption. If ``KmsKeyId`` is specified, the encrypted state must be ``true`` . If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key . Alternatively, if you want to specify a different key, you can specify one of the following: - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab. - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` . - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab. - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.
        :param multi_attach_enabled: Indicates whether Amazon EBS Multi-Attach is enabled. AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.
        :param outpost_arn: The Amazon Resource Name (ARN) of the Outpost.
        :param size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size. The following are the supported volumes sizes for each volume type: - ``gp2`` and ``gp3`` : 1-16,384 - ``io1`` and ``io2`` : 4-16,384 - ``st1`` and ``sc1`` : 125-16,384 - ``standard`` : 1-1,024
        :param snapshot_id: The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size.
        :param tags: The tags to apply to the volume during creation.
        :param throughput: The throughput that the volume supports, in MiB/s.
        :param volume_type: The volume type. This parameter can be one of the following values:. - General Purpose SSD: ``gp2`` | ``gp3`` - Provisioned IOPS SSD: ``io1`` | ``io2`` - Throughput Optimized HDD: ``st1`` - Cold HDD: ``sc1`` - Magnetic: ``standard`` For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* . Default: ``gp2``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html
        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            cfn_volume_props = ec2.CfnVolumeProps(
                availability_zone="availabilityZone",
            
                # the properties below are optional
                auto_enable_io=False,
                encrypted=False,
                iops=123,
                kms_key_id="kmsKeyId",
                multi_attach_enabled=False,
                outpost_arn="outpostArn",
                size=123,
                snapshot_id="snapshotId",
                tags=[CfnTag(
                    key="key",
                    value="value"
                )],
                throughput=123,
                volume_type="volumeType"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
        }
        if auto_enable_io is not None:
            self._values["auto_enable_io"] = auto_enable_io
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if iops is not None:
            self._values["iops"] = iops
        if kms_key_id is not None:
            self._values["kms_key_id"] = kms_key_id
        if multi_attach_enabled is not None:
            self._values["multi_attach_enabled"] = multi_attach_enabled
        if outpost_arn is not None:
            self._values["outpost_arn"] = outpost_arn
        if size is not None:
            self._values["size"] = size
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if tags is not None:
            self._values["tags"] = tags
        if throughput is not None:
            self._values["throughput"] = throughput
        if volume_type is not None:
            self._values["volume_type"] = volume_type

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to create the volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-availabilityzone
        '''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auto_enable_io(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the volume is auto-enabled for I/O operations.

        By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-autoenableio
        '''
        result = self._values.get("auto_enable_io")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def encrypted(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether the volume should be encrypted.

        The effect of setting the encryption state to ``true`` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see `Encryption by default <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see `Supported instance types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances>`_ .

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-encrypted
        '''
        result = self._values.get("encrypted")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS).

        For ``gp3`` , ``io1`` , and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - ``gp3`` : 3,000-16,000 IOPS
        - ``io1`` : 100-64,000 IOPS
        - ``io2`` : 100-64,000 IOPS

        ``io1`` and ``io2`` volumes support up to 64,000 IOPS only on `Instances built on the Nitro System <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances>`_ . Other instance families support performance up to 32,000 IOPS.

        This parameter is required for ``io1`` and ``io2`` volumes. The default for ``gp3`` volumes is 3,000 IOPS. This parameter is not supported for ``gp2`` , ``st1`` , ``sc1`` , or ``standard`` volumes.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-iops
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def kms_key_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the AWS KMS key to use for Amazon EBS encryption.

        If ``KmsKeyId`` is specified, the encrypted state must be ``true`` .

        If you omit this property and your account is enabled for encryption by default, or *Encrypted* is set to ``true`` , then the volume is encrypted using the default key specified for your account. If your account does not have a default key, then the volume is encrypted using the AWS managed key .

        Alternatively, if you want to specify a different key, you can specify one of the following:

        - Key ID. For example, 1234abcd-12ab-34cd-56ef-1234567890ab.
        - Key alias. Specify the alias for the key, prefixed with ``alias/`` . For example, for a key with the alias ``my_cmk`` , use ``alias/my_cmk`` . Or to specify the AWS managed key , use ``alias/aws/ebs`` .
        - Key ARN. For example, arn:aws:kms:us-east-1:012345678910:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        - Alias ARN. For example, arn:aws:kms:us-east-1:012345678910:alias/ExampleAlias.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-kmskeyid
        '''
        result = self._values.get("kms_key_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def multi_attach_enabled(
        self,
    ) -> typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]]:
        '''Indicates whether Amazon EBS Multi-Attach is enabled.

        AWS CloudFormation does not currently support updating a single-attach volume to be multi-attach enabled, updating a multi-attach enabled volume to be single-attach, or updating the size or number of I/O operations per second (IOPS) of a multi-attach enabled volume.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-multiattachenabled
        '''
        result = self._values.get("multi_attach_enabled")
        return typing.cast(typing.Optional[typing.Union[builtins.bool, _IResolvable_da3f097b]], result)

    @builtins.property
    def outpost_arn(self) -> typing.Optional[builtins.str]:
        '''The Amazon Resource Name (ARN) of the Outpost.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-outpostarn
        '''
        result = self._values.get("outpost_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def size(self) -> typing.Optional[jsii.Number]:
        '''The size of the volume, in GiBs.

        You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported volumes sizes for each volume type:

        - ``gp2`` and ``gp3`` : 1-16,384
        - ``io1`` and ``io2`` : 4-16,384
        - ``st1`` and ``sc1`` : 125-16,384
        - ``standard`` : 1-1,024

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-size
        '''
        result = self._values.get("size")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        '''The snapshot from which to create the volume.

        You must specify either a snapshot ID or a volume size.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-snapshotid
        '''
        result = self._values.get("snapshot_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_CfnTag_f6864754]]:
        '''The tags to apply to the volume during creation.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_CfnTag_f6864754]], result)

    @builtins.property
    def throughput(self) -> typing.Optional[jsii.Number]:
        '''The throughput that the volume supports, in MiB/s.

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-throughput
        '''
        result = self._values.get("throughput")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_type(self) -> typing.Optional[builtins.str]:
        '''The volume type. This parameter can be one of the following values:.

        - General Purpose SSD: ``gp2`` | ``gp3``
        - Provisioned IOPS SSD: ``io1`` | ``io2``
        - Throughput Optimized HDD: ``st1``
        - Cold HDD: ``sc1``
        - Magnetic: ``standard``

        For more information, see `Amazon EBS volume types <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>`_ in the *Amazon Elastic Compute Cloud User Guide* .

        Default: ``gp2``

        :link: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html#cfn-ec2-ebs-volume-volumetype
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CfnVolumeProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClientVpnAuthorizationRule(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnAuthorizationRule",
):
    '''A client VPN authorization rule.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # client_vpn_endpoint: ec2.ClientVpnEndpoint
        
        client_vpn_authorization_rule = ec2.ClientVpnAuthorizationRule(self, "MyClientVpnAuthorizationRule",
            cidr="cidr",
        
            # the properties below are optional
            client_vpn_endpoint=client_vpn_endpoint,
            description="description",
            group_id="groupId"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_vpn_endpoint: typing.Optional["IClientVpnEndpoint"] = None,
        cidr: builtins.str,
        description: typing.Optional[builtins.str] = None,
        group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param client_vpn_endpoint: The client VPN endpoint to which to add the rule. Default: clientVpnEndpoint is required
        :param cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
        :param description: A brief description of the authorization rule. Default: - no description
        :param group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups
        '''
        props = ClientVpnAuthorizationRuleProps(
            client_vpn_endpoint=client_vpn_endpoint,
            cidr=cidr,
            description=description,
            group_id=group_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnAuthorizationRuleOptions",
    jsii_struct_bases=[],
    name_mapping={"cidr": "cidr", "description": "description", "group_id": "groupId"},
)
class ClientVpnAuthorizationRuleOptions:
    def __init__(
        self,
        *,
        cidr: builtins.str,
        description: typing.Optional[builtins.str] = None,
        group_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options for a ClientVpnAuthorizationRule.

        :param cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
        :param description: A brief description of the authorization rule. Default: - no description
        :param group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups

        :exampleMetadata: fixture=client-vpn infused

        Example::

            endpoint = vpc.add_client_vpn_endpoint("Endpoint",
                cidr="10.100.0.0/16",
                server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
                user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),
                authorize_all_users_to_vpc_cidr=False
            )
            
            endpoint.add_authorization_rule("Rule",
                cidr="10.0.10.0/32",
                group_id="group-id"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
        }
        if description is not None:
            self._values["description"] = description
        if group_id is not None:
            self._values["group_id"] = group_id

    @builtins.property
    def cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the network for which access is being authorized.'''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :default: - no description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.

        :default: - authorize all groups
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnAuthorizationRuleOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnAuthorizationRuleProps",
    jsii_struct_bases=[ClientVpnAuthorizationRuleOptions],
    name_mapping={
        "cidr": "cidr",
        "description": "description",
        "group_id": "groupId",
        "client_vpn_endpoint": "clientVpnEndpoint",
    },
)
class ClientVpnAuthorizationRuleProps(ClientVpnAuthorizationRuleOptions):
    def __init__(
        self,
        *,
        cidr: builtins.str,
        description: typing.Optional[builtins.str] = None,
        group_id: typing.Optional[builtins.str] = None,
        client_vpn_endpoint: typing.Optional["IClientVpnEndpoint"] = None,
    ) -> None:
        '''Properties for a ClientVpnAuthorizationRule.

        :param cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
        :param description: A brief description of the authorization rule. Default: - no description
        :param group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups
        :param client_vpn_endpoint: The client VPN endpoint to which to add the rule. Default: clientVpnEndpoint is required

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # client_vpn_endpoint: ec2.ClientVpnEndpoint
            
            client_vpn_authorization_rule_props = ec2.ClientVpnAuthorizationRuleProps(
                cidr="cidr",
            
                # the properties below are optional
                client_vpn_endpoint=client_vpn_endpoint,
                description="description",
                group_id="groupId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
        }
        if description is not None:
            self._values["description"] = description
        if group_id is not None:
            self._values["group_id"] = group_id
        if client_vpn_endpoint is not None:
            self._values["client_vpn_endpoint"] = client_vpn_endpoint

    @builtins.property
    def cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the network for which access is being authorized.'''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :default: - no description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def group_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group.

        :default: - authorize all groups
        '''
        result = self._values.get("group_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_vpn_endpoint(self) -> typing.Optional["IClientVpnEndpoint"]:
        '''The client VPN endpoint to which to add the rule.

        :default: clientVpnEndpoint is required
        '''
        result = self._values.get("client_vpn_endpoint")
        return typing.cast(typing.Optional["IClientVpnEndpoint"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnAuthorizationRuleProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnEndpointAttributes",
    jsii_struct_bases=[],
    name_mapping={"endpoint_id": "endpointId", "security_groups": "securityGroups"},
)
class ClientVpnEndpointAttributes:
    def __init__(
        self,
        *,
        endpoint_id: builtins.str,
        security_groups: typing.Sequence["ISecurityGroup"],
    ) -> None:
        '''Attributes when importing an existing client VPN endpoint.

        :param endpoint_id: The endpoint ID.
        :param security_groups: The security groups associated with the endpoint.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # security_group: ec2.SecurityGroup
            
            client_vpn_endpoint_attributes = ec2.ClientVpnEndpointAttributes(
                endpoint_id="endpointId",
                security_groups=[security_group]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "endpoint_id": endpoint_id,
            "security_groups": security_groups,
        }

    @builtins.property
    def endpoint_id(self) -> builtins.str:
        '''The endpoint ID.'''
        result = self._values.get("endpoint_id")
        assert result is not None, "Required property 'endpoint_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def security_groups(self) -> typing.List["ISecurityGroup"]:
        '''The security groups associated with the endpoint.'''
        result = self._values.get("security_groups")
        assert result is not None, "Required property 'security_groups' is missing"
        return typing.cast(typing.List["ISecurityGroup"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnEndpointAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnEndpointOptions",
    jsii_struct_bases=[],
    name_mapping={
        "cidr": "cidr",
        "server_certificate_arn": "serverCertificateArn",
        "authorize_all_users_to_vpc_cidr": "authorizeAllUsersToVpcCidr",
        "client_certificate_arn": "clientCertificateArn",
        "client_connection_handler": "clientConnectionHandler",
        "client_login_banner": "clientLoginBanner",
        "description": "description",
        "dns_servers": "dnsServers",
        "logging": "logging",
        "log_group": "logGroup",
        "log_stream": "logStream",
        "port": "port",
        "security_groups": "securityGroups",
        "self_service_portal": "selfServicePortal",
        "session_timeout": "sessionTimeout",
        "split_tunnel": "splitTunnel",
        "transport_protocol": "transportProtocol",
        "user_based_authentication": "userBasedAuthentication",
        "vpc_subnets": "vpcSubnets",
    },
)
class ClientVpnEndpointOptions:
    def __init__(
        self,
        *,
        cidr: builtins.str,
        server_certificate_arn: builtins.str,
        authorize_all_users_to_vpc_cidr: typing.Optional[builtins.bool] = None,
        client_certificate_arn: typing.Optional[builtins.str] = None,
        client_connection_handler: typing.Optional["IClientVpnConnectionHandler"] = None,
        client_login_banner: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        log_stream: typing.Optional[_ILogStream_dcfca8c2] = None,
        port: typing.Optional["VpnPort"] = None,
        security_groups: typing.Optional[typing.Sequence["ISecurityGroup"]] = None,
        self_service_portal: typing.Optional[builtins.bool] = None,
        session_timeout: typing.Optional["ClientVpnSessionTimeout"] = None,
        split_tunnel: typing.Optional[builtins.bool] = None,
        transport_protocol: typing.Optional["TransportProtocol"] = None,
        user_based_authentication: typing.Optional["ClientVpnUserBasedAuthentication"] = None,
        vpc_subnets: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''Options for a client VPN endpoint.

        :param cidr: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.
        :param server_certificate_arn: The ARN of the server certificate.
        :param authorize_all_users_to_vpc_cidr: Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true
        :param client_certificate_arn: The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication
        :param client_connection_handler: The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler
        :param client_login_banner: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client
        :param description: A brief description of the Client VPN endpoint. Default: - no description
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device
        :param logging: Whether to enable connections logging. Default: true
        :param log_group: A CloudWatch Logs log group for connection logging. Default: - a new group is created
        :param log_stream: A CloudWatch Logs log stream for connection logging. Default: - a new stream is created
        :param port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS
        :param security_groups: The security groups to apply to the target network. Default: - a new security group is created
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true
        :param session_timeout: The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false
        :param transport_protocol: The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP
        :param user_based_authentication: The type of user-based authentication to use. Default: - use mutual authentication
        :param vpc_subnets: Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy

        :exampleMetadata: fixture=client-vpn infused

        Example::

            endpoint = vpc.add_client_vpn_endpoint("Endpoint",
                cidr="10.100.0.0/16",
                server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
                user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),
                authorize_all_users_to_vpc_cidr=False
            )
            
            endpoint.add_authorization_rule("Rule",
                cidr="10.0.10.0/32",
                group_id="group-id"
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = SubnetSelection(**vpc_subnets)
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
            "server_certificate_arn": server_certificate_arn,
        }
        if authorize_all_users_to_vpc_cidr is not None:
            self._values["authorize_all_users_to_vpc_cidr"] = authorize_all_users_to_vpc_cidr
        if client_certificate_arn is not None:
            self._values["client_certificate_arn"] = client_certificate_arn
        if client_connection_handler is not None:
            self._values["client_connection_handler"] = client_connection_handler
        if client_login_banner is not None:
            self._values["client_login_banner"] = client_login_banner
        if description is not None:
            self._values["description"] = description
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers
        if logging is not None:
            self._values["logging"] = logging
        if log_group is not None:
            self._values["log_group"] = log_group
        if log_stream is not None:
            self._values["log_stream"] = log_stream
        if port is not None:
            self._values["port"] = port
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if self_service_portal is not None:
            self._values["self_service_portal"] = self_service_portal
        if session_timeout is not None:
            self._values["session_timeout"] = session_timeout
        if split_tunnel is not None:
            self._values["split_tunnel"] = split_tunnel
        if transport_protocol is not None:
            self._values["transport_protocol"] = transport_protocol
        if user_based_authentication is not None:
            self._values["user_based_authentication"] = user_based_authentication
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, from which to assign client IP addresses.

        The address range cannot overlap with the local CIDR of the VPC
        in which the associated subnet is located, or the routes that you add manually.

        Changing the address range will replace the Client VPN endpoint.

        The CIDR block should be /22 or greater.
        '''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server_certificate_arn(self) -> builtins.str:
        '''The ARN of the server certificate.'''
        result = self._values.get("server_certificate_arn")
        assert result is not None, "Required property 'server_certificate_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def authorize_all_users_to_vpc_cidr(self) -> typing.Optional[builtins.bool]:
        '''Whether to authorize all users to the VPC CIDR.

        This automatically creates an authorization rule. Set this to ``false`` and
        use ``addAuthorizationRule()`` to create your own rules instead.

        :default: true
        '''
        result = self._values.get("authorize_all_users_to_vpc_cidr")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def client_certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the client certificate for mutual authentication.

        The certificate must be signed by a certificate authority (CA) and it must
        be provisioned in AWS Certificate Manager (ACM).

        :default: - use user-based authentication
        '''
        result = self._values.get("client_certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_connection_handler(
        self,
    ) -> typing.Optional["IClientVpnConnectionHandler"]:
        '''The AWS Lambda function used for connection authorization.

        The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix

        :default: - no connection handler
        '''
        result = self._values.get("client_connection_handler")
        return typing.cast(typing.Optional["IClientVpnConnectionHandler"], result)

    @builtins.property
    def client_login_banner(self) -> typing.Optional[builtins.str]:
        '''Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established.

        UTF-8 encoded characters only. Maximum of 1400 characters.

        :default: - no banner is presented to the client
        '''
        result = self._values.get("client_login_banner")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the Client VPN endpoint.

        :default: - no description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Information about the DNS servers to be used for DNS resolution.

        A Client VPN endpoint can have up to two DNS servers.

        :default: - use the DNS address configured on the device
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def logging(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable connections logging.

        :default: true
        '''
        result = self._values.get("logging")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_group(self) -> typing.Optional[_ILogGroup_3c4fa718]:
        '''A CloudWatch Logs log group for connection logging.

        :default: - a new group is created
        '''
        result = self._values.get("log_group")
        return typing.cast(typing.Optional[_ILogGroup_3c4fa718], result)

    @builtins.property
    def log_stream(self) -> typing.Optional[_ILogStream_dcfca8c2]:
        '''A CloudWatch Logs log stream for connection logging.

        :default: - a new stream is created
        '''
        result = self._values.get("log_stream")
        return typing.cast(typing.Optional[_ILogStream_dcfca8c2], result)

    @builtins.property
    def port(self) -> typing.Optional["VpnPort"]:
        '''The port number to assign to the Client VPN endpoint for TCP and UDP traffic.

        :default: VpnPort.HTTPS
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional["VpnPort"], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List["ISecurityGroup"]]:
        '''The security groups to apply to the target network.

        :default: - a new security group is created
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List["ISecurityGroup"]], result)

    @builtins.property
    def self_service_portal(self) -> typing.Optional[builtins.bool]:
        '''Specify whether to enable the self-service portal for the Client VPN endpoint.

        :default: true
        '''
        result = self._values.get("self_service_portal")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def session_timeout(self) -> typing.Optional["ClientVpnSessionTimeout"]:
        '''The maximum VPN session duration time.

        :default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        '''
        result = self._values.get("session_timeout")
        return typing.cast(typing.Optional["ClientVpnSessionTimeout"], result)

    @builtins.property
    def split_tunnel(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.

        :default: false

        :see: https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html
        '''
        result = self._values.get("split_tunnel")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def transport_protocol(self) -> typing.Optional["TransportProtocol"]:
        '''The transport protocol to be used by the VPN session.

        :default: TransportProtocol.UDP
        '''
        result = self._values.get("transport_protocol")
        return typing.cast(typing.Optional["TransportProtocol"], result)

    @builtins.property
    def user_based_authentication(
        self,
    ) -> typing.Optional["ClientVpnUserBasedAuthentication"]:
        '''The type of user-based authentication to use.

        :default: - use mutual authentication

        :see: https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/client-authentication.html
        '''
        result = self._values.get("user_based_authentication")
        return typing.cast(typing.Optional["ClientVpnUserBasedAuthentication"], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional["SubnetSelection"]:
        '''Subnets to associate to the client VPN endpoint.

        :default: - the VPC default strategy
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnEndpointOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnEndpointProps",
    jsii_struct_bases=[ClientVpnEndpointOptions],
    name_mapping={
        "cidr": "cidr",
        "server_certificate_arn": "serverCertificateArn",
        "authorize_all_users_to_vpc_cidr": "authorizeAllUsersToVpcCidr",
        "client_certificate_arn": "clientCertificateArn",
        "client_connection_handler": "clientConnectionHandler",
        "client_login_banner": "clientLoginBanner",
        "description": "description",
        "dns_servers": "dnsServers",
        "logging": "logging",
        "log_group": "logGroup",
        "log_stream": "logStream",
        "port": "port",
        "security_groups": "securityGroups",
        "self_service_portal": "selfServicePortal",
        "session_timeout": "sessionTimeout",
        "split_tunnel": "splitTunnel",
        "transport_protocol": "transportProtocol",
        "user_based_authentication": "userBasedAuthentication",
        "vpc_subnets": "vpcSubnets",
        "vpc": "vpc",
    },
)
class ClientVpnEndpointProps(ClientVpnEndpointOptions):
    def __init__(
        self,
        *,
        cidr: builtins.str,
        server_certificate_arn: builtins.str,
        authorize_all_users_to_vpc_cidr: typing.Optional[builtins.bool] = None,
        client_certificate_arn: typing.Optional[builtins.str] = None,
        client_connection_handler: typing.Optional["IClientVpnConnectionHandler"] = None,
        client_login_banner: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        log_stream: typing.Optional[_ILogStream_dcfca8c2] = None,
        port: typing.Optional["VpnPort"] = None,
        security_groups: typing.Optional[typing.Sequence["ISecurityGroup"]] = None,
        self_service_portal: typing.Optional[builtins.bool] = None,
        session_timeout: typing.Optional["ClientVpnSessionTimeout"] = None,
        split_tunnel: typing.Optional[builtins.bool] = None,
        transport_protocol: typing.Optional["TransportProtocol"] = None,
        user_based_authentication: typing.Optional["ClientVpnUserBasedAuthentication"] = None,
        vpc_subnets: typing.Optional["SubnetSelection"] = None,
        vpc: "IVpc",
    ) -> None:
        '''Properties for a client VPN endpoint.

        :param cidr: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.
        :param server_certificate_arn: The ARN of the server certificate.
        :param authorize_all_users_to_vpc_cidr: Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true
        :param client_certificate_arn: The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication
        :param client_connection_handler: The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler
        :param client_login_banner: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client
        :param description: A brief description of the Client VPN endpoint. Default: - no description
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device
        :param logging: Whether to enable connections logging. Default: true
        :param log_group: A CloudWatch Logs log group for connection logging. Default: - a new group is created
        :param log_stream: A CloudWatch Logs log stream for connection logging. Default: - a new stream is created
        :param port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS
        :param security_groups: The security groups to apply to the target network. Default: - a new security group is created
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true
        :param session_timeout: The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false
        :param transport_protocol: The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP
        :param user_based_authentication: The type of user-based authentication to use. Default: - use mutual authentication
        :param vpc_subnets: Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy
        :param vpc: The VPC to connect to.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_logs as logs
            
            # client_vpn_connection_handler: ec2.IClientVpnConnectionHandler
            # client_vpn_user_based_authentication: ec2.ClientVpnUserBasedAuthentication
            # log_group: logs.LogGroup
            # log_stream: logs.LogStream
            # security_group: ec2.SecurityGroup
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # vpc: ec2.Vpc
            
            client_vpn_endpoint_props = ec2.ClientVpnEndpointProps(
                cidr="cidr",
                server_certificate_arn="serverCertificateArn",
                vpc=vpc,
            
                # the properties below are optional
                authorize_all_users_to_vpc_cidr=False,
                client_certificate_arn="clientCertificateArn",
                client_connection_handler=client_vpn_connection_handler,
                client_login_banner="clientLoginBanner",
                description="description",
                dns_servers=["dnsServers"],
                logging=False,
                log_group=log_group,
                log_stream=log_stream,
                port=ec2.VpnPort.HTTPS,
                security_groups=[security_group],
                self_service_portal=False,
                session_timeout=ec2.ClientVpnSessionTimeout.EIGHT_HOURS,
                split_tunnel=False,
                transport_protocol=ec2.TransportProtocol.TCP,
                user_based_authentication=client_vpn_user_based_authentication,
                vpc_subnets=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
                )
            )
        '''
        if isinstance(vpc_subnets, dict):
            vpc_subnets = SubnetSelection(**vpc_subnets)
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
            "server_certificate_arn": server_certificate_arn,
            "vpc": vpc,
        }
        if authorize_all_users_to_vpc_cidr is not None:
            self._values["authorize_all_users_to_vpc_cidr"] = authorize_all_users_to_vpc_cidr
        if client_certificate_arn is not None:
            self._values["client_certificate_arn"] = client_certificate_arn
        if client_connection_handler is not None:
            self._values["client_connection_handler"] = client_connection_handler
        if client_login_banner is not None:
            self._values["client_login_banner"] = client_login_banner
        if description is not None:
            self._values["description"] = description
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers
        if logging is not None:
            self._values["logging"] = logging
        if log_group is not None:
            self._values["log_group"] = log_group
        if log_stream is not None:
            self._values["log_stream"] = log_stream
        if port is not None:
            self._values["port"] = port
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if self_service_portal is not None:
            self._values["self_service_portal"] = self_service_portal
        if session_timeout is not None:
            self._values["session_timeout"] = session_timeout
        if split_tunnel is not None:
            self._values["split_tunnel"] = split_tunnel
        if transport_protocol is not None:
            self._values["transport_protocol"] = transport_protocol
        if user_based_authentication is not None:
            self._values["user_based_authentication"] = user_based_authentication
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, from which to assign client IP addresses.

        The address range cannot overlap with the local CIDR of the VPC
        in which the associated subnet is located, or the routes that you add manually.

        Changing the address range will replace the Client VPN endpoint.

        The CIDR block should be /22 or greater.
        '''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def server_certificate_arn(self) -> builtins.str:
        '''The ARN of the server certificate.'''
        result = self._values.get("server_certificate_arn")
        assert result is not None, "Required property 'server_certificate_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def authorize_all_users_to_vpc_cidr(self) -> typing.Optional[builtins.bool]:
        '''Whether to authorize all users to the VPC CIDR.

        This automatically creates an authorization rule. Set this to ``false`` and
        use ``addAuthorizationRule()`` to create your own rules instead.

        :default: true
        '''
        result = self._values.get("authorize_all_users_to_vpc_cidr")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def client_certificate_arn(self) -> typing.Optional[builtins.str]:
        '''The ARN of the client certificate for mutual authentication.

        The certificate must be signed by a certificate authority (CA) and it must
        be provisioned in AWS Certificate Manager (ACM).

        :default: - use user-based authentication
        '''
        result = self._values.get("client_certificate_arn")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_connection_handler(
        self,
    ) -> typing.Optional["IClientVpnConnectionHandler"]:
        '''The AWS Lambda function used for connection authorization.

        The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix

        :default: - no connection handler
        '''
        result = self._values.get("client_connection_handler")
        return typing.cast(typing.Optional["IClientVpnConnectionHandler"], result)

    @builtins.property
    def client_login_banner(self) -> typing.Optional[builtins.str]:
        '''Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established.

        UTF-8 encoded characters only. Maximum of 1400 characters.

        :default: - no banner is presented to the client
        '''
        result = self._values.get("client_login_banner")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the Client VPN endpoint.

        :default: - no description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Information about the DNS servers to be used for DNS resolution.

        A Client VPN endpoint can have up to two DNS servers.

        :default: - use the DNS address configured on the device
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def logging(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable connections logging.

        :default: true
        '''
        result = self._values.get("logging")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def log_group(self) -> typing.Optional[_ILogGroup_3c4fa718]:
        '''A CloudWatch Logs log group for connection logging.

        :default: - a new group is created
        '''
        result = self._values.get("log_group")
        return typing.cast(typing.Optional[_ILogGroup_3c4fa718], result)

    @builtins.property
    def log_stream(self) -> typing.Optional[_ILogStream_dcfca8c2]:
        '''A CloudWatch Logs log stream for connection logging.

        :default: - a new stream is created
        '''
        result = self._values.get("log_stream")
        return typing.cast(typing.Optional[_ILogStream_dcfca8c2], result)

    @builtins.property
    def port(self) -> typing.Optional["VpnPort"]:
        '''The port number to assign to the Client VPN endpoint for TCP and UDP traffic.

        :default: VpnPort.HTTPS
        '''
        result = self._values.get("port")
        return typing.cast(typing.Optional["VpnPort"], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List["ISecurityGroup"]]:
        '''The security groups to apply to the target network.

        :default: - a new security group is created
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List["ISecurityGroup"]], result)

    @builtins.property
    def self_service_portal(self) -> typing.Optional[builtins.bool]:
        '''Specify whether to enable the self-service portal for the Client VPN endpoint.

        :default: true
        '''
        result = self._values.get("self_service_portal")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def session_timeout(self) -> typing.Optional["ClientVpnSessionTimeout"]:
        '''The maximum VPN session duration time.

        :default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        '''
        result = self._values.get("session_timeout")
        return typing.cast(typing.Optional["ClientVpnSessionTimeout"], result)

    @builtins.property
    def split_tunnel(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint.

        :default: false

        :see: https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html
        '''
        result = self._values.get("split_tunnel")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def transport_protocol(self) -> typing.Optional["TransportProtocol"]:
        '''The transport protocol to be used by the VPN session.

        :default: TransportProtocol.UDP
        '''
        result = self._values.get("transport_protocol")
        return typing.cast(typing.Optional["TransportProtocol"], result)

    @builtins.property
    def user_based_authentication(
        self,
    ) -> typing.Optional["ClientVpnUserBasedAuthentication"]:
        '''The type of user-based authentication to use.

        :default: - use mutual authentication

        :see: https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/client-authentication.html
        '''
        result = self._values.get("user_based_authentication")
        return typing.cast(typing.Optional["ClientVpnUserBasedAuthentication"], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional["SubnetSelection"]:
        '''Subnets to associate to the client VPN endpoint.

        :default: - the VPC default strategy
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    @builtins.property
    def vpc(self) -> "IVpc":
        '''The VPC to connect to.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast("IVpc", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClientVpnRoute(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnRoute",
):
    '''A client VPN route.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # client_vpn_endpoint: ec2.ClientVpnEndpoint
        # client_vpn_route_target: ec2.ClientVpnRouteTarget
        
        client_vpn_route = ec2.ClientVpnRoute(self, "MyClientVpnRoute",
            cidr="cidr",
            target=client_vpn_route_target,
        
            # the properties below are optional
            client_vpn_endpoint=client_vpn_endpoint,
            description="description"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        client_vpn_endpoint: typing.Optional["IClientVpnEndpoint"] = None,
        cidr: builtins.str,
        target: "ClientVpnRouteTarget",
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param client_vpn_endpoint: The client VPN endpoint to which to add the route. Default: clientVpnEndpoint is required
        :param cidr: The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target: The target for the route.
        :param description: A brief description of the authorization rule. Default: - no description
        '''
        props = ClientVpnRouteProps(
            client_vpn_endpoint=client_vpn_endpoint,
            cidr=cidr,
            target=target,
            description=description,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnRouteOptions",
    jsii_struct_bases=[],
    name_mapping={"cidr": "cidr", "target": "target", "description": "description"},
)
class ClientVpnRouteOptions:
    def __init__(
        self,
        *,
        cidr: builtins.str,
        target: "ClientVpnRouteTarget",
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options for a ClientVpnRoute.

        :param cidr: The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target: The target for the route.
        :param description: A brief description of the authorization rule. Default: - no description

        :exampleMetadata: fixture=client-vpn infused

        Example::

            endpoint = vpc.add_client_vpn_endpoint("Endpoint",
                cidr="10.100.0.0/16",
                server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
                user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider)
            )
            
            # Client-to-client access
            endpoint.add_route("Route",
                cidr="10.100.0.0/16",
                target=ec2.ClientVpnRouteTarget.local()
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
            "target": target,
        }
        if description is not None:
            self._values["description"] = description

    @builtins.property
    def cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the route destination.

        For example:

        - To add a route for Internet access, enter 0.0.0.0/0
        - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
        - To add a route for an on-premises network, enter the AWS Site-to-Site VPN
          connection's IPv4 CIDR range
        - To add a route for the local network, enter the client CIDR range
        '''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> "ClientVpnRouteTarget":
        '''The target for the route.'''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast("ClientVpnRouteTarget", result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :default: - no description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnRouteOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnRouteProps",
    jsii_struct_bases=[ClientVpnRouteOptions],
    name_mapping={
        "cidr": "cidr",
        "target": "target",
        "description": "description",
        "client_vpn_endpoint": "clientVpnEndpoint",
    },
)
class ClientVpnRouteProps(ClientVpnRouteOptions):
    def __init__(
        self,
        *,
        cidr: builtins.str,
        target: "ClientVpnRouteTarget",
        description: typing.Optional[builtins.str] = None,
        client_vpn_endpoint: typing.Optional["IClientVpnEndpoint"] = None,
    ) -> None:
        '''Properties for a ClientVpnRoute.

        :param cidr: The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target: The target for the route.
        :param description: A brief description of the authorization rule. Default: - no description
        :param client_vpn_endpoint: The client VPN endpoint to which to add the route. Default: clientVpnEndpoint is required

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # client_vpn_endpoint: ec2.ClientVpnEndpoint
            # client_vpn_route_target: ec2.ClientVpnRouteTarget
            
            client_vpn_route_props = ec2.ClientVpnRouteProps(
                cidr="cidr",
                target=client_vpn_route_target,
            
                # the properties below are optional
                client_vpn_endpoint=client_vpn_endpoint,
                description="description"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
            "target": target,
        }
        if description is not None:
            self._values["description"] = description
        if client_vpn_endpoint is not None:
            self._values["client_vpn_endpoint"] = client_vpn_endpoint

    @builtins.property
    def cidr(self) -> builtins.str:
        '''The IPv4 address range, in CIDR notation, of the route destination.

        For example:

        - To add a route for Internet access, enter 0.0.0.0/0
        - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range
        - To add a route for an on-premises network, enter the AWS Site-to-Site VPN
          connection's IPv4 CIDR range
        - To add a route for the local network, enter the client CIDR range
        '''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target(self) -> "ClientVpnRouteTarget":
        '''The target for the route.'''
        result = self._values.get("target")
        assert result is not None, "Required property 'target' is missing"
        return typing.cast("ClientVpnRouteTarget", result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A brief description of the authorization rule.

        :default: - no description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def client_vpn_endpoint(self) -> typing.Optional["IClientVpnEndpoint"]:
        '''The client VPN endpoint to which to add the route.

        :default: clientVpnEndpoint is required
        '''
        result = self._values.get("client_vpn_endpoint")
        return typing.cast(typing.Optional["IClientVpnEndpoint"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ClientVpnRouteProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ClientVpnRouteTarget(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnRouteTarget",
):
    '''Target for a client VPN route.

    :exampleMetadata: fixture=client-vpn infused

    Example::

        endpoint = vpc.add_client_vpn_endpoint("Endpoint",
            cidr="10.100.0.0/16",
            server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
            user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider)
        )
        
        # Client-to-client access
        endpoint.add_route("Route",
            cidr="10.100.0.0/16",
            target=ec2.ClientVpnRouteTarget.local()
        )
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="local") # type: ignore[misc]
    @builtins.classmethod
    def local(cls) -> "ClientVpnRouteTarget":
        '''Local network.'''
        return typing.cast("ClientVpnRouteTarget", jsii.sinvoke(cls, "local", []))

    @jsii.member(jsii_name="subnet") # type: ignore[misc]
    @builtins.classmethod
    def subnet(cls, subnet: "ISubnet") -> "ClientVpnRouteTarget":
        '''Subnet.

        The specified subnet must be an existing target network of the client VPN
        endpoint.

        :param subnet: -
        '''
        return typing.cast("ClientVpnRouteTarget", jsii.sinvoke(cls, "subnet", [subnet]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    @abc.abstractmethod
    def subnet_id(self) -> builtins.str:
        '''The subnet ID.'''
        ...


class _ClientVpnRouteTargetProxy(ClientVpnRouteTarget):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The subnet ID.'''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, ClientVpnRouteTarget).__jsii_proxy_class__ = lambda : _ClientVpnRouteTargetProxy


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.ClientVpnSessionTimeout")
class ClientVpnSessionTimeout(enum.Enum):
    '''Maximum VPN session duration time.'''

    EIGHT_HOURS = "EIGHT_HOURS"
    '''8 hours.'''
    TEN_HOURS = "TEN_HOURS"
    '''10 hours.'''
    TWELVE_HOURS = "TWELVE_HOURS"
    '''12 hours.'''
    TWENTY_FOUR_HOURS = "TWENTY_FOUR_HOURS"
    '''24 hours.'''


class ClientVpnUserBasedAuthentication(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnUserBasedAuthentication",
):
    '''User-based authentication for a client VPN endpoint.

    :exampleMetadata: fixture=client-vpn infused

    Example::

        endpoint = vpc.add_client_vpn_endpoint("Endpoint",
            cidr="10.100.0.0/16",
            server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
            user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),
            authorize_all_users_to_vpc_cidr=False
        )
        
        endpoint.add_authorization_rule("Rule",
            cidr="10.0.10.0/32",
            group_id="group-id"
        )
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="activeDirectory") # type: ignore[misc]
    @builtins.classmethod
    def active_directory(
        cls,
        directory_id: builtins.str,
    ) -> "ClientVpnUserBasedAuthentication":
        '''Active Directory authentication.

        :param directory_id: -
        '''
        return typing.cast("ClientVpnUserBasedAuthentication", jsii.sinvoke(cls, "activeDirectory", [directory_id]))

    @jsii.member(jsii_name="federated") # type: ignore[misc]
    @builtins.classmethod
    def federated(
        cls,
        saml_provider: _ISamlProvider_63f03582,
        self_service_saml_provider: typing.Optional[_ISamlProvider_63f03582] = None,
    ) -> "ClientVpnUserBasedAuthentication":
        '''Federated authentication.

        :param saml_provider: -
        :param self_service_saml_provider: -
        '''
        return typing.cast("ClientVpnUserBasedAuthentication", jsii.sinvoke(cls, "federated", [saml_provider, self_service_saml_provider]))

    @jsii.member(jsii_name="render") # type: ignore[misc]
    @abc.abstractmethod
    def render(self) -> typing.Any:
        '''Renders the user based authentication.'''
        ...


class _ClientVpnUserBasedAuthenticationProxy(ClientVpnUserBasedAuthentication):
    @jsii.member(jsii_name="render")
    def render(self) -> typing.Any:
        '''Renders the user based authentication.'''
        return typing.cast(typing.Any, jsii.invoke(self, "render", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, ClientVpnUserBasedAuthentication).__jsii_proxy_class__ = lambda : _ClientVpnUserBasedAuthenticationProxy


class CloudFormationInit(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.CloudFormationInit",
):
    '''A CloudFormation-init configuration.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # my_bucket: s3.Bucket
        
        
        handle = ec2.InitServiceRestartHandle()
        
        ec2.CloudFormationInit.from_elements(
            ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
            ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
            ec2.InitService.enable("nginx",
                service_restart_handle=handle
            ))
    '''

    @jsii.member(jsii_name="fromConfig") # type: ignore[misc]
    @builtins.classmethod
    def from_config(cls, config: "InitConfig") -> "CloudFormationInit":
        '''Use an existing InitConfig object as the default and only config.

        :param config: -
        '''
        return typing.cast("CloudFormationInit", jsii.sinvoke(cls, "fromConfig", [config]))

    @jsii.member(jsii_name="fromConfigSets") # type: ignore[misc]
    @builtins.classmethod
    def from_config_sets(
        cls,
        *,
        configs: typing.Mapping[builtins.str, "InitConfig"],
        config_sets: typing.Mapping[builtins.str, typing.Sequence[builtins.str]],
    ) -> "CloudFormationInit":
        '''Build a CloudFormationInit from config sets.

        :param configs: The sets of configs to pick from.
        :param config_sets: The definitions of each config set.
        '''
        props = ConfigSetProps(configs=configs, config_sets=config_sets)

        return typing.cast("CloudFormationInit", jsii.sinvoke(cls, "fromConfigSets", [props]))

    @jsii.member(jsii_name="fromElements") # type: ignore[misc]
    @builtins.classmethod
    def from_elements(cls, *elements: "InitElement") -> "CloudFormationInit":
        '''Build a new config from a set of Init Elements.

        :param elements: -
        '''
        return typing.cast("CloudFormationInit", jsii.sinvoke(cls, "fromElements", [*elements]))

    @jsii.member(jsii_name="addConfig")
    def add_config(self, config_name: builtins.str, config: "InitConfig") -> None:
        '''Add a config with the given name to this CloudFormationInit object.

        :param config_name: -
        :param config: -
        '''
        return typing.cast(None, jsii.invoke(self, "addConfig", [config_name, config]))

    @jsii.member(jsii_name="addConfigSet")
    def add_config_set(
        self,
        config_set_name: builtins.str,
        config_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Add a config set with the given name to this CloudFormationInit object.

        The new configset will reference the given configs in the given order.

        :param config_set_name: -
        :param config_names: -
        '''
        return typing.cast(None, jsii.invoke(self, "addConfigSet", [config_set_name, config_names]))

    @jsii.member(jsii_name="attach")
    def attach(
        self,
        attached_resource: _CfnResource_9df397a6,
        *,
        instance_role: _IRole_235f5d8e,
        platform: "OperatingSystemType",
        user_data: "UserData",
        config_sets: typing.Optional[typing.Sequence[builtins.str]] = None,
        embed_fingerprint: typing.Optional[builtins.bool] = None,
        ignore_failures: typing.Optional[builtins.bool] = None,
        include_role: typing.Optional[builtins.bool] = None,
        include_url: typing.Optional[builtins.bool] = None,
        print_log: typing.Optional[builtins.bool] = None,
        signal_resource: typing.Optional[_CfnResource_9df397a6] = None,
    ) -> None:
        '''Attach the CloudFormation Init config to the given resource.

        As an app builder, use ``instance.applyCloudFormationInit()`` or
        ``autoScalingGroup.applyCloudFormationInit()`` to trigger this method.

        This method does the following:

        - Renders the ``AWS::CloudFormation::Init`` object to the given resource's
          metadata, potentially adding a ``AWS::CloudFormation::Authentication`` object
          next to it if required.
        - Updates the instance role policy to be able to call the APIs required for
          ``cfn-init`` and ``cfn-signal`` to work, and potentially add permissions to download
          referenced asset and bucket resources.
        - Updates the given UserData with commands to execute the ``cfn-init`` script.

        :param attached_resource: -
        :param instance_role: Instance role of the consuming instance or fleet.
        :param platform: OS Platform the init config will be used for.
        :param user_data: UserData to add commands to.
        :param config_sets: ConfigSet to activate. Default: ['default']
        :param embed_fingerprint: Whether to embed a hash into the userData. If ``true`` (the default), a hash of the config will be embedded into the UserData, so that if the config changes, the UserData changes and the instance will be replaced. If ``false``, no such hash will be embedded, and if the CloudFormation Init config changes nothing will happen to the running instance. Default: true
        :param ignore_failures: Don't fail the instance creation when cfn-init fails. You can use this to prevent CloudFormation from rolling back when instances fail to start up, to help in debugging. Default: false
        :param include_role: Include --role argument when running cfn-init and cfn-signal commands. This will be the IAM instance profile attached to the EC2 instance Default: false
        :param include_url: Include --url argument when running cfn-init and cfn-signal commands. This will be the cloudformation endpoint in the deployed region e.g. https://cloudformation.us-east-1.amazonaws.com Default: false
        :param print_log: Print the results of running cfn-init to the Instance System Log. By default, the output of running cfn-init is written to a log file on the instance. Set this to ``true`` to print it to the System Log (visible from the EC2 Console), ``false`` to not print it. (Be aware that the system log is refreshed at certain points in time of the instance life cycle, and successful execution may not always show up). Default: true
        :param signal_resource: When provided, signals this resource instead of the attached resource. You can use this to support signaling LaunchTemplate while attaching AutoScalingGroup Default: - if this property is undefined cfn-signal signals the attached resource
        '''
        attach_options = AttachInitOptions(
            instance_role=instance_role,
            platform=platform,
            user_data=user_data,
            config_sets=config_sets,
            embed_fingerprint=embed_fingerprint,
            ignore_failures=ignore_failures,
            include_role=include_role,
            include_url=include_url,
            print_log=print_log,
            signal_resource=signal_resource,
        )

        return typing.cast(None, jsii.invoke(self, "attach", [attached_resource, attach_options]))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.CommonNetworkAclEntryOptions",
    jsii_struct_bases=[],
    name_mapping={
        "cidr": "cidr",
        "rule_number": "ruleNumber",
        "traffic": "traffic",
        "direction": "direction",
        "network_acl_entry_name": "networkAclEntryName",
        "rule_action": "ruleAction",
    },
)
class CommonNetworkAclEntryOptions:
    def __init__(
        self,
        *,
        cidr: AclCidr,
        rule_number: jsii.Number,
        traffic: AclTraffic,
        direction: typing.Optional["TrafficDirection"] = None,
        network_acl_entry_name: typing.Optional[builtins.str] = None,
        rule_action: typing.Optional[Action] = None,
    ) -> None:
        '''Basic NetworkACL entry props.

        :param cidr: The CIDR range to allow or deny.
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param traffic: What kind of traffic this ACL rule applies to.
        :param direction: Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS
        :param network_acl_entry_name: The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # acl_cidr: ec2.AclCidr
            # acl_traffic: ec2.AclTraffic
            
            common_network_acl_entry_options = ec2.CommonNetworkAclEntryOptions(
                cidr=acl_cidr,
                rule_number=123,
                traffic=acl_traffic,
            
                # the properties below are optional
                direction=ec2.TrafficDirection.EGRESS,
                network_acl_entry_name="networkAclEntryName",
                rule_action=ec2.Action.ALLOW
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
            "rule_number": rule_number,
            "traffic": traffic,
        }
        if direction is not None:
            self._values["direction"] = direction
        if network_acl_entry_name is not None:
            self._values["network_acl_entry_name"] = network_acl_entry_name
        if rule_action is not None:
            self._values["rule_action"] = rule_action

    @builtins.property
    def cidr(self) -> AclCidr:
        '''The CIDR range to allow or deny.'''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(AclCidr, result)

    @builtins.property
    def rule_number(self) -> jsii.Number:
        '''Rule number to assign to the entry, such as 100.

        ACL entries are processed in ascending order by rule number.
        Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        '''
        result = self._values.get("rule_number")
        assert result is not None, "Required property 'rule_number' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def traffic(self) -> AclTraffic:
        '''What kind of traffic this ACL rule applies to.'''
        result = self._values.get("traffic")
        assert result is not None, "Required property 'traffic' is missing"
        return typing.cast(AclTraffic, result)

    @builtins.property
    def direction(self) -> typing.Optional["TrafficDirection"]:
        '''Traffic direction, with respect to the subnet, this rule applies to.

        :default: TrafficDirection.INGRESS
        '''
        result = self._values.get("direction")
        return typing.cast(typing.Optional["TrafficDirection"], result)

    @builtins.property
    def network_acl_entry_name(self) -> typing.Optional[builtins.str]:
        '''The name of the NetworkAclEntry.

        It is not recommended to use an explicit group name.

        :default:

        If you don't specify a NetworkAclName, AWS CloudFormation generates a
        unique physical ID and uses that ID for the group name.
        '''
        result = self._values.get("network_acl_entry_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rule_action(self) -> typing.Optional[Action]:
        '''Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".

        Any traffic that is not explicitly allowed is automatically denied in a custom
        ACL, all traffic is automatically allowed in a default ACL.

        :default: ALLOW
        '''
        result = self._values.get("rule_action")
        return typing.cast(typing.Optional[Action], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CommonNetworkAclEntryOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ConfigSetProps",
    jsii_struct_bases=[],
    name_mapping={"configs": "configs", "config_sets": "configSets"},
)
class ConfigSetProps:
    def __init__(
        self,
        *,
        configs: typing.Mapping[builtins.str, "InitConfig"],
        config_sets: typing.Mapping[builtins.str, typing.Sequence[builtins.str]],
    ) -> None:
        '''Options for CloudFormationInit.withConfigSets.

        :param configs: The sets of configs to pick from.
        :param config_sets: The definitions of each config set.

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            # instance_type: ec2.InstanceType
            # machine_image: ec2.IMachineImage
            
            
            ec2.Instance(self, "Instance",
                vpc=vpc,
                instance_type=instance_type,
                machine_image=machine_image,
            
                # Showing the most complex setup, if you have simpler requirements
                # you can use `CloudFormationInit.fromElements()`.
                init=ec2.CloudFormationInit.from_config_sets(
                    config_sets={
                        # Applies the configs below in this order
                        "default": ["yumPreinstall", "config"]
                    },
                    configs={
                        "yum_preinstall": ec2.InitConfig([
                            # Install an Amazon Linux package using yum
                            ec2.InitPackage.yum("git")
                        ]),
                        "config": ec2.InitConfig([
                            # Create a JSON file from tokens (can also create other files)
                            ec2.InitFile.from_object("/etc/stack.json", {
                                "stack_id": Stack.of(self).stack_id,
                                "stack_name": Stack.of(self).stack_name,
                                "region": Stack.of(self).region
                            }),
            
                            # Create a group and user
                            ec2.InitGroup.from_name("my-group"),
                            ec2.InitUser.from_name("my-user"),
            
                            # Install an RPM from the internet
                            ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
                        ])
                    }
                ),
                init_options=ec2.ApplyCloudFormationInitOptions(
                    # Optional, which configsets to activate (['default'] by default)
                    config_sets=["default"],
            
                    # Optional, how long the installation is expected to take (5 minutes by default)
                    timeout=Duration.minutes(30),
            
                    # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
                    include_url=True,
            
                    # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
                    include_role=True
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "configs": configs,
            "config_sets": config_sets,
        }

    @builtins.property
    def configs(self) -> typing.Mapping[builtins.str, "InitConfig"]:
        '''The sets of configs to pick from.'''
        result = self._values.get("configs")
        assert result is not None, "Required property 'configs' is missing"
        return typing.cast(typing.Mapping[builtins.str, "InitConfig"], result)

    @builtins.property
    def config_sets(self) -> typing.Mapping[builtins.str, typing.List[builtins.str]]:
        '''The definitions of each config set.'''
        result = self._values.get("config_sets")
        assert result is not None, "Required property 'config_sets' is missing"
        return typing.cast(typing.Mapping[builtins.str, typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConfigSetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ConfigureNatOptions",
    jsii_struct_bases=[],
    name_mapping={
        "nat_subnets": "natSubnets",
        "private_subnets": "privateSubnets",
        "vpc": "vpc",
    },
)
class ConfigureNatOptions:
    def __init__(
        self,
        *,
        nat_subnets: typing.Sequence["PublicSubnet"],
        private_subnets: typing.Sequence["PrivateSubnet"],
        vpc: "Vpc",
    ) -> None:
        '''Options passed by the VPC when NAT needs to be configured.

        :param nat_subnets: The public subnets where the NAT providers need to be placed.
        :param private_subnets: The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.
        :param vpc: The VPC we're configuring NAT for.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # private_subnet: ec2.PrivateSubnet
            # public_subnet: ec2.PublicSubnet
            # vpc: ec2.Vpc
            
            configure_nat_options = ec2.ConfigureNatOptions(
                nat_subnets=[public_subnet],
                private_subnets=[private_subnet],
                vpc=vpc
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "nat_subnets": nat_subnets,
            "private_subnets": private_subnets,
            "vpc": vpc,
        }

    @builtins.property
    def nat_subnets(self) -> typing.List["PublicSubnet"]:
        '''The public subnets where the NAT providers need to be placed.'''
        result = self._values.get("nat_subnets")
        assert result is not None, "Required property 'nat_subnets' is missing"
        return typing.cast(typing.List["PublicSubnet"], result)

    @builtins.property
    def private_subnets(self) -> typing.List["PrivateSubnet"]:
        '''The private subnets that need to route through the NAT providers.

        There may be more private subnets than public subnets with NAT providers.
        '''
        result = self._values.get("private_subnets")
        assert result is not None, "Required property 'private_subnets' is missing"
        return typing.cast(typing.List["PrivateSubnet"], result)

    @builtins.property
    def vpc(self) -> "Vpc":
        '''The VPC we're configuring NAT for.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast("Vpc", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConfigureNatOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ConnectionRule",
    jsii_struct_bases=[],
    name_mapping={
        "from_port": "fromPort",
        "description": "description",
        "protocol": "protocol",
        "to_port": "toPort",
    },
)
class ConnectionRule:
    def __init__(
        self,
        *,
        from_port: jsii.Number,
        description: typing.Optional[builtins.str] = None,
        protocol: typing.Optional[builtins.str] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param from_port: Start of port range for the TCP and UDP protocols, or an ICMP type number. If you specify icmp for the IpProtocol property, you can specify -1 as a wildcard (i.e., any ICMP type number).
        :param description: Description of this connection. It is applied to both the ingress rule and the egress rule. Default: No description
        :param protocol: The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers). Use -1 to specify all protocols. If you specify -1, or a protocol number other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For tcp, udp, and icmp, you must specify a port range. For protocol 58 (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed. Default: tcp
        :param to_port: End of port range for the TCP and UDP protocols, or an ICMP code. If you specify icmp for the IpProtocol property, you can specify -1 as a wildcard (i.e., any ICMP code). Default: If toPort is not specified, it will be the same as fromPort.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            connection_rule = ec2.ConnectionRule(
                from_port=123,
            
                # the properties below are optional
                description="description",
                protocol="protocol",
                to_port=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "from_port": from_port,
        }
        if description is not None:
            self._values["description"] = description
        if protocol is not None:
            self._values["protocol"] = protocol
        if to_port is not None:
            self._values["to_port"] = to_port

    @builtins.property
    def from_port(self) -> jsii.Number:
        '''Start of port range for the TCP and UDP protocols, or an ICMP type number.

        If you specify icmp for the IpProtocol property, you can specify
        -1 as a wildcard (i.e., any ICMP type number).
        '''
        result = self._values.get("from_port")
        assert result is not None, "Required property 'from_port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''Description of this connection.

        It is applied to both the ingress rule
        and the egress rule.

        :default: No description
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def protocol(self) -> typing.Optional[builtins.str]:
        '''The IP protocol name (tcp, udp, icmp) or number (see Protocol Numbers).

        Use -1 to specify all protocols. If you specify -1, or a protocol number
        other than tcp, udp, icmp, or 58 (ICMPv6), traffic on all ports is
        allowed, regardless of any ports you specify. For tcp, udp, and icmp, you
        must specify a port range. For protocol 58 (ICMPv6), you can optionally
        specify a port range; if you don't, traffic for all types and codes is
        allowed.

        :default: tcp
        '''
        result = self._values.get("protocol")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''End of port range for the TCP and UDP protocols, or an ICMP code.

        If you specify icmp for the IpProtocol property, you can specify -1 as a
        wildcard (i.e., any ICMP code).

        :default: If toPort is not specified, it will be the same as fromPort.
        '''
        result = self._values.get("to_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConnectionRule(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ConnectionsProps",
    jsii_struct_bases=[],
    name_mapping={
        "default_port": "defaultPort",
        "peer": "peer",
        "security_groups": "securityGroups",
    },
)
class ConnectionsProps:
    def __init__(
        self,
        *,
        default_port: typing.Optional["Port"] = None,
        peer: typing.Optional["IPeer"] = None,
        security_groups: typing.Optional[typing.Sequence["ISecurityGroup"]] = None,
    ) -> None:
        '''Properties to intialize a new Connections object.

        :param default_port: Default port range for initiating connections to and from this object. Default: - No default port
        :param peer: Class that represents the rule by which others can connect to this connectable. This object is required, but will be derived from securityGroup if that is passed. Default: Derived from securityGroup if set.
        :param security_groups: What securityGroup(s) this object is managing connections for. Default: No security groups

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # peer: ec2.IPeer
            # port: ec2.Port
            # security_group: ec2.SecurityGroup
            
            connections_props = ec2.ConnectionsProps(
                default_port=port,
                peer=peer,
                security_groups=[security_group]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if default_port is not None:
            self._values["default_port"] = default_port
        if peer is not None:
            self._values["peer"] = peer
        if security_groups is not None:
            self._values["security_groups"] = security_groups

    @builtins.property
    def default_port(self) -> typing.Optional["Port"]:
        '''Default port range for initiating connections to and from this object.

        :default: - No default port
        '''
        result = self._values.get("default_port")
        return typing.cast(typing.Optional["Port"], result)

    @builtins.property
    def peer(self) -> typing.Optional["IPeer"]:
        '''Class that represents the rule by which others can connect to this connectable.

        This object is required, but will be derived from securityGroup if that is passed.

        :default: Derived from securityGroup if set.
        '''
        result = self._values.get("peer")
        return typing.cast(typing.Optional["IPeer"], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List["ISecurityGroup"]]:
        '''What securityGroup(s) this object is managing connections for.

        :default: No security groups
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List["ISecurityGroup"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConnectionsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.CpuCredits")
class CpuCredits(enum.Enum):
    '''Provides the options for specifying the CPU credit type for burstable EC2 instance types (T2, T3, T3a, etc).

    :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-how-to.html
    '''

    STANDARD = "STANDARD"
    '''Standard bursting mode.

    :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-standard-mode.html
    '''
    UNLIMITED = "UNLIMITED"
    '''Unlimited bursting mode.

    :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode.html
    '''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.DefaultInstanceTenancy")
class DefaultInstanceTenancy(enum.Enum):
    '''The default tenancy of instances launched into the VPC.'''

    DEFAULT = "DEFAULT"
    '''Instances can be launched with any tenancy.'''
    DEDICATED = "DEDICATED"
    '''Any instance launched into the VPC automatically has dedicated tenancy, unless you launch it with the default tenancy.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.EbsDeviceOptionsBase",
    jsii_struct_bases=[],
    name_mapping={
        "delete_on_termination": "deleteOnTermination",
        "iops": "iops",
        "volume_type": "volumeType",
    },
)
class EbsDeviceOptionsBase:
    def __init__(
        self,
        *,
        delete_on_termination: typing.Optional[builtins.bool] = None,
        iops: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional["EbsDeviceVolumeType"] = None,
    ) -> None:
        '''Base block device options for an EBS volume.

        :param delete_on_termination: Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1} The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for {@link EbsDeviceVolumeType.IO1}
        :param volume_type: The EBS volume type. Default: {@link EbsDeviceVolumeType.GP2}

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            ebs_device_options_base = ec2.EbsDeviceOptionsBase(
                delete_on_termination=False,
                iops=123,
                volume_type=ec2.EbsDeviceVolumeType.STANDARD
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if delete_on_termination is not None:
            self._values["delete_on_termination"] = delete_on_termination
        if iops is not None:
            self._values["iops"] = iops
        if volume_type is not None:
            self._values["volume_type"] = volume_type

    @builtins.property
    def delete_on_termination(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether to delete the volume when the instance is terminated.

        :default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        '''
        result = self._values.get("delete_on_termination")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) to provision for the volume.

        Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1}

        The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS,
        you need at least 100 GiB storage on the volume.

        :default: - none, required for {@link EbsDeviceVolumeType.IO1}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_type(self) -> typing.Optional["EbsDeviceVolumeType"]:
        '''The EBS volume type.

        :default: {@link EbsDeviceVolumeType.GP2}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional["EbsDeviceVolumeType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EbsDeviceOptionsBase(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.EbsDeviceSnapshotOptions",
    jsii_struct_bases=[EbsDeviceOptionsBase],
    name_mapping={
        "delete_on_termination": "deleteOnTermination",
        "iops": "iops",
        "volume_type": "volumeType",
        "volume_size": "volumeSize",
    },
)
class EbsDeviceSnapshotOptions(EbsDeviceOptionsBase):
    def __init__(
        self,
        *,
        delete_on_termination: typing.Optional[builtins.bool] = None,
        iops: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional["EbsDeviceVolumeType"] = None,
        volume_size: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Block device options for an EBS volume created from a snapshot.

        :param delete_on_termination: Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1} The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for {@link EbsDeviceVolumeType.IO1}
        :param volume_type: The EBS volume type. Default: {@link EbsDeviceVolumeType.GP2}
        :param volume_size: The volume size, in Gibibytes (GiB). If you specify volumeSize, it must be equal or greater than the size of the snapshot. Default: - The snapshot size

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            ebs_device_snapshot_options = ec2.EbsDeviceSnapshotOptions(
                delete_on_termination=False,
                iops=123,
                volume_size=123,
                volume_type=ec2.EbsDeviceVolumeType.STANDARD
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if delete_on_termination is not None:
            self._values["delete_on_termination"] = delete_on_termination
        if iops is not None:
            self._values["iops"] = iops
        if volume_type is not None:
            self._values["volume_type"] = volume_type
        if volume_size is not None:
            self._values["volume_size"] = volume_size

    @builtins.property
    def delete_on_termination(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether to delete the volume when the instance is terminated.

        :default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        '''
        result = self._values.get("delete_on_termination")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) to provision for the volume.

        Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1}

        The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS,
        you need at least 100 GiB storage on the volume.

        :default: - none, required for {@link EbsDeviceVolumeType.IO1}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_type(self) -> typing.Optional["EbsDeviceVolumeType"]:
        '''The EBS volume type.

        :default: {@link EbsDeviceVolumeType.GP2}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional["EbsDeviceVolumeType"], result)

    @builtins.property
    def volume_size(self) -> typing.Optional[jsii.Number]:
        '''The volume size, in Gibibytes (GiB).

        If you specify volumeSize, it must be equal or greater than the size of the snapshot.

        :default: - The snapshot size
        '''
        result = self._values.get("volume_size")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EbsDeviceSnapshotOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.EbsDeviceVolumeType")
class EbsDeviceVolumeType(enum.Enum):
    '''Supported EBS volume types for blockDevices.

    :exampleMetadata: infused

    Example::

        domain = es.Domain(self, "Domain",
            version=es.ElasticsearchVersion.V7_4,
            ebs=es.EbsOptions(
                volume_size=100,
                volume_type=ec2.EbsDeviceVolumeType.GENERAL_PURPOSE_SSD
            ),
            node_to_node_encryption=True,
            encryption_at_rest=es.EncryptionAtRestOptions(
                enabled=True
            )
        )
    '''

    STANDARD = "STANDARD"
    '''Magnetic.'''
    IO1 = "IO1"
    '''Provisioned IOPS SSD - IO1.'''
    IO2 = "IO2"
    '''Provisioned IOPS SSD - IO2.'''
    GP2 = "GP2"
    '''General Purpose SSD - GP2.'''
    GP3 = "GP3"
    '''General Purpose SSD - GP3.'''
    ST1 = "ST1"
    '''Throughput Optimized HDD.'''
    SC1 = "SC1"
    '''Cold HDD.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.ExecuteFileOptions",
    jsii_struct_bases=[],
    name_mapping={"file_path": "filePath", "arguments": "arguments"},
)
class ExecuteFileOptions:
    def __init__(
        self,
        *,
        file_path: builtins.str,
        arguments: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options when executing a file.

        :param file_path: The path to the file.
        :param arguments: The arguments to be passed to the file. Default: No arguments are passed to the file.

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            from aws_cdk.aws_s3_assets import Asset
            
            # instance: ec2.Instance
            
            
            asset = Asset(self, "Asset",
                path="./configure.sh"
            )
            
            local_path = instance.user_data.add_s3_download_command(
                bucket=asset.bucket,
                bucket_key=asset.s3_object_key,
                region="us-east-1"
            )
            instance.user_data.add_execute_file_command(
                file_path=local_path,
                arguments="--verbose -y"
            )
            asset.grant_read(instance.role)
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "file_path": file_path,
        }
        if arguments is not None:
            self._values["arguments"] = arguments

    @builtins.property
    def file_path(self) -> builtins.str:
        '''The path to the file.'''
        result = self._values.get("file_path")
        assert result is not None, "Required property 'file_path' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def arguments(self) -> typing.Optional[builtins.str]:
        '''The arguments to be passed to the file.

        :default: No arguments are passed to the file.
        '''
        result = self._values.get("arguments")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ExecuteFileOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FlowLogDestination(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.FlowLogDestination",
):
    '''The destination type for the flow log.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        log_group = logs.LogGroup(self, "MyCustomLogGroup")
        
        role = iam.Role(self, "MyCustomRole",
            assumed_by=iam.ServicePrincipal("vpc-flow-logs.amazonaws.com")
        )
        
        ec2.FlowLog(self, "FlowLog",
            resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
            destination=ec2.FlowLogDestination.to_cloud_watch_logs(log_group, role)
        )
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="toCloudWatchLogs") # type: ignore[misc]
    @builtins.classmethod
    def to_cloud_watch_logs(
        cls,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        iam_role: typing.Optional[_IRole_235f5d8e] = None,
    ) -> "FlowLogDestination":
        '''Use CloudWatch logs as the destination.

        :param log_group: -
        :param iam_role: -
        '''
        return typing.cast("FlowLogDestination", jsii.sinvoke(cls, "toCloudWatchLogs", [log_group, iam_role]))

    @jsii.member(jsii_name="toS3") # type: ignore[misc]
    @builtins.classmethod
    def to_s3(
        cls,
        bucket: typing.Optional[_IBucket_42e086fd] = None,
        key_prefix: typing.Optional[builtins.str] = None,
    ) -> "FlowLogDestination":
        '''Use S3 as the destination.

        :param bucket: -
        :param key_prefix: -
        '''
        return typing.cast("FlowLogDestination", jsii.sinvoke(cls, "toS3", [bucket, key_prefix]))

    @jsii.member(jsii_name="bind") # type: ignore[misc]
    @abc.abstractmethod
    def bind(
        self,
        scope: constructs.Construct,
        flow_log: "FlowLog",
    ) -> "FlowLogDestinationConfig":
        '''Generates a flow log destination configuration.

        :param scope: -
        :param flow_log: -
        '''
        ...


class _FlowLogDestinationProxy(FlowLogDestination):
    @jsii.member(jsii_name="bind")
    def bind(
        self,
        scope: constructs.Construct,
        flow_log: "FlowLog",
    ) -> "FlowLogDestinationConfig":
        '''Generates a flow log destination configuration.

        :param scope: -
        :param flow_log: -
        '''
        return typing.cast("FlowLogDestinationConfig", jsii.invoke(self, "bind", [scope, flow_log]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, FlowLogDestination).__jsii_proxy_class__ = lambda : _FlowLogDestinationProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.FlowLogDestinationConfig",
    jsii_struct_bases=[],
    name_mapping={
        "log_destination_type": "logDestinationType",
        "iam_role": "iamRole",
        "key_prefix": "keyPrefix",
        "log_group": "logGroup",
        "s3_bucket": "s3Bucket",
    },
)
class FlowLogDestinationConfig:
    def __init__(
        self,
        *,
        log_destination_type: "FlowLogDestinationType",
        iam_role: typing.Optional[_IRole_235f5d8e] = None,
        key_prefix: typing.Optional[builtins.str] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        s3_bucket: typing.Optional[_IBucket_42e086fd] = None,
    ) -> None:
        '''Flow Log Destination configuration.

        :param log_destination_type: The type of destination to publish the flow logs to. Default: - CLOUD_WATCH_LOGS
        :param iam_role: The IAM Role that has access to publish to CloudWatch logs. Default: - default IAM role is created for you
        :param key_prefix: S3 bucket key prefix to publish the flow logs to. Default: - undefined
        :param log_group: The CloudWatch Logs Log Group to publish the flow logs to. Default: - default log group is created for you
        :param s3_bucket: S3 bucket to publish the flow logs to. Default: - undefined

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_iam as iam
            from aws_cdk import aws_logs as logs
            from aws_cdk import aws_s3 as s3
            
            # bucket: s3.Bucket
            # log_group: logs.LogGroup
            # role: iam.Role
            
            flow_log_destination_config = ec2.FlowLogDestinationConfig(
                log_destination_type=ec2.FlowLogDestinationType.CLOUD_WATCH_LOGS,
            
                # the properties below are optional
                iam_role=role,
                key_prefix="keyPrefix",
                log_group=log_group,
                s3_bucket=bucket
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "log_destination_type": log_destination_type,
        }
        if iam_role is not None:
            self._values["iam_role"] = iam_role
        if key_prefix is not None:
            self._values["key_prefix"] = key_prefix
        if log_group is not None:
            self._values["log_group"] = log_group
        if s3_bucket is not None:
            self._values["s3_bucket"] = s3_bucket

    @builtins.property
    def log_destination_type(self) -> "FlowLogDestinationType":
        '''The type of destination to publish the flow logs to.

        :default: - CLOUD_WATCH_LOGS
        '''
        result = self._values.get("log_destination_type")
        assert result is not None, "Required property 'log_destination_type' is missing"
        return typing.cast("FlowLogDestinationType", result)

    @builtins.property
    def iam_role(self) -> typing.Optional[_IRole_235f5d8e]:
        '''The IAM Role that has access to publish to CloudWatch logs.

        :default: - default IAM role is created for you
        '''
        result = self._values.get("iam_role")
        return typing.cast(typing.Optional[_IRole_235f5d8e], result)

    @builtins.property
    def key_prefix(self) -> typing.Optional[builtins.str]:
        '''S3 bucket key prefix to publish the flow logs to.

        :default: - undefined
        '''
        result = self._values.get("key_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_group(self) -> typing.Optional[_ILogGroup_3c4fa718]:
        '''The CloudWatch Logs Log Group to publish the flow logs to.

        :default: - default log group is created for you
        '''
        result = self._values.get("log_group")
        return typing.cast(typing.Optional[_ILogGroup_3c4fa718], result)

    @builtins.property
    def s3_bucket(self) -> typing.Optional[_IBucket_42e086fd]:
        '''S3 bucket to publish the flow logs to.

        :default: - undefined
        '''
        result = self._values.get("s3_bucket")
        return typing.cast(typing.Optional[_IBucket_42e086fd], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FlowLogDestinationConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.FlowLogDestinationType")
class FlowLogDestinationType(enum.Enum):
    '''The available destination types for Flow Logs.'''

    CLOUD_WATCH_LOGS = "CLOUD_WATCH_LOGS"
    '''Send flow logs to CloudWatch Logs Group.'''
    S3 = "S3"
    '''Send flow logs to S3 Bucket.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.FlowLogOptions",
    jsii_struct_bases=[],
    name_mapping={"destination": "destination", "traffic_type": "trafficType"},
)
class FlowLogOptions:
    def __init__(
        self,
        *,
        destination: typing.Optional[FlowLogDestination] = None,
        traffic_type: typing.Optional["FlowLogTrafficType"] = None,
    ) -> None:
        '''Options to add a flow log to a VPC.

        :param destination: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            vpc = ec2.Vpc(self, "Vpc")
            
            vpc.add_flow_log("FlowLogS3",
                destination=ec2.FlowLogDestination.to_s3()
            )
            
            vpc.add_flow_log("FlowLogCloudWatch",
                traffic_type=ec2.FlowLogTrafficType.REJECT
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if destination is not None:
            self._values["destination"] = destination
        if traffic_type is not None:
            self._values["traffic_type"] = traffic_type

    @builtins.property
    def destination(self) -> typing.Optional[FlowLogDestination]:
        '''Specifies the type of destination to which the flow log data is to be published.

        Flow log data can be published to CloudWatch Logs or Amazon S3

        :default: FlowLogDestinationType.toCloudWatchLogs()
        '''
        result = self._values.get("destination")
        return typing.cast(typing.Optional[FlowLogDestination], result)

    @builtins.property
    def traffic_type(self) -> typing.Optional["FlowLogTrafficType"]:
        '''The type of traffic to log.

        You can log traffic that the resource accepts or rejects, or all traffic.

        :default: ALL
        '''
        result = self._values.get("traffic_type")
        return typing.cast(typing.Optional["FlowLogTrafficType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FlowLogOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.FlowLogProps",
    jsii_struct_bases=[FlowLogOptions],
    name_mapping={
        "destination": "destination",
        "traffic_type": "trafficType",
        "resource_type": "resourceType",
        "flow_log_name": "flowLogName",
    },
)
class FlowLogProps(FlowLogOptions):
    def __init__(
        self,
        *,
        destination: typing.Optional[FlowLogDestination] = None,
        traffic_type: typing.Optional["FlowLogTrafficType"] = None,
        resource_type: "FlowLogResourceType",
        flow_log_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties of a VPC Flow Log.

        :param destination: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL
        :param resource_type: The type of resource for which to create the flow log.
        :param flow_log_name: The name of the FlowLog. It is not recommended to use an explicit name. Default: If you don't specify a flowLogName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            
            
            log_group = logs.LogGroup(self, "MyCustomLogGroup")
            
            role = iam.Role(self, "MyCustomRole",
                assumed_by=iam.ServicePrincipal("vpc-flow-logs.amazonaws.com")
            )
            
            ec2.FlowLog(self, "FlowLog",
                resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
                destination=ec2.FlowLogDestination.to_cloud_watch_logs(log_group, role)
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "resource_type": resource_type,
        }
        if destination is not None:
            self._values["destination"] = destination
        if traffic_type is not None:
            self._values["traffic_type"] = traffic_type
        if flow_log_name is not None:
            self._values["flow_log_name"] = flow_log_name

    @builtins.property
    def destination(self) -> typing.Optional[FlowLogDestination]:
        '''Specifies the type of destination to which the flow log data is to be published.

        Flow log data can be published to CloudWatch Logs or Amazon S3

        :default: FlowLogDestinationType.toCloudWatchLogs()
        '''
        result = self._values.get("destination")
        return typing.cast(typing.Optional[FlowLogDestination], result)

    @builtins.property
    def traffic_type(self) -> typing.Optional["FlowLogTrafficType"]:
        '''The type of traffic to log.

        You can log traffic that the resource accepts or rejects, or all traffic.

        :default: ALL
        '''
        result = self._values.get("traffic_type")
        return typing.cast(typing.Optional["FlowLogTrafficType"], result)

    @builtins.property
    def resource_type(self) -> "FlowLogResourceType":
        '''The type of resource for which to create the flow log.'''
        result = self._values.get("resource_type")
        assert result is not None, "Required property 'resource_type' is missing"
        return typing.cast("FlowLogResourceType", result)

    @builtins.property
    def flow_log_name(self) -> typing.Optional[builtins.str]:
        '''The name of the FlowLog.

        It is not recommended to use an explicit name.

        :default:

        If you don't specify a flowLogName, AWS CloudFormation generates a
        unique physical ID and uses that ID for the group name.
        '''
        result = self._values.get("flow_log_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FlowLogProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FlowLogResourceType(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.FlowLogResourceType",
):
    '''The type of resource to create the flow log for.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        log_group = logs.LogGroup(self, "MyCustomLogGroup")
        
        role = iam.Role(self, "MyCustomRole",
            assumed_by=iam.ServicePrincipal("vpc-flow-logs.amazonaws.com")
        )
        
        ec2.FlowLog(self, "FlowLog",
            resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
            destination=ec2.FlowLogDestination.to_cloud_watch_logs(log_group, role)
        )
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromNetworkInterfaceId") # type: ignore[misc]
    @builtins.classmethod
    def from_network_interface_id(cls, id: builtins.str) -> "FlowLogResourceType":
        '''The Network Interface to attach the Flow Log to.

        :param id: -
        '''
        return typing.cast("FlowLogResourceType", jsii.sinvoke(cls, "fromNetworkInterfaceId", [id]))

    @jsii.member(jsii_name="fromSubnet") # type: ignore[misc]
    @builtins.classmethod
    def from_subnet(cls, subnet: "ISubnet") -> "FlowLogResourceType":
        '''The subnet to attach the Flow Log to.

        :param subnet: -
        '''
        return typing.cast("FlowLogResourceType", jsii.sinvoke(cls, "fromSubnet", [subnet]))

    @jsii.member(jsii_name="fromVpc") # type: ignore[misc]
    @builtins.classmethod
    def from_vpc(cls, vpc: "IVpc") -> "FlowLogResourceType":
        '''The VPC to attach the Flow Log to.

        :param vpc: -
        '''
        return typing.cast("FlowLogResourceType", jsii.sinvoke(cls, "fromVpc", [vpc]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="resourceId")
    @abc.abstractmethod
    def resource_id(self) -> builtins.str:
        '''The Id of the resource that the flow log should be attached to.'''
        ...

    @resource_id.setter
    @abc.abstractmethod
    def resource_id(self, value: builtins.str) -> None:
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="resourceType")
    @abc.abstractmethod
    def resource_type(self) -> builtins.str:
        '''The type of resource to attach a flow log to.'''
        ...

    @resource_type.setter
    @abc.abstractmethod
    def resource_type(self, value: builtins.str) -> None:
        ...


class _FlowLogResourceTypeProxy(FlowLogResourceType):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="resourceId")
    def resource_id(self) -> builtins.str:
        '''The Id of the resource that the flow log should be attached to.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceId"))

    @resource_id.setter
    def resource_id(self, value: builtins.str) -> None:
        jsii.set(self, "resourceId", value)

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="resourceType")
    def resource_type(self) -> builtins.str:
        '''The type of resource to attach a flow log to.'''
        return typing.cast(builtins.str, jsii.get(self, "resourceType"))

    @resource_type.setter
    def resource_type(self, value: builtins.str) -> None:
        jsii.set(self, "resourceType", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, FlowLogResourceType).__jsii_proxy_class__ = lambda : _FlowLogResourceTypeProxy


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.FlowLogTrafficType")
class FlowLogTrafficType(enum.Enum):
    '''The type of VPC traffic to log.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        vpc = ec2.Vpc(self, "Vpc")
        
        vpc.add_flow_log("FlowLogS3",
            destination=ec2.FlowLogDestination.to_s3()
        )
        
        vpc.add_flow_log("FlowLogCloudWatch",
            traffic_type=ec2.FlowLogTrafficType.REJECT
        )
    '''

    ACCEPT = "ACCEPT"
    '''Only log accepts.'''
    ALL = "ALL"
    '''Log all requests.'''
    REJECT = "REJECT"
    '''Only log rejects.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.GatewayConfig",
    jsii_struct_bases=[],
    name_mapping={"az": "az", "gateway_id": "gatewayId"},
)
class GatewayConfig:
    def __init__(self, *, az: builtins.str, gateway_id: builtins.str) -> None:
        '''Pair represents a gateway created by NAT Provider.

        :param az: Availability Zone.
        :param gateway_id: Identity of gateway spawned by the provider.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            gateway_config = ec2.GatewayConfig(
                az="az",
                gateway_id="gatewayId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "az": az,
            "gateway_id": gateway_id,
        }

    @builtins.property
    def az(self) -> builtins.str:
        '''Availability Zone.'''
        result = self._values.get("az")
        assert result is not None, "Required property 'az' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def gateway_id(self) -> builtins.str:
        '''Identity of gateway spawned by the provider.'''
        result = self._values.get("gateway_id")
        assert result is not None, "Required property 'gateway_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GatewayConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.GatewayVpcEndpointOptions",
    jsii_struct_bases=[],
    name_mapping={"service": "service", "subnets": "subnets"},
)
class GatewayVpcEndpointOptions:
    def __init__(
        self,
        *,
        service: "IGatewayVpcEndpointService",
        subnets: typing.Optional[typing.Sequence["SubnetSelection"]] = None,
    ) -> None:
        '''Options to add a gateway endpoint to a VPC.

        :param service: The service to use for this gateway VPC endpoint.
        :param subnets: Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC

        :exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused

        Example::

            # Add gateway endpoints when creating the VPC
            vpc = ec2.Vpc(self, "MyVpc",
                gateway_endpoints={
                    "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(
                        service=ec2.GatewayVpcEndpointAwsService.S3
                    )
                }
            )
            
            # Alternatively gateway endpoints can be added on the VPC
            dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",
                service=ec2.GatewayVpcEndpointAwsService.DYNAMODB
            )
            
            # This allows to customize the endpoint policy
            dynamo_db_endpoint.add_to_policy(
                iam.PolicyStatement( # Restrict to listing and describing tables
                    principals=[iam.AnyPrincipal()],
                    actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],
                    resources=["*"]))
            
            # Add an interface endpoint
            vpc.add_interface_endpoint("EcrDockerEndpoint",
                service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "service": service,
        }
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def service(self) -> "IGatewayVpcEndpointService":
        '''The service to use for this gateway VPC endpoint.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("IGatewayVpcEndpointService", result)

    @builtins.property
    def subnets(self) -> typing.Optional[typing.List["SubnetSelection"]]:
        '''Where to add endpoint routing.

        By default, this endpoint will be routable from all subnets in the VPC.
        Specify a list of subnet selection objects here to be more specific.

        :default: - All subnets in the VPC

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            
            
            vpc.add_gateway_endpoint("DynamoDbEndpoint",
                service=ec2.GatewayVpcEndpointAwsService.DYNAMODB,
                # Add only to ISOLATED subnets
                subnets=[ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_ISOLATED)
                ]
            )
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[typing.List["SubnetSelection"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GatewayVpcEndpointOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.GatewayVpcEndpointProps",
    jsii_struct_bases=[GatewayVpcEndpointOptions],
    name_mapping={"service": "service", "subnets": "subnets", "vpc": "vpc"},
)
class GatewayVpcEndpointProps(GatewayVpcEndpointOptions):
    def __init__(
        self,
        *,
        service: "IGatewayVpcEndpointService",
        subnets: typing.Optional[typing.Sequence["SubnetSelection"]] = None,
        vpc: "IVpc",
    ) -> None:
        '''Construction properties for a GatewayVpcEndpoint.

        :param service: The service to use for this gateway VPC endpoint.
        :param subnets: Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC
        :param vpc: The VPC network in which the gateway endpoint will be used.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # gateway_vpc_endpoint_service: ec2.IGatewayVpcEndpointService
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # vpc: ec2.Vpc
            
            gateway_vpc_endpoint_props = ec2.GatewayVpcEndpointProps(
                service=gateway_vpc_endpoint_service,
                vpc=vpc,
            
                # the properties below are optional
                subnets=[ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "service": service,
            "vpc": vpc,
        }
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def service(self) -> "IGatewayVpcEndpointService":
        '''The service to use for this gateway VPC endpoint.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast("IGatewayVpcEndpointService", result)

    @builtins.property
    def subnets(self) -> typing.Optional[typing.List["SubnetSelection"]]:
        '''Where to add endpoint routing.

        By default, this endpoint will be routable from all subnets in the VPC.
        Specify a list of subnet selection objects here to be more specific.

        :default: - All subnets in the VPC

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            
            
            vpc.add_gateway_endpoint("DynamoDbEndpoint",
                service=ec2.GatewayVpcEndpointAwsService.DYNAMODB,
                # Add only to ISOLATED subnets
                subnets=[ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_ISOLATED)
                ]
            )
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[typing.List["SubnetSelection"]], result)

    @builtins.property
    def vpc(self) -> "IVpc":
        '''The VPC network in which the gateway endpoint will be used.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast("IVpc", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GatewayVpcEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.GenericLinuxImageProps",
    jsii_struct_bases=[],
    name_mapping={"user_data": "userData"},
)
class GenericLinuxImageProps:
    def __init__(self, *, user_data: typing.Optional["UserData"] = None) -> None:
        '''Configuration options for GenericLinuxImage.

        :param user_data: Initial user data. Default: - Empty UserData for Linux machines

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # user_data: ec2.UserData
            
            generic_linux_image_props = ec2.GenericLinuxImageProps(
                user_data=user_data
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if user_data is not None:
            self._values["user_data"] = user_data

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''Initial user data.

        :default: - Empty UserData for Linux machines
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GenericLinuxImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.GenericWindowsImageProps",
    jsii_struct_bases=[],
    name_mapping={"user_data": "userData"},
)
class GenericWindowsImageProps:
    def __init__(self, *, user_data: typing.Optional["UserData"] = None) -> None:
        '''Configuration options for GenericWindowsImage.

        :param user_data: Initial user data. Default: - Empty UserData for Windows machines

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # user_data: ec2.UserData
            
            generic_windows_image_props = ec2.GenericWindowsImageProps(
                user_data=user_data
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if user_data is not None:
            self._values["user_data"] = user_data

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''Initial user data.

        :default: - Empty UserData for Windows machines
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GenericWindowsImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IClientVpnConnectionHandler")
class IClientVpnConnectionHandler(typing_extensions.Protocol):
    '''A connection handler for client VPN endpoints.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="functionArn")
    def function_arn(self) -> builtins.str:
        '''The ARN of the function.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="functionName")
    def function_name(self) -> builtins.str:
        '''The name of the function.'''
        ...


class _IClientVpnConnectionHandlerProxy:
    '''A connection handler for client VPN endpoints.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IClientVpnConnectionHandler"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="functionArn")
    def function_arn(self) -> builtins.str:
        '''The ARN of the function.'''
        return typing.cast(builtins.str, jsii.get(self, "functionArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="functionName")
    def function_name(self) -> builtins.str:
        '''The name of the function.'''
        return typing.cast(builtins.str, jsii.get(self, "functionName"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IClientVpnConnectionHandler).__jsii_proxy_class__ = lambda : _IClientVpnConnectionHandlerProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IConnectable")
class IConnectable(typing_extensions.Protocol):
    '''An object that has a Connections object.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''The network connections associated with this resource.'''
        ...


class _IConnectableProxy:
    '''An object that has a Connections object.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IConnectable"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''The network connections associated with this resource.'''
        return typing.cast("Connections", jsii.get(self, "connections"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IConnectable).__jsii_proxy_class__ = lambda : _IConnectableProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IFlowLog")
class IFlowLog(_IResource_c80c4260, typing_extensions.Protocol):
    '''A FlowLog.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="flowLogId")
    def flow_log_id(self) -> builtins.str:
        '''The Id of the VPC Flow Log.

        :attribute: true
        '''
        ...


class _IFlowLogProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''A FlowLog.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IFlowLog"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="flowLogId")
    def flow_log_id(self) -> builtins.str:
        '''The Id of the VPC Flow Log.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "flowLogId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IFlowLog).__jsii_proxy_class__ = lambda : _IFlowLogProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IGatewayVpcEndpointService")
class IGatewayVpcEndpointService(typing_extensions.Protocol):
    '''A service for a gateway VPC endpoint.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        ...


class _IGatewayVpcEndpointServiceProxy:
    '''A service for a gateway VPC endpoint.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IGatewayVpcEndpointService"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IGatewayVpcEndpointService).__jsii_proxy_class__ = lambda : _IGatewayVpcEndpointServiceProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IInstance")
class IInstance(
    _IResource_c80c4260,
    IConnectable,
    _IGrantable_71c4f5de,
    typing_extensions.Protocol,
):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceAvailabilityZone")
    def instance_availability_zone(self) -> builtins.str:
        '''The availability zone the instance was launched in.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        '''The instance's ID.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateDnsName")
    def instance_private_dns_name(self) -> builtins.str:
        '''Private DNS name for this instance.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateIp")
    def instance_private_ip(self) -> builtins.str:
        '''Private IP for this instance.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicDnsName")
    def instance_public_dns_name(self) -> builtins.str:
        '''Publicly-routable DNS name for this instance.

        (May be an empty string if the instance does not have a public name).

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicIp")
    def instance_public_ip(self) -> builtins.str:
        '''Publicly-routable IP  address for this instance.

        (May be an empty string if the instance does not have a public IP).

        :attribute: true
        '''
        ...


class _IInstanceProxy(
    jsii.proxy_for(_IResource_c80c4260), # type: ignore[misc]
    jsii.proxy_for(IConnectable), # type: ignore[misc]
    jsii.proxy_for(_IGrantable_71c4f5de), # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IInstance"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceAvailabilityZone")
    def instance_availability_zone(self) -> builtins.str:
        '''The availability zone the instance was launched in.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        '''The instance's ID.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateDnsName")
    def instance_private_dns_name(self) -> builtins.str:
        '''Private DNS name for this instance.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePrivateDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateIp")
    def instance_private_ip(self) -> builtins.str:
        '''Private IP for this instance.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePrivateIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicDnsName")
    def instance_public_dns_name(self) -> builtins.str:
        '''Publicly-routable DNS name for this instance.

        (May be an empty string if the instance does not have a public name).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePublicDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicIp")
    def instance_public_ip(self) -> builtins.str:
        '''Publicly-routable IP  address for this instance.

        (May be an empty string if the instance does not have a public IP).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePublicIp"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInstance).__jsii_proxy_class__ = lambda : _IInstanceProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IInterfaceVpcEndpointService")
class IInterfaceVpcEndpointService(typing_extensions.Protocol):
    '''A service for an interface VPC endpoint.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        '''The port of the service.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsDefault")
    def private_dns_default(self) -> typing.Optional[builtins.bool]:
        '''Whether Private DNS is supported by default.'''
        ...


class _IInterfaceVpcEndpointServiceProxy:
    '''A service for an interface VPC endpoint.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IInterfaceVpcEndpointService"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        '''The port of the service.'''
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsDefault")
    def private_dns_default(self) -> typing.Optional[builtins.bool]:
        '''Whether Private DNS is supported by default.'''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "privateDnsDefault"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceVpcEndpointService).__jsii_proxy_class__ = lambda : _IInterfaceVpcEndpointServiceProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.ILaunchTemplate")
class ILaunchTemplate(_IResource_c80c4260, typing_extensions.Protocol):
    '''Interface for LaunchTemplate-like objects.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="versionNumber")
    def version_number(self) -> builtins.str:
        '''The version number of this launch template to use.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` will be set.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''The name of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` will be set.

        :attribute: true
        '''
        ...


class _ILaunchTemplateProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''Interface for LaunchTemplate-like objects.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.ILaunchTemplate"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="versionNumber")
    def version_number(self) -> builtins.str:
        '''The version number of this launch template to use.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "versionNumber"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` will be set.

        :attribute: true
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "launchTemplateId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''The name of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` will be set.

        :attribute: true
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "launchTemplateName"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ILaunchTemplate).__jsii_proxy_class__ = lambda : _ILaunchTemplateProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IMachineImage")
class IMachineImage(typing_extensions.Protocol):
    '''Interface for classes that can select an appropriate machine image to use.'''

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> "MachineImageConfig":
        '''Return the image to use in the given context.

        :param scope: -
        '''
        ...


class _IMachineImageProxy:
    '''Interface for classes that can select an appropriate machine image to use.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IMachineImage"

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> "MachineImageConfig":
        '''Return the image to use in the given context.

        :param scope: -
        '''
        return typing.cast("MachineImageConfig", jsii.invoke(self, "getImage", [scope]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IMachineImage).__jsii_proxy_class__ = lambda : _IMachineImageProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.INetworkAcl")
class INetworkAcl(_IResource_c80c4260, typing_extensions.Protocol):
    '''A NetworkAcl.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAclId")
    def network_acl_id(self) -> builtins.str:
        '''ID for the current Network ACL.

        :attribute: true
        '''
        ...

    @jsii.member(jsii_name="addEntry")
    def add_entry(
        self,
        id: builtins.str,
        *,
        cidr: AclCidr,
        rule_number: jsii.Number,
        traffic: AclTraffic,
        direction: typing.Optional["TrafficDirection"] = None,
        network_acl_entry_name: typing.Optional[builtins.str] = None,
        rule_action: typing.Optional[Action] = None,
    ) -> "NetworkAclEntry":
        '''Add a new entry to the ACL.

        :param id: -
        :param cidr: The CIDR range to allow or deny.
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param traffic: What kind of traffic this ACL rule applies to.
        :param direction: Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS
        :param network_acl_entry_name: The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW
        '''
        ...


class _INetworkAclProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''A NetworkAcl.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.INetworkAcl"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAclId")
    def network_acl_id(self) -> builtins.str:
        '''ID for the current Network ACL.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkAclId"))

    @jsii.member(jsii_name="addEntry")
    def add_entry(
        self,
        id: builtins.str,
        *,
        cidr: AclCidr,
        rule_number: jsii.Number,
        traffic: AclTraffic,
        direction: typing.Optional["TrafficDirection"] = None,
        network_acl_entry_name: typing.Optional[builtins.str] = None,
        rule_action: typing.Optional[Action] = None,
    ) -> "NetworkAclEntry":
        '''Add a new entry to the ACL.

        :param id: -
        :param cidr: The CIDR range to allow or deny.
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param traffic: What kind of traffic this ACL rule applies to.
        :param direction: Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS
        :param network_acl_entry_name: The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW
        '''
        options = CommonNetworkAclEntryOptions(
            cidr=cidr,
            rule_number=rule_number,
            traffic=traffic,
            direction=direction,
            network_acl_entry_name=network_acl_entry_name,
            rule_action=rule_action,
        )

        return typing.cast("NetworkAclEntry", jsii.invoke(self, "addEntry", [id, options]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, INetworkAcl).__jsii_proxy_class__ = lambda : _INetworkAclProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.INetworkAclEntry")
class INetworkAclEntry(_IResource_c80c4260, typing_extensions.Protocol):
    '''A NetworkAclEntry.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAcl")
    def network_acl(self) -> INetworkAcl:
        '''The network ACL.'''
        ...


class _INetworkAclEntryProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''A NetworkAclEntry.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.INetworkAclEntry"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAcl")
    def network_acl(self) -> INetworkAcl:
        '''The network ACL.'''
        return typing.cast(INetworkAcl, jsii.get(self, "networkAcl"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, INetworkAclEntry).__jsii_proxy_class__ = lambda : _INetworkAclEntryProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IPeer")
class IPeer(IConnectable, typing_extensions.Protocol):
    '''Interface for classes that provide the peer-specification parts of a security group rule.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="canInlineRule")
    def can_inline_rule(self) -> builtins.bool:
        '''Whether the rule can be inlined into a SecurityGroup or not.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="uniqueId")
    def unique_id(self) -> builtins.str:
        '''A unique identifier for this connection peer.'''
        ...

    @jsii.member(jsii_name="toEgressRuleConfig")
    def to_egress_rule_config(self) -> typing.Any:
        '''Produce the egress rule JSON for the given connection.'''
        ...

    @jsii.member(jsii_name="toIngressRuleConfig")
    def to_ingress_rule_config(self) -> typing.Any:
        '''Produce the ingress rule JSON for the given connection.'''
        ...


class _IPeerProxy(
    jsii.proxy_for(IConnectable) # type: ignore[misc]
):
    '''Interface for classes that provide the peer-specification parts of a security group rule.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IPeer"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="canInlineRule")
    def can_inline_rule(self) -> builtins.bool:
        '''Whether the rule can be inlined into a SecurityGroup or not.'''
        return typing.cast(builtins.bool, jsii.get(self, "canInlineRule"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="uniqueId")
    def unique_id(self) -> builtins.str:
        '''A unique identifier for this connection peer.'''
        return typing.cast(builtins.str, jsii.get(self, "uniqueId"))

    @jsii.member(jsii_name="toEgressRuleConfig")
    def to_egress_rule_config(self) -> typing.Any:
        '''Produce the egress rule JSON for the given connection.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toEgressRuleConfig", []))

    @jsii.member(jsii_name="toIngressRuleConfig")
    def to_ingress_rule_config(self) -> typing.Any:
        '''Produce the ingress rule JSON for the given connection.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toIngressRuleConfig", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPeer).__jsii_proxy_class__ = lambda : _IPeerProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IRouteTable")
class IRouteTable(typing_extensions.Protocol):
    '''An abstract route table.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(self) -> builtins.str:
        '''Route table ID.'''
        ...


class _IRouteTableProxy:
    '''An abstract route table.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IRouteTable"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTableId")
    def route_table_id(self) -> builtins.str:
        '''Route table ID.'''
        return typing.cast(builtins.str, jsii.get(self, "routeTableId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IRouteTable).__jsii_proxy_class__ = lambda : _IRouteTableProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.ISecurityGroup")
class ISecurityGroup(_IResource_c80c4260, IPeer, typing_extensions.Protocol):
    '''Interface for security group-like objects.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allowAllOutbound")
    def allow_all_outbound(self) -> builtins.bool:
        '''Whether the SecurityGroup has been configured to allow all outbound traffic.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> builtins.str:
        '''ID for the current security group.

        :attribute: true
        '''
        ...

    @jsii.member(jsii_name="addEgressRule")
    def add_egress_rule(
        self,
        peer: IPeer,
        connection: "Port",
        description: typing.Optional[builtins.str] = None,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Add an egress rule for the current security group.

        ``remoteRule`` controls where the Rule object is created if the peer is also a
        securityGroup and they are in different stack. If false (default) the
        rule object is created under the current SecurityGroup object. If true and the
        peer is also a SecurityGroup, the rule object is created under the remote
        SecurityGroup object.

        :param peer: -
        :param connection: -
        :param description: -
        :param remote_rule: -
        '''
        ...

    @jsii.member(jsii_name="addIngressRule")
    def add_ingress_rule(
        self,
        peer: IPeer,
        connection: "Port",
        description: typing.Optional[builtins.str] = None,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Add an ingress rule for the current security group.

        ``remoteRule`` controls where the Rule object is created if the peer is also a
        securityGroup and they are in different stack. If false (default) the
        rule object is created under the current SecurityGroup object. If true and the
        peer is also a SecurityGroup, the rule object is created under the remote
        SecurityGroup object.

        :param peer: -
        :param connection: -
        :param description: -
        :param remote_rule: -
        '''
        ...


class _ISecurityGroupProxy(
    jsii.proxy_for(_IResource_c80c4260), # type: ignore[misc]
    jsii.proxy_for(IPeer), # type: ignore[misc]
):
    '''Interface for security group-like objects.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.ISecurityGroup"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allowAllOutbound")
    def allow_all_outbound(self) -> builtins.bool:
        '''Whether the SecurityGroup has been configured to allow all outbound traffic.'''
        return typing.cast(builtins.bool, jsii.get(self, "allowAllOutbound"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> builtins.str:
        '''ID for the current security group.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "securityGroupId"))

    @jsii.member(jsii_name="addEgressRule")
    def add_egress_rule(
        self,
        peer: IPeer,
        connection: "Port",
        description: typing.Optional[builtins.str] = None,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Add an egress rule for the current security group.

        ``remoteRule`` controls where the Rule object is created if the peer is also a
        securityGroup and they are in different stack. If false (default) the
        rule object is created under the current SecurityGroup object. If true and the
        peer is also a SecurityGroup, the rule object is created under the remote
        SecurityGroup object.

        :param peer: -
        :param connection: -
        :param description: -
        :param remote_rule: -
        '''
        return typing.cast(None, jsii.invoke(self, "addEgressRule", [peer, connection, description, remote_rule]))

    @jsii.member(jsii_name="addIngressRule")
    def add_ingress_rule(
        self,
        peer: IPeer,
        connection: "Port",
        description: typing.Optional[builtins.str] = None,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Add an ingress rule for the current security group.

        ``remoteRule`` controls where the Rule object is created if the peer is also a
        securityGroup and they are in different stack. If false (default) the
        rule object is created under the current SecurityGroup object. If true and the
        peer is also a SecurityGroup, the rule object is created under the remote
        SecurityGroup object.

        :param peer: -
        :param connection: -
        :param description: -
        :param remote_rule: -
        '''
        return typing.cast(None, jsii.invoke(self, "addIngressRule", [peer, connection, description, remote_rule]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISecurityGroup).__jsii_proxy_class__ = lambda : _ISecurityGroupProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.ISubnet")
class ISubnet(_IResource_c80c4260, typing_extensions.Protocol):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone the subnet is located in.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetConnectivityEstablished")
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force internet connectivity established on the VPC.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4CidrBlock")
    def ipv4_cidr_block(self) -> builtins.str:
        '''The IPv4 CIDR block for this subnet.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTable")
    def route_table(self) -> IRouteTable:
        '''The route table for this subnet.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The subnetId for this particular subnet.

        :attribute: true
        '''
        ...

    @jsii.member(jsii_name="associateNetworkAcl")
    def associate_network_acl(self, id: builtins.str, acl: INetworkAcl) -> None:
        '''Associate a Network ACL with this subnet.

        :param id: -
        :param acl: The Network ACL to associate.
        '''
        ...


class _ISubnetProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.ISubnet"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone the subnet is located in.'''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetConnectivityEstablished")
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force internet connectivity established on the VPC.'''
        return typing.cast(constructs.IDependable, jsii.get(self, "internetConnectivityEstablished"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4CidrBlock")
    def ipv4_cidr_block(self) -> builtins.str:
        '''The IPv4 CIDR block for this subnet.'''
        return typing.cast(builtins.str, jsii.get(self, "ipv4CidrBlock"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTable")
    def route_table(self) -> IRouteTable:
        '''The route table for this subnet.'''
        return typing.cast(IRouteTable, jsii.get(self, "routeTable"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The subnetId for this particular subnet.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @jsii.member(jsii_name="associateNetworkAcl")
    def associate_network_acl(self, id: builtins.str, acl: INetworkAcl) -> None:
        '''Associate a Network ACL with this subnet.

        :param id: -
        :param acl: The Network ACL to associate.
        '''
        return typing.cast(None, jsii.invoke(self, "associateNetworkAcl", [id, acl]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISubnet).__jsii_proxy_class__ = lambda : _ISubnetProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.ISubnetNetworkAclAssociation")
class ISubnetNetworkAclAssociation(_IResource_c80c4260, typing_extensions.Protocol):
    '''A SubnetNetworkAclAssociation.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetNetworkAclAssociationAssociationId")
    def subnet_network_acl_association_association_id(self) -> builtins.str:
        '''ID for the current SubnetNetworkAclAssociation.

        :attribute: true
        '''
        ...


class _ISubnetNetworkAclAssociationProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''A SubnetNetworkAclAssociation.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.ISubnetNetworkAclAssociation"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetNetworkAclAssociationAssociationId")
    def subnet_network_acl_association_association_id(self) -> builtins.str:
        '''ID for the current SubnetNetworkAclAssociation.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetNetworkAclAssociationAssociationId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ISubnetNetworkAclAssociation).__jsii_proxy_class__ = lambda : _ISubnetNetworkAclAssociationProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVolume")
class IVolume(_IResource_c80c4260, typing_extensions.Protocol):
    '''An EBS Volume in AWS EC2.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The availability zone that the EBS Volume is contained within (ex: us-west-2a).'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="volumeId")
    def volume_id(self) -> builtins.str:
        '''The EBS Volume's ID.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="encryptionKey")
    def encryption_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The customer-managed encryption key that is used to encrypt the Volume.

        :attribute: true
        '''
        ...

    @jsii.member(jsii_name="grantAttachVolume")
    def grant_attach_volume(
        self,
        grantee: _IGrantable_71c4f5de,
        instances: typing.Optional[typing.Sequence[IInstance]] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to attach this Volume to an instance.

        CAUTION: Granting an instance permission to attach to itself using this method will lead to
        an unresolvable circular reference between the instance role and the instance.
        Use {@link IVolume.grantAttachVolumeToSelf} to grant an instance permission to attach this
        volume to itself.

        :param grantee: the principal being granted permission.
        :param instances: the instances to which permission is being granted to attach this volume to. If not specified, then permission is granted to attach to all instances in this account.
        '''
        ...

    @jsii.member(jsii_name="grantAttachVolumeByResourceTag")
    def grant_attach_volume_by_resource_tag(
        self,
        grantee: _IGrantable_71c4f5de,
        constructs: typing.Sequence[constructs.Construct],
        tag_key_suffix: typing.Optional[builtins.str] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to attach the Volume by a ResourceTag condition.

        If you are looking to
        grant an Instance, AutoScalingGroup, EC2-Fleet, SpotFleet, ECS host, etc the ability to attach
        this volume to **itself** then this is the method you want to use.

        This is implemented by adding a Tag with key ``VolumeGrantAttach-<suffix>`` to the given
        constructs and this Volume, and then conditioning the Grant such that the grantee is only
        given the ability to AttachVolume if both the Volume and the destination Instance have that
        tag applied to them.

        :param grantee: the principal being granted permission.
        :param constructs: The list of constructs that will have the generated resource tag applied to them.
        :param tag_key_suffix: A suffix to use on the generated Tag key in place of the generated hash value. Defaults to a hash calculated from this volume and list of constructs. (DEPRECATED)
        '''
        ...

    @jsii.member(jsii_name="grantDetachVolume")
    def grant_detach_volume(
        self,
        grantee: _IGrantable_71c4f5de,
        instances: typing.Optional[typing.Sequence[IInstance]] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to detach this Volume from an instance CAUTION: Granting an instance permission to detach from itself using this method will lead to an unresolvable circular reference between the instance role and the instance.

        Use {@link IVolume.grantDetachVolumeFromSelf} to grant an instance permission to detach this
        volume from itself.

        :param grantee: the principal being granted permission.
        :param instances: the instances to which permission is being granted to detach this volume from. If not specified, then permission is granted to detach from all instances in this account.
        '''
        ...

    @jsii.member(jsii_name="grantDetachVolumeByResourceTag")
    def grant_detach_volume_by_resource_tag(
        self,
        grantee: _IGrantable_71c4f5de,
        constructs: typing.Sequence[constructs.Construct],
        tag_key_suffix: typing.Optional[builtins.str] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to detach the Volume by a ResourceTag condition.

        This is implemented via the same mechanism as {@link IVolume.grantAttachVolumeByResourceTag},
        and is subject to the same conditions.

        :param grantee: the principal being granted permission.
        :param constructs: The list of constructs that will have the generated resource tag applied to them.
        :param tag_key_suffix: A suffix to use on the generated Tag key in place of the generated hash value. Defaults to a hash calculated from this volume and list of constructs. (DEPRECATED)
        '''
        ...


class _IVolumeProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''An EBS Volume in AWS EC2.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVolume"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The availability zone that the EBS Volume is contained within (ex: us-west-2a).'''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="volumeId")
    def volume_id(self) -> builtins.str:
        '''The EBS Volume's ID.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "volumeId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="encryptionKey")
    def encryption_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The customer-managed encryption key that is used to encrypt the Volume.

        :attribute: true
        '''
        return typing.cast(typing.Optional[_IKey_5f11635f], jsii.get(self, "encryptionKey"))

    @jsii.member(jsii_name="grantAttachVolume")
    def grant_attach_volume(
        self,
        grantee: _IGrantable_71c4f5de,
        instances: typing.Optional[typing.Sequence[IInstance]] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to attach this Volume to an instance.

        CAUTION: Granting an instance permission to attach to itself using this method will lead to
        an unresolvable circular reference between the instance role and the instance.
        Use {@link IVolume.grantAttachVolumeToSelf} to grant an instance permission to attach this
        volume to itself.

        :param grantee: the principal being granted permission.
        :param instances: the instances to which permission is being granted to attach this volume to. If not specified, then permission is granted to attach to all instances in this account.
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantAttachVolume", [grantee, instances]))

    @jsii.member(jsii_name="grantAttachVolumeByResourceTag")
    def grant_attach_volume_by_resource_tag(
        self,
        grantee: _IGrantable_71c4f5de,
        constructs: typing.Sequence[constructs.Construct],
        tag_key_suffix: typing.Optional[builtins.str] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to attach the Volume by a ResourceTag condition.

        If you are looking to
        grant an Instance, AutoScalingGroup, EC2-Fleet, SpotFleet, ECS host, etc the ability to attach
        this volume to **itself** then this is the method you want to use.

        This is implemented by adding a Tag with key ``VolumeGrantAttach-<suffix>`` to the given
        constructs and this Volume, and then conditioning the Grant such that the grantee is only
        given the ability to AttachVolume if both the Volume and the destination Instance have that
        tag applied to them.

        :param grantee: the principal being granted permission.
        :param constructs: The list of constructs that will have the generated resource tag applied to them.
        :param tag_key_suffix: A suffix to use on the generated Tag key in place of the generated hash value. Defaults to a hash calculated from this volume and list of constructs. (DEPRECATED)
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantAttachVolumeByResourceTag", [grantee, constructs, tag_key_suffix]))

    @jsii.member(jsii_name="grantDetachVolume")
    def grant_detach_volume(
        self,
        grantee: _IGrantable_71c4f5de,
        instances: typing.Optional[typing.Sequence[IInstance]] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to detach this Volume from an instance CAUTION: Granting an instance permission to detach from itself using this method will lead to an unresolvable circular reference between the instance role and the instance.

        Use {@link IVolume.grantDetachVolumeFromSelf} to grant an instance permission to detach this
        volume from itself.

        :param grantee: the principal being granted permission.
        :param instances: the instances to which permission is being granted to detach this volume from. If not specified, then permission is granted to detach from all instances in this account.
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantDetachVolume", [grantee, instances]))

    @jsii.member(jsii_name="grantDetachVolumeByResourceTag")
    def grant_detach_volume_by_resource_tag(
        self,
        grantee: _IGrantable_71c4f5de,
        constructs: typing.Sequence[constructs.Construct],
        tag_key_suffix: typing.Optional[builtins.str] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to detach the Volume by a ResourceTag condition.

        This is implemented via the same mechanism as {@link IVolume.grantAttachVolumeByResourceTag},
        and is subject to the same conditions.

        :param grantee: the principal being granted permission.
        :param constructs: The list of constructs that will have the generated resource tag applied to them.
        :param tag_key_suffix: A suffix to use on the generated Tag key in place of the generated hash value. Defaults to a hash calculated from this volume and list of constructs. (DEPRECATED)
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantDetachVolumeByResourceTag", [grantee, constructs, tag_key_suffix]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVolume).__jsii_proxy_class__ = lambda : _IVolumeProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVpc")
class IVpc(_IResource_c80c4260, typing_extensions.Protocol):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZones")
    def availability_zones(self) -> typing.List[builtins.str]:
        '''AZs for this VPC.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetConnectivityEstablished")
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force internet connectivity established on the VPC.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isolatedSubnets")
    def isolated_subnets(self) -> typing.List[ISubnet]:
        '''List of isolated subnets in this VPC.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateSubnets")
    def private_subnets(self) -> typing.List[ISubnet]:
        '''List of private subnets in this VPC.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="publicSubnets")
    def public_subnets(self) -> typing.List[ISubnet]:
        '''List of public subnets in this VPC.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcArn")
    def vpc_arn(self) -> builtins.str:
        '''ARN for this VPC.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcCidrBlock")
    def vpc_cidr_block(self) -> builtins.str:
        '''CIDR range for this VPC.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''Identifier for this VPC.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''Identifier for the VPN gateway.'''
        ...

    @jsii.member(jsii_name="addClientVpnEndpoint")
    def add_client_vpn_endpoint(
        self,
        id: builtins.str,
        *,
        cidr: builtins.str,
        server_certificate_arn: builtins.str,
        authorize_all_users_to_vpc_cidr: typing.Optional[builtins.bool] = None,
        client_certificate_arn: typing.Optional[builtins.str] = None,
        client_connection_handler: typing.Optional[IClientVpnConnectionHandler] = None,
        client_login_banner: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        log_stream: typing.Optional[_ILogStream_dcfca8c2] = None,
        port: typing.Optional["VpnPort"] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        self_service_portal: typing.Optional[builtins.bool] = None,
        session_timeout: typing.Optional[ClientVpnSessionTimeout] = None,
        split_tunnel: typing.Optional[builtins.bool] = None,
        transport_protocol: typing.Optional["TransportProtocol"] = None,
        user_based_authentication: typing.Optional[ClientVpnUserBasedAuthentication] = None,
        vpc_subnets: typing.Optional["SubnetSelection"] = None,
    ) -> "ClientVpnEndpoint":
        '''Adds a new client VPN endpoint to this VPC.

        :param id: -
        :param cidr: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.
        :param server_certificate_arn: The ARN of the server certificate.
        :param authorize_all_users_to_vpc_cidr: Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true
        :param client_certificate_arn: The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication
        :param client_connection_handler: The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler
        :param client_login_banner: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client
        :param description: A brief description of the Client VPN endpoint. Default: - no description
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device
        :param logging: Whether to enable connections logging. Default: true
        :param log_group: A CloudWatch Logs log group for connection logging. Default: - a new group is created
        :param log_stream: A CloudWatch Logs log stream for connection logging. Default: - a new stream is created
        :param port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS
        :param security_groups: The security groups to apply to the target network. Default: - a new security group is created
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true
        :param session_timeout: The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false
        :param transport_protocol: The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP
        :param user_based_authentication: The type of user-based authentication to use. Default: - use mutual authentication
        :param vpc_subnets: Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy
        '''
        ...

    @jsii.member(jsii_name="addFlowLog")
    def add_flow_log(
        self,
        id: builtins.str,
        *,
        destination: typing.Optional[FlowLogDestination] = None,
        traffic_type: typing.Optional[FlowLogTrafficType] = None,
    ) -> "FlowLog":
        '''Adds a new Flow Log to this VPC.

        :param id: -
        :param destination: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL
        '''
        ...

    @jsii.member(jsii_name="addGatewayEndpoint")
    def add_gateway_endpoint(
        self,
        id: builtins.str,
        *,
        service: IGatewayVpcEndpointService,
        subnets: typing.Optional[typing.Sequence["SubnetSelection"]] = None,
    ) -> "GatewayVpcEndpoint":
        '''Adds a new gateway endpoint to this VPC.

        :param id: -
        :param service: The service to use for this gateway VPC endpoint.
        :param subnets: Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC
        '''
        ...

    @jsii.member(jsii_name="addInterfaceEndpoint")
    def add_interface_endpoint(
        self,
        id: builtins.str,
        *,
        service: IInterfaceVpcEndpointService,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        subnets: typing.Optional["SubnetSelection"] = None,
    ) -> "InterfaceVpcEndpoint":
        '''Adds a new interface endpoint to this VPC.

        :param id: -
        :param service: The service to use for this interface VPC endpoint.
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets
        '''
        ...

    @jsii.member(jsii_name="addVpnConnection")
    def add_vpn_connection(
        self,
        id: builtins.str,
        *,
        ip: builtins.str,
        asn: typing.Optional[jsii.Number] = None,
        static_routes: typing.Optional[typing.Sequence[builtins.str]] = None,
        tunnel_options: typing.Optional[typing.Sequence["VpnTunnelOption"]] = None,
    ) -> "VpnConnection":
        '''Adds a new VPN connection to this VPC.

        :param id: -
        :param ip: The ip address of the customer gateway.
        :param asn: The ASN of the customer gateway. Default: 65000
        :param static_routes: The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)
        :param tunnel_options: The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options
        '''
        ...

    @jsii.member(jsii_name="enableVpnGateway")
    def enable_vpn_gateway(
        self,
        *,
        vpn_route_propagation: typing.Optional[typing.Sequence["SubnetSelection"]] = None,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Adds a VPN Gateway to this VPC.

        :param vpn_route_propagation: Provide an array of subnets where the route propagation should be added. Default: noPropagation
        :param type: Default type ipsec.1.
        :param amazon_side_asn: Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000
        '''
        ...

    @jsii.member(jsii_name="selectSubnets")
    def select_subnets(
        self,
        *,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        one_per_az: typing.Optional[builtins.bool] = None,
        subnet_filters: typing.Optional[typing.Sequence["SubnetFilter"]] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[ISubnet]] = None,
        subnet_type: typing.Optional["SubnetType"] = None,
    ) -> "SelectedSubnets":
        '''Return information on the subnets appropriate for the given selection strategy.

        Requires that at least one subnet is matched, throws a descriptive
        error message otherwise.

        :param availability_zones: Select subnets only in the given AZs. Default: no filtering on AZs is done
        :param one_per_az: If true, return at most one subnet per AZ. Default: false
        :param subnet_filters: List of provided subnet filters. Default: - none
        :param subnet_group_name: Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name
        :param subnets: Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)
        :param subnet_type: Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)
        '''
        ...


class _IVpcProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVpc"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZones")
    def availability_zones(self) -> typing.List[builtins.str]:
        '''AZs for this VPC.'''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "availabilityZones"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetConnectivityEstablished")
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force internet connectivity established on the VPC.'''
        return typing.cast(constructs.IDependable, jsii.get(self, "internetConnectivityEstablished"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isolatedSubnets")
    def isolated_subnets(self) -> typing.List[ISubnet]:
        '''List of isolated subnets in this VPC.'''
        return typing.cast(typing.List[ISubnet], jsii.get(self, "isolatedSubnets"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateSubnets")
    def private_subnets(self) -> typing.List[ISubnet]:
        '''List of private subnets in this VPC.'''
        return typing.cast(typing.List[ISubnet], jsii.get(self, "privateSubnets"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="publicSubnets")
    def public_subnets(self) -> typing.List[ISubnet]:
        '''List of public subnets in this VPC.'''
        return typing.cast(typing.List[ISubnet], jsii.get(self, "publicSubnets"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcArn")
    def vpc_arn(self) -> builtins.str:
        '''ARN for this VPC.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcCidrBlock")
    def vpc_cidr_block(self) -> builtins.str:
        '''CIDR range for this VPC.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcCidrBlock"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''Identifier for this VPC.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''Identifier for the VPN gateway.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpnGatewayId"))

    @jsii.member(jsii_name="addClientVpnEndpoint")
    def add_client_vpn_endpoint(
        self,
        id: builtins.str,
        *,
        cidr: builtins.str,
        server_certificate_arn: builtins.str,
        authorize_all_users_to_vpc_cidr: typing.Optional[builtins.bool] = None,
        client_certificate_arn: typing.Optional[builtins.str] = None,
        client_connection_handler: typing.Optional[IClientVpnConnectionHandler] = None,
        client_login_banner: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        log_stream: typing.Optional[_ILogStream_dcfca8c2] = None,
        port: typing.Optional["VpnPort"] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        self_service_portal: typing.Optional[builtins.bool] = None,
        session_timeout: typing.Optional[ClientVpnSessionTimeout] = None,
        split_tunnel: typing.Optional[builtins.bool] = None,
        transport_protocol: typing.Optional["TransportProtocol"] = None,
        user_based_authentication: typing.Optional[ClientVpnUserBasedAuthentication] = None,
        vpc_subnets: typing.Optional["SubnetSelection"] = None,
    ) -> "ClientVpnEndpoint":
        '''Adds a new client VPN endpoint to this VPC.

        :param id: -
        :param cidr: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.
        :param server_certificate_arn: The ARN of the server certificate.
        :param authorize_all_users_to_vpc_cidr: Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true
        :param client_certificate_arn: The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication
        :param client_connection_handler: The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler
        :param client_login_banner: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client
        :param description: A brief description of the Client VPN endpoint. Default: - no description
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device
        :param logging: Whether to enable connections logging. Default: true
        :param log_group: A CloudWatch Logs log group for connection logging. Default: - a new group is created
        :param log_stream: A CloudWatch Logs log stream for connection logging. Default: - a new stream is created
        :param port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS
        :param security_groups: The security groups to apply to the target network. Default: - a new security group is created
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true
        :param session_timeout: The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false
        :param transport_protocol: The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP
        :param user_based_authentication: The type of user-based authentication to use. Default: - use mutual authentication
        :param vpc_subnets: Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy
        '''
        options = ClientVpnEndpointOptions(
            cidr=cidr,
            server_certificate_arn=server_certificate_arn,
            authorize_all_users_to_vpc_cidr=authorize_all_users_to_vpc_cidr,
            client_certificate_arn=client_certificate_arn,
            client_connection_handler=client_connection_handler,
            client_login_banner=client_login_banner,
            description=description,
            dns_servers=dns_servers,
            logging=logging,
            log_group=log_group,
            log_stream=log_stream,
            port=port,
            security_groups=security_groups,
            self_service_portal=self_service_portal,
            session_timeout=session_timeout,
            split_tunnel=split_tunnel,
            transport_protocol=transport_protocol,
            user_based_authentication=user_based_authentication,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast("ClientVpnEndpoint", jsii.invoke(self, "addClientVpnEndpoint", [id, options]))

    @jsii.member(jsii_name="addFlowLog")
    def add_flow_log(
        self,
        id: builtins.str,
        *,
        destination: typing.Optional[FlowLogDestination] = None,
        traffic_type: typing.Optional[FlowLogTrafficType] = None,
    ) -> "FlowLog":
        '''Adds a new Flow Log to this VPC.

        :param id: -
        :param destination: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL
        '''
        options = FlowLogOptions(destination=destination, traffic_type=traffic_type)

        return typing.cast("FlowLog", jsii.invoke(self, "addFlowLog", [id, options]))

    @jsii.member(jsii_name="addGatewayEndpoint")
    def add_gateway_endpoint(
        self,
        id: builtins.str,
        *,
        service: IGatewayVpcEndpointService,
        subnets: typing.Optional[typing.Sequence["SubnetSelection"]] = None,
    ) -> "GatewayVpcEndpoint":
        '''Adds a new gateway endpoint to this VPC.

        :param id: -
        :param service: The service to use for this gateway VPC endpoint.
        :param subnets: Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC
        '''
        options = GatewayVpcEndpointOptions(service=service, subnets=subnets)

        return typing.cast("GatewayVpcEndpoint", jsii.invoke(self, "addGatewayEndpoint", [id, options]))

    @jsii.member(jsii_name="addInterfaceEndpoint")
    def add_interface_endpoint(
        self,
        id: builtins.str,
        *,
        service: IInterfaceVpcEndpointService,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        subnets: typing.Optional["SubnetSelection"] = None,
    ) -> "InterfaceVpcEndpoint":
        '''Adds a new interface endpoint to this VPC.

        :param id: -
        :param service: The service to use for this interface VPC endpoint.
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets
        '''
        options = InterfaceVpcEndpointOptions(
            service=service,
            lookup_supported_azs=lookup_supported_azs,
            open=open,
            private_dns_enabled=private_dns_enabled,
            security_groups=security_groups,
            subnets=subnets,
        )

        return typing.cast("InterfaceVpcEndpoint", jsii.invoke(self, "addInterfaceEndpoint", [id, options]))

    @jsii.member(jsii_name="addVpnConnection")
    def add_vpn_connection(
        self,
        id: builtins.str,
        *,
        ip: builtins.str,
        asn: typing.Optional[jsii.Number] = None,
        static_routes: typing.Optional[typing.Sequence[builtins.str]] = None,
        tunnel_options: typing.Optional[typing.Sequence["VpnTunnelOption"]] = None,
    ) -> "VpnConnection":
        '''Adds a new VPN connection to this VPC.

        :param id: -
        :param ip: The ip address of the customer gateway.
        :param asn: The ASN of the customer gateway. Default: 65000
        :param static_routes: The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)
        :param tunnel_options: The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options
        '''
        options = VpnConnectionOptions(
            ip=ip, asn=asn, static_routes=static_routes, tunnel_options=tunnel_options
        )

        return typing.cast("VpnConnection", jsii.invoke(self, "addVpnConnection", [id, options]))

    @jsii.member(jsii_name="enableVpnGateway")
    def enable_vpn_gateway(
        self,
        *,
        vpn_route_propagation: typing.Optional[typing.Sequence["SubnetSelection"]] = None,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Adds a VPN Gateway to this VPC.

        :param vpn_route_propagation: Provide an array of subnets where the route propagation should be added. Default: noPropagation
        :param type: Default type ipsec.1.
        :param amazon_side_asn: Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000
        '''
        options = EnableVpnGatewayOptions(
            vpn_route_propagation=vpn_route_propagation,
            type=type,
            amazon_side_asn=amazon_side_asn,
        )

        return typing.cast(None, jsii.invoke(self, "enableVpnGateway", [options]))

    @jsii.member(jsii_name="selectSubnets")
    def select_subnets(
        self,
        *,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        one_per_az: typing.Optional[builtins.bool] = None,
        subnet_filters: typing.Optional[typing.Sequence["SubnetFilter"]] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[ISubnet]] = None,
        subnet_type: typing.Optional["SubnetType"] = None,
    ) -> "SelectedSubnets":
        '''Return information on the subnets appropriate for the given selection strategy.

        Requires that at least one subnet is matched, throws a descriptive
        error message otherwise.

        :param availability_zones: Select subnets only in the given AZs. Default: no filtering on AZs is done
        :param one_per_az: If true, return at most one subnet per AZ. Default: false
        :param subnet_filters: List of provided subnet filters. Default: - none
        :param subnet_group_name: Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name
        :param subnets: Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)
        :param subnet_type: Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)
        '''
        selection = SubnetSelection(
            availability_zones=availability_zones,
            one_per_az=one_per_az,
            subnet_filters=subnet_filters,
            subnet_group_name=subnet_group_name,
            subnets=subnets,
            subnet_type=subnet_type,
        )

        return typing.cast("SelectedSubnets", jsii.invoke(self, "selectSubnets", [selection]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpc).__jsii_proxy_class__ = lambda : _IVpcProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVpcEndpoint")
class IVpcEndpoint(_IResource_c80c4260, typing_extensions.Protocol):
    '''A VPC endpoint.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> builtins.str:
        '''The VPC endpoint identifier.

        :attribute: true
        '''
        ...


class _IVpcEndpointProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''A VPC endpoint.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVpcEndpoint"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> builtins.str:
        '''The VPC endpoint identifier.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpcEndpoint).__jsii_proxy_class__ = lambda : _IVpcEndpointProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVpcEndpointService")
class IVpcEndpointService(_IResource_c80c4260, typing_extensions.Protocol):
    '''A VPC endpoint service.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceId")
    def vpc_endpoint_service_id(self) -> builtins.str:
        '''The id of the VPC Endpoint Service that clients use to connect to, like vpce-svc-xxxxxxxxxxxxxxxx.

        :attribute: true
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> builtins.str:
        '''The service name of the VPC Endpoint Service that clients use to connect to, like com.amazonaws.vpce..vpce-svc-xxxxxxxxxxxxxxxx.

        :attribute: true
        '''
        ...


class _IVpcEndpointServiceProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''A VPC endpoint service.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVpcEndpointService"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceId")
    def vpc_endpoint_service_id(self) -> builtins.str:
        '''The id of the VPC Endpoint Service that clients use to connect to, like vpce-svc-xxxxxxxxxxxxxxxx.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointServiceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> builtins.str:
        '''The service name of the VPC Endpoint Service that clients use to connect to, like com.amazonaws.vpce..vpce-svc-xxxxxxxxxxxxxxxx.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointServiceName"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpcEndpointService).__jsii_proxy_class__ = lambda : _IVpcEndpointServiceProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVpcEndpointServiceLoadBalancer")
class IVpcEndpointServiceLoadBalancer(typing_extensions.Protocol):
    '''A load balancer that can host a VPC Endpoint Service.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="loadBalancerArn")
    def load_balancer_arn(self) -> builtins.str:
        '''The ARN of the load balancer that hosts the VPC Endpoint Service.

        :attribute: true
        '''
        ...


class _IVpcEndpointServiceLoadBalancerProxy:
    '''A load balancer that can host a VPC Endpoint Service.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVpcEndpointServiceLoadBalancer"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="loadBalancerArn")
    def load_balancer_arn(self) -> builtins.str:
        '''The ARN of the load balancer that hosts the VPC Endpoint Service.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "loadBalancerArn"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpcEndpointServiceLoadBalancer).__jsii_proxy_class__ = lambda : _IVpcEndpointServiceLoadBalancerProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVpnConnection")
class IVpnConnection(_IResource_c80c4260, typing_extensions.Protocol):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayAsn")
    def customer_gateway_asn(self) -> jsii.Number:
        '''The ASN of the customer gateway.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayId")
    def customer_gateway_id(self) -> builtins.str:
        '''The id of the customer gateway.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayIp")
    def customer_gateway_ip(self) -> builtins.str:
        '''The ip address of the customer gateway.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnId")
    def vpn_id(self) -> builtins.str:
        '''The id of the VPN connection.'''
        ...

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Return the given named metric for this VPNConnection.

        :param metric_name: -
        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        ...

    @jsii.member(jsii_name="metricTunnelDataIn")
    def metric_tunnel_data_in(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The bytes received through the VPN tunnel.

        Sum over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        ...

    @jsii.member(jsii_name="metricTunnelDataOut")
    def metric_tunnel_data_out(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The bytes sent through the VPN tunnel.

        Sum over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        ...

    @jsii.member(jsii_name="metricTunnelState")
    def metric_tunnel_state(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The state of the tunnel. 0 indicates DOWN and 1 indicates UP.

        Average over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        ...


class _IVpnConnectionProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVpnConnection"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayAsn")
    def customer_gateway_asn(self) -> jsii.Number:
        '''The ASN of the customer gateway.'''
        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayId")
    def customer_gateway_id(self) -> builtins.str:
        '''The id of the customer gateway.'''
        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayIp")
    def customer_gateway_ip(self) -> builtins.str:
        '''The ip address of the customer gateway.'''
        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnId")
    def vpn_id(self) -> builtins.str:
        '''The id of the VPN connection.'''
        return typing.cast(builtins.str, jsii.get(self, "vpnId"))

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Return the given named metric for this VPNConnection.

        :param metric_name: -
        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricTunnelDataIn")
    def metric_tunnel_data_in(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The bytes received through the VPN tunnel.

        Sum over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metricTunnelDataIn", [props]))

    @jsii.member(jsii_name="metricTunnelDataOut")
    def metric_tunnel_data_out(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The bytes sent through the VPN tunnel.

        Sum over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metricTunnelDataOut", [props]))

    @jsii.member(jsii_name="metricTunnelState")
    def metric_tunnel_state(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The state of the tunnel. 0 indicates DOWN and 1 indicates UP.

        Average over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metricTunnelState", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpnConnection).__jsii_proxy_class__ = lambda : _IVpnConnectionProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IVpnGateway")
class IVpnGateway(_IResource_c80c4260, typing_extensions.Protocol):
    '''The virtual private gateway interface.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gatewayId")
    def gateway_id(self) -> builtins.str:
        '''The virtual private gateway Id.'''
        ...


class _IVpnGatewayProxy(
    jsii.proxy_for(_IResource_c80c4260) # type: ignore[misc]
):
    '''The virtual private gateway interface.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IVpnGateway"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gatewayId")
    def gateway_id(self) -> builtins.str:
        '''The virtual private gateway Id.'''
        return typing.cast(builtins.str, jsii.get(self, "gatewayId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IVpnGateway).__jsii_proxy_class__ = lambda : _IVpnGatewayProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitCommandOptions",
    jsii_struct_bases=[],
    name_mapping={
        "cwd": "cwd",
        "env": "env",
        "ignore_errors": "ignoreErrors",
        "key": "key",
        "service_restart_handles": "serviceRestartHandles",
        "test_cmd": "testCmd",
        "wait_after_completion": "waitAfterCompletion",
    },
)
class InitCommandOptions:
    def __init__(
        self,
        *,
        cwd: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_errors: typing.Optional[builtins.bool] = None,
        key: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
        test_cmd: typing.Optional[builtins.str] = None,
        wait_after_completion: typing.Optional["InitCommandWaitDuration"] = None,
    ) -> None:
        '''Options for InitCommand.

        :param cwd: The working directory. Default: - Use default working directory
        :param env: Sets environment variables for the command. This property overwrites, rather than appends, the existing environment. Default: - Use current environment
        :param ignore_errors: Continue running if this command fails. Default: false
        :param key: Identifier key for this command. Commands are executed in lexicographical order of their key names. Default: - Automatically generated based on index
        :param service_restart_handles: Restart the given service(s) after this command has run. Default: - Do not restart any service
        :param test_cmd: Command to determine whether this command should be run. If the test passes (exits with error code of 0), the command is run. Default: - Always run the command
        :param wait_after_completion: The duration to wait after a command has finished in case the command causes a reboot. Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command; ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete. For Windows systems only. Default: - 60 seconds

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            handle = ec2.InitServiceRestartHandle()
            ec2.CloudFormationInit.from_elements(
                ec2.InitCommand.shell_command("/usr/bin/custom-nginx-install.sh", service_restart_handles=[handle]),
                ec2.InitService.enable("nginx", service_restart_handle=handle))
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if cwd is not None:
            self._values["cwd"] = cwd
        if env is not None:
            self._values["env"] = env
        if ignore_errors is not None:
            self._values["ignore_errors"] = ignore_errors
        if key is not None:
            self._values["key"] = key
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles
        if test_cmd is not None:
            self._values["test_cmd"] = test_cmd
        if wait_after_completion is not None:
            self._values["wait_after_completion"] = wait_after_completion

    @builtins.property
    def cwd(self) -> typing.Optional[builtins.str]:
        '''The working directory.

        :default: - Use default working directory
        '''
        result = self._values.get("cwd")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def env(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Sets environment variables for the command.

        This property overwrites, rather than appends, the existing environment.

        :default: - Use current environment
        '''
        result = self._values.get("env")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def ignore_errors(self) -> typing.Optional[builtins.bool]:
        '''Continue running if this command fails.

        :default: false
        '''
        result = self._values.get("ignore_errors")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Identifier key for this command.

        Commands are executed in lexicographical order of their key names.

        :default: - Automatically generated based on index
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List["InitServiceRestartHandle"]]:
        '''Restart the given service(s) after this command has run.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List["InitServiceRestartHandle"]], result)

    @builtins.property
    def test_cmd(self) -> typing.Optional[builtins.str]:
        '''Command to determine whether this command should be run.

        If the test passes (exits with error code of 0), the command is run.

        :default: - Always run the command
        '''
        result = self._values.get("test_cmd")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def wait_after_completion(self) -> typing.Optional["InitCommandWaitDuration"]:
        '''The duration to wait after a command has finished in case the command causes a reboot.

        Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command;
        ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete.

        For Windows systems only.

        :default: - 60 seconds
        '''
        result = self._values.get("wait_after_completion")
        return typing.cast(typing.Optional["InitCommandWaitDuration"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitCommandOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InitCommandWaitDuration(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.InitCommandWaitDuration",
):
    '''Represents a duration to wait after a command has finished, in case of a reboot (Windows only).

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        init_command_wait_duration = ec2.InitCommandWaitDuration.forever()
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="forever") # type: ignore[misc]
    @builtins.classmethod
    def forever(cls) -> "InitCommandWaitDuration":
        '''cfn-init will exit and resume only after a reboot.'''
        return typing.cast("InitCommandWaitDuration", jsii.sinvoke(cls, "forever", []))

    @jsii.member(jsii_name="none") # type: ignore[misc]
    @builtins.classmethod
    def none(cls) -> "InitCommandWaitDuration":
        '''Do not wait for this command.'''
        return typing.cast("InitCommandWaitDuration", jsii.sinvoke(cls, "none", []))

    @jsii.member(jsii_name="of") # type: ignore[misc]
    @builtins.classmethod
    def of(cls, duration: _Duration_4839e8c3) -> "InitCommandWaitDuration":
        '''Wait for a specified duration after a command.

        :param duration: -
        '''
        return typing.cast("InitCommandWaitDuration", jsii.sinvoke(cls, "of", [duration]))


class _InitCommandWaitDurationProxy(InitCommandWaitDuration):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, InitCommandWaitDuration).__jsii_proxy_class__ = lambda : _InitCommandWaitDurationProxy


class InitConfig(metaclass=jsii.JSIIMeta, jsii_type="aws-cdk-lib.aws_ec2.InitConfig"):
    '''A collection of configuration elements.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        ec2.Instance(self, "Instance",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # Showing the most complex setup, if you have simpler requirements
            # you can use `CloudFormationInit.fromElements()`.
            init=ec2.CloudFormationInit.from_config_sets(
                config_sets={
                    # Applies the configs below in this order
                    "default": ["yumPreinstall", "config"]
                },
                configs={
                    "yum_preinstall": ec2.InitConfig([
                        # Install an Amazon Linux package using yum
                        ec2.InitPackage.yum("git")
                    ]),
                    "config": ec2.InitConfig([
                        # Create a JSON file from tokens (can also create other files)
                        ec2.InitFile.from_object("/etc/stack.json", {
                            "stack_id": Stack.of(self).stack_id,
                            "stack_name": Stack.of(self).stack_name,
                            "region": Stack.of(self).region
                        }),
        
                        # Create a group and user
                        ec2.InitGroup.from_name("my-group"),
                        ec2.InitUser.from_name("my-user"),
        
                        # Install an RPM from the internet
                        ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
                    ])
                }
            ),
            init_options=ec2.ApplyCloudFormationInitOptions(
                # Optional, which configsets to activate (['default'] by default)
                config_sets=["default"],
        
                # Optional, how long the installation is expected to take (5 minutes by default)
                timeout=Duration.minutes(30),
        
                # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
                include_url=True,
        
                # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
                include_role=True
            )
        )
    '''

    def __init__(self, elements: typing.Sequence["InitElement"]) -> None:
        '''
        :param elements: -
        '''
        jsii.create(self.__class__, self, [elements])

    @jsii.member(jsii_name="add")
    def add(self, *elements: "InitElement") -> None:
        '''Add one or more elements to the config.

        :param elements: -
        '''
        return typing.cast(None, jsii.invoke(self, "add", [*elements]))

    @jsii.member(jsii_name="isEmpty")
    def is_empty(self) -> builtins.bool:
        '''Whether this configset has elements or not.'''
        return typing.cast(builtins.bool, jsii.invoke(self, "isEmpty", []))


class InitElement(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.InitElement",
):
    '''Base class for all CloudFormation Init elements.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # my_bucket: s3.Bucket
        
        
        handle = ec2.InitServiceRestartHandle()
        
        ec2.CloudFormationInit.from_elements(
            ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
            ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
            ec2.InitService.enable("nginx",
                service_restart_handle=handle
            ))
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    @abc.abstractmethod
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        ...


class _InitElementProxy(InitElement):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, InitElement).__jsii_proxy_class__ = lambda : _InitElementProxy


class InitFile(
    InitElement,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.InitFile",
):
    '''Create files on the EC2 instance.

    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        autoscaling.AutoScalingGroup(self, "ASG",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # ...
        
            init=ec2.CloudFormationInit.from_elements(
                ec2.InitFile.from_string("/etc/my_instance", "This got written during instance startup")),
            signals=autoscaling.Signals.wait_for_all(
                timeout=Duration.minutes(10)
            )
        )
    '''

    def __init__(
        self,
        file_name: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> None:
        '''
        :param file_name: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        jsii.create(self.__class__, self, [file_name, options])

    @jsii.member(jsii_name="fromAsset") # type: ignore[misc]
    @builtins.classmethod
    def from_asset(
        cls,
        target_file_name: builtins.str,
        path: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
        readers: typing.Optional[typing.Sequence[_IGrantable_71c4f5de]] = None,
        asset_hash: typing.Optional[builtins.str] = None,
        asset_hash_type: typing.Optional[_AssetHashType_05b67f2d] = None,
        bundling: typing.Optional[_BundlingOptions_588cc936] = None,
        exclude: typing.Optional[typing.Sequence[builtins.str]] = None,
        follow_symlinks: typing.Optional[_SymlinkFollowMode_047ec1f6] = None,
        ignore_mode: typing.Optional[_IgnoreMode_655a98e8] = None,
    ) -> "InitFile":
        '''Create an asset from the given file.

        This is appropriate for files that are too large to embed into the template.

        :param target_file_name: -
        :param path: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        :param readers: A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.
        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
        :param exclude: Glob patterns to exclude from the copy. Default: - nothing is excluded
        :param follow_symlinks: A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER
        :param ignore_mode: The ignore behavior to use for exclude patterns. Default: IgnoreMode.GLOB
        '''
        options = InitFileAssetOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
            readers=readers,
            asset_hash=asset_hash,
            asset_hash_type=asset_hash_type,
            bundling=bundling,
            exclude=exclude,
            follow_symlinks=follow_symlinks,
            ignore_mode=ignore_mode,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromAsset", [target_file_name, path, options]))

    @jsii.member(jsii_name="fromExistingAsset") # type: ignore[misc]
    @builtins.classmethod
    def from_existing_asset(
        cls,
        target_file_name: builtins.str,
        asset: _Asset_ac2a7e61,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Use a file from an asset at instance startup time.

        :param target_file_name: -
        :param asset: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromExistingAsset", [target_file_name, asset, options]))

    @jsii.member(jsii_name="fromFileInline") # type: ignore[misc]
    @builtins.classmethod
    def from_file_inline(
        cls,
        target_file_name: builtins.str,
        source_file_name: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Read a file from disk and use its contents.

        The file will be embedded in the template, so care should be taken to not
        exceed the template size.

        If options.base64encoded is set to true, this will base64-encode the file's contents.

        :param target_file_name: -
        :param source_file_name: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromFileInline", [target_file_name, source_file_name, options]))

    @jsii.member(jsii_name="fromObject") # type: ignore[misc]
    @builtins.classmethod
    def from_object(
        cls,
        file_name: builtins.str,
        obj: typing.Mapping[builtins.str, typing.Any],
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Use a JSON-compatible object as the file content, write it to a JSON file.

        May contain tokens.

        :param file_name: -
        :param obj: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromObject", [file_name, obj, options]))

    @jsii.member(jsii_name="fromS3Object") # type: ignore[misc]
    @builtins.classmethod
    def from_s3_object(
        cls,
        file_name: builtins.str,
        bucket: _IBucket_42e086fd,
        key: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Download a file from an S3 bucket at instance startup time.

        :param file_name: -
        :param bucket: -
        :param key: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromS3Object", [file_name, bucket, key, options]))

    @jsii.member(jsii_name="fromString") # type: ignore[misc]
    @builtins.classmethod
    def from_string(
        cls,
        file_name: builtins.str,
        content: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Use a literal string as the file content.

        :param file_name: -
        :param content: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromString", [file_name, content, options]))

    @jsii.member(jsii_name="fromUrl") # type: ignore[misc]
    @builtins.classmethod
    def from_url(
        cls,
        file_name: builtins.str,
        url: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Download from a URL at instance startup time.

        :param file_name: -
        :param url: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "fromUrl", [file_name, url, options]))

    @jsii.member(jsii_name="symlink") # type: ignore[misc]
    @builtins.classmethod
    def symlink(
        cls,
        file_name: builtins.str,
        target: builtins.str,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitFile":
        '''Write a symlink with the given symlink target.

        :param file_name: -
        :param target: -
        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        '''
        options = InitFileOptions(
            base64_encoded=base64_encoded,
            group=group,
            mode=mode,
            owner=owner,
            service_restart_handles=service_restart_handles,
        )

        return typing.cast("InitFile", jsii.sinvoke(cls, "symlink", [file_name, target, options]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


class _InitFileProxy(
    InitFile, jsii.proxy_for(InitElement) # type: ignore[misc]
):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, InitFile).__jsii_proxy_class__ = lambda : _InitFileProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitFileOptions",
    jsii_struct_bases=[],
    name_mapping={
        "base64_encoded": "base64Encoded",
        "group": "group",
        "mode": "mode",
        "owner": "owner",
        "service_restart_handles": "serviceRestartHandles",
    },
)
class InitFileOptions:
    def __init__(
        self,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> None:
        '''Options for InitFile.

        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # my_bucket: s3.Bucket
            
            
            handle = ec2.InitServiceRestartHandle()
            
            ec2.CloudFormationInit.from_elements(
                ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
                ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
                ec2.InitService.enable("nginx",
                    service_restart_handle=handle
                ))
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if base64_encoded is not None:
            self._values["base64_encoded"] = base64_encoded
        if group is not None:
            self._values["group"] = group
        if mode is not None:
            self._values["mode"] = mode
        if owner is not None:
            self._values["owner"] = owner
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles

    @builtins.property
    def base64_encoded(self) -> typing.Optional[builtins.bool]:
        '''True if the inlined content (from a string or file) should be treated as base64 encoded.

        Only applicable for inlined string and file content.

        :default: false
        '''
        result = self._values.get("base64_encoded")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''The name of the owning group for this file.

        Not supported for Windows systems.

        :default: 'root'
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''A six-digit octal value representing the mode for this file.

        Use the first three digits for symlinks and the last three digits for
        setting permissions. To create a symlink, specify 120xxx, where xxx
        defines the permissions of the target file. To specify permissions for a
        file, use the last three digits, such as 000644.

        Not supported for Windows systems.

        :default: '000644'
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def owner(self) -> typing.Optional[builtins.str]:
        '''The name of the owning user for this file.

        Not supported for Windows systems.

        :default: 'root'
        '''
        result = self._values.get("owner")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List["InitServiceRestartHandle"]]:
        '''Restart the given service after this file has been written.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List["InitServiceRestartHandle"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitFileOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InitGroup(
    InitElement,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InitGroup",
):
    '''Create Linux/UNIX groups and assign group IDs.

    Not supported for Windows systems.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        ec2.Instance(self, "Instance",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # Showing the most complex setup, if you have simpler requirements
            # you can use `CloudFormationInit.fromElements()`.
            init=ec2.CloudFormationInit.from_config_sets(
                config_sets={
                    # Applies the configs below in this order
                    "default": ["yumPreinstall", "config"]
                },
                configs={
                    "yum_preinstall": ec2.InitConfig([
                        # Install an Amazon Linux package using yum
                        ec2.InitPackage.yum("git")
                    ]),
                    "config": ec2.InitConfig([
                        # Create a JSON file from tokens (can also create other files)
                        ec2.InitFile.from_object("/etc/stack.json", {
                            "stack_id": Stack.of(self).stack_id,
                            "stack_name": Stack.of(self).stack_name,
                            "region": Stack.of(self).region
                        }),
        
                        # Create a group and user
                        ec2.InitGroup.from_name("my-group"),
                        ec2.InitUser.from_name("my-user"),
        
                        # Install an RPM from the internet
                        ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
                    ])
                }
            ),
            init_options=ec2.ApplyCloudFormationInitOptions(
                # Optional, which configsets to activate (['default'] by default)
                config_sets=["default"],
        
                # Optional, how long the installation is expected to take (5 minutes by default)
                timeout=Duration.minutes(30),
        
                # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
                include_url=True,
        
                # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
                include_role=True
            )
        )
    '''

    def __init__(
        self,
        group_name: builtins.str,
        group_id: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param group_name: -
        :param group_id: -
        '''
        jsii.create(self.__class__, self, [group_name, group_id])

    @jsii.member(jsii_name="fromName") # type: ignore[misc]
    @builtins.classmethod
    def from_name(
        cls,
        group_name: builtins.str,
        group_id: typing.Optional[jsii.Number] = None,
    ) -> "InitGroup":
        '''Create a group from its name, and optionally, group id.

        :param group_name: -
        :param group_id: -
        '''
        return typing.cast("InitGroup", jsii.sinvoke(cls, "fromName", [group_name, group_id]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


class InitPackage(
    InitElement,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InitPackage",
):
    '''A package to be installed during cfn-init time.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        ec2.Instance(self, "Instance",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # Showing the most complex setup, if you have simpler requirements
            # you can use `CloudFormationInit.fromElements()`.
            init=ec2.CloudFormationInit.from_config_sets(
                config_sets={
                    # Applies the configs below in this order
                    "default": ["yumPreinstall", "config"]
                },
                configs={
                    "yum_preinstall": ec2.InitConfig([
                        # Install an Amazon Linux package using yum
                        ec2.InitPackage.yum("git")
                    ]),
                    "config": ec2.InitConfig([
                        # Create a JSON file from tokens (can also create other files)
                        ec2.InitFile.from_object("/etc/stack.json", {
                            "stack_id": Stack.of(self).stack_id,
                            "stack_name": Stack.of(self).stack_name,
                            "region": Stack.of(self).region
                        }),
        
                        # Create a group and user
                        ec2.InitGroup.from_name("my-group"),
                        ec2.InitUser.from_name("my-user"),
        
                        # Install an RPM from the internet
                        ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
                    ])
                }
            ),
            init_options=ec2.ApplyCloudFormationInitOptions(
                # Optional, which configsets to activate (['default'] by default)
                config_sets=["default"],
        
                # Optional, how long the installation is expected to take (5 minutes by default)
                timeout=Duration.minutes(30),
        
                # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
                include_url=True,
        
                # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
                include_role=True
            )
        )
    '''

    def __init__(
        self,
        type: builtins.str,
        versions: typing.Sequence[builtins.str],
        package_name: typing.Optional[builtins.str] = None,
        service_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> None:
        '''
        :param type: -
        :param versions: -
        :param package_name: -
        :param service_handles: -
        '''
        jsii.create(self.__class__, self, [type, versions, package_name, service_handles])

    @jsii.member(jsii_name="apt") # type: ignore[misc]
    @builtins.classmethod
    def apt(
        cls,
        package_name: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
        version: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> "InitPackage":
        '''Install a package using APT.

        :param package_name: -
        :param service_restart_handles: Restart the given services after this command has run. Default: - Do not restart any service
        :param version: Specify the versions to install. Default: - Install the latest version
        '''
        options = NamedPackageOptions(
            service_restart_handles=service_restart_handles, version=version
        )

        return typing.cast("InitPackage", jsii.sinvoke(cls, "apt", [package_name, options]))

    @jsii.member(jsii_name="msi") # type: ignore[misc]
    @builtins.classmethod
    def msi(
        cls,
        location: builtins.str,
        *,
        key: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitPackage":
        '''Install an MSI package from an HTTP URL or a location on disk.

        :param location: -
        :param key: Identifier key for this package. You can use this to order package installs. Default: - Automatically generated
        :param service_restart_handles: Restart the given service after this command has run. Default: - Do not restart any service
        '''
        options = LocationPackageOptions(
            key=key, service_restart_handles=service_restart_handles
        )

        return typing.cast("InitPackage", jsii.sinvoke(cls, "msi", [location, options]))

    @jsii.member(jsii_name="python") # type: ignore[misc]
    @builtins.classmethod
    def python(
        cls,
        package_name: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
        version: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> "InitPackage":
        '''Install a package from PyPI.

        :param package_name: -
        :param service_restart_handles: Restart the given services after this command has run. Default: - Do not restart any service
        :param version: Specify the versions to install. Default: - Install the latest version
        '''
        options = NamedPackageOptions(
            service_restart_handles=service_restart_handles, version=version
        )

        return typing.cast("InitPackage", jsii.sinvoke(cls, "python", [package_name, options]))

    @jsii.member(jsii_name="rpm") # type: ignore[misc]
    @builtins.classmethod
    def rpm(
        cls,
        location: builtins.str,
        *,
        key: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
    ) -> "InitPackage":
        '''Install an RPM from an HTTP URL or a location on disk.

        :param location: -
        :param key: Identifier key for this package. You can use this to order package installs. Default: - Automatically generated
        :param service_restart_handles: Restart the given service after this command has run. Default: - Do not restart any service
        '''
        options = LocationPackageOptions(
            key=key, service_restart_handles=service_restart_handles
        )

        return typing.cast("InitPackage", jsii.sinvoke(cls, "rpm", [location, options]))

    @jsii.member(jsii_name="rubyGem") # type: ignore[misc]
    @builtins.classmethod
    def ruby_gem(
        cls,
        gem_name: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
        version: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> "InitPackage":
        '''Install a package from RubyGems.

        :param gem_name: -
        :param service_restart_handles: Restart the given services after this command has run. Default: - Do not restart any service
        :param version: Specify the versions to install. Default: - Install the latest version
        '''
        options = NamedPackageOptions(
            service_restart_handles=service_restart_handles, version=version
        )

        return typing.cast("InitPackage", jsii.sinvoke(cls, "rubyGem", [gem_name, options]))

    @jsii.member(jsii_name="yum") # type: ignore[misc]
    @builtins.classmethod
    def yum(
        cls,
        package_name: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence["InitServiceRestartHandle"]] = None,
        version: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> "InitPackage":
        '''Install a package using Yum.

        :param package_name: -
        :param service_restart_handles: Restart the given services after this command has run. Default: - Do not restart any service
        :param version: Specify the versions to install. Default: - Install the latest version
        '''
        options = NamedPackageOptions(
            service_restart_handles=service_restart_handles, version=version
        )

        return typing.cast("InitPackage", jsii.sinvoke(cls, "yum", [package_name, options]))

    @jsii.member(jsii_name="renderPackageVersions")
    def _render_package_versions(self) -> typing.Any:
        return typing.cast(typing.Any, jsii.invoke(self, "renderPackageVersions", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


class InitService(
    InitElement,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InitService",
):
    '''A services that be enabled, disabled or restarted when the instance is launched.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # my_bucket: s3.Bucket
        
        
        handle = ec2.InitServiceRestartHandle()
        
        ec2.CloudFormationInit.from_elements(
            ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
            ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
            ec2.InitService.enable("nginx",
                service_restart_handle=handle
            ))
    '''

    @jsii.member(jsii_name="disable") # type: ignore[misc]
    @builtins.classmethod
    def disable(cls, service_name: builtins.str) -> "InitService":
        '''Disable and stop the given service.

        :param service_name: -
        '''
        return typing.cast("InitService", jsii.sinvoke(cls, "disable", [service_name]))

    @jsii.member(jsii_name="enable") # type: ignore[misc]
    @builtins.classmethod
    def enable(
        cls,
        service_name: builtins.str,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        ensure_running: typing.Optional[builtins.bool] = None,
        service_restart_handle: typing.Optional["InitServiceRestartHandle"] = None,
    ) -> "InitService":
        '''Enable and start the given service, optionally restarting it.

        :param service_name: -
        :param enabled: Enable or disable this service. Set to true to ensure that the service will be started automatically upon boot. Set to false to ensure that the service will not be started automatically upon boot. Default: - true if used in ``InitService.enable()``, no change to service state if used in ``InitService.fromOptions()``.
        :param ensure_running: Make sure this service is running or not running after cfn-init finishes. Set to true to ensure that the service is running after cfn-init finishes. Set to false to ensure that the service is not running after cfn-init finishes. Default: - same value as ``enabled``.
        :param service_restart_handle: Restart service when the actions registered into the restartHandle have been performed. Register actions into the restartHandle by passing it to ``InitFile``, ``InitCommand``, ``InitPackage`` and ``InitSource`` objects. Default: - No files trigger restart
        '''
        options = InitServiceOptions(
            enabled=enabled,
            ensure_running=ensure_running,
            service_restart_handle=service_restart_handle,
        )

        return typing.cast("InitService", jsii.sinvoke(cls, "enable", [service_name, options]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitServiceOptions",
    jsii_struct_bases=[],
    name_mapping={
        "enabled": "enabled",
        "ensure_running": "ensureRunning",
        "service_restart_handle": "serviceRestartHandle",
    },
)
class InitServiceOptions:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        ensure_running: typing.Optional[builtins.bool] = None,
        service_restart_handle: typing.Optional["InitServiceRestartHandle"] = None,
    ) -> None:
        '''Options for an InitService.

        :param enabled: Enable or disable this service. Set to true to ensure that the service will be started automatically upon boot. Set to false to ensure that the service will not be started automatically upon boot. Default: - true if used in ``InitService.enable()``, no change to service state if used in ``InitService.fromOptions()``.
        :param ensure_running: Make sure this service is running or not running after cfn-init finishes. Set to true to ensure that the service is running after cfn-init finishes. Set to false to ensure that the service is not running after cfn-init finishes. Default: - same value as ``enabled``.
        :param service_restart_handle: Restart service when the actions registered into the restartHandle have been performed. Register actions into the restartHandle by passing it to ``InitFile``, ``InitCommand``, ``InitPackage`` and ``InitSource`` objects. Default: - No files trigger restart

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # my_bucket: s3.Bucket
            
            
            handle = ec2.InitServiceRestartHandle()
            
            ec2.CloudFormationInit.from_elements(
                ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
                ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
                ec2.InitService.enable("nginx",
                    service_restart_handle=handle
                ))
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if ensure_running is not None:
            self._values["ensure_running"] = ensure_running
        if service_restart_handle is not None:
            self._values["service_restart_handle"] = service_restart_handle

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable this service.

        Set to true to ensure that the service will be started automatically upon boot.

        Set to false to ensure that the service will not be started automatically upon boot.

        :default:

        - true if used in ``InitService.enable()``, no change to service
        state if used in ``InitService.fromOptions()``.
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ensure_running(self) -> typing.Optional[builtins.bool]:
        '''Make sure this service is running or not running after cfn-init finishes.

        Set to true to ensure that the service is running after cfn-init finishes.

        Set to false to ensure that the service is not running after cfn-init finishes.

        :default: - same value as ``enabled``.
        '''
        result = self._values.get("ensure_running")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def service_restart_handle(self) -> typing.Optional["InitServiceRestartHandle"]:
        '''Restart service when the actions registered into the restartHandle have been performed.

        Register actions into the restartHandle by passing it to ``InitFile``, ``InitCommand``,
        ``InitPackage`` and ``InitSource`` objects.

        :default: - No files trigger restart
        '''
        result = self._values.get("service_restart_handle")
        return typing.cast(typing.Optional["InitServiceRestartHandle"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitServiceOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InitServiceRestartHandle(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InitServiceRestartHandle",
):
    '''An object that represents reasons to restart an InitService.

    Pass an instance of this object to the ``InitFile``, ``InitCommand``,
    ``InitSource`` and ``InitPackage`` objects, and finally to an ``InitService``
    itself to cause the actions (files, commands, sources, and packages)
    to trigger a restart of the service.

    For example, the following will run a custom command to install Nginx,
    and trigger the nginx service to be restarted after the command has run::

       # Example automatically generated from non-compiling source. May contain errors.
       handle = ec2.InitServiceRestartHandle()
       ec2.CloudFormationInit.from_elements(
           ec2.InitCommand.shell_command("/usr/bin/custom-nginx-install.sh", service_restart_handles=[handle]),
           ec2.InitService.enable("nginx", service_restart_handle=handle))

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # my_bucket: s3.Bucket
        
        
        handle = ec2.InitServiceRestartHandle()
        
        ec2.CloudFormationInit.from_elements(
            ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
            ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
            ec2.InitService.enable("nginx",
                service_restart_handle=handle
            ))
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


class InitSource(
    InitElement,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.InitSource",
):
    '''Extract an archive into a directory.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # my_bucket: s3.Bucket
        
        
        handle = ec2.InitServiceRestartHandle()
        
        ec2.CloudFormationInit.from_elements(
            ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
            ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
            ec2.InitService.enable("nginx",
                service_restart_handle=handle
            ))
    '''

    def __init__(
        self,
        target_directory: builtins.str,
        service_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> None:
        '''
        :param target_directory: -
        :param service_handles: -
        '''
        jsii.create(self.__class__, self, [target_directory, service_handles])

    @jsii.member(jsii_name="fromAsset") # type: ignore[misc]
    @builtins.classmethod
    def from_asset(
        cls,
        target_directory: builtins.str,
        path: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
        readers: typing.Optional[typing.Sequence[_IGrantable_71c4f5de]] = None,
        asset_hash: typing.Optional[builtins.str] = None,
        asset_hash_type: typing.Optional[_AssetHashType_05b67f2d] = None,
        bundling: typing.Optional[_BundlingOptions_588cc936] = None,
        exclude: typing.Optional[typing.Sequence[builtins.str]] = None,
        follow_symlinks: typing.Optional[_SymlinkFollowMode_047ec1f6] = None,
        ignore_mode: typing.Optional[_IgnoreMode_655a98e8] = None,
    ) -> "InitSource":
        '''Create an InitSource from an asset created from the given path.

        :param target_directory: -
        :param path: -
        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service
        :param readers: A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.
        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
        :param exclude: Glob patterns to exclude from the copy. Default: - nothing is excluded
        :param follow_symlinks: A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER
        :param ignore_mode: The ignore behavior to use for exclude patterns. Default: IgnoreMode.GLOB
        '''
        options = InitSourceAssetOptions(
            service_restart_handles=service_restart_handles,
            readers=readers,
            asset_hash=asset_hash,
            asset_hash_type=asset_hash_type,
            bundling=bundling,
            exclude=exclude,
            follow_symlinks=follow_symlinks,
            ignore_mode=ignore_mode,
        )

        return typing.cast("InitSource", jsii.sinvoke(cls, "fromAsset", [target_directory, path, options]))

    @jsii.member(jsii_name="fromExistingAsset") # type: ignore[misc]
    @builtins.classmethod
    def from_existing_asset(
        cls,
        target_directory: builtins.str,
        asset: _Asset_ac2a7e61,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> "InitSource":
        '''Extract a directory from an existing directory asset.

        :param target_directory: -
        :param asset: -
        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service
        '''
        options = InitSourceOptions(service_restart_handles=service_restart_handles)

        return typing.cast("InitSource", jsii.sinvoke(cls, "fromExistingAsset", [target_directory, asset, options]))

    @jsii.member(jsii_name="fromGitHub") # type: ignore[misc]
    @builtins.classmethod
    def from_git_hub(
        cls,
        target_directory: builtins.str,
        owner: builtins.str,
        repo: builtins.str,
        ref_spec: typing.Optional[builtins.str] = None,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> "InitSource":
        '''Extract a GitHub branch into a given directory.

        :param target_directory: -
        :param owner: -
        :param repo: -
        :param ref_spec: -
        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service
        '''
        options = InitSourceOptions(service_restart_handles=service_restart_handles)

        return typing.cast("InitSource", jsii.sinvoke(cls, "fromGitHub", [target_directory, owner, repo, ref_spec, options]))

    @jsii.member(jsii_name="fromS3Object") # type: ignore[misc]
    @builtins.classmethod
    def from_s3_object(
        cls,
        target_directory: builtins.str,
        bucket: _IBucket_42e086fd,
        key: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> "InitSource":
        '''Extract an archive stored in an S3 bucket into the given directory.

        :param target_directory: -
        :param bucket: -
        :param key: -
        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service
        '''
        options = InitSourceOptions(service_restart_handles=service_restart_handles)

        return typing.cast("InitSource", jsii.sinvoke(cls, "fromS3Object", [target_directory, bucket, key, options]))

    @jsii.member(jsii_name="fromUrl") # type: ignore[misc]
    @builtins.classmethod
    def from_url(
        cls,
        target_directory: builtins.str,
        url: builtins.str,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> "InitSource":
        '''Retrieve a URL and extract it into the given directory.

        :param target_directory: -
        :param url: -
        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service
        '''
        options = InitSourceOptions(service_restart_handles=service_restart_handles)

        return typing.cast("InitSource", jsii.sinvoke(cls, "fromUrl", [target_directory, url, options]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


class _InitSourceProxy(
    InitSource, jsii.proxy_for(InitElement) # type: ignore[misc]
):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, InitSource).__jsii_proxy_class__ = lambda : _InitSourceProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitSourceOptions",
    jsii_struct_bases=[],
    name_mapping={"service_restart_handles": "serviceRestartHandles"},
)
class InitSourceOptions:
    def __init__(
        self,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> None:
        '''Additional options for an InitSource.

        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # my_bucket: s3.Bucket
            
            
            handle = ec2.InitServiceRestartHandle()
            
            ec2.CloudFormationInit.from_elements(
                ec2.InitFile.from_string("/etc/nginx/nginx.conf", "...", service_restart_handles=[handle]),
                ec2.InitSource.from_s3_object("/var/www/html", my_bucket, "html.zip", service_restart_handles=[handle]),
                ec2.InitService.enable("nginx",
                    service_restart_handle=handle
                ))
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List[InitServiceRestartHandle]]:
        '''Restart the given services after this archive has been extracted.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List[InitServiceRestartHandle]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitSourceOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class InitUser(
    InitElement,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InitUser",
):
    '''Create Linux/UNIX users and to assign user IDs.

    Users are created as non-interactive system users with a shell of
    /sbin/nologin. This is by design and cannot be modified.

    Not supported for Windows systems.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        ec2.Instance(self, "Instance",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # Showing the most complex setup, if you have simpler requirements
            # you can use `CloudFormationInit.fromElements()`.
            init=ec2.CloudFormationInit.from_config_sets(
                config_sets={
                    # Applies the configs below in this order
                    "default": ["yumPreinstall", "config"]
                },
                configs={
                    "yum_preinstall": ec2.InitConfig([
                        # Install an Amazon Linux package using yum
                        ec2.InitPackage.yum("git")
                    ]),
                    "config": ec2.InitConfig([
                        # Create a JSON file from tokens (can also create other files)
                        ec2.InitFile.from_object("/etc/stack.json", {
                            "stack_id": Stack.of(self).stack_id,
                            "stack_name": Stack.of(self).stack_name,
                            "region": Stack.of(self).region
                        }),
        
                        # Create a group and user
                        ec2.InitGroup.from_name("my-group"),
                        ec2.InitUser.from_name("my-user"),
        
                        # Install an RPM from the internet
                        ec2.InitPackage.rpm("http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm")
                    ])
                }
            ),
            init_options=ec2.ApplyCloudFormationInitOptions(
                # Optional, which configsets to activate (['default'] by default)
                config_sets=["default"],
        
                # Optional, how long the installation is expected to take (5 minutes by default)
                timeout=Duration.minutes(30),
        
                # Optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)
                include_url=True,
        
                # Optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)
                include_role=True
            )
        )
    '''

    def __init__(
        self,
        user_name: builtins.str,
        *,
        groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        home_dir: typing.Optional[builtins.str] = None,
        user_id: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param user_name: -
        :param groups: A list of group names. The user will be added to each group in the list. Default: the user is not associated with any groups.
        :param home_dir: The user's home directory. Default: assigned by the OS
        :param user_id: A user ID. The creation process fails if the user name exists with a different user ID. If the user ID is already assigned to an existing user the operating system may reject the creation request. Default: assigned by the OS
        '''
        user_options = InitUserOptions(
            groups=groups, home_dir=home_dir, user_id=user_id
        )

        jsii.create(self.__class__, self, [user_name, user_options])

    @jsii.member(jsii_name="fromName") # type: ignore[misc]
    @builtins.classmethod
    def from_name(
        cls,
        user_name: builtins.str,
        *,
        groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        home_dir: typing.Optional[builtins.str] = None,
        user_id: typing.Optional[jsii.Number] = None,
    ) -> "InitUser":
        '''Create a user from user name.

        :param user_name: -
        :param groups: A list of group names. The user will be added to each group in the list. Default: the user is not associated with any groups.
        :param home_dir: The user's home directory. Default: assigned by the OS
        :param user_id: A user ID. The creation process fails if the user name exists with a different user ID. If the user ID is already assigned to an existing user the operating system may reject the creation request. Default: assigned by the OS
        '''
        options = InitUserOptions(groups=groups, home_dir=home_dir, user_id=user_id)

        return typing.cast("InitUser", jsii.sinvoke(cls, "fromName", [user_name, options]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitUserOptions",
    jsii_struct_bases=[],
    name_mapping={"groups": "groups", "home_dir": "homeDir", "user_id": "userId"},
)
class InitUserOptions:
    def __init__(
        self,
        *,
        groups: typing.Optional[typing.Sequence[builtins.str]] = None,
        home_dir: typing.Optional[builtins.str] = None,
        user_id: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Optional parameters used when creating a user.

        :param groups: A list of group names. The user will be added to each group in the list. Default: the user is not associated with any groups.
        :param home_dir: The user's home directory. Default: assigned by the OS
        :param user_id: A user ID. The creation process fails if the user name exists with a different user ID. If the user ID is already assigned to an existing user the operating system may reject the creation request. Default: assigned by the OS

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            init_user_options = ec2.InitUserOptions(
                groups=["groups"],
                home_dir="homeDir",
                user_id=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if groups is not None:
            self._values["groups"] = groups
        if home_dir is not None:
            self._values["home_dir"] = home_dir
        if user_id is not None:
            self._values["user_id"] = user_id

    @builtins.property
    def groups(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of group names.

        The user will be added to each group in the list.

        :default: the user is not associated with any groups.
        '''
        result = self._values.get("groups")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def home_dir(self) -> typing.Optional[builtins.str]:
        '''The user's home directory.

        :default: assigned by the OS
        '''
        result = self._values.get("home_dir")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def user_id(self) -> typing.Optional[jsii.Number]:
        '''A user ID.

        The creation process fails if the user name exists with a different user ID.
        If the user ID is already assigned to an existing user the operating system may
        reject the creation request.

        :default: assigned by the OS
        '''
        result = self._values.get("user_id")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitUserOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IInstance)
class Instance(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.Instance",
):
    '''This represents a single EC2 instance.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        from aws_cdk.aws_kms import Key
        
        # vpc: ec2.Vpc
        # instance_type: ec2.InstanceType
        # machine_image: ec2.IMachineImage
        
        
        kms_key = Key(self, "KmsKey")
        
        ec2.Instance(self, "Instance",
            vpc=vpc,
            instance_type=instance_type,
            machine_image=machine_image,
        
            # ...
        
            block_devices=[ec2.BlockDevice(
                device_name="/dev/sda1",
                volume=ec2.BlockDeviceVolume.ebs(50,
                    encrypted=True,
                    kms_key=kms_key
                )
            )
            ]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        instance_type: "InstanceType",
        machine_image: IMachineImage,
        vpc: IVpc,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        block_devices: typing.Optional[typing.Sequence[BlockDevice]] = None,
        init: typing.Optional[CloudFormationInit] = None,
        init_options: typing.Optional[ApplyCloudFormationInitOptions] = None,
        instance_name: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        propagate_tags_to_volume_on_creation: typing.Optional[builtins.bool] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        resource_signal_timeout: typing.Optional[_Duration_4839e8c3] = None,
        role: typing.Optional[_IRole_235f5d8e] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
        source_dest_check: typing.Optional[builtins.bool] = None,
        user_data: typing.Optional["UserData"] = None,
        user_data_causes_replacement: typing.Optional[builtins.bool] = None,
        vpc_subnets: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance_type: Type of instance to launch.
        :param machine_image: AMI to launch.
        :param vpc: VPC to launch the instance in.
        :param allow_all_outbound: Whether the instance could initiate connections to anywhere by default. This property is only used when you do not provide a security group. Default: true
        :param availability_zone: In which AZ to place the instance within the VPC. Default: - Random zone.
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param init: Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init
        :param init_options: Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options
        :param instance_name: The name of the instance. Default: - CDK generated name
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param private_ip_address: Defines a private IP address to associate with an instance. Private IP should be available within the VPC that the instance is build within. Default: - no association
        :param propagate_tags_to_volume_on_creation: Propagate the EC2 instance tags to the EBS volumes. Default: - false
        :param require_imdsv2: Whether IMDSv2 should be required on this instance. Default: - false
        :param resource_signal_timeout: The length of time to wait for the resourceSignalCount. The maximum value is 43200 (12 hours). Default: Duration.minutes(5)
        :param role: An IAM role to associate with the instance profile assigned to this Auto Scaling Group. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - A role will automatically be created, it can be accessed via the ``role`` property
        :param security_group: Security Group to assign to this instance. Default: - create new security group
        :param source_dest_check: Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means that checking is enabled, and false means that checking is disabled. The value must be false for the instance to perform NAT. Default: true
        :param user_data: Specific UserData to use. The UserData may still be mutated after creation. Default: - A UserData object appropriate for the MachineImage's Operating System is created.
        :param user_data_causes_replacement: Changes to the UserData force replacement. Depending the EC2 instance type, changing UserData either restarts the instance or replaces the instance. - Instance store-backed instances are replaced. - EBS-backed instances are restarted. By default, restarting does not execute the new UserData so you will need a different mechanism to ensure the instance is restarted. Setting this to ``true`` will make the instance's Logical ID depend on the UserData, which will cause CloudFormation to replace it if the UserData changes. Default: - true iff ``initOptions`` is specified, false otherwise.
        :param vpc_subnets: Where to place the instance within the VPC. Default: - Private subnets.
        '''
        props = InstanceProps(
            instance_type=instance_type,
            machine_image=machine_image,
            vpc=vpc,
            allow_all_outbound=allow_all_outbound,
            availability_zone=availability_zone,
            block_devices=block_devices,
            init=init,
            init_options=init_options,
            instance_name=instance_name,
            key_name=key_name,
            private_ip_address=private_ip_address,
            propagate_tags_to_volume_on_creation=propagate_tags_to_volume_on_creation,
            require_imdsv2=require_imdsv2,
            resource_signal_timeout=resource_signal_timeout,
            role=role,
            security_group=security_group,
            source_dest_check=source_dest_check,
            user_data=user_data,
            user_data_causes_replacement=user_data_causes_replacement,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSecurityGroup")
    def add_security_group(self, security_group: ISecurityGroup) -> None:
        '''Add the security group to the instance.

        :param security_group: : The security group to add.
        '''
        return typing.cast(None, jsii.invoke(self, "addSecurityGroup", [security_group]))

    @jsii.member(jsii_name="addToRolePolicy")
    def add_to_role_policy(self, statement: _PolicyStatement_0fe33853) -> None:
        '''Adds a statement to the IAM role assumed by the instance.

        :param statement: -
        '''
        return typing.cast(None, jsii.invoke(self, "addToRolePolicy", [statement]))

    @jsii.member(jsii_name="addUserData")
    def add_user_data(self, *commands: builtins.str) -> None:
        '''Add command to the startup script of the instance.

        The command must be in the scripting language supported by the instance's OS (i.e. Linux/Windows).

        :param commands: -
        '''
        return typing.cast(None, jsii.invoke(self, "addUserData", [*commands]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''Allows specify security group connections for the instance.'''
        return typing.cast("Connections", jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="grantPrincipal")
    def grant_principal(self) -> _IPrincipal_539bb2fd:
        '''The principal to grant permissions to.'''
        return typing.cast(_IPrincipal_539bb2fd, jsii.get(self, "grantPrincipal"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instance")
    def instance(self) -> CfnInstance:
        '''the underlying instance resource.'''
        return typing.cast(CfnInstance, jsii.get(self, "instance"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceAvailabilityZone")
    def instance_availability_zone(self) -> builtins.str:
        '''The availability zone the instance was launched in.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        '''The instance's ID.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateDnsName")
    def instance_private_dns_name(self) -> builtins.str:
        '''Private DNS name for this instance.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePrivateDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateIp")
    def instance_private_ip(self) -> builtins.str:
        '''Private IP for this instance.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePrivateIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicDnsName")
    def instance_public_dns_name(self) -> builtins.str:
        '''Publicly-routable DNS name for this instance.

        (May be an empty string if the instance does not have a public name).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePublicDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicIp")
    def instance_public_ip(self) -> builtins.str:
        '''Publicly-routable IP  address for this instance.

        (May be an empty string if the instance does not have a public IP).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePublicIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="osType")
    def os_type(self) -> "OperatingSystemType":
        '''The type of OS the instance is running.'''
        return typing.cast("OperatingSystemType", jsii.get(self, "osType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="role")
    def role(self) -> _IRole_235f5d8e:
        '''The IAM role assumed by the instance.'''
        return typing.cast(_IRole_235f5d8e, jsii.get(self, "role"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userData")
    def user_data(self) -> "UserData":
        '''UserData for the instance.'''
        return typing.cast("UserData", jsii.get(self, "userData"))


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.InstanceArchitecture")
class InstanceArchitecture(enum.Enum):
    '''Identifies an instance's CPU architecture.'''

    ARM_64 = "ARM_64"
    '''ARM64 architecture.'''
    X86_64 = "X86_64"
    '''x86-64 architecture.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.InstanceClass")
class InstanceClass(enum.Enum):
    '''What class and generation of instance to use.

    We have both symbolic and concrete enums for every type.

    The first are for people that want to specify by purpose,
    the second one are for people who already know exactly what
    'R4' means.

    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        # source_instance: rds.DatabaseInstance
        
        rds.DatabaseInstanceFromSnapshot(self, "Instance",
            snapshot_identifier="my-snapshot",
            engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
            # optional, defaults to m5.large
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
        rds.DatabaseInstanceReadReplica(self, "ReadReplica",
            source_database_instance=source_instance,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
    '''

    STANDARD3 = "STANDARD3"
    '''Standard instances, 3rd generation.'''
    STANDARD4 = "STANDARD4"
    '''Standard instances, 4th generation.'''
    STANDARD5 = "STANDARD5"
    '''Standard instances, 5th generation.'''
    STANDARD5_NVME_DRIVE = "STANDARD5_NVME_DRIVE"
    '''Standard instances with local NVME drive, 5th generation.'''
    STANDARD5_AMD = "STANDARD5_AMD"
    '''Standard instances based on AMD EPYC, 5th generation.'''
    STANDARD5_AMD_NVME_DRIVE = "STANDARD5_AMD_NVME_DRIVE"
    '''Standard instances based on AMD EPYC with local NVME drive, 5th generation.'''
    STANDARD5_HIGH_PERFORMANCE = "STANDARD5_HIGH_PERFORMANCE"
    '''Standard instances for high performance computing, 5th generation.'''
    STANDARD5_NVME_DRIVE_HIGH_PERFORMANCE = "STANDARD5_NVME_DRIVE_HIGH_PERFORMANCE"
    '''Standard instances with local NVME drive for high performance computing, 5th generation.'''
    STANDARD5_HIGH_COMPUTE = "STANDARD5_HIGH_COMPUTE"
    '''Standard instances with high memory and compute capacity based on Intel Xeon Scalable (Cascade Lake) processors, 5nd generation.'''
    MEMORY3 = "MEMORY3"
    '''Memory optimized instances, 3rd generation.'''
    MEMORY4 = "MEMORY4"
    '''Memory optimized instances, 4th generation.'''
    MEMORY5 = "MEMORY5"
    '''Memory optimized instances, 5th generation.'''
    MEMORY6_INTEL = "MEMORY6_INTEL"
    '''Memory optimized instances, 6th generation with Intel Xeon Scalable processors (3rd generation processors code named Ice Lake).'''
    MEMORY5_HIGH_PERFORMANCE = "MEMORY5_HIGH_PERFORMANCE"
    '''Memory optimized instances for high performance computing, 5th generation.'''
    MEMORY5_NVME_DRIVE = "MEMORY5_NVME_DRIVE"
    '''Memory optimized instances with local NVME drive, 5th generation.'''
    MEMORY5_NVME_DRIVE_HIGH_PERFORMANCE = "MEMORY5_NVME_DRIVE_HIGH_PERFORMANCE"
    '''Memory optimized instances with local NVME drive for high performance computing, 5th generation.'''
    MEMORY5_AMD = "MEMORY5_AMD"
    '''Memory optimized instances based on AMD EPYC, 5th generation.'''
    MEMORY5_AMD_NVME_DRIVE = "MEMORY5_AMD_NVME_DRIVE"
    '''Memory optimized instances based on AMD EPYC with local NVME drive, 5th generation.'''
    HIGH_MEMORY_6TB_1 = "HIGH_MEMORY_6TB_1"
    '''High memory instances (6TB) based on Intel Xeon Platinum 8176M (Skylake) processors, 1st generation.'''
    HIGH_MEMORY_9TB_1 = "HIGH_MEMORY_9TB_1"
    '''High memory instances (9TB) based on Intel Xeon Platinum 8176M (Skylake) processors, 1st generation.'''
    HIGH_MEMORY_12TB_1 = "HIGH_MEMORY_12TB_1"
    '''High memory instances (12TB) based on Intel Xeon Platinum 8176M (Skylake) processors, 1st generation.'''
    HIGH_MEMORY_18TB_1 = "HIGH_MEMORY_18TB_1"
    '''High memory instances (18TB) based on Intel Xeon Scalable (Cascade Lake) processors, 1st generation.'''
    HIGH_MEMORY_24TB_1 = "HIGH_MEMORY_24TB_1"
    '''High memory instances (24TB) based on Intel Xeon Scalable (Cascade Lake) processors, 1st generation.'''
    MEMORY5_EBS_OPTIMIZED = "MEMORY5_EBS_OPTIMIZED"
    '''Memory optimized instances that are also EBS-optimized, 5th generation.'''
    MEMORY6_GRAVITON = "MEMORY6_GRAVITON"
    '''Memory optimized instances, 6th generation with Graviton2 processors.'''
    MEMORY6_GRAVITON2_NVME_DRIVE = "MEMORY6_GRAVITON2_NVME_DRIVE"
    '''Memory optimized instances, 6th generation with Graviton2 processors and local NVME drive.'''
    COMPUTE3 = "COMPUTE3"
    '''Compute optimized instances, 3rd generation.'''
    COMPUTE4 = "COMPUTE4"
    '''Compute optimized instances, 4th generation.'''
    COMPUTE5 = "COMPUTE5"
    '''Compute optimized instances, 5th generation.'''
    COMPUTE5_NVME_DRIVE = "COMPUTE5_NVME_DRIVE"
    '''Compute optimized instances with local NVME drive, 5th generation.'''
    COMPUTE5_AMD = "COMPUTE5_AMD"
    '''Compute optimized instances based on AMD EPYC, 5th generation.'''
    COMPUTE5_AMD_NVME_DRIVE = "COMPUTE5_AMD_NVME_DRIVE"
    '''Compute optimized instances with local NVME drive based on AMD EPYC, 5th generation.'''
    COMPUTE5_HIGH_PERFORMANCE = "COMPUTE5_HIGH_PERFORMANCE"
    '''Compute optimized instances for high performance computing, 5th generation.'''
    COMPUTE6_INTEL = "COMPUTE6_INTEL"
    '''Compute optimized instances, 6th generation.'''
    COMPUTE6_AMD = "COMPUTE6_AMD"
    '''Compute optimized instances based on AMD EPYC (codename Milan), 6th generation.'''
    COMPUTE6_GRAVITON2 = "COMPUTE6_GRAVITON2"
    '''Compute optimized instances for high performance computing, 6th generation with Graviton2 processors.'''
    COMPUTE6_GRAVITON2_NVME_DRIVE = "COMPUTE6_GRAVITON2_NVME_DRIVE"
    '''Compute optimized instances for high performance computing, 6th generation with Graviton2 processors and local NVME drive.'''
    COMPUTE6_GRAVITON2_HIGH_NETWORK_BANDWITH = "COMPUTE6_GRAVITON2_HIGH_NETWORK_BANDWITH"
    '''Compute optimized instances for high performance computing, 6th generation with Graviton2 processors and high network bandwidth capabilities.'''
    STORAGE2 = "STORAGE2"
    '''Storage-optimized instances, 2nd generation.'''
    STORAGE3 = "STORAGE3"
    '''Storage-optimized instances, 3rd generation.'''
    STORAGE3_ENHANCED_NETWORK = "STORAGE3_ENHANCED_NETWORK"
    '''Storage-optimized instances, 3rd generation.'''
    STORAGE_COMPUTE_1 = "STORAGE_COMPUTE_1"
    '''Storage/compute balanced instances, 1st generation.'''
    IO3 = "IO3"
    '''I/O-optimized instances, 3rd generation.'''
    IO3_DENSE_NVME_DRIVE = "IO3_DENSE_NVME_DRIVE"
    '''I/O-optimized instances with local NVME drive, 3rd generation.'''
    STORAGE4_GRAVITON_NETWORK_OPTIMIZED = "STORAGE4_GRAVITON_NETWORK_OPTIMIZED"
    '''Storage optimized instances powered by Graviton2 processor, 4th generation.'''
    STORAGE4_GRAVITON_NETWORK_STORAGE_OPTIMIZED = "STORAGE4_GRAVITON_NETWORK_STORAGE_OPTIMIZED"
    '''Storage optimized instances powered by Graviton2 processor, 4th generation.'''
    BURSTABLE2 = "BURSTABLE2"
    '''Burstable instances, 2nd generation.'''
    BURSTABLE3 = "BURSTABLE3"
    '''Burstable instances, 3rd generation.'''
    BURSTABLE3_AMD = "BURSTABLE3_AMD"
    '''Burstable instances based on AMD EPYC, 3rd generation.'''
    BURSTABLE4_GRAVITON = "BURSTABLE4_GRAVITON"
    '''Burstable instances, 4th generation with Graviton2 processors.'''
    MEMORY_INTENSIVE_1 = "MEMORY_INTENSIVE_1"
    '''Memory-intensive instances, 1st generation.'''
    MEMORY_INTENSIVE_1_EXTENDED = "MEMORY_INTENSIVE_1_EXTENDED"
    '''Memory-intensive instances, extended, 1st generation.'''
    MEMORY_INTENSIVE_2_GRAVITON2 = "MEMORY_INTENSIVE_2_GRAVITON2"
    '''Memory-intensive instances, 2nd generation with Graviton2 processors.

    This instance type can be used only in RDS. It is not supported in EC2.
    '''
    MEMORY_INTENSIVE_2_GRAVITON2_NVME_DRIVE = "MEMORY_INTENSIVE_2_GRAVITON2_NVME_DRIVE"
    '''Memory-intensive instances, 2nd generation with Graviton2 processors and local NVME drive.'''
    FPGA1 = "FPGA1"
    '''Instances with customizable hardware acceleration, 1st generation.'''
    GRAPHICS3 = "GRAPHICS3"
    '''Graphics-optimized instances, 3rd generation.'''
    GRAPHICS4_NVME_DRIVE_HIGH_PERFORMANCE = "GRAPHICS4_NVME_DRIVE_HIGH_PERFORMANCE"
    '''Graphics-optimized instances with NVME drive for high performance computing, 4th generation.'''
    GRAPHICS4_AMD_NVME_DRIVE = "GRAPHICS4_AMD_NVME_DRIVE"
    '''Graphics-optimized instances based on AMD EPYC And Radeon Pro GPU (NAVI) with local NVME drive, 4th generation.'''
    GRAPHICS5 = "GRAPHICS5"
    '''Graphics-optimized instances, 5th generation.'''
    GRAPHICS5_GRAVITON2 = "GRAPHICS5_GRAVITON2"
    '''Graphics-optimized instances powered by AWS Graviton2 Processors and NVIDIA T4G Tensor Core GPUs, 5th generation.'''
    PARALLEL2 = "PARALLEL2"
    '''Parallel-processing optimized instances, 2nd generation.'''
    PARALLEL3 = "PARALLEL3"
    '''Parallel-processing optimized instances, 3nd generation.'''
    PARALLEL4 = "PARALLEL4"
    '''Parallel-processing optimized instances, 4th generation.'''
    ARM1 = "ARM1"
    '''Arm processor based instances, 1st generation.'''
    STANDARD6_GRAVITON = "STANDARD6_GRAVITON"
    '''Arm processor based instances, 2nd generation.'''
    STANDARD6_INTEL = "STANDARD6_INTEL"
    '''Standard instances based on Intel (Ice Lake), 6th generation.'''
    STANDARD6_AMD = "STANDARD6_AMD"
    '''Standard instances based on 3rd Gen AMD EPYC processors, 6th generation.'''
    STANDARD6_GRAVITON2_NVME_DRIVE = "STANDARD6_GRAVITON2_NVME_DRIVE"
    '''Standard instances, 6th generation with Graviton2 processors and local NVME drive.'''
    HIGH_COMPUTE_MEMORY1 = "HIGH_COMPUTE_MEMORY1"
    '''High memory and compute capacity instances, 1st generation.'''
    INFERENCE1 = "INFERENCE1"
    '''Inferentia Chips based instances for machine learning inference applications, 1st generation.'''
    MACINTOSH1_INTEL = "MACINTOSH1_INTEL"
    '''Macintosh instances built on Apple Mac mini computers, 1st generation with Intel procesors.'''
    VIDEO_TRANSCODING1 = "VIDEO_TRANSCODING1"
    '''Multi-stream video transcoding instances for resolutions up to 4K UHD, 1st generation.'''
    HIGH_PERFORMANCE_COMPUTING6_AMD = "HIGH_PERFORMANCE_COMPUTING6_AMD"
    '''High performance computing based on AMD EPYC, 6th generation.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.InstanceInitiatedShutdownBehavior")
class InstanceInitiatedShutdownBehavior(enum.Enum):
    '''Provides the options for specifying the instance initiated shutdown behavior.

    :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#Using_ChangingInstanceInitiatedShutdownBehavior
    '''

    STOP = "STOP"
    '''The instance will stop when it initiates a shutdown.'''
    TERMINATE = "TERMINATE"
    '''The instance will be terminated when it initiates a shutdown.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "instance_type": "instanceType",
        "machine_image": "machineImage",
        "vpc": "vpc",
        "allow_all_outbound": "allowAllOutbound",
        "availability_zone": "availabilityZone",
        "block_devices": "blockDevices",
        "init": "init",
        "init_options": "initOptions",
        "instance_name": "instanceName",
        "key_name": "keyName",
        "private_ip_address": "privateIpAddress",
        "propagate_tags_to_volume_on_creation": "propagateTagsToVolumeOnCreation",
        "require_imdsv2": "requireImdsv2",
        "resource_signal_timeout": "resourceSignalTimeout",
        "role": "role",
        "security_group": "securityGroup",
        "source_dest_check": "sourceDestCheck",
        "user_data": "userData",
        "user_data_causes_replacement": "userDataCausesReplacement",
        "vpc_subnets": "vpcSubnets",
    },
)
class InstanceProps:
    def __init__(
        self,
        *,
        instance_type: "InstanceType",
        machine_image: IMachineImage,
        vpc: IVpc,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        block_devices: typing.Optional[typing.Sequence[BlockDevice]] = None,
        init: typing.Optional[CloudFormationInit] = None,
        init_options: typing.Optional[ApplyCloudFormationInitOptions] = None,
        instance_name: typing.Optional[builtins.str] = None,
        key_name: typing.Optional[builtins.str] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        propagate_tags_to_volume_on_creation: typing.Optional[builtins.bool] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        resource_signal_timeout: typing.Optional[_Duration_4839e8c3] = None,
        role: typing.Optional[_IRole_235f5d8e] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
        source_dest_check: typing.Optional[builtins.bool] = None,
        user_data: typing.Optional["UserData"] = None,
        user_data_causes_replacement: typing.Optional[builtins.bool] = None,
        vpc_subnets: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''Properties of an EC2 Instance.

        :param instance_type: Type of instance to launch.
        :param machine_image: AMI to launch.
        :param vpc: VPC to launch the instance in.
        :param allow_all_outbound: Whether the instance could initiate connections to anywhere by default. This property is only used when you do not provide a security group. Default: true
        :param availability_zone: In which AZ to place the instance within the VPC. Default: - Random zone.
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param init: Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init
        :param init_options: Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options
        :param instance_name: The name of the instance. Default: - CDK generated name
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param private_ip_address: Defines a private IP address to associate with an instance. Private IP should be available within the VPC that the instance is build within. Default: - no association
        :param propagate_tags_to_volume_on_creation: Propagate the EC2 instance tags to the EBS volumes. Default: - false
        :param require_imdsv2: Whether IMDSv2 should be required on this instance. Default: - false
        :param resource_signal_timeout: The length of time to wait for the resourceSignalCount. The maximum value is 43200 (12 hours). Default: Duration.minutes(5)
        :param role: An IAM role to associate with the instance profile assigned to this Auto Scaling Group. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - A role will automatically be created, it can be accessed via the ``role`` property
        :param security_group: Security Group to assign to this instance. Default: - create new security group
        :param source_dest_check: Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means that checking is enabled, and false means that checking is disabled. The value must be false for the instance to perform NAT. Default: true
        :param user_data: Specific UserData to use. The UserData may still be mutated after creation. Default: - A UserData object appropriate for the MachineImage's Operating System is created.
        :param user_data_causes_replacement: Changes to the UserData force replacement. Depending the EC2 instance type, changing UserData either restarts the instance or replaces the instance. - Instance store-backed instances are replaced. - EBS-backed instances are restarted. By default, restarting does not execute the new UserData so you will need a different mechanism to ensure the instance is restarted. Setting this to ``true`` will make the instance's Logical ID depend on the UserData, which will cause CloudFormation to replace it if the UserData changes. Default: - true iff ``initOptions`` is specified, false otherwise.
        :param vpc_subnets: Where to place the instance within the VPC. Default: - Private subnets.

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            from aws_cdk.aws_kms import Key
            
            # vpc: ec2.Vpc
            # instance_type: ec2.InstanceType
            # machine_image: ec2.IMachineImage
            
            
            kms_key = Key(self, "KmsKey")
            
            ec2.Instance(self, "Instance",
                vpc=vpc,
                instance_type=instance_type,
                machine_image=machine_image,
            
                # ...
            
                block_devices=[ec2.BlockDevice(
                    device_name="/dev/sda1",
                    volume=ec2.BlockDeviceVolume.ebs(50,
                        encrypted=True,
                        kms_key=kms_key
                    )
                )
                ]
            )
        '''
        if isinstance(init_options, dict):
            init_options = ApplyCloudFormationInitOptions(**init_options)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = SubnetSelection(**vpc_subnets)
        self._values: typing.Dict[str, typing.Any] = {
            "instance_type": instance_type,
            "machine_image": machine_image,
            "vpc": vpc,
        }
        if allow_all_outbound is not None:
            self._values["allow_all_outbound"] = allow_all_outbound
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if block_devices is not None:
            self._values["block_devices"] = block_devices
        if init is not None:
            self._values["init"] = init
        if init_options is not None:
            self._values["init_options"] = init_options
        if instance_name is not None:
            self._values["instance_name"] = instance_name
        if key_name is not None:
            self._values["key_name"] = key_name
        if private_ip_address is not None:
            self._values["private_ip_address"] = private_ip_address
        if propagate_tags_to_volume_on_creation is not None:
            self._values["propagate_tags_to_volume_on_creation"] = propagate_tags_to_volume_on_creation
        if require_imdsv2 is not None:
            self._values["require_imdsv2"] = require_imdsv2
        if resource_signal_timeout is not None:
            self._values["resource_signal_timeout"] = resource_signal_timeout
        if role is not None:
            self._values["role"] = role
        if security_group is not None:
            self._values["security_group"] = security_group
        if source_dest_check is not None:
            self._values["source_dest_check"] = source_dest_check
        if user_data is not None:
            self._values["user_data"] = user_data
        if user_data_causes_replacement is not None:
            self._values["user_data_causes_replacement"] = user_data_causes_replacement
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def instance_type(self) -> "InstanceType":
        '''Type of instance to launch.'''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast("InstanceType", result)

    @builtins.property
    def machine_image(self) -> IMachineImage:
        '''AMI to launch.'''
        result = self._values.get("machine_image")
        assert result is not None, "Required property 'machine_image' is missing"
        return typing.cast(IMachineImage, result)

    @builtins.property
    def vpc(self) -> IVpc:
        '''VPC to launch the instance in.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(IVpc, result)

    @builtins.property
    def allow_all_outbound(self) -> typing.Optional[builtins.bool]:
        '''Whether the instance could initiate connections to anywhere by default.

        This property is only used when you do not provide a security group.

        :default: true
        '''
        result = self._values.get("allow_all_outbound")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''In which AZ to place the instance within the VPC.

        :default: - Random zone.
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def block_devices(self) -> typing.Optional[typing.List[BlockDevice]]:
        '''Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes.

        Each instance that is launched has an associated root device volume,
        either an Amazon EBS volume or an instance store volume.
        You can use block device mappings to specify additional EBS volumes or
        instance store volumes to attach to an instance when it is launched.

        :default: - Uses the block device mapping of the AMI

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html
        '''
        result = self._values.get("block_devices")
        return typing.cast(typing.Optional[typing.List[BlockDevice]], result)

    @builtins.property
    def init(self) -> typing.Optional[CloudFormationInit]:
        '''Apply the given CloudFormation Init configuration to the instance at startup.

        :default: - no CloudFormation init
        '''
        result = self._values.get("init")
        return typing.cast(typing.Optional[CloudFormationInit], result)

    @builtins.property
    def init_options(self) -> typing.Optional[ApplyCloudFormationInitOptions]:
        '''Use the given options for applying CloudFormation Init.

        Describes the configsets to use and the timeout to wait

        :default: - default options
        '''
        result = self._values.get("init_options")
        return typing.cast(typing.Optional[ApplyCloudFormationInitOptions], result)

    @builtins.property
    def instance_name(self) -> typing.Optional[builtins.str]:
        '''The name of the instance.

        :default: - CDK generated name
        '''
        result = self._values.get("instance_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''Name of SSH keypair to grant access to instance.

        :default: - No SSH access will be possible.
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def private_ip_address(self) -> typing.Optional[builtins.str]:
        '''Defines a private IP address to associate with an instance.

        Private IP should be available within the VPC that the instance is build within.

        :default: - no association
        '''
        result = self._values.get("private_ip_address")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def propagate_tags_to_volume_on_creation(self) -> typing.Optional[builtins.bool]:
        '''Propagate the EC2 instance tags to the EBS volumes.

        :default: - false
        '''
        result = self._values.get("propagate_tags_to_volume_on_creation")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def require_imdsv2(self) -> typing.Optional[builtins.bool]:
        '''Whether IMDSv2 should be required on this instance.

        :default: - false
        '''
        result = self._values.get("require_imdsv2")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def resource_signal_timeout(self) -> typing.Optional[_Duration_4839e8c3]:
        '''The length of time to wait for the resourceSignalCount.

        The maximum value is 43200 (12 hours).

        :default: Duration.minutes(5)
        '''
        result = self._values.get("resource_signal_timeout")
        return typing.cast(typing.Optional[_Duration_4839e8c3], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_235f5d8e]:
        '''An IAM role to associate with the instance profile assigned to this Auto Scaling Group.

        The role must be assumable by the service principal ``ec2.amazonaws.com``:

        :default: - A role will automatically be created, it can be accessed via the ``role`` property

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            role = iam.Role(self, "MyRole",
                assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")
            )
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_235f5d8e], result)

    @builtins.property
    def security_group(self) -> typing.Optional[ISecurityGroup]:
        '''Security Group to assign to this instance.

        :default: - create new security group
        '''
        result = self._values.get("security_group")
        return typing.cast(typing.Optional[ISecurityGroup], result)

    @builtins.property
    def source_dest_check(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether to enable an instance launched in a VPC to perform NAT.

        This controls whether source/destination checking is enabled on the instance.
        A value of true means that checking is enabled, and false means that checking is disabled.
        The value must be false for the instance to perform NAT.

        :default: true
        '''
        result = self._values.get("source_dest_check")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''Specific UserData to use.

        The UserData may still be mutated after creation.

        :default:

        - A UserData object appropriate for the MachineImage's
        Operating System is created.
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    @builtins.property
    def user_data_causes_replacement(self) -> typing.Optional[builtins.bool]:
        '''Changes to the UserData force replacement.

        Depending the EC2 instance type, changing UserData either
        restarts the instance or replaces the instance.

        - Instance store-backed instances are replaced.
        - EBS-backed instances are restarted.

        By default, restarting does not execute the new UserData so you
        will need a different mechanism to ensure the instance is restarted.

        Setting this to ``true`` will make the instance's Logical ID depend on the
        UserData, which will cause CloudFormation to replace it if the UserData
        changes.

        :default: - true iff ``initOptions`` is specified, false otherwise.
        '''
        result = self._values.get("user_data_causes_replacement")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional["SubnetSelection"]:
        '''Where to place the instance within the VPC.

        :default: - Private subnets.
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IAspect_118c810a)
class InstanceRequireImdsv2Aspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InstanceRequireImdsv2Aspect",
):
    '''Aspect that applies IMDS configuration on EC2 Instance constructs.

    This aspect configures IMDS on an EC2 instance by creating a Launch Template with the
    IMDS configuration and associating that Launch Template with the instance. If an Instance
    is already associated with a Launch Template, a warning will (optionally) be added to the
    construct node and it will be skipped.

    To cover Instances already associated with Launch Templates, use ``LaunchTemplateImdsAspect``.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        aspect = ec2.InstanceRequireImdsv2Aspect()
        Aspects.of(self).add(aspect)
    '''

    def __init__(
        self,
        *,
        suppress_launch_template_warning: typing.Optional[builtins.bool] = None,
        suppress_warnings: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param suppress_launch_template_warning: Whether warnings that would be raised when an Instance is associated with an existing Launch Template should be suppressed or not. You can set this to ``true`` if ``LaunchTemplateImdsAspect`` is being used alongside this Aspect to suppress false-positive warnings because any Launch Templates associated with Instances will still be covered. Default: - false
        :param suppress_warnings: Whether warning annotations from this Aspect should be suppressed or not. Default: - false
        '''
        props = InstanceRequireImdsv2AspectProps(
            suppress_launch_template_warning=suppress_launch_template_warning,
            suppress_warnings=suppress_warnings,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: constructs.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        return typing.cast(None, jsii.invoke(self, "visit", [node]))

    @jsii.member(jsii_name="warn")
    def _warn(self, node: constructs.IConstruct, message: builtins.str) -> None:
        '''Adds a warning annotation to a node, unless ``suppressWarnings`` is true.

        :param node: -
        :param message: -
        '''
        return typing.cast(None, jsii.invoke(self, "warn", [node, message]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="suppressWarnings")
    def _suppress_warnings(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "suppressWarnings"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InstanceRequireImdsv2AspectProps",
    jsii_struct_bases=[],
    name_mapping={
        "suppress_launch_template_warning": "suppressLaunchTemplateWarning",
        "suppress_warnings": "suppressWarnings",
    },
)
class InstanceRequireImdsv2AspectProps:
    def __init__(
        self,
        *,
        suppress_launch_template_warning: typing.Optional[builtins.bool] = None,
        suppress_warnings: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Properties for ``InstanceRequireImdsv2Aspect``.

        :param suppress_launch_template_warning: Whether warnings that would be raised when an Instance is associated with an existing Launch Template should be suppressed or not. You can set this to ``true`` if ``LaunchTemplateImdsAspect`` is being used alongside this Aspect to suppress false-positive warnings because any Launch Templates associated with Instances will still be covered. Default: - false
        :param suppress_warnings: Whether warning annotations from this Aspect should be suppressed or not. Default: - false

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            instance_require_imdsv2_aspect_props = ec2.InstanceRequireImdsv2AspectProps(
                suppress_launch_template_warning=False,
                suppress_warnings=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if suppress_launch_template_warning is not None:
            self._values["suppress_launch_template_warning"] = suppress_launch_template_warning
        if suppress_warnings is not None:
            self._values["suppress_warnings"] = suppress_warnings

    @builtins.property
    def suppress_launch_template_warning(self) -> typing.Optional[builtins.bool]:
        '''Whether warnings that would be raised when an Instance is associated with an existing Launch Template should be suppressed or not.

        You can set this to ``true`` if ``LaunchTemplateImdsAspect`` is being used alongside this Aspect to
        suppress false-positive warnings because any Launch Templates associated with Instances will still be covered.

        :default: - false
        '''
        result = self._values.get("suppress_launch_template_warning")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def suppress_warnings(self) -> typing.Optional[builtins.bool]:
        '''Whether warning annotations from this Aspect should be suppressed or not.

        :default: - false
        '''
        result = self._values.get("suppress_warnings")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InstanceRequireImdsv2AspectProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.InstanceSize")
class InstanceSize(enum.Enum):
    '''What size of instance to use.

    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        # source_instance: rds.DatabaseInstance
        
        rds.DatabaseInstanceFromSnapshot(self, "Instance",
            snapshot_identifier="my-snapshot",
            engine=rds.DatabaseInstanceEngine.postgres(version=rds.PostgresEngineVersion.VER_12_3),
            # optional, defaults to m5.large
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
        rds.DatabaseInstanceReadReplica(self, "ReadReplica",
            source_database_instance=source_instance,
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.BURSTABLE2, ec2.InstanceSize.LARGE),
            vpc=vpc
        )
    '''

    NANO = "NANO"
    '''Instance size NANO (nano).'''
    MICRO = "MICRO"
    '''Instance size MICRO (micro).'''
    SMALL = "SMALL"
    '''Instance size SMALL (small).'''
    MEDIUM = "MEDIUM"
    '''Instance size MEDIUM (medium).'''
    LARGE = "LARGE"
    '''Instance size LARGE (large).'''
    XLARGE = "XLARGE"
    '''Instance size XLARGE (xlarge).'''
    XLARGE2 = "XLARGE2"
    '''Instance size XLARGE2 (2xlarge).'''
    XLARGE3 = "XLARGE3"
    '''Instance size XLARGE3 (3xlarge).'''
    XLARGE4 = "XLARGE4"
    '''Instance size XLARGE4 (4xlarge).'''
    XLARGE6 = "XLARGE6"
    '''Instance size XLARGE6 (6xlarge).'''
    XLARGE8 = "XLARGE8"
    '''Instance size XLARGE8 (8xlarge).'''
    XLARGE9 = "XLARGE9"
    '''Instance size XLARGE9 (9xlarge).'''
    XLARGE10 = "XLARGE10"
    '''Instance size XLARGE10 (10xlarge).'''
    XLARGE12 = "XLARGE12"
    '''Instance size XLARGE12 (12xlarge).'''
    XLARGE16 = "XLARGE16"
    '''Instance size XLARGE16 (16xlarge).'''
    XLARGE18 = "XLARGE18"
    '''Instance size XLARGE18 (18xlarge).'''
    XLARGE24 = "XLARGE24"
    '''Instance size XLARGE24 (24xlarge).'''
    XLARGE32 = "XLARGE32"
    '''Instance size XLARGE32 (32xlarge).'''
    XLARGE48 = "XLARGE48"
    '''Instance size XLARGE48 (48xlarge).'''
    XLARGE56 = "XLARGE56"
    '''Instance size XLARGE56 (56xlarge).'''
    XLARGE112 = "XLARGE112"
    '''Instance size XLARGE56 (112xlarge).'''
    METAL = "METAL"
    '''Instance size METAL (metal).'''


class InstanceType(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InstanceType",
):
    '''Instance type for EC2 instances.

    This class takes a literal string, good if you already
    know the identifier of the type you want.

    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        cluster = docdb.DatabaseCluster(self, "Database",
            master_user=docdb.Login(
                username="myuser",  # NOTE: 'admin' is reserved by DocumentDB
                exclude_characters="\"@/:",  # optional, defaults to the set "\"@/" and is also used for eventually created rotations
                secret_name="/myapp/mydocdb/masteruser"
            ),
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.R5, ec2.InstanceSize.LARGE),
            vpc_subnets=ec2.SubnetSelection(
                subnet_type=ec2.SubnetType.PUBLIC
            ),
            vpc=vpc
        )
    '''

    def __init__(self, instance_type_identifier: builtins.str) -> None:
        '''
        :param instance_type_identifier: -
        '''
        jsii.create(self.__class__, self, [instance_type_identifier])

    @jsii.member(jsii_name="of") # type: ignore[misc]
    @builtins.classmethod
    def of(
        cls,
        instance_class: InstanceClass,
        instance_size: InstanceSize,
    ) -> "InstanceType":
        '''Instance type for EC2 instances.

        This class takes a combination of a class and size.

        Be aware that not all combinations of class and size are available, and not all
        classes are available in all regions.

        :param instance_class: -
        :param instance_size: -
        '''
        return typing.cast("InstanceType", jsii.sinvoke(cls, "of", [instance_class, instance_size]))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        '''Return the instance type as a dotted string.'''
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="architecture")
    def architecture(self) -> InstanceArchitecture:
        '''The instance's CPU architecture.'''
        return typing.cast(InstanceArchitecture, jsii.get(self, "architecture"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InterfaceVpcEndpointAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "port": "port",
        "vpc_endpoint_id": "vpcEndpointId",
        "security_groups": "securityGroups",
    },
)
class InterfaceVpcEndpointAttributes:
    def __init__(
        self,
        *,
        port: jsii.Number,
        vpc_endpoint_id: builtins.str,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
    ) -> None:
        '''Construction properties for an ImportedInterfaceVpcEndpoint.

        :param port: The port of the service of the interface VPC endpoint.
        :param vpc_endpoint_id: The interface VPC endpoint identifier.
        :param security_groups: The security groups associated with the interface VPC endpoint.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # security_group: ec2.SecurityGroup
            
            interface_vpc_endpoint_attributes = ec2.InterfaceVpcEndpointAttributes(
                port=123,
                vpc_endpoint_id="vpcEndpointId",
            
                # the properties below are optional
                security_groups=[security_group]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "port": port,
            "vpc_endpoint_id": vpc_endpoint_id,
        }
        if security_groups is not None:
            self._values["security_groups"] = security_groups

    @builtins.property
    def port(self) -> jsii.Number:
        '''The port of the service of the interface VPC endpoint.'''
        result = self._values.get("port")
        assert result is not None, "Required property 'port' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def vpc_endpoint_id(self) -> builtins.str:
        '''The interface VPC endpoint identifier.'''
        result = self._values.get("vpc_endpoint_id")
        assert result is not None, "Required property 'vpc_endpoint_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[ISecurityGroup]]:
        '''The security groups associated with the interface VPC endpoint.'''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[ISecurityGroup]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InterfaceVpcEndpointAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IInterfaceVpcEndpointService)
class InterfaceVpcEndpointAwsService(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InterfaceVpcEndpointAwsService",
):
    '''An AWS service for an interface VPC endpoint.

    :exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused

    Example::

        # Add gateway endpoints when creating the VPC
        vpc = ec2.Vpc(self, "MyVpc",
            gateway_endpoints={
                "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(
                    service=ec2.GatewayVpcEndpointAwsService.S3
                )
            }
        )
        
        # Alternatively gateway endpoints can be added on the VPC
        dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",
            service=ec2.GatewayVpcEndpointAwsService.DYNAMODB
        )
        
        # This allows to customize the endpoint policy
        dynamo_db_endpoint.add_to_policy(
            iam.PolicyStatement( # Restrict to listing and describing tables
                principals=[iam.AnyPrincipal()],
                actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],
                resources=["*"]))
        
        # Add an interface endpoint
        vpc.add_interface_endpoint("EcrDockerEndpoint",
            service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER
        )
    '''

    def __init__(
        self,
        name: builtins.str,
        prefix: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param name: -
        :param prefix: -
        :param port: -
        '''
        jsii.create(self.__class__, self, [name, prefix, port])

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="APIGATEWAY")
    def APIGATEWAY(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "APIGATEWAY"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ATHENA")
    def ATHENA(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ATHENA"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CLOUDFORMATION")
    def CLOUDFORMATION(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CLOUDFORMATION"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CLOUDTRAIL")
    def CLOUDTRAIL(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CLOUDTRAIL"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CLOUDWATCH")
    def CLOUDWATCH(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CLOUDWATCH"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CLOUDWATCH_EVENTS")
    def CLOUDWATCH_EVENTS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CLOUDWATCH_EVENTS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CLOUDWATCH_LOGS")
    def CLOUDWATCH_LOGS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CLOUDWATCH_LOGS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODEBUILD")
    def CODEBUILD(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODEBUILD"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODEBUILD_FIPS")
    def CODEBUILD_FIPS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODEBUILD_FIPS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODECOMMIT")
    def CODECOMMIT(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODECOMMIT"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODECOMMIT_FIPS")
    def CODECOMMIT_FIPS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODECOMMIT_FIPS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODECOMMIT_GIT")
    def CODECOMMIT_GIT(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODECOMMIT_GIT"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODECOMMIT_GIT_FIPS")
    def CODECOMMIT_GIT_FIPS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODECOMMIT_GIT_FIPS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODEGURU_PROFILER")
    def CODEGURU_PROFILER(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODEGURU_PROFILER"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODEGURU_REVIEWER")
    def CODEGURU_REVIEWER(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODEGURU_REVIEWER"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CODEPIPELINE")
    def CODEPIPELINE(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CODEPIPELINE"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CONFIG")
    def CONFIG(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "CONFIG"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="EC2")
    def EC2(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "EC2"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="EC2_MESSAGES")
    def EC2_MESSAGES(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "EC2_MESSAGES"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ECR")
    def ECR(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ECR"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ECR_DOCKER")
    def ECR_DOCKER(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ECR_DOCKER"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ECS")
    def ECS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ECS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ECS_AGENT")
    def ECS_AGENT(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ECS_AGENT"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ECS_TELEMETRY")
    def ECS_TELEMETRY(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ECS_TELEMETRY"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ELASTIC_FILESYSTEM")
    def ELASTIC_FILESYSTEM(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ELASTIC_FILESYSTEM"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ELASTIC_FILESYSTEM_FIPS")
    def ELASTIC_FILESYSTEM_FIPS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ELASTIC_FILESYSTEM_FIPS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ELASTIC_INFERENCE_RUNTIME")
    def ELASTIC_INFERENCE_RUNTIME(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ELASTIC_INFERENCE_RUNTIME"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="ELASTIC_LOAD_BALANCING")
    def ELASTIC_LOAD_BALANCING(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "ELASTIC_LOAD_BALANCING"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="GLUE")
    def GLUE(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "GLUE"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="KEYSPACES")
    def KEYSPACES(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "KEYSPACES"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="KINESIS_FIREHOSE")
    def KINESIS_FIREHOSE(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "KINESIS_FIREHOSE"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="KINESIS_STREAMS")
    def KINESIS_STREAMS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "KINESIS_STREAMS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="KMS")
    def KMS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "KMS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="LAMBDA")
    def LAMBDA_(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "LAMBDA"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="RDS")
    def RDS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "RDS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="RDS_DATA")
    def RDS_DATA(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "RDS_DATA"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="REKOGNITION")
    def REKOGNITION(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "REKOGNITION"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="REKOGNITION_FIPS")
    def REKOGNITION_FIPS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "REKOGNITION_FIPS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SAGEMAKER_API")
    def SAGEMAKER_API(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SAGEMAKER_API"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SAGEMAKER_NOTEBOOK")
    def SAGEMAKER_NOTEBOOK(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SAGEMAKER_NOTEBOOK"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SAGEMAKER_RUNTIME")
    def SAGEMAKER_RUNTIME(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SAGEMAKER_RUNTIME"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SAGEMAKER_RUNTIME_FIPS")
    def SAGEMAKER_RUNTIME_FIPS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SAGEMAKER_RUNTIME_FIPS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SECRETS_MANAGER")
    def SECRETS_MANAGER(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SECRETS_MANAGER"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SERVICE_CATALOG")
    def SERVICE_CATALOG(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SERVICE_CATALOG"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SNS")
    def SNS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SNS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SQS")
    def SQS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SQS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SSM")
    def SSM(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SSM"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SSM_MESSAGES")
    def SSM_MESSAGES(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "SSM_MESSAGES"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="STEP_FUNCTIONS")
    def STEP_FUNCTIONS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "STEP_FUNCTIONS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="STORAGE_GATEWAY")
    def STORAGE_GATEWAY(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "STORAGE_GATEWAY"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="STS")
    def STS(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "STS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="TRANSCRIBE")
    def TRANSCRIBE(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "TRANSCRIBE"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="TRANSFER")
    def TRANSFER(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "TRANSFER"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="XRAY")
    def XRAY(cls) -> "InterfaceVpcEndpointAwsService":
        return typing.cast("InterfaceVpcEndpointAwsService", jsii.sget(cls, "XRAY"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        '''The port of the service.'''
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsDefault")
    def private_dns_default(self) -> typing.Optional[builtins.bool]:
        '''Whether Private DNS is supported by default.'''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "privateDnsDefault"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InterfaceVpcEndpointOptions",
    jsii_struct_bases=[],
    name_mapping={
        "service": "service",
        "lookup_supported_azs": "lookupSupportedAzs",
        "open": "open",
        "private_dns_enabled": "privateDnsEnabled",
        "security_groups": "securityGroups",
        "subnets": "subnets",
    },
)
class InterfaceVpcEndpointOptions:
    def __init__(
        self,
        *,
        service: IInterfaceVpcEndpointService,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        subnets: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''Options to add an interface endpoint to a VPC.

        :param service: The service to use for this interface VPC endpoint.
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets

        :exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused

        Example::

            # Add gateway endpoints when creating the VPC
            vpc = ec2.Vpc(self, "MyVpc",
                gateway_endpoints={
                    "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(
                        service=ec2.GatewayVpcEndpointAwsService.S3
                    )
                }
            )
            
            # Alternatively gateway endpoints can be added on the VPC
            dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",
                service=ec2.GatewayVpcEndpointAwsService.DYNAMODB
            )
            
            # This allows to customize the endpoint policy
            dynamo_db_endpoint.add_to_policy(
                iam.PolicyStatement( # Restrict to listing and describing tables
                    principals=[iam.AnyPrincipal()],
                    actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],
                    resources=["*"]))
            
            # Add an interface endpoint
            vpc.add_interface_endpoint("EcrDockerEndpoint",
                service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER
            )
        '''
        if isinstance(subnets, dict):
            subnets = SubnetSelection(**subnets)
        self._values: typing.Dict[str, typing.Any] = {
            "service": service,
        }
        if lookup_supported_azs is not None:
            self._values["lookup_supported_azs"] = lookup_supported_azs
        if open is not None:
            self._values["open"] = open
        if private_dns_enabled is not None:
            self._values["private_dns_enabled"] = private_dns_enabled
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def service(self) -> IInterfaceVpcEndpointService:
        '''The service to use for this interface VPC endpoint.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(IInterfaceVpcEndpointService, result)

    @builtins.property
    def lookup_supported_azs(self) -> typing.Optional[builtins.bool]:
        '''Limit to only those availability zones where the endpoint service can be created.

        Setting this to 'true' requires a lookup to be performed at synthesis time. Account
        and region must be set on the containing stack for this to work.

        :default: false
        '''
        result = self._values.get("lookup_supported_azs")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def open(self) -> typing.Optional[builtins.bool]:
        '''Whether to automatically allow VPC traffic to the endpoint.

        If enabled, all traffic to the endpoint from within the VPC will be
        automatically allowed. This is done based on the VPC's CIDR range.

        :default: true
        '''
        result = self._values.get("open")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def private_dns_enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether to associate a private hosted zone with the specified VPC.

        This
        allows you to make requests to the service using its default DNS hostname.

        :default:

        set by the instance of IInterfaceVpcEndpointService, or true if
        not defined by the instance of IInterfaceVpcEndpointService
        '''
        result = self._values.get("private_dns_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[ISecurityGroup]]:
        '''The security groups to associate with this interface VPC endpoint.

        :default: - a new security group is created
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[ISecurityGroup]], result)

    @builtins.property
    def subnets(self) -> typing.Optional["SubnetSelection"]:
        '''The subnets in which to create an endpoint network interface.

        At most one
        per availability zone.

        :default: - private subnets
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InterfaceVpcEndpointOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InterfaceVpcEndpointProps",
    jsii_struct_bases=[InterfaceVpcEndpointOptions],
    name_mapping={
        "service": "service",
        "lookup_supported_azs": "lookupSupportedAzs",
        "open": "open",
        "private_dns_enabled": "privateDnsEnabled",
        "security_groups": "securityGroups",
        "subnets": "subnets",
        "vpc": "vpc",
    },
)
class InterfaceVpcEndpointProps(InterfaceVpcEndpointOptions):
    def __init__(
        self,
        *,
        service: IInterfaceVpcEndpointService,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        subnets: typing.Optional["SubnetSelection"] = None,
        vpc: IVpc,
    ) -> None:
        '''Construction properties for an InterfaceVpcEndpoint.

        :param service: The service to use for this interface VPC endpoint.
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets
        :param vpc: The VPC network in which the interface endpoint will be used.

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            
            
            ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
                vpc=vpc,
                service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
                # Choose which availability zones to place the VPC endpoint in, based on
                # available AZs
                subnets=ec2.SubnetSelection(
                    availability_zones=["us-east-1a", "us-east-1c"]
                )
            )
        '''
        if isinstance(subnets, dict):
            subnets = SubnetSelection(**subnets)
        self._values: typing.Dict[str, typing.Any] = {
            "service": service,
            "vpc": vpc,
        }
        if lookup_supported_azs is not None:
            self._values["lookup_supported_azs"] = lookup_supported_azs
        if open is not None:
            self._values["open"] = open
        if private_dns_enabled is not None:
            self._values["private_dns_enabled"] = private_dns_enabled
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def service(self) -> IInterfaceVpcEndpointService:
        '''The service to use for this interface VPC endpoint.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(IInterfaceVpcEndpointService, result)

    @builtins.property
    def lookup_supported_azs(self) -> typing.Optional[builtins.bool]:
        '''Limit to only those availability zones where the endpoint service can be created.

        Setting this to 'true' requires a lookup to be performed at synthesis time. Account
        and region must be set on the containing stack for this to work.

        :default: false
        '''
        result = self._values.get("lookup_supported_azs")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def open(self) -> typing.Optional[builtins.bool]:
        '''Whether to automatically allow VPC traffic to the endpoint.

        If enabled, all traffic to the endpoint from within the VPC will be
        automatically allowed. This is done based on the VPC's CIDR range.

        :default: true
        '''
        result = self._values.get("open")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def private_dns_enabled(self) -> typing.Optional[builtins.bool]:
        '''Whether to associate a private hosted zone with the specified VPC.

        This
        allows you to make requests to the service using its default DNS hostname.

        :default:

        set by the instance of IInterfaceVpcEndpointService, or true if
        not defined by the instance of IInterfaceVpcEndpointService
        '''
        result = self._values.get("private_dns_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def security_groups(self) -> typing.Optional[typing.List[ISecurityGroup]]:
        '''The security groups to associate with this interface VPC endpoint.

        :default: - a new security group is created
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[ISecurityGroup]], result)

    @builtins.property
    def subnets(self) -> typing.Optional["SubnetSelection"]:
        '''The subnets in which to create an endpoint network interface.

        At most one
        per availability zone.

        :default: - private subnets
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    @builtins.property
    def vpc(self) -> IVpc:
        '''The VPC network in which the interface endpoint will be used.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(IVpc, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InterfaceVpcEndpointProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IInterfaceVpcEndpointService)
class InterfaceVpcEndpointService(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InterfaceVpcEndpointService",
):
    '''A custom-hosted service for an interface VPC endpoint.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
            vpc=vpc,
            service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
            # Choose which availability zones to place the VPC endpoint in, based on
            # available AZs
            subnets=ec2.SubnetSelection(
                availability_zones=["us-east-1a", "us-east-1c"]
            )
        )
    '''

    def __init__(
        self,
        name: builtins.str,
        port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param name: -
        :param port: -
        '''
        jsii.create(self.__class__, self, [name, port])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="port")
    def port(self) -> jsii.Number:
        '''The port of the service.'''
        return typing.cast(jsii.Number, jsii.get(self, "port"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateDnsDefault")
    def private_dns_default(self) -> typing.Optional[builtins.bool]:
        '''Whether Private DNS is supported by default.'''
        return typing.cast(typing.Optional[builtins.bool], jsii.get(self, "privateDnsDefault"))


@jsii.implements(ILaunchTemplate, _IGrantable_71c4f5de, IConnectable)
class LaunchTemplate(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplate",
):
    '''This represents an EC2 LaunchTemplate.

    :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html
    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        boot_hook_conf = ec2.UserData.for_linux()
        boot_hook_conf.add_commands("cloud-init-per once docker_options echo 'OPTIONS=\"${OPTIONS} --storage-opt dm.basesize=40G\"' >> /etc/sysconfig/docker")
        
        setup_commands = ec2.UserData.for_linux()
        setup_commands.add_commands("sudo yum install awscli && echo Packages installed ã‚‰ã¨ > /var/tmp/setup")
        
        multipart_user_data = ec2.MultipartUserData()
        # The docker has to be configured at early stage, so content type is overridden to boothook
        multipart_user_data.add_part(ec2.MultipartBody.from_user_data(boot_hook_conf, "text/cloud-boothook; charset=\"us-ascii\""))
        # Execute the rest of setup
        multipart_user_data.add_part(ec2.MultipartBody.from_user_data(setup_commands))
        
        ec2.LaunchTemplate(self, "",
            user_data=multipart_user_data,
            block_devices=[]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        block_devices: typing.Optional[typing.Sequence[BlockDevice]] = None,
        cpu_credits: typing.Optional[CpuCredits] = None,
        detailed_monitoring: typing.Optional[builtins.bool] = None,
        disable_api_termination: typing.Optional[builtins.bool] = None,
        ebs_optimized: typing.Optional[builtins.bool] = None,
        hibernation_configured: typing.Optional[builtins.bool] = None,
        instance_initiated_shutdown_behavior: typing.Optional[InstanceInitiatedShutdownBehavior] = None,
        instance_type: typing.Optional[InstanceType] = None,
        key_name: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        machine_image: typing.Optional[IMachineImage] = None,
        nitro_enclave_enabled: typing.Optional[builtins.bool] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_235f5d8e] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
        spot_options: typing.Optional["LaunchTemplateSpotOptions"] = None,
        user_data: typing.Optional["UserData"] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param cpu_credits: CPU credit type for burstable EC2 instance types. Default: - No credit type is specified in the Launch Template.
        :param detailed_monitoring: If set to true, then detailed monitoring will be enabled on instances created with this launch template. Default: False - Detailed monitoring is disabled.
        :param disable_api_termination: If you set this parameter to true, you cannot terminate the instances launched with this launch template using the Amazon EC2 console, CLI, or API; otherwise, you can. Default: - The API termination setting is not specified in the Launch Template.
        :param ebs_optimized: Indicates whether the instances are optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: - EBS optimization is not specified in the launch template.
        :param hibernation_configured: If you set this parameter to true, the instance is enabled for hibernation. Default: - Hibernation configuration is not specified in the launch template; defaulting to false.
        :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: - Shutdown behavior is not specified in the launch template; defaults to STOP.
        :param instance_type: Type of instance to launch. Default: - This Launch Template does not specify a default Instance Type.
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param launch_template_name: Name for this launch template. Default: Automatically generated name
        :param machine_image: The AMI that will be used by instances. Default: - This Launch Template does not specify a default AMI.
        :param nitro_enclave_enabled: If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves. Default: - Enablement of Nitro enclaves is not specified in the launch template; defaulting to false.
        :param require_imdsv2: Whether IMDSv2 should be required on launched instances. Default: - false
        :param role: An IAM role to associate with the instance profile that is used by instances. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - No new role is created.
        :param security_group: Security group to assign to instances created with the launch template. Default: No security group is assigned.
        :param spot_options: If this property is defined, then the Launch Template's InstanceMarketOptions will be set to use Spot instances, and the options for the Spot instances will be as defined. Default: - Instance launched with this template will not be spot instances.
        :param user_data: The AMI that will be used by instances. Default: - This Launch Template creates a UserData based on the type of provided machineImage; no UserData is created if a machineImage is not provided
        '''
        props = LaunchTemplateProps(
            block_devices=block_devices,
            cpu_credits=cpu_credits,
            detailed_monitoring=detailed_monitoring,
            disable_api_termination=disable_api_termination,
            ebs_optimized=ebs_optimized,
            hibernation_configured=hibernation_configured,
            instance_initiated_shutdown_behavior=instance_initiated_shutdown_behavior,
            instance_type=instance_type,
            key_name=key_name,
            launch_template_name=launch_template_name,
            machine_image=machine_image,
            nitro_enclave_enabled=nitro_enclave_enabled,
            require_imdsv2=require_imdsv2,
            role=role,
            security_group=security_group,
            spot_options=spot_options,
            user_data=user_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromLaunchTemplateAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_launch_template_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        version_number: typing.Optional[builtins.str] = None,
    ) -> ILaunchTemplate:
        '''Import an existing LaunchTemplate.

        :param scope: -
        :param id: -
        :param launch_template_id: The identifier of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None
        :param launch_template_name: The name of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None
        :param version_number: The version number of this launch template to use. Default: Version: "$Default"
        '''
        attrs = LaunchTemplateAttributes(
            launch_template_id=launch_template_id,
            launch_template_name=launch_template_name,
            version_number=version_number,
        )

        return typing.cast(ILaunchTemplate, jsii.sinvoke(cls, "fromLaunchTemplateAttributes", [scope, id, attrs]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''Allows specifying security group connections for the instance.

        :note: Only available if you provide a securityGroup when constructing the LaunchTemplate.
        '''
        return typing.cast("Connections", jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultVersionNumber")
    def default_version_number(self) -> builtins.str:
        '''The default version for the launch template.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "defaultVersionNumber"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="grantPrincipal")
    def grant_principal(self) -> _IPrincipal_539bb2fd:
        '''Principal to grant permissions to.

        :note: Only available if you provide a role when constructing the LaunchTemplate.
        '''
        return typing.cast(_IPrincipal_539bb2fd, jsii.get(self, "grantPrincipal"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="latestVersionNumber")
    def latest_version_number(self) -> builtins.str:
        '''The latest version of the launch template.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "latestVersionNumber"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="tags")
    def _tags(self) -> _TagManager_0a598cb3:
        '''TagManager for tagging support.'''
        return typing.cast(_TagManager_0a598cb3, jsii.get(self, "tags"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="versionNumber")
    def version_number(self) -> builtins.str:
        '''The version number of this launch template to use.'''
        return typing.cast(builtins.str, jsii.get(self, "versionNumber"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateId")
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` will be set.
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "launchTemplateId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="launchTemplateName")
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''The name of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` will be set.
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "launchTemplateName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="osType")
    def os_type(self) -> typing.Optional["OperatingSystemType"]:
        '''The type of OS the instance is running.

        :attribute: true
        '''
        return typing.cast(typing.Optional["OperatingSystemType"], jsii.get(self, "osType"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="role")
    def role(self) -> typing.Optional[_IRole_235f5d8e]:
        '''IAM Role assumed by instances that are launched from this template.

        :attribute: true
        '''
        return typing.cast(typing.Optional[_IRole_235f5d8e], jsii.get(self, "role"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="userData")
    def user_data(self) -> typing.Optional["UserData"]:
        '''UserData executed by instances that are launched from this template.

        :attribute: true
        '''
        return typing.cast(typing.Optional["UserData"], jsii.get(self, "userData"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplateAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "launch_template_id": "launchTemplateId",
        "launch_template_name": "launchTemplateName",
        "version_number": "versionNumber",
    },
)
class LaunchTemplateAttributes:
    def __init__(
        self,
        *,
        launch_template_id: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        version_number: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Attributes for an imported LaunchTemplate.

        :param launch_template_id: The identifier of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None
        :param launch_template_name: The name of the Launch Template. Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set. Default: None
        :param version_number: The version number of this launch template to use. Default: Version: "$Default"

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            launch_template_attributes = ec2.LaunchTemplateAttributes(
                launch_template_id="launchTemplateId",
                launch_template_name="launchTemplateName",
                version_number="versionNumber"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if launch_template_id is not None:
            self._values["launch_template_id"] = launch_template_id
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if version_number is not None:
            self._values["version_number"] = version_number

    @builtins.property
    def launch_template_id(self) -> typing.Optional[builtins.str]:
        '''The identifier of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set.

        :default: None
        '''
        result = self._values.get("launch_template_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''The name of the Launch Template.

        Exactly one of ``launchTemplateId`` and ``launchTemplateName`` may be set.

        :default: None
        '''
        result = self._values.get("launch_template_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def version_number(self) -> typing.Optional[builtins.str]:
        '''The version number of this launch template to use.

        :default: Version: "$Default"
        '''
        result = self._values.get("version_number")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LaunchTemplateAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplateProps",
    jsii_struct_bases=[],
    name_mapping={
        "block_devices": "blockDevices",
        "cpu_credits": "cpuCredits",
        "detailed_monitoring": "detailedMonitoring",
        "disable_api_termination": "disableApiTermination",
        "ebs_optimized": "ebsOptimized",
        "hibernation_configured": "hibernationConfigured",
        "instance_initiated_shutdown_behavior": "instanceInitiatedShutdownBehavior",
        "instance_type": "instanceType",
        "key_name": "keyName",
        "launch_template_name": "launchTemplateName",
        "machine_image": "machineImage",
        "nitro_enclave_enabled": "nitroEnclaveEnabled",
        "require_imdsv2": "requireImdsv2",
        "role": "role",
        "security_group": "securityGroup",
        "spot_options": "spotOptions",
        "user_data": "userData",
    },
)
class LaunchTemplateProps:
    def __init__(
        self,
        *,
        block_devices: typing.Optional[typing.Sequence[BlockDevice]] = None,
        cpu_credits: typing.Optional[CpuCredits] = None,
        detailed_monitoring: typing.Optional[builtins.bool] = None,
        disable_api_termination: typing.Optional[builtins.bool] = None,
        ebs_optimized: typing.Optional[builtins.bool] = None,
        hibernation_configured: typing.Optional[builtins.bool] = None,
        instance_initiated_shutdown_behavior: typing.Optional[InstanceInitiatedShutdownBehavior] = None,
        instance_type: typing.Optional[InstanceType] = None,
        key_name: typing.Optional[builtins.str] = None,
        launch_template_name: typing.Optional[builtins.str] = None,
        machine_image: typing.Optional[IMachineImage] = None,
        nitro_enclave_enabled: typing.Optional[builtins.bool] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_IRole_235f5d8e] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
        spot_options: typing.Optional["LaunchTemplateSpotOptions"] = None,
        user_data: typing.Optional["UserData"] = None,
    ) -> None:
        '''Properties of a LaunchTemplate.

        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param cpu_credits: CPU credit type for burstable EC2 instance types. Default: - No credit type is specified in the Launch Template.
        :param detailed_monitoring: If set to true, then detailed monitoring will be enabled on instances created with this launch template. Default: False - Detailed monitoring is disabled.
        :param disable_api_termination: If you set this parameter to true, you cannot terminate the instances launched with this launch template using the Amazon EC2 console, CLI, or API; otherwise, you can. Default: - The API termination setting is not specified in the Launch Template.
        :param ebs_optimized: Indicates whether the instances are optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: - EBS optimization is not specified in the launch template.
        :param hibernation_configured: If you set this parameter to true, the instance is enabled for hibernation. Default: - Hibernation configuration is not specified in the launch template; defaulting to false.
        :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: - Shutdown behavior is not specified in the launch template; defaults to STOP.
        :param instance_type: Type of instance to launch. Default: - This Launch Template does not specify a default Instance Type.
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param launch_template_name: Name for this launch template. Default: Automatically generated name
        :param machine_image: The AMI that will be used by instances. Default: - This Launch Template does not specify a default AMI.
        :param nitro_enclave_enabled: If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves. Default: - Enablement of Nitro enclaves is not specified in the launch template; defaulting to false.
        :param require_imdsv2: Whether IMDSv2 should be required on launched instances. Default: - false
        :param role: An IAM role to associate with the instance profile that is used by instances. The role must be assumable by the service principal ``ec2.amazonaws.com``: Default: - No new role is created.
        :param security_group: Security group to assign to instances created with the launch template. Default: No security group is assigned.
        :param spot_options: If this property is defined, then the Launch Template's InstanceMarketOptions will be set to use Spot instances, and the options for the Spot instances will be as defined. Default: - Instance launched with this template will not be spot instances.
        :param user_data: The AMI that will be used by instances. Default: - This Launch Template creates a UserData based on the type of provided machineImage; no UserData is created if a machineImage is not provided

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            boot_hook_conf = ec2.UserData.for_linux()
            boot_hook_conf.add_commands("cloud-init-per once docker_options echo 'OPTIONS=\"${OPTIONS} --storage-opt dm.basesize=40G\"' >> /etc/sysconfig/docker")
            
            setup_commands = ec2.UserData.for_linux()
            setup_commands.add_commands("sudo yum install awscli && echo Packages installed ã‚‰ã¨ > /var/tmp/setup")
            
            multipart_user_data = ec2.MultipartUserData()
            # The docker has to be configured at early stage, so content type is overridden to boothook
            multipart_user_data.add_part(ec2.MultipartBody.from_user_data(boot_hook_conf, "text/cloud-boothook; charset=\"us-ascii\""))
            # Execute the rest of setup
            multipart_user_data.add_part(ec2.MultipartBody.from_user_data(setup_commands))
            
            ec2.LaunchTemplate(self, "",
                user_data=multipart_user_data,
                block_devices=[]
            )
        '''
        if isinstance(spot_options, dict):
            spot_options = LaunchTemplateSpotOptions(**spot_options)
        self._values: typing.Dict[str, typing.Any] = {}
        if block_devices is not None:
            self._values["block_devices"] = block_devices
        if cpu_credits is not None:
            self._values["cpu_credits"] = cpu_credits
        if detailed_monitoring is not None:
            self._values["detailed_monitoring"] = detailed_monitoring
        if disable_api_termination is not None:
            self._values["disable_api_termination"] = disable_api_termination
        if ebs_optimized is not None:
            self._values["ebs_optimized"] = ebs_optimized
        if hibernation_configured is not None:
            self._values["hibernation_configured"] = hibernation_configured
        if instance_initiated_shutdown_behavior is not None:
            self._values["instance_initiated_shutdown_behavior"] = instance_initiated_shutdown_behavior
        if instance_type is not None:
            self._values["instance_type"] = instance_type
        if key_name is not None:
            self._values["key_name"] = key_name
        if launch_template_name is not None:
            self._values["launch_template_name"] = launch_template_name
        if machine_image is not None:
            self._values["machine_image"] = machine_image
        if nitro_enclave_enabled is not None:
            self._values["nitro_enclave_enabled"] = nitro_enclave_enabled
        if require_imdsv2 is not None:
            self._values["require_imdsv2"] = require_imdsv2
        if role is not None:
            self._values["role"] = role
        if security_group is not None:
            self._values["security_group"] = security_group
        if spot_options is not None:
            self._values["spot_options"] = spot_options
        if user_data is not None:
            self._values["user_data"] = user_data

    @builtins.property
    def block_devices(self) -> typing.Optional[typing.List[BlockDevice]]:
        '''Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes.

        Each instance that is launched has an associated root device volume,
        either an Amazon EBS volume or an instance store volume.
        You can use block device mappings to specify additional EBS volumes or
        instance store volumes to attach to an instance when it is launched.

        :default: - Uses the block device mapping of the AMI

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html
        '''
        result = self._values.get("block_devices")
        return typing.cast(typing.Optional[typing.List[BlockDevice]], result)

    @builtins.property
    def cpu_credits(self) -> typing.Optional[CpuCredits]:
        '''CPU credit type for burstable EC2 instance types.

        :default: - No credit type is specified in the Launch Template.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html
        '''
        result = self._values.get("cpu_credits")
        return typing.cast(typing.Optional[CpuCredits], result)

    @builtins.property
    def detailed_monitoring(self) -> typing.Optional[builtins.bool]:
        '''If set to true, then detailed monitoring will be enabled on instances created with this launch template.

        :default: False - Detailed monitoring is disabled.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html
        '''
        result = self._values.get("detailed_monitoring")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def disable_api_termination(self) -> typing.Optional[builtins.bool]:
        '''If you set this parameter to true, you cannot terminate the instances launched with this launch template using the Amazon EC2 console, CLI, or API;

        otherwise, you can.

        :default: - The API termination setting is not specified in the Launch Template.
        '''
        result = self._values.get("disable_api_termination")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def ebs_optimized(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether the instances are optimized for Amazon EBS I/O.

        This optimization provides dedicated throughput
        to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization
        isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.

        :default: - EBS optimization is not specified in the launch template.
        '''
        result = self._values.get("ebs_optimized")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def hibernation_configured(self) -> typing.Optional[builtins.bool]:
        '''If you set this parameter to true, the instance is enabled for hibernation.

        :default: - Hibernation configuration is not specified in the launch template; defaulting to false.
        '''
        result = self._values.get("hibernation_configured")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def instance_initiated_shutdown_behavior(
        self,
    ) -> typing.Optional[InstanceInitiatedShutdownBehavior]:
        '''Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).

        :default: - Shutdown behavior is not specified in the launch template; defaults to STOP.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#Using_ChangingInstanceInitiatedShutdownBehavior
        '''
        result = self._values.get("instance_initiated_shutdown_behavior")
        return typing.cast(typing.Optional[InstanceInitiatedShutdownBehavior], result)

    @builtins.property
    def instance_type(self) -> typing.Optional[InstanceType]:
        '''Type of instance to launch.

        :default: - This Launch Template does not specify a default Instance Type.
        '''
        result = self._values.get("instance_type")
        return typing.cast(typing.Optional[InstanceType], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''Name of SSH keypair to grant access to instance.

        :default: - No SSH access will be possible.
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def launch_template_name(self) -> typing.Optional[builtins.str]:
        '''Name for this launch template.

        :default: Automatically generated name
        '''
        result = self._values.get("launch_template_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def machine_image(self) -> typing.Optional[IMachineImage]:
        '''The AMI that will be used by instances.

        :default: - This Launch Template does not specify a default AMI.
        '''
        result = self._values.get("machine_image")
        return typing.cast(typing.Optional[IMachineImage], result)

    @builtins.property
    def nitro_enclave_enabled(self) -> typing.Optional[builtins.bool]:
        '''If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves;

        otherwise, it is not enabled for AWS Nitro Enclaves.

        :default: - Enablement of Nitro enclaves is not specified in the launch template; defaulting to false.
        '''
        result = self._values.get("nitro_enclave_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def require_imdsv2(self) -> typing.Optional[builtins.bool]:
        '''Whether IMDSv2 should be required on launched instances.

        :default: - false
        '''
        result = self._values.get("require_imdsv2")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def role(self) -> typing.Optional[_IRole_235f5d8e]:
        '''An IAM role to associate with the instance profile that is used by instances.

        The role must be assumable by the service principal ``ec2.amazonaws.com``:

        :default: - No new role is created.

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            role = iam.Role(self, "MyRole",
                assumed_by=iam.ServicePrincipal("ec2.amazonaws.com")
            )
        '''
        result = self._values.get("role")
        return typing.cast(typing.Optional[_IRole_235f5d8e], result)

    @builtins.property
    def security_group(self) -> typing.Optional[ISecurityGroup]:
        '''Security group to assign to instances created with the launch template.

        :default: No security group is assigned.
        '''
        result = self._values.get("security_group")
        return typing.cast(typing.Optional[ISecurityGroup], result)

    @builtins.property
    def spot_options(self) -> typing.Optional["LaunchTemplateSpotOptions"]:
        '''If this property is defined, then the Launch Template's InstanceMarketOptions will be set to use Spot instances, and the options for the Spot instances will be as defined.

        :default: - Instance launched with this template will not be spot instances.
        '''
        result = self._values.get("spot_options")
        return typing.cast(typing.Optional["LaunchTemplateSpotOptions"], result)

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''The AMI that will be used by instances.

        :default:

        - This Launch Template creates a UserData based on the type of provided
        machineImage; no UserData is created if a machineImage is not provided
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LaunchTemplateProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_IAspect_118c810a)
class LaunchTemplateRequireImdsv2Aspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplateRequireImdsv2Aspect",
):
    '''Aspect that applies IMDS configuration on EC2 Launch Template constructs.

    :see: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-metadataoptions.html
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        launch_template_require_imdsv2_aspect = ec2.LaunchTemplateRequireImdsv2Aspect(
            suppress_warnings=False
        )
    '''

    def __init__(
        self,
        *,
        suppress_warnings: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param suppress_warnings: Whether warning annotations from this Aspect should be suppressed or not. Default: - false
        '''
        props = LaunchTemplateRequireImdsv2AspectProps(
            suppress_warnings=suppress_warnings
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: constructs.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        return typing.cast(None, jsii.invoke(self, "visit", [node]))

    @jsii.member(jsii_name="warn")
    def _warn(self, node: constructs.IConstruct, message: builtins.str) -> None:
        '''Adds a warning annotation to a node, unless ``suppressWarnings`` is true.

        :param node: The scope to add the warning to.
        :param message: The warning message.
        '''
        return typing.cast(None, jsii.invoke(self, "warn", [node, message]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="suppressWarnings")
    def _suppress_warnings(self) -> builtins.bool:
        return typing.cast(builtins.bool, jsii.get(self, "suppressWarnings"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplateRequireImdsv2AspectProps",
    jsii_struct_bases=[],
    name_mapping={"suppress_warnings": "suppressWarnings"},
)
class LaunchTemplateRequireImdsv2AspectProps:
    def __init__(
        self,
        *,
        suppress_warnings: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Properties for ``LaunchTemplateRequireImdsv2Aspect``.

        :param suppress_warnings: Whether warning annotations from this Aspect should be suppressed or not. Default: - false

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            launch_template_require_imdsv2_aspect_props = ec2.LaunchTemplateRequireImdsv2AspectProps(
                suppress_warnings=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if suppress_warnings is not None:
            self._values["suppress_warnings"] = suppress_warnings

    @builtins.property
    def suppress_warnings(self) -> typing.Optional[builtins.bool]:
        '''Whether warning annotations from this Aspect should be suppressed or not.

        :default: - false
        '''
        result = self._values.get("suppress_warnings")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LaunchTemplateRequireImdsv2AspectProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LaunchTemplateSpecialVersions(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplateSpecialVersions",
):
    '''A class that provides convenient access to special version tokens for LaunchTemplate versions.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        launch_template_special_versions = ec2.LaunchTemplateSpecialVersions()
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="DEFAULT_VERSION")
    def DEFAULT_VERSION(cls) -> builtins.str:
        '''The special value that denotes that users of a Launch Template should reference the DEFAULT version of the template.'''
        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_VERSION"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="LATEST_VERSION")
    def LATEST_VERSION(cls) -> builtins.str:
        '''The special value that denotes that users of a Launch Template should reference the LATEST version of the template.'''
        return typing.cast(builtins.str, jsii.sget(cls, "LATEST_VERSION"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LaunchTemplateSpotOptions",
    jsii_struct_bases=[],
    name_mapping={
        "block_duration": "blockDuration",
        "interruption_behavior": "interruptionBehavior",
        "max_price": "maxPrice",
        "request_type": "requestType",
        "valid_until": "validUntil",
    },
)
class LaunchTemplateSpotOptions:
    def __init__(
        self,
        *,
        block_duration: typing.Optional[_Duration_4839e8c3] = None,
        interruption_behavior: typing.Optional["SpotInstanceInterruption"] = None,
        max_price: typing.Optional[jsii.Number] = None,
        request_type: typing.Optional["SpotRequestType"] = None,
        valid_until: typing.Optional[_Expiration_059d47d0] = None,
    ) -> None:
        '''Interface for the Spot market instance options provided in a LaunchTemplate.

        :param block_duration: Spot Instances with a defined duration (also known as Spot blocks) are designed not to be interrupted and will run continuously for the duration you select. You can use a duration of 1, 2, 3, 4, 5, or 6 hours. Default: Requested spot instances do not have a pre-defined duration.
        :param interruption_behavior: The behavior when a Spot Instance is interrupted. Default: Spot instances will terminate when interrupted.
        :param max_price: Maximum hourly price you're willing to pay for each Spot instance. The value is given in dollars. ex: 0.01 for 1 cent per hour, or 0.001 for one-tenth of a cent per hour. Default: Maximum hourly price will default to the on-demand price for the instance type.
        :param request_type: The Spot Instance request type. If you are using Spot Instances with an Auto Scaling group, use one-time requests, as the Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is below its desired capacity. Default: One-time spot request.
        :param valid_until: The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. Default: The default end date is 7 days from the current date.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import aws_cdk as cdk
            from aws_cdk import aws_ec2 as ec2
            
            # expiration: cdk.Expiration
            
            launch_template_spot_options = ec2.LaunchTemplateSpotOptions(
                block_duration=cdk.Duration.minutes(30),
                interruption_behavior=ec2.SpotInstanceInterruption.STOP,
                max_price=123,
                request_type=ec2.SpotRequestType.ONE_TIME,
                valid_until=expiration
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if block_duration is not None:
            self._values["block_duration"] = block_duration
        if interruption_behavior is not None:
            self._values["interruption_behavior"] = interruption_behavior
        if max_price is not None:
            self._values["max_price"] = max_price
        if request_type is not None:
            self._values["request_type"] = request_type
        if valid_until is not None:
            self._values["valid_until"] = valid_until

    @builtins.property
    def block_duration(self) -> typing.Optional[_Duration_4839e8c3]:
        '''Spot Instances with a defined duration (also known as Spot blocks) are designed not to be interrupted and will run continuously for the duration you select.

        You can use a duration of 1, 2, 3, 4, 5, or 6 hours.

        :default: Requested spot instances do not have a pre-defined duration.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-requests.html#fixed-duration-spot-instances
        '''
        result = self._values.get("block_duration")
        return typing.cast(typing.Optional[_Duration_4839e8c3], result)

    @builtins.property
    def interruption_behavior(self) -> typing.Optional["SpotInstanceInterruption"]:
        '''The behavior when a Spot Instance is interrupted.

        :default: Spot instances will terminate when interrupted.
        '''
        result = self._values.get("interruption_behavior")
        return typing.cast(typing.Optional["SpotInstanceInterruption"], result)

    @builtins.property
    def max_price(self) -> typing.Optional[jsii.Number]:
        '''Maximum hourly price you're willing to pay for each Spot instance.

        The value is given
        in dollars. ex: 0.01 for 1 cent per hour, or 0.001 for one-tenth of a cent per hour.

        :default: Maximum hourly price will default to the on-demand price for the instance type.
        '''
        result = self._values.get("max_price")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def request_type(self) -> typing.Optional["SpotRequestType"]:
        '''The Spot Instance request type.

        If you are using Spot Instances with an Auto Scaling group, use one-time requests, as the
        Amazon EC2 Auto Scaling service handles requesting new Spot Instances whenever the group is
        below its desired capacity.

        :default: One-time spot request.
        '''
        result = self._values.get("request_type")
        return typing.cast(typing.Optional["SpotRequestType"], result)

    @builtins.property
    def valid_until(self) -> typing.Optional[_Expiration_059d47d0]:
        '''The end date of the request.

        For a one-time request, the request remains active until all instances
        launch, the request is canceled, or this date is reached. If the request is persistent, it remains
        active until it is canceled or this date and time is reached.

        :default: The default end date is 7 days from the current date.
        '''
        result = self._values.get("valid_until")
        return typing.cast(typing.Optional[_Expiration_059d47d0], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LaunchTemplateSpotOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LinuxUserDataOptions",
    jsii_struct_bases=[],
    name_mapping={"shebang": "shebang"},
)
class LinuxUserDataOptions:
    def __init__(self, *, shebang: typing.Optional[builtins.str] = None) -> None:
        '''Options when constructing UserData for Linux.

        :param shebang: Shebang for the UserData script. Default: "#!/bin/bash"

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            linux_user_data_options = ec2.LinuxUserDataOptions(
                shebang="shebang"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if shebang is not None:
            self._values["shebang"] = shebang

    @builtins.property
    def shebang(self) -> typing.Optional[builtins.str]:
        '''Shebang for the UserData script.

        :default: "#!/bin/bash"
        '''
        result = self._values.get("shebang")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LinuxUserDataOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LocationPackageOptions",
    jsii_struct_bases=[],
    name_mapping={"key": "key", "service_restart_handles": "serviceRestartHandles"},
)
class LocationPackageOptions:
    def __init__(
        self,
        *,
        key: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
    ) -> None:
        '''Options for InitPackage.rpm/InitPackage.msi.

        :param key: Identifier key for this package. You can use this to order package installs. Default: - Automatically generated
        :param service_restart_handles: Restart the given service after this command has run. Default: - Do not restart any service

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # init_service_restart_handle: ec2.InitServiceRestartHandle
            
            location_package_options = ec2.LocationPackageOptions(
                key="key",
                service_restart_handles=[init_service_restart_handle]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if key is not None:
            self._values["key"] = key
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles

    @builtins.property
    def key(self) -> typing.Optional[builtins.str]:
        '''Identifier key for this package.

        You can use this to order package installs.

        :default: - Automatically generated
        '''
        result = self._values.get("key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List[InitServiceRestartHandle]]:
        '''Restart the given service after this command has run.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List[InitServiceRestartHandle]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LocationPackageOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IMachineImage)
class LookupMachineImage(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.LookupMachineImage",
):
    '''A machine image whose AMI ID will be searched using DescribeImages.

    The most recent, available, launchable image matching the given filter
    criteria will be used. Looking up AMIs may take a long time; specify
    as many filter criteria as possible to narrow down the search.

    The AMI selected will be cached in ``cdk.context.json`` and the same value
    will be used on future runs. To refresh the AMI lookup, you will have to
    evict the value from the cache using the ``cdk context`` command. See
    https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # user_data: ec2.UserData
        
        lookup_machine_image = ec2.LookupMachineImage(
            name="name",
        
            # the properties below are optional
            filters={
                "filters_key": ["filters"]
            },
            owners=["owners"],
            user_data=user_data,
            windows=False
        )
    '''

    def __init__(
        self,
        *,
        name: builtins.str,
        filters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
        owners: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_data: typing.Optional["UserData"] = None,
        windows: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param name: Name of the image (may contain wildcards).
        :param filters: Additional filters on the AMI. Default: - No additional filters
        :param owners: Owner account IDs or aliases. Default: - All owners
        :param user_data: Custom userdata for this image. Default: - Empty user data appropriate for the platform type
        :param windows: Look for Windows images. Default: false
        '''
        props = LookupMachineImageProps(
            name=name,
            filters=filters,
            owners=owners,
            user_data=user_data,
            windows=windows,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> "MachineImageConfig":
        '''Return the image to use in the given context.

        :param scope: -
        '''
        return typing.cast("MachineImageConfig", jsii.invoke(self, "getImage", [scope]))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.LookupMachineImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "filters": "filters",
        "owners": "owners",
        "user_data": "userData",
        "windows": "windows",
    },
)
class LookupMachineImageProps:
    def __init__(
        self,
        *,
        name: builtins.str,
        filters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
        owners: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_data: typing.Optional["UserData"] = None,
        windows: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Properties for looking up an image.

        :param name: Name of the image (may contain wildcards).
        :param filters: Additional filters on the AMI. Default: - No additional filters
        :param owners: Owner account IDs or aliases. Default: - All owners
        :param user_data: Custom userdata for this image. Default: - Empty user data appropriate for the platform type
        :param windows: Look for Windows images. Default: false

        :exampleMetadata: lit=aws-ec2/test/example.images.lit.ts infused

        Example::

            # Pick the right Amazon Linux edition. All arguments shown are optional
            # and will default to these values when omitted.
            amzn_linux = ec2.MachineImage.latest_amazon_linux(
                generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
                edition=ec2.AmazonLinuxEdition.STANDARD,
                virtualization=ec2.AmazonLinuxVirt.HVM,
                storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
                cpu_type=ec2.AmazonLinuxCpuType.X86_64
            )
            
            # Pick a Windows edition to use
            windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
            
            # Read AMI id from SSM parameter store
            ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)
            
            # Look up the most recent image matching a set of AMI filters.
            # In this case, look up the NAT instance AMI, by using a wildcard
            # in the 'name' field:
            nat_ami = ec2.MachineImage.lookup(
                name="amzn-ami-vpc-nat-*",
                owners=["amazon"]
            )
            
            # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
            # a map giving the AMI to in for each region:
            linux = ec2.MachineImage.generic_linux({
                "us-east-1": "ami-97785bed",
                "eu-west-1": "ami-12345678"
            })
            
            # For other custom (Windows) images, instantiate a `GenericWindowsImage` with
            # a map giving the AMI to in for each region:
            generic_windows = ec2.MachineImage.generic_windows({
                "us-east-1": "ami-97785bed",
                "eu-west-1": "ami-12345678"
            })
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
        }
        if filters is not None:
            self._values["filters"] = filters
        if owners is not None:
            self._values["owners"] = owners
        if user_data is not None:
            self._values["user_data"] = user_data
        if windows is not None:
            self._values["windows"] = windows

    @builtins.property
    def name(self) -> builtins.str:
        '''Name of the image (may contain wildcards).'''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def filters(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]]:
        '''Additional filters on the AMI.

        :default: - No additional filters

        :see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html
        '''
        result = self._values.get("filters")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.List[builtins.str]]], result)

    @builtins.property
    def owners(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Owner account IDs or aliases.

        :default: - All owners
        '''
        result = self._values.get("owners")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''Custom userdata for this image.

        :default: - Empty user data appropriate for the platform type
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    @builtins.property
    def windows(self) -> typing.Optional[builtins.bool]:
        '''Look for Windows images.

        :default: false
        '''
        result = self._values.get("windows")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LookupMachineImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MachineImage(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.MachineImage",
):
    '''Factory functions for standard Amazon Machine Image objects.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        template = ec2.LaunchTemplate(self, "LaunchTemplate",
            machine_image=ec2.MachineImage.latest_amazon_linux(),
            security_group=ec2.SecurityGroup(self, "LaunchTemplateSG",
                vpc=vpc
            )
        )
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromSsmParameter") # type: ignore[misc]
    @builtins.classmethod
    def from_ssm_parameter(
        cls,
        parameter_name: builtins.str,
        *,
        cached_in_context: typing.Optional[builtins.bool] = None,
        os: typing.Optional["OperatingSystemType"] = None,
        user_data: typing.Optional["UserData"] = None,
    ) -> IMachineImage:
        '''An image specified in SSM parameter store.

        By default, the SSM parameter is refreshed at every deployment,
        causing your instances to be replaced whenever a new version of the AMI
        is released.

        Pass ``{ cachedInContext: true }`` to keep the AMI ID stable. If you do, you
        will have to remember to periodically invalidate the context to refresh
        to the newest AMI ID.

        :param parameter_name: -
        :param cached_in_context: Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false
        :param os: Operating system. Default: OperatingSystemType.LINUX
        :param user_data: Custom UserData. Default: - UserData appropriate for the OS
        '''
        options = SsmParameterImageOptions(
            cached_in_context=cached_in_context, os=os, user_data=user_data
        )

        return typing.cast(IMachineImage, jsii.sinvoke(cls, "fromSsmParameter", [parameter_name, options]))

    @jsii.member(jsii_name="genericLinux") # type: ignore[misc]
    @builtins.classmethod
    def generic_linux(
        cls,
        ami_map: typing.Mapping[builtins.str, builtins.str],
        *,
        user_data: typing.Optional["UserData"] = None,
    ) -> IMachineImage:
        '''A Linux image where you specify the AMI ID for every region.

        :param ami_map: For every region where you are deploying the stack, specify the AMI ID for that region.
        :param user_data: Initial user data. Default: - Empty UserData for Linux machines
        '''
        props = GenericLinuxImageProps(user_data=user_data)

        return typing.cast(IMachineImage, jsii.sinvoke(cls, "genericLinux", [ami_map, props]))

    @jsii.member(jsii_name="genericWindows") # type: ignore[misc]
    @builtins.classmethod
    def generic_windows(
        cls,
        ami_map: typing.Mapping[builtins.str, builtins.str],
        *,
        user_data: typing.Optional["UserData"] = None,
    ) -> IMachineImage:
        '''A Windows image where you specify the AMI ID for every region.

        :param ami_map: For every region where you are deploying the stack, specify the AMI ID for that region.
        :param user_data: Initial user data. Default: - Empty UserData for Windows machines
        '''
        props = GenericWindowsImageProps(user_data=user_data)

        return typing.cast(IMachineImage, jsii.sinvoke(cls, "genericWindows", [ami_map, props]))

    @jsii.member(jsii_name="latestAmazonLinux") # type: ignore[misc]
    @builtins.classmethod
    def latest_amazon_linux(
        cls,
        *,
        cached_in_context: typing.Optional[builtins.bool] = None,
        cpu_type: typing.Optional[AmazonLinuxCpuType] = None,
        edition: typing.Optional[AmazonLinuxEdition] = None,
        generation: typing.Optional[AmazonLinuxGeneration] = None,
        kernel: typing.Optional[AmazonLinuxKernel] = None,
        storage: typing.Optional[AmazonLinuxStorage] = None,
        user_data: typing.Optional["UserData"] = None,
        virtualization: typing.Optional[AmazonLinuxVirt] = None,
    ) -> IMachineImage:
        '''An Amazon Linux image that is automatically kept up-to-date.

        This Machine Image automatically updates to the latest version on every
        deployment. Be aware this will cause your instances to be replaced when a
        new version of the image becomes available. Do not store stateful information
        on the instance if you are using this image.

        :param cached_in_context: Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false
        :param cpu_type: CPU Type. Default: X86_64
        :param edition: What edition of Amazon Linux to use. Default: Standard
        :param generation: What generation of Amazon Linux to use. Default: AmazonLinux
        :param kernel: What kernel version of Amazon Linux to use. Default: -
        :param storage: What storage backed image to use. Default: GeneralPurpose
        :param user_data: Initial user data. Default: - Empty UserData for Linux machines
        :param virtualization: Virtualization type. Default: HVM
        '''
        props = AmazonLinuxImageProps(
            cached_in_context=cached_in_context,
            cpu_type=cpu_type,
            edition=edition,
            generation=generation,
            kernel=kernel,
            storage=storage,
            user_data=user_data,
            virtualization=virtualization,
        )

        return typing.cast(IMachineImage, jsii.sinvoke(cls, "latestAmazonLinux", [props]))

    @jsii.member(jsii_name="latestWindows") # type: ignore[misc]
    @builtins.classmethod
    def latest_windows(
        cls,
        version: "WindowsVersion",
        *,
        user_data: typing.Optional["UserData"] = None,
    ) -> IMachineImage:
        '''A Windows image that is automatically kept up-to-date.

        This Machine Image automatically updates to the latest version on every
        deployment. Be aware this will cause your instances to be replaced when a
        new version of the image becomes available. Do not store stateful information
        on the instance if you are using this image.

        :param version: -
        :param user_data: Initial user data. Default: - Empty UserData for Windows machines
        '''
        props = WindowsImageProps(user_data=user_data)

        return typing.cast(IMachineImage, jsii.sinvoke(cls, "latestWindows", [version, props]))

    @jsii.member(jsii_name="lookup") # type: ignore[misc]
    @builtins.classmethod
    def lookup(
        cls,
        *,
        name: builtins.str,
        filters: typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.str]]] = None,
        owners: typing.Optional[typing.Sequence[builtins.str]] = None,
        user_data: typing.Optional["UserData"] = None,
        windows: typing.Optional[builtins.bool] = None,
    ) -> IMachineImage:
        '''Look up a shared Machine Image using DescribeImages.

        The most recent, available, launchable image matching the given filter
        criteria will be used. Looking up AMIs may take a long time; specify
        as many filter criteria as possible to narrow down the search.

        The AMI selected will be cached in ``cdk.context.json`` and the same value
        will be used on future runs. To refresh the AMI lookup, you will have to
        evict the value from the cache using the ``cdk context`` command. See
        https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information.

        This function can not be used in environment-agnostic stacks.

        :param name: Name of the image (may contain wildcards).
        :param filters: Additional filters on the AMI. Default: - No additional filters
        :param owners: Owner account IDs or aliases. Default: - All owners
        :param user_data: Custom userdata for this image. Default: - Empty user data appropriate for the platform type
        :param windows: Look for Windows images. Default: false
        '''
        props = LookupMachineImageProps(
            name=name,
            filters=filters,
            owners=owners,
            user_data=user_data,
            windows=windows,
        )

        return typing.cast(IMachineImage, jsii.sinvoke(cls, "lookup", [props]))


class _MachineImageProxy(MachineImage):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, MachineImage).__jsii_proxy_class__ = lambda : _MachineImageProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.MachineImageConfig",
    jsii_struct_bases=[],
    name_mapping={"image_id": "imageId", "os_type": "osType", "user_data": "userData"},
)
class MachineImageConfig:
    def __init__(
        self,
        *,
        image_id: builtins.str,
        os_type: "OperatingSystemType",
        user_data: "UserData",
    ) -> None:
        '''Configuration for a machine image.

        :param image_id: The AMI ID of the image to use.
        :param os_type: Operating system type for this image.
        :param user_data: Initial UserData for this image.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # user_data: ec2.UserData
            
            machine_image_config = ec2.MachineImageConfig(
                image_id="imageId",
                os_type=ec2.OperatingSystemType.LINUX,
                user_data=user_data
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "image_id": image_id,
            "os_type": os_type,
            "user_data": user_data,
        }

    @builtins.property
    def image_id(self) -> builtins.str:
        '''The AMI ID of the image to use.'''
        result = self._values.get("image_id")
        assert result is not None, "Required property 'image_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def os_type(self) -> "OperatingSystemType":
        '''Operating system type for this image.'''
        result = self._values.get("os_type")
        assert result is not None, "Required property 'os_type' is missing"
        return typing.cast("OperatingSystemType", result)

    @builtins.property
    def user_data(self) -> "UserData":
        '''Initial UserData for this image.'''
        result = self._values.get("user_data")
        assert result is not None, "Required property 'user_data' is missing"
        return typing.cast("UserData", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MachineImageConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MultipartBody(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.MultipartBody",
):
    '''The base class for all classes which can be used as {@link MultipartUserData}.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        multipart_user_data = ec2.MultipartUserData()
        commands_user_data = ec2.UserData.for_linux()
        multipart_user_data.add_user_data_part(commands_user_data, ec2.MultipartBody.SHELL_SCRIPT, True)
        
        # Adding commands to the multipartUserData adds them to commandsUserData, and vice-versa.
        multipart_user_data.add_commands("touch /root/multi.txt")
        commands_user_data.add_commands("touch /root/userdata.txt")
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="fromRawBody") # type: ignore[misc]
    @builtins.classmethod
    def from_raw_body(
        cls,
        *,
        content_type: builtins.str,
        body: typing.Optional[builtins.str] = None,
        transfer_encoding: typing.Optional[builtins.str] = None,
    ) -> "MultipartBody":
        '''Constructs the raw ``MultipartBody`` using specified body, content type and transfer encoding.

        When transfer encoding is specified (typically as Base64), it's caller responsibility to convert body to
        Base64 either by wrapping with ``Fn.base64`` or by converting it by other converters.

        :param content_type: ``Content-Type`` header of this part. Some examples of content types: - ``text/x-shellscript; charset="utf-8"`` (shell script) - ``text/cloud-boothook; charset="utf-8"`` (shell script executed during boot phase) For Linux shell scripts use ``text/x-shellscript``.
        :param body: The body of message. Default: undefined - body will not be added to part
        :param transfer_encoding: ``Content-Transfer-Encoding`` header specifying part encoding. Default: undefined - body is not encoded
        '''
        opts = MultipartBodyOptions(
            content_type=content_type, body=body, transfer_encoding=transfer_encoding
        )

        return typing.cast("MultipartBody", jsii.sinvoke(cls, "fromRawBody", [opts]))

    @jsii.member(jsii_name="fromUserData") # type: ignore[misc]
    @builtins.classmethod
    def from_user_data(
        cls,
        user_data: "UserData",
        content_type: typing.Optional[builtins.str] = None,
    ) -> "MultipartBody":
        '''Constructs the new ``MultipartBody`` wrapping existing ``UserData``. Modification to ``UserData`` are reflected in subsequent renders of the part.

        For more information about content types see {@link MultipartBodyOptions.contentType}.

        :param user_data: user data to wrap into body part.
        :param content_type: optional content type, if default one should not be used.
        '''
        return typing.cast("MultipartBody", jsii.sinvoke(cls, "fromUserData", [user_data, content_type]))

    @jsii.member(jsii_name="renderBodyPart") # type: ignore[misc]
    @abc.abstractmethod
    def render_body_part(self) -> typing.List[builtins.str]:
        '''Render body part as the string.

        Subclasses should not add leading nor trailing new line characters (\\r \\n)
        '''
        ...

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="CLOUD_BOOTHOOK")
    def CLOUD_BOOTHOOK(cls) -> builtins.str:
        '''Content type for boot hooks.'''
        return typing.cast(builtins.str, jsii.sget(cls, "CLOUD_BOOTHOOK"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="SHELL_SCRIPT")
    def SHELL_SCRIPT(cls) -> builtins.str:
        '''Content type for shell scripts.'''
        return typing.cast(builtins.str, jsii.sget(cls, "SHELL_SCRIPT"))


class _MultipartBodyProxy(MultipartBody):
    @jsii.member(jsii_name="renderBodyPart")
    def render_body_part(self) -> typing.List[builtins.str]:
        '''Render body part as the string.

        Subclasses should not add leading nor trailing new line characters (\\r \\n)
        '''
        return typing.cast(typing.List[builtins.str], jsii.invoke(self, "renderBodyPart", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, MultipartBody).__jsii_proxy_class__ = lambda : _MultipartBodyProxy


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.MultipartBodyOptions",
    jsii_struct_bases=[],
    name_mapping={
        "content_type": "contentType",
        "body": "body",
        "transfer_encoding": "transferEncoding",
    },
)
class MultipartBodyOptions:
    def __init__(
        self,
        *,
        content_type: builtins.str,
        body: typing.Optional[builtins.str] = None,
        transfer_encoding: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options when creating ``MultipartBody``.

        :param content_type: ``Content-Type`` header of this part. Some examples of content types: - ``text/x-shellscript; charset="utf-8"`` (shell script) - ``text/cloud-boothook; charset="utf-8"`` (shell script executed during boot phase) For Linux shell scripts use ``text/x-shellscript``.
        :param body: The body of message. Default: undefined - body will not be added to part
        :param transfer_encoding: ``Content-Transfer-Encoding`` header specifying part encoding. Default: undefined - body is not encoded

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            multipart_body_options = ec2.MultipartBodyOptions(
                content_type="contentType",
            
                # the properties below are optional
                body="body",
                transfer_encoding="transferEncoding"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "content_type": content_type,
        }
        if body is not None:
            self._values["body"] = body
        if transfer_encoding is not None:
            self._values["transfer_encoding"] = transfer_encoding

    @builtins.property
    def content_type(self) -> builtins.str:
        '''``Content-Type`` header of this part.

        Some examples of content types:

        - ``text/x-shellscript; charset="utf-8"`` (shell script)
        - ``text/cloud-boothook; charset="utf-8"`` (shell script executed during boot phase)

        For Linux shell scripts use ``text/x-shellscript``.
        '''
        result = self._values.get("content_type")
        assert result is not None, "Required property 'content_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def body(self) -> typing.Optional[builtins.str]:
        '''The body of message.

        :default: undefined - body will not be added to part
        '''
        result = self._values.get("body")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def transfer_encoding(self) -> typing.Optional[builtins.str]:
        '''``Content-Transfer-Encoding`` header specifying part encoding.

        :default: undefined - body is not encoded
        '''
        result = self._values.get("transfer_encoding")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MultipartBodyOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.MultipartUserDataOptions",
    jsii_struct_bases=[],
    name_mapping={"parts_separator": "partsSeparator"},
)
class MultipartUserDataOptions:
    def __init__(
        self,
        *,
        parts_separator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options for creating {@link MultipartUserData}.

        :param parts_separator: The string used to separate parts in multipart user data archive (it's like MIME boundary). This string should contain [a-zA-Z0-9()+,-./:=?] characters only, and should not be present in any part, or in text content of archive. Default: ``+AWS+CDK+User+Data+Separator==``

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            multipart_user_data_options = ec2.MultipartUserDataOptions(
                parts_separator="partsSeparator"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if parts_separator is not None:
            self._values["parts_separator"] = parts_separator

    @builtins.property
    def parts_separator(self) -> typing.Optional[builtins.str]:
        '''The string used to separate parts in multipart user data archive (it's like MIME boundary).

        This string should contain [a-zA-Z0-9()+,-./:=?] characters only, and should not be present in any part, or in text content of archive.

        :default: ``+AWS+CDK+User+Data+Separator==``
        '''
        result = self._values.get("parts_separator")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MultipartUserDataOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.NamedPackageOptions",
    jsii_struct_bases=[],
    name_mapping={
        "service_restart_handles": "serviceRestartHandles",
        "version": "version",
    },
)
class NamedPackageOptions:
    def __init__(
        self,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
        version: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Options for InitPackage.yum/apt/rubyGem/python.

        :param service_restart_handles: Restart the given services after this command has run. Default: - Do not restart any service
        :param version: Specify the versions to install. Default: - Install the latest version

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # init_service_restart_handle: ec2.InitServiceRestartHandle
            
            named_package_options = ec2.NamedPackageOptions(
                service_restart_handles=[init_service_restart_handle],
                version=["version"]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles
        if version is not None:
            self._values["version"] = version

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List[InitServiceRestartHandle]]:
        '''Restart the given services after this command has run.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List[InitServiceRestartHandle]], result)

    @builtins.property
    def version(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Specify the versions to install.

        :default: - Install the latest version
        '''
        result = self._values.get("version")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NamedPackageOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.NatGatewayProps",
    jsii_struct_bases=[],
    name_mapping={"eip_allocation_ids": "eipAllocationIds"},
)
class NatGatewayProps:
    def __init__(
        self,
        *,
        eip_allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''Properties for a NAT gateway.

        :param eip_allocation_ids: EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            nat_gateway_props = ec2.NatGatewayProps(
                eip_allocation_ids=["eipAllocationIds"]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if eip_allocation_ids is not None:
            self._values["eip_allocation_ids"] = eip_allocation_ids

    @builtins.property
    def eip_allocation_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''EIP allocation IDs for the NAT gateways.

        :default: - No fixed EIPs allocated for the NAT gateways
        '''
        result = self._values.get("eip_allocation_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NatGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NatInstanceImage(
    LookupMachineImage,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.NatInstanceImage",
):
    '''Machine image representing the latest NAT instance image.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        nat_instance_image = ec2.NatInstanceImage()
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.NatInstanceProps",
    jsii_struct_bases=[],
    name_mapping={
        "instance_type": "instanceType",
        "default_allowed_traffic": "defaultAllowedTraffic",
        "key_name": "keyName",
        "machine_image": "machineImage",
        "security_group": "securityGroup",
    },
)
class NatInstanceProps:
    def __init__(
        self,
        *,
        instance_type: InstanceType,
        default_allowed_traffic: typing.Optional["NatTrafficDirection"] = None,
        key_name: typing.Optional[builtins.str] = None,
        machine_image: typing.Optional[IMachineImage] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
    ) -> None:
        '''Properties for a NAT instance.

        :param instance_type: Instance type of the NAT instance.
        :param default_allowed_traffic: Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param machine_image: The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image
        :param security_group: Security Group for NAT instances. Default: - A new security group will be created

        :exampleMetadata: lit=aws-ec2/test/integ.nat-instances.lit.ts infused

        Example::

            # Configure the `natGatewayProvider` when defining a Vpc
            nat_gateway_provider = ec2.NatProvider.instance(
                instance_type=ec2.InstanceType("t3.small")
            )
            
            vpc = ec2.Vpc(self, "MyVpc",
                nat_gateway_provider=nat_gateway_provider,
            
                # The 'natGateways' parameter now controls the number of NAT instances
                nat_gateways=2
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "instance_type": instance_type,
        }
        if default_allowed_traffic is not None:
            self._values["default_allowed_traffic"] = default_allowed_traffic
        if key_name is not None:
            self._values["key_name"] = key_name
        if machine_image is not None:
            self._values["machine_image"] = machine_image
        if security_group is not None:
            self._values["security_group"] = security_group

    @builtins.property
    def instance_type(self) -> InstanceType:
        '''Instance type of the NAT instance.'''
        result = self._values.get("instance_type")
        assert result is not None, "Required property 'instance_type' is missing"
        return typing.cast(InstanceType, result)

    @builtins.property
    def default_allowed_traffic(self) -> typing.Optional["NatTrafficDirection"]:
        '''Direction to allow all traffic through the NAT instance by default.

        By default, inbound and outbound traffic is allowed.

        If you set this to another value than INBOUND_AND_OUTBOUND, you must
        configure the NAT instance's security groups in another way, either by
        passing in a fully configured Security Group using the ``securityGroup``
        property, or by configuring it using the ``.securityGroup`` or
        ``.connections`` members after passing the NAT Instance Provider to a Vpc.

        :default: NatTrafficDirection.INBOUND_AND_OUTBOUND
        '''
        result = self._values.get("default_allowed_traffic")
        return typing.cast(typing.Optional["NatTrafficDirection"], result)

    @builtins.property
    def key_name(self) -> typing.Optional[builtins.str]:
        '''Name of SSH keypair to grant access to instance.

        :default: - No SSH access will be possible.
        '''
        result = self._values.get("key_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def machine_image(self) -> typing.Optional[IMachineImage]:
        '''The machine image (AMI) to use.

        By default, will do an AMI lookup for the latest NAT instance image.

        If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example::

           # Example automatically generated from non-compiling source. May contain errors.
           ec2.NatProvider.instance(
               instance_type=ec2.InstanceType("t3.micro"),
               machine_image=ec2.GenericLinuxImage({
                   "us-east-2": "ami-0f9c61b5a562a16af"
               })
           )

        :default: - Latest NAT instance image
        '''
        result = self._values.get("machine_image")
        return typing.cast(typing.Optional[IMachineImage], result)

    @builtins.property
    def security_group(self) -> typing.Optional[ISecurityGroup]:
        '''Security Group for NAT instances.

        :default: - A new security group will be created
        '''
        result = self._values.get("security_group")
        return typing.cast(typing.Optional[ISecurityGroup], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NatInstanceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NatProvider(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.NatProvider",
):
    '''NAT providers.

    Determines what type of NAT provider to create, either NAT gateways or NAT
    instance.

    :exampleMetadata: lit=aws-ec2/test/integ.nat-instances.lit.ts infused

    Example::

        # Configure the `natGatewayProvider` when defining a Vpc
        nat_gateway_provider = ec2.NatProvider.instance(
            instance_type=ec2.InstanceType("t3.small")
        )
        
        vpc = ec2.Vpc(self, "MyVpc",
            nat_gateway_provider=nat_gateway_provider,
        
            # The 'natGateways' parameter now controls the number of NAT instances
            nat_gateways=2
        )
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="gateway") # type: ignore[misc]
    @builtins.classmethod
    def gateway(
        cls,
        *,
        eip_allocation_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> "NatProvider":
        '''Use NAT Gateways to provide NAT services for your VPC.

        NAT gateways are managed by AWS.

        :param eip_allocation_ids: EIP allocation IDs for the NAT gateways. Default: - No fixed EIPs allocated for the NAT gateways

        :see: https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html
        '''
        props = NatGatewayProps(eip_allocation_ids=eip_allocation_ids)

        return typing.cast("NatProvider", jsii.sinvoke(cls, "gateway", [props]))

    @jsii.member(jsii_name="instance") # type: ignore[misc]
    @builtins.classmethod
    def instance(
        cls,
        *,
        instance_type: InstanceType,
        default_allowed_traffic: typing.Optional["NatTrafficDirection"] = None,
        key_name: typing.Optional[builtins.str] = None,
        machine_image: typing.Optional[IMachineImage] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
    ) -> "NatInstanceProvider":
        '''Use NAT instances to provide NAT services for your VPC.

        NAT instances are managed by you, but in return allow more configuration.

        Be aware that instances created using this provider will not be
        automatically replaced if they are stopped for any reason. You should implement
        your own NatProvider based on AutoScaling groups if you need that.

        :param instance_type: Instance type of the NAT instance.
        :param default_allowed_traffic: Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param machine_image: The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image
        :param security_group: Security Group for NAT instances. Default: - A new security group will be created

        :see: https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html
        '''
        props = NatInstanceProps(
            instance_type=instance_type,
            default_allowed_traffic=default_allowed_traffic,
            key_name=key_name,
            machine_image=machine_image,
            security_group=security_group,
        )

        return typing.cast("NatInstanceProvider", jsii.sinvoke(cls, "instance", [props]))

    @jsii.member(jsii_name="configureNat") # type: ignore[misc]
    @abc.abstractmethod
    def configure_nat(
        self,
        *,
        nat_subnets: typing.Sequence["PublicSubnet"],
        private_subnets: typing.Sequence["PrivateSubnet"],
        vpc: "Vpc",
    ) -> None:
        '''Called by the VPC to configure NAT.

        Don't call this directly, the VPC will call it automatically.

        :param nat_subnets: The public subnets where the NAT providers need to be placed.
        :param private_subnets: The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.
        :param vpc: The VPC we're configuring NAT for.
        '''
        ...

    @jsii.member(jsii_name="configureSubnet") # type: ignore[misc]
    @abc.abstractmethod
    def configure_subnet(self, subnet: "PrivateSubnet") -> None:
        '''Configures subnet with the gateway.

        Don't call this directly, the VPC will call it automatically.

        :param subnet: -
        '''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="configuredGateways")
    @abc.abstractmethod
    def configured_gateways(self) -> typing.List[GatewayConfig]:
        '''Return list of gateways spawned by the provider.'''
        ...


class _NatProviderProxy(NatProvider):
    @jsii.member(jsii_name="configureNat")
    def configure_nat(
        self,
        *,
        nat_subnets: typing.Sequence["PublicSubnet"],
        private_subnets: typing.Sequence["PrivateSubnet"],
        vpc: "Vpc",
    ) -> None:
        '''Called by the VPC to configure NAT.

        Don't call this directly, the VPC will call it automatically.

        :param nat_subnets: The public subnets where the NAT providers need to be placed.
        :param private_subnets: The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.
        :param vpc: The VPC we're configuring NAT for.
        '''
        options = ConfigureNatOptions(
            nat_subnets=nat_subnets, private_subnets=private_subnets, vpc=vpc
        )

        return typing.cast(None, jsii.invoke(self, "configureNat", [options]))

    @jsii.member(jsii_name="configureSubnet")
    def configure_subnet(self, subnet: "PrivateSubnet") -> None:
        '''Configures subnet with the gateway.

        Don't call this directly, the VPC will call it automatically.

        :param subnet: -
        '''
        return typing.cast(None, jsii.invoke(self, "configureSubnet", [subnet]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="configuredGateways")
    def configured_gateways(self) -> typing.List[GatewayConfig]:
        '''Return list of gateways spawned by the provider.'''
        return typing.cast(typing.List[GatewayConfig], jsii.get(self, "configuredGateways"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, NatProvider).__jsii_proxy_class__ = lambda : _NatProviderProxy


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.NatTrafficDirection")
class NatTrafficDirection(enum.Enum):
    '''Direction of traffic to allow all by default.'''

    OUTBOUND_ONLY = "OUTBOUND_ONLY"
    '''Allow all outbound traffic and disallow all inbound traffic.'''
    INBOUND_AND_OUTBOUND = "INBOUND_AND_OUTBOUND"
    '''Allow all outbound and inbound traffic.'''
    NONE = "NONE"
    '''Disallow all outbound and inbound traffic.'''


@jsii.implements(INetworkAcl)
class NetworkAcl(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.NetworkAcl",
):
    '''Define a new custom network ACL.

    By default, will deny all inbound and outbound traffic unless entries are
    added explicitly allowing it.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # subnet: ec2.Subnet
        # subnet_filter: ec2.SubnetFilter
        # vpc: ec2.Vpc
        
        network_acl = ec2.NetworkAcl(self, "MyNetworkAcl",
            vpc=vpc,
        
            # the properties below are optional
            network_acl_name="networkAclName",
            subnet_selection=ec2.SubnetSelection(
                availability_zones=["availabilityZones"],
                one_per_az=False,
                subnet_filters=[subnet_filter],
                subnet_group_name="subnetGroupName",
                subnets=[subnet],
                subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        network_acl_name: typing.Optional[builtins.str] = None,
        subnet_selection: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC in which to create the NetworkACL.
        :param network_acl_name: The name of the NetworkAcl. It is not recommended to use an explicit name. Default: If you don't specify a networkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param subnet_selection: Subnets in the given VPC to associate the ACL with. More subnets can always be added later by calling ``associateWithSubnets()``. Default: - No subnets associated
        '''
        props = NetworkAclProps(
            vpc=vpc,
            network_acl_name=network_acl_name,
            subnet_selection=subnet_selection,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromNetworkAclId") # type: ignore[misc]
    @builtins.classmethod
    def from_network_acl_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        network_acl_id: builtins.str,
    ) -> INetworkAcl:
        '''Import an existing NetworkAcl into this app.

        :param scope: -
        :param id: -
        :param network_acl_id: -
        '''
        return typing.cast(INetworkAcl, jsii.sinvoke(cls, "fromNetworkAclId", [scope, id, network_acl_id]))

    @jsii.member(jsii_name="addEntry")
    def add_entry(
        self,
        id: builtins.str,
        *,
        cidr: AclCidr,
        rule_number: jsii.Number,
        traffic: AclTraffic,
        direction: typing.Optional["TrafficDirection"] = None,
        network_acl_entry_name: typing.Optional[builtins.str] = None,
        rule_action: typing.Optional[Action] = None,
    ) -> "NetworkAclEntry":
        '''Add a new entry to the ACL.

        :param id: -
        :param cidr: The CIDR range to allow or deny.
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param traffic: What kind of traffic this ACL rule applies to.
        :param direction: Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS
        :param network_acl_entry_name: The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW
        '''
        options = CommonNetworkAclEntryOptions(
            cidr=cidr,
            rule_number=rule_number,
            traffic=traffic,
            direction=direction,
            network_acl_entry_name=network_acl_entry_name,
            rule_action=rule_action,
        )

        return typing.cast("NetworkAclEntry", jsii.invoke(self, "addEntry", [id, options]))

    @jsii.member(jsii_name="associateWithSubnet")
    def associate_with_subnet(
        self,
        id: builtins.str,
        *,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        one_per_az: typing.Optional[builtins.bool] = None,
        subnet_filters: typing.Optional[typing.Sequence["SubnetFilter"]] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[ISubnet]] = None,
        subnet_type: typing.Optional["SubnetType"] = None,
    ) -> None:
        '''Associate the ACL with a given set of subnets.

        :param id: -
        :param availability_zones: Select subnets only in the given AZs. Default: no filtering on AZs is done
        :param one_per_az: If true, return at most one subnet per AZ. Default: false
        :param subnet_filters: List of provided subnet filters. Default: - none
        :param subnet_group_name: Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name
        :param subnets: Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)
        :param subnet_type: Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)
        '''
        selection = SubnetSelection(
            availability_zones=availability_zones,
            one_per_az=one_per_az,
            subnet_filters=subnet_filters,
            subnet_group_name=subnet_group_name,
            subnets=subnets,
            subnet_type=subnet_type,
        )

        return typing.cast(None, jsii.invoke(self, "associateWithSubnet", [id, selection]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAclId")
    def network_acl_id(self) -> builtins.str:
        '''The ID of the NetworkACL.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkAclId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAclVpcId")
    def network_acl_vpc_id(self) -> builtins.str:
        '''The VPC ID for this NetworkACL.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "networkAclVpcId"))


@jsii.implements(INetworkAclEntry)
class NetworkAclEntry(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.NetworkAclEntry",
):
    '''Define an entry in a Network ACL table.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # acl_cidr: ec2.AclCidr
        # acl_traffic: ec2.AclTraffic
        # network_acl: ec2.NetworkAcl
        
        network_acl_entry = ec2.NetworkAclEntry(self, "MyNetworkAclEntry",
            cidr=acl_cidr,
            network_acl=network_acl,
            rule_number=123,
            traffic=acl_traffic,
        
            # the properties below are optional
            direction=ec2.TrafficDirection.EGRESS,
            network_acl_entry_name="networkAclEntryName",
            rule_action=ec2.Action.ALLOW
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_acl: INetworkAcl,
        cidr: AclCidr,
        rule_number: jsii.Number,
        traffic: AclTraffic,
        direction: typing.Optional["TrafficDirection"] = None,
        network_acl_entry_name: typing.Optional[builtins.str] = None,
        rule_action: typing.Optional[Action] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param network_acl: The network ACL this entry applies to.
        :param cidr: The CIDR range to allow or deny.
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param traffic: What kind of traffic this ACL rule applies to.
        :param direction: Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS
        :param network_acl_entry_name: The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW
        '''
        props = NetworkAclEntryProps(
            network_acl=network_acl,
            cidr=cidr,
            rule_number=rule_number,
            traffic=traffic,
            direction=direction,
            network_acl_entry_name=network_acl_entry_name,
            rule_action=rule_action,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAcl")
    def network_acl(self) -> INetworkAcl:
        '''The network ACL.'''
        return typing.cast(INetworkAcl, jsii.get(self, "networkAcl"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.NetworkAclEntryProps",
    jsii_struct_bases=[CommonNetworkAclEntryOptions],
    name_mapping={
        "cidr": "cidr",
        "rule_number": "ruleNumber",
        "traffic": "traffic",
        "direction": "direction",
        "network_acl_entry_name": "networkAclEntryName",
        "rule_action": "ruleAction",
        "network_acl": "networkAcl",
    },
)
class NetworkAclEntryProps(CommonNetworkAclEntryOptions):
    def __init__(
        self,
        *,
        cidr: AclCidr,
        rule_number: jsii.Number,
        traffic: AclTraffic,
        direction: typing.Optional["TrafficDirection"] = None,
        network_acl_entry_name: typing.Optional[builtins.str] = None,
        rule_action: typing.Optional[Action] = None,
        network_acl: INetworkAcl,
    ) -> None:
        '''Properties to create NetworkAclEntry.

        :param cidr: The CIDR range to allow or deny.
        :param rule_number: Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        :param traffic: What kind of traffic this ACL rule applies to.
        :param direction: Traffic direction, with respect to the subnet, this rule applies to. Default: TrafficDirection.INGRESS
        :param network_acl_entry_name: The name of the NetworkAclEntry. It is not recommended to use an explicit group name. Default: If you don't specify a NetworkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param rule_action: Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny". Any traffic that is not explicitly allowed is automatically denied in a custom ACL, all traffic is automatically allowed in a default ACL. Default: ALLOW
        :param network_acl: The network ACL this entry applies to.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # acl_cidr: ec2.AclCidr
            # acl_traffic: ec2.AclTraffic
            # network_acl: ec2.NetworkAcl
            
            network_acl_entry_props = ec2.NetworkAclEntryProps(
                cidr=acl_cidr,
                network_acl=network_acl,
                rule_number=123,
                traffic=acl_traffic,
            
                # the properties below are optional
                direction=ec2.TrafficDirection.EGRESS,
                network_acl_entry_name="networkAclEntryName",
                rule_action=ec2.Action.ALLOW
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "cidr": cidr,
            "rule_number": rule_number,
            "traffic": traffic,
            "network_acl": network_acl,
        }
        if direction is not None:
            self._values["direction"] = direction
        if network_acl_entry_name is not None:
            self._values["network_acl_entry_name"] = network_acl_entry_name
        if rule_action is not None:
            self._values["rule_action"] = rule_action

    @builtins.property
    def cidr(self) -> AclCidr:
        '''The CIDR range to allow or deny.'''
        result = self._values.get("cidr")
        assert result is not None, "Required property 'cidr' is missing"
        return typing.cast(AclCidr, result)

    @builtins.property
    def rule_number(self) -> jsii.Number:
        '''Rule number to assign to the entry, such as 100.

        ACL entries are processed in ascending order by rule number.
        Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule.
        '''
        result = self._values.get("rule_number")
        assert result is not None, "Required property 'rule_number' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def traffic(self) -> AclTraffic:
        '''What kind of traffic this ACL rule applies to.'''
        result = self._values.get("traffic")
        assert result is not None, "Required property 'traffic' is missing"
        return typing.cast(AclTraffic, result)

    @builtins.property
    def direction(self) -> typing.Optional["TrafficDirection"]:
        '''Traffic direction, with respect to the subnet, this rule applies to.

        :default: TrafficDirection.INGRESS
        '''
        result = self._values.get("direction")
        return typing.cast(typing.Optional["TrafficDirection"], result)

    @builtins.property
    def network_acl_entry_name(self) -> typing.Optional[builtins.str]:
        '''The name of the NetworkAclEntry.

        It is not recommended to use an explicit group name.

        :default:

        If you don't specify a NetworkAclName, AWS CloudFormation generates a
        unique physical ID and uses that ID for the group name.
        '''
        result = self._values.get("network_acl_entry_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def rule_action(self) -> typing.Optional[Action]:
        '''Whether to allow or deny traffic that matches the rule; valid values are "allow" or "deny".

        Any traffic that is not explicitly allowed is automatically denied in a custom
        ACL, all traffic is automatically allowed in a default ACL.

        :default: ALLOW
        '''
        result = self._values.get("rule_action")
        return typing.cast(typing.Optional[Action], result)

    @builtins.property
    def network_acl(self) -> INetworkAcl:
        '''The network ACL this entry applies to.'''
        result = self._values.get("network_acl")
        assert result is not None, "Required property 'network_acl' is missing"
        return typing.cast(INetworkAcl, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkAclEntryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.NetworkAclProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc": "vpc",
        "network_acl_name": "networkAclName",
        "subnet_selection": "subnetSelection",
    },
)
class NetworkAclProps:
    def __init__(
        self,
        *,
        vpc: IVpc,
        network_acl_name: typing.Optional[builtins.str] = None,
        subnet_selection: typing.Optional["SubnetSelection"] = None,
    ) -> None:
        '''Properties to create NetworkAcl.

        :param vpc: The VPC in which to create the NetworkACL.
        :param network_acl_name: The name of the NetworkAcl. It is not recommended to use an explicit name. Default: If you don't specify a networkAclName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param subnet_selection: Subnets in the given VPC to associate the ACL with. More subnets can always be added later by calling ``associateWithSubnets()``. Default: - No subnets associated

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            # vpc: ec2.Vpc
            
            network_acl_props = ec2.NetworkAclProps(
                vpc=vpc,
            
                # the properties below are optional
                network_acl_name="networkAclName",
                subnet_selection=ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
                )
            )
        '''
        if isinstance(subnet_selection, dict):
            subnet_selection = SubnetSelection(**subnet_selection)
        self._values: typing.Dict[str, typing.Any] = {
            "vpc": vpc,
        }
        if network_acl_name is not None:
            self._values["network_acl_name"] = network_acl_name
        if subnet_selection is not None:
            self._values["subnet_selection"] = subnet_selection

    @builtins.property
    def vpc(self) -> IVpc:
        '''The VPC in which to create the NetworkACL.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(IVpc, result)

    @builtins.property
    def network_acl_name(self) -> typing.Optional[builtins.str]:
        '''The name of the NetworkAcl.

        It is not recommended to use an explicit name.

        :default:

        If you don't specify a networkAclName, AWS CloudFormation generates a
        unique physical ID and uses that ID for the group name.
        '''
        result = self._values.get("network_acl_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_selection(self) -> typing.Optional["SubnetSelection"]:
        '''Subnets in the given VPC to associate the ACL with.

        More subnets can always be added later by calling
        ``associateWithSubnets()``.

        :default: - No subnets associated
        '''
        result = self._values.get("subnet_selection")
        return typing.cast(typing.Optional["SubnetSelection"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkAclProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.OperatingSystemType")
class OperatingSystemType(enum.Enum):
    '''The OS type of a particular image.

    :exampleMetadata: lit=aws-ec2/test/example.images.lit.ts infused

    Example::

        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.MachineImage.latest_amazon_linux(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
            cpu_type=ec2.AmazonLinuxCpuType.X86_64
        )
        
        # Pick a Windows edition to use
        windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Read AMI id from SSM parameter store
        ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)
        
        # Look up the most recent image matching a set of AMI filters.
        # In this case, look up the NAT instance AMI, by using a wildcard
        # in the 'name' field:
        nat_ami = ec2.MachineImage.lookup(
            name="amzn-ami-vpc-nat-*",
            owners=["amazon"]
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        linux = ec2.MachineImage.generic_linux({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
        
        # For other custom (Windows) images, instantiate a `GenericWindowsImage` with
        # a map giving the AMI to in for each region:
        generic_windows = ec2.MachineImage.generic_windows({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    LINUX = "LINUX"
    WINDOWS = "WINDOWS"
    UNKNOWN = "UNKNOWN"
    '''Used when the type of the operating system is not known (for example, for imported Auto-Scaling Groups).'''


class Peer(metaclass=jsii.JSIIMeta, jsii_type="aws-cdk-lib.aws_ec2.Peer"):
    '''Peer object factories (to be used in Security Group management).

    The static methods on this object can be used to create peer objects
    which represent a connection partner in Security Group rules.

    Use this object if you need to represent connection partners using plain IP
    addresses, or a prefix list ID.

    If you want to address a connection partner by Security Group, you can just
    use the Security Group (or the construct that contains a Security Group)
    directly, as it already implements ``IPeer``.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # instance_type: ec2.InstanceType
        
        
        provider = ec2.NatProvider.instance(
            instance_type=instance_type,
            allow_all_traffic=False
        )
        ec2.Vpc(self, "TheVPC",
            nat_gateway_provider=provider
        )
        provider.connections.allow_from(ec2.Peer.ipv4("1.2.3.4/8"), ec2.Port.tcp(80))
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="anyIpv4") # type: ignore[misc]
    @builtins.classmethod
    def any_ipv4(cls) -> IPeer:
        '''Any IPv4 address.'''
        return typing.cast(IPeer, jsii.sinvoke(cls, "anyIpv4", []))

    @jsii.member(jsii_name="anyIpv6") # type: ignore[misc]
    @builtins.classmethod
    def any_ipv6(cls) -> IPeer:
        '''Any IPv6 address.'''
        return typing.cast(IPeer, jsii.sinvoke(cls, "anyIpv6", []))

    @jsii.member(jsii_name="ipv4") # type: ignore[misc]
    @builtins.classmethod
    def ipv4(cls, cidr_ip: builtins.str) -> IPeer:
        '''Create an IPv4 peer from a CIDR.

        :param cidr_ip: -
        '''
        return typing.cast(IPeer, jsii.sinvoke(cls, "ipv4", [cidr_ip]))

    @jsii.member(jsii_name="ipv6") # type: ignore[misc]
    @builtins.classmethod
    def ipv6(cls, cidr_ip: builtins.str) -> IPeer:
        '''Create an IPv6 peer from a CIDR.

        :param cidr_ip: -
        '''
        return typing.cast(IPeer, jsii.sinvoke(cls, "ipv6", [cidr_ip]))

    @jsii.member(jsii_name="prefixList") # type: ignore[misc]
    @builtins.classmethod
    def prefix_list(cls, prefix_list_id: builtins.str) -> IPeer:
        '''A prefix list.

        :param prefix_list_id: -
        '''
        return typing.cast(IPeer, jsii.sinvoke(cls, "prefixList", [prefix_list_id]))

    @jsii.member(jsii_name="securityGroupId") # type: ignore[misc]
    @builtins.classmethod
    def security_group_id(
        cls,
        security_group_id: builtins.str,
        source_security_group_owner_id: typing.Optional[builtins.str] = None,
    ) -> IPeer:
        '''A security group ID.

        :param security_group_id: -
        :param source_security_group_owner_id: -
        '''
        return typing.cast(IPeer, jsii.sinvoke(cls, "securityGroupId", [security_group_id, source_security_group_owner_id]))


class Port(metaclass=jsii.JSIIMeta, jsii_type="aws-cdk-lib.aws_ec2.Port"):
    '''Interface for classes that provide the connection-specification parts of a security group rule.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # instance_type: ec2.InstanceType
        
        
        provider = ec2.NatProvider.instance(
            instance_type=instance_type,
            allow_all_traffic=False
        )
        ec2.Vpc(self, "TheVPC",
            nat_gateway_provider=provider
        )
        provider.connections.allow_from(ec2.Peer.ipv4("1.2.3.4/8"), ec2.Port.tcp(80))
    '''

    def __init__(
        self,
        *,
        protocol: "Protocol",
        string_representation: builtins.str,
        from_port: typing.Optional[jsii.Number] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param protocol: The protocol for the range.
        :param string_representation: String representation for this object.
        :param from_port: The starting port for the range. Default: - Not included in the rule
        :param to_port: The ending port for the range. Default: - Not included in the rule
        '''
        props = PortProps(
            protocol=protocol,
            string_representation=string_representation,
            from_port=from_port,
            to_port=to_port,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="ah") # type: ignore[misc]
    @builtins.classmethod
    def ah(cls) -> "Port":
        '''A single AH port.'''
        return typing.cast("Port", jsii.sinvoke(cls, "ah", []))

    @jsii.member(jsii_name="allIcmp") # type: ignore[misc]
    @builtins.classmethod
    def all_icmp(cls) -> "Port":
        '''All ICMP traffic.'''
        return typing.cast("Port", jsii.sinvoke(cls, "allIcmp", []))

    @jsii.member(jsii_name="allTcp") # type: ignore[misc]
    @builtins.classmethod
    def all_tcp(cls) -> "Port":
        '''Any TCP traffic.'''
        return typing.cast("Port", jsii.sinvoke(cls, "allTcp", []))

    @jsii.member(jsii_name="allTraffic") # type: ignore[misc]
    @builtins.classmethod
    def all_traffic(cls) -> "Port":
        '''All traffic.'''
        return typing.cast("Port", jsii.sinvoke(cls, "allTraffic", []))

    @jsii.member(jsii_name="allUdp") # type: ignore[misc]
    @builtins.classmethod
    def all_udp(cls) -> "Port":
        '''Any UDP traffic.'''
        return typing.cast("Port", jsii.sinvoke(cls, "allUdp", []))

    @jsii.member(jsii_name="esp") # type: ignore[misc]
    @builtins.classmethod
    def esp(cls) -> "Port":
        '''A single ESP port.'''
        return typing.cast("Port", jsii.sinvoke(cls, "esp", []))

    @jsii.member(jsii_name="icmpPing") # type: ignore[misc]
    @builtins.classmethod
    def icmp_ping(cls) -> "Port":
        '''ICMP ping (echo) traffic.'''
        return typing.cast("Port", jsii.sinvoke(cls, "icmpPing", []))

    @jsii.member(jsii_name="icmpType") # type: ignore[misc]
    @builtins.classmethod
    def icmp_type(cls, type: jsii.Number) -> "Port":
        '''All codes for a single ICMP type.

        :param type: -
        '''
        return typing.cast("Port", jsii.sinvoke(cls, "icmpType", [type]))

    @jsii.member(jsii_name="icmpTypeAndCode") # type: ignore[misc]
    @builtins.classmethod
    def icmp_type_and_code(cls, type: jsii.Number, code: jsii.Number) -> "Port":
        '''A specific combination of ICMP type and code.

        :param type: -
        :param code: -

        :see: https://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml
        '''
        return typing.cast("Port", jsii.sinvoke(cls, "icmpTypeAndCode", [type, code]))

    @jsii.member(jsii_name="tcp") # type: ignore[misc]
    @builtins.classmethod
    def tcp(cls, port: jsii.Number) -> "Port":
        '''A single TCP port.

        :param port: -
        '''
        return typing.cast("Port", jsii.sinvoke(cls, "tcp", [port]))

    @jsii.member(jsii_name="tcpRange") # type: ignore[misc]
    @builtins.classmethod
    def tcp_range(cls, start_port: jsii.Number, end_port: jsii.Number) -> "Port":
        '''A TCP port range.

        :param start_port: -
        :param end_port: -
        '''
        return typing.cast("Port", jsii.sinvoke(cls, "tcpRange", [start_port, end_port]))

    @jsii.member(jsii_name="udp") # type: ignore[misc]
    @builtins.classmethod
    def udp(cls, port: jsii.Number) -> "Port":
        '''A single UDP port.

        :param port: -
        '''
        return typing.cast("Port", jsii.sinvoke(cls, "udp", [port]))

    @jsii.member(jsii_name="udpRange") # type: ignore[misc]
    @builtins.classmethod
    def udp_range(cls, start_port: jsii.Number, end_port: jsii.Number) -> "Port":
        '''A UDP port range.

        :param start_port: -
        :param end_port: -
        '''
        return typing.cast("Port", jsii.sinvoke(cls, "udpRange", [start_port, end_port]))

    @jsii.member(jsii_name="toRuleJson")
    def to_rule_json(self) -> typing.Any:
        '''Produce the ingress/egress rule JSON for the given connection.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toRuleJson", []))

    @jsii.member(jsii_name="toString")
    def to_string(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.invoke(self, "toString", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="canInlineRule")
    def can_inline_rule(self) -> builtins.bool:
        '''Whether the rule containing this port range can be inlined into a securitygroup or not.'''
        return typing.cast(builtins.bool, jsii.get(self, "canInlineRule"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.PortProps",
    jsii_struct_bases=[],
    name_mapping={
        "protocol": "protocol",
        "string_representation": "stringRepresentation",
        "from_port": "fromPort",
        "to_port": "toPort",
    },
)
class PortProps:
    def __init__(
        self,
        *,
        protocol: "Protocol",
        string_representation: builtins.str,
        from_port: typing.Optional[jsii.Number] = None,
        to_port: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Properties to create a port range.

        :param protocol: The protocol for the range.
        :param string_representation: String representation for this object.
        :param from_port: The starting port for the range. Default: - Not included in the rule
        :param to_port: The ending port for the range. Default: - Not included in the rule

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            port_props = ec2.PortProps(
                protocol=ec2.Protocol.ALL,
                string_representation="stringRepresentation",
            
                # the properties below are optional
                from_port=123,
                to_port=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "protocol": protocol,
            "string_representation": string_representation,
        }
        if from_port is not None:
            self._values["from_port"] = from_port
        if to_port is not None:
            self._values["to_port"] = to_port

    @builtins.property
    def protocol(self) -> "Protocol":
        '''The protocol for the range.'''
        result = self._values.get("protocol")
        assert result is not None, "Required property 'protocol' is missing"
        return typing.cast("Protocol", result)

    @builtins.property
    def string_representation(self) -> builtins.str:
        '''String representation for this object.'''
        result = self._values.get("string_representation")
        assert result is not None, "Required property 'string_representation' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def from_port(self) -> typing.Optional[jsii.Number]:
        '''The starting port for the range.

        :default: - Not included in the rule
        '''
        result = self._values.get("from_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def to_port(self) -> typing.Optional[jsii.Number]:
        '''The ending port for the range.

        :default: - Not included in the rule
        '''
        result = self._values.get("to_port")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PortProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.Protocol")
class Protocol(enum.Enum):
    '''Protocol for use in Connection Rules.

    https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
    '''

    ALL = "ALL"
    HOPOPT = "HOPOPT"
    ICMP = "ICMP"
    IGMP = "IGMP"
    GGP = "GGP"
    IPV4 = "IPV4"
    ST = "ST"
    TCP = "TCP"
    CBT = "CBT"
    EGP = "EGP"
    IGP = "IGP"
    BBN_RCC_MON = "BBN_RCC_MON"
    NVP_II = "NVP_II"
    PUP = "PUP"
    EMCON = "EMCON"
    XNET = "XNET"
    CHAOS = "CHAOS"
    UDP = "UDP"
    MUX = "MUX"
    DCN_MEAS = "DCN_MEAS"
    HMP = "HMP"
    PRM = "PRM"
    XNS_IDP = "XNS_IDP"
    TRUNK_1 = "TRUNK_1"
    TRUNK_2 = "TRUNK_2"
    LEAF_1 = "LEAF_1"
    LEAF_2 = "LEAF_2"
    RDP = "RDP"
    IRTP = "IRTP"
    ISO_TP4 = "ISO_TP4"
    NETBLT = "NETBLT"
    MFE_NSP = "MFE_NSP"
    MERIT_INP = "MERIT_INP"
    DCCP = "DCCP"
    THREEPC = "THREEPC"
    IDPR = "IDPR"
    XTP = "XTP"
    DDP = "DDP"
    IDPR_CMTP = "IDPR_CMTP"
    TPPLUSPLUS = "TPPLUSPLUS"
    IL = "IL"
    IPV6 = "IPV6"
    SDRP = "SDRP"
    IPV6_ROUTE = "IPV6_ROUTE"
    IPV6_FRAG = "IPV6_FRAG"
    IDRP = "IDRP"
    RSVP = "RSVP"
    GRE = "GRE"
    DSR = "DSR"
    BNA = "BNA"
    ESP = "ESP"
    AH = "AH"
    I_NLSP = "I_NLSP"
    SWIPE = "SWIPE"
    NARP = "NARP"
    MOBILE = "MOBILE"
    TLSP = "TLSP"
    SKIP = "SKIP"
    ICMPV6 = "ICMPV6"
    IPV6_NONXT = "IPV6_NONXT"
    IPV6_OPTS = "IPV6_OPTS"
    CFTP = "CFTP"
    ANY_LOCAL = "ANY_LOCAL"
    SAT_EXPAK = "SAT_EXPAK"
    KRYPTOLAN = "KRYPTOLAN"
    RVD = "RVD"
    IPPC = "IPPC"
    ANY_DFS = "ANY_DFS"
    SAT_MON = "SAT_MON"
    VISA = "VISA"
    IPCV = "IPCV"
    CPNX = "CPNX"
    CPHB = "CPHB"
    WSN = "WSN"
    PVP = "PVP"
    BR_SAT_MON = "BR_SAT_MON"
    SUN_ND = "SUN_ND"
    WB_MON = "WB_MON"
    WB_EXPAK = "WB_EXPAK"
    ISO_IP = "ISO_IP"
    VMTP = "VMTP"
    SECURE_VMTP = "SECURE_VMTP"
    VINES = "VINES"
    TTP = "TTP"
    NSFNET_IGP = "NSFNET_IGP"
    DGP = "DGP"
    TCF = "TCF"
    EIGRP = "EIGRP"
    OSPFIGP = "OSPFIGP"
    SPRITE_RPC = "SPRITE_RPC"
    LARP = "LARP"
    MTP = "MTP"
    AX_25 = "AX_25"
    IPIP = "IPIP"
    MICP = "MICP"
    SCC_SP = "SCC_SP"
    ETHERIP = "ETHERIP"
    ENCAP = "ENCAP"
    ANY_ENC = "ANY_ENC"
    GMTP = "GMTP"
    IFMP = "IFMP"
    PNNI = "PNNI"
    PIM = "PIM"
    ARIS = "ARIS"
    SCPS = "SCPS"
    QNX = "QNX"
    A_N = "A_N"
    IPCOMP = "IPCOMP"
    SNP = "SNP"
    COMPAQ_PEER = "COMPAQ_PEER"
    IPX_IN_IP = "IPX_IN_IP"
    VRRP = "VRRP"
    PGM = "PGM"
    ANY_0_HOP = "ANY_0_HOP"
    L2_T_P = "L2_T_P"
    DDX = "DDX"
    IATP = "IATP"
    STP = "STP"
    SRP = "SRP"
    UTI = "UTI"
    SMP = "SMP"
    SM = "SM"
    PTP = "PTP"
    ISIS_IPV4 = "ISIS_IPV4"
    FIRE = "FIRE"
    CRTP = "CRTP"
    CRUDP = "CRUDP"
    SSCOPMCE = "SSCOPMCE"
    IPLT = "IPLT"
    SPS = "SPS"
    PIPE = "PIPE"
    SCTP = "SCTP"
    FC = "FC"
    RSVP_E2E_IGNORE = "RSVP_E2E_IGNORE"
    MOBILITY_HEADER = "MOBILITY_HEADER"
    UDPLITE = "UDPLITE"
    MPLS_IN_IP = "MPLS_IN_IP"
    MANET = "MANET"
    HIP = "HIP"
    SHIM6 = "SHIM6"
    WESP = "WESP"
    ROHC = "ROHC"
    ETHERNET = "ETHERNET"
    EXPERIMENT_1 = "EXPERIMENT_1"
    EXPERIMENT_2 = "EXPERIMENT_2"
    RESERVED = "RESERVED"


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.RouterType")
class RouterType(enum.Enum):
    '''Type of router used in route.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        vpc = ec2.Vpc(self, "VPC",
            subnet_configuration=[ec2.SubnetConfiguration(
                subnet_type=ec2.SubnetType.PUBLIC,
                name="Public"
            ), ec2.SubnetConfiguration(
                subnet_type=ec2.SubnetType.ISOLATED,
                name="Isolated"
            )]
        )
        
        (vpc.isolated_subnets[0]).add_route("StaticRoute",
            router_id=vpc.internet_gateway_id,
            router_type=ec2.RouterType.GATEWAY,
            destination_cidr_block="8.8.8.8/32"
        )
    '''

    EGRESS_ONLY_INTERNET_GATEWAY = "EGRESS_ONLY_INTERNET_GATEWAY"
    '''Egress-only Internet Gateway.'''
    GATEWAY = "GATEWAY"
    '''Internet Gateway.'''
    INSTANCE = "INSTANCE"
    '''Instance.'''
    NAT_GATEWAY = "NAT_GATEWAY"
    '''NAT Gateway.'''
    NETWORK_INTERFACE = "NETWORK_INTERFACE"
    '''Network Interface.'''
    VPC_PEERING_CONNECTION = "VPC_PEERING_CONNECTION"
    '''VPC peering connection.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.S3DownloadOptions",
    jsii_struct_bases=[],
    name_mapping={
        "bucket": "bucket",
        "bucket_key": "bucketKey",
        "local_file": "localFile",
        "region": "region",
    },
)
class S3DownloadOptions:
    def __init__(
        self,
        *,
        bucket: _IBucket_42e086fd,
        bucket_key: builtins.str,
        local_file: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Options when downloading files from S3.

        :param bucket: Name of the S3 bucket to download from.
        :param bucket_key: The key of the file to download.
        :param local_file: The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey
        :param region: The region of the S3 Bucket (needed for access via VPC Gateway). Default: none

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            from aws_cdk.aws_s3_assets import Asset
            
            # instance: ec2.Instance
            
            
            asset = Asset(self, "Asset",
                path="./configure.sh"
            )
            
            local_path = instance.user_data.add_s3_download_command(
                bucket=asset.bucket,
                bucket_key=asset.s3_object_key,
                region="us-east-1"
            )
            instance.user_data.add_execute_file_command(
                file_path=local_path,
                arguments="--verbose -y"
            )
            asset.grant_read(instance.role)
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "bucket": bucket,
            "bucket_key": bucket_key,
        }
        if local_file is not None:
            self._values["local_file"] = local_file
        if region is not None:
            self._values["region"] = region

    @builtins.property
    def bucket(self) -> _IBucket_42e086fd:
        '''Name of the S3 bucket to download from.'''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(_IBucket_42e086fd, result)

    @builtins.property
    def bucket_key(self) -> builtins.str:
        '''The key of the file to download.'''
        result = self._values.get("bucket_key")
        assert result is not None, "Required property 'bucket_key' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def local_file(self) -> typing.Optional[builtins.str]:
        '''The name of the local file.

        :default:

        Linux   - /tmp/bucketKey
        Windows - %TEMP%/bucketKey
        '''
        result = self._values.get("local_file")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The region of the S3 Bucket (needed for access via VPC Gateway).

        :default: none
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3DownloadOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ISecurityGroup)
class SecurityGroup(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.SecurityGroup",
):
    '''Creates an Amazon EC2 security group within a VPC.

    Security Groups act like a firewall with a set of rules, and are associated
    with any AWS resource that has or creates Elastic Network Interfaces (ENIs).
    A typical example of a resource that has a security group is an Instance (or
    Auto Scaling Group of instances)

    If you are defining new infrastructure in CDK, there is a good chance you
    won't have to interact with this class at all. Like IAM Roles, Security
    Groups need to exist to control access between AWS resources, but CDK will
    automatically generate and populate them with least-privilege permissions
    for you so you can concentrate on your business logic.

    All Constructs that require Security Groups will create one for you if you
    don't specify one at construction. After construction, you can selectively
    allow connections to and between constructs via--for example-- the ``instance.connections``
    object. Think of it as "allowing connections to your instance", rather than
    "adding ingress rules a security group". See the `Allowing
    Connections <https://docs.aws.amazon.com/cdk/api/latest/docs/aws-ec2-readme.html#allowing-connections>`_
    section in the library documentation for examples.

    Direct manipulation of the Security Group through ``addIngressRule`` and
    ``addEgressRule`` is possible, but mutation through the ``.connections`` object
    is recommended. If you peer two constructs with security groups this way,
    appropriate rules will be created in both.

    If you have an existing security group you want to use in your CDK application,
    you would import it like this::

       # Example automatically generated from non-compiling source. May contain errors.
       security_group = ec2.SecurityGroup.from_security_group_id(self, "SG", "sg-12345",
           mutable=False
       )

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        template = ec2.LaunchTemplate(self, "LaunchTemplate",
            machine_image=ec2.MachineImage.latest_amazon_linux(),
            security_group=ec2.SecurityGroup(self, "LaunchTemplateSG",
                vpc=vpc
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        disable_inline_rules: typing.Optional[builtins.bool] = None,
        security_group_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC in which to create the security group.
        :param allow_all_outbound: Whether to allow all outbound traffic by default. If this is set to true, there will only be a single egress rule which allows all outbound traffic. If this is set to false, no outbound traffic will be allowed by default and all egress traffic must be explicitly authorized. Default: true
        :param description: A description of the security group. Default: The default name will be the construct's CDK path.
        :param disable_inline_rules: Whether to disable inline ingress and egress rule optimization. If this is set to true, ingress and egress rules will not be declared under the SecurityGroup in cloudformation, but will be separate elements. Inlining rules is an optimization for producing smaller stack templates. Sometimes this is not desirable, for example when security group access is managed via tags. The default value can be overriden globally by setting the context variable '@aws-cdk/aws-ec2.securityGroupDisableInlineRules'. Default: false
        :param security_group_name: The name of the security group. For valid values, see the GroupName parameter of the CreateSecurityGroup action in the Amazon EC2 API Reference. It is not recommended to use an explicit group name. Default: If you don't specify a GroupName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        '''
        props = SecurityGroupProps(
            vpc=vpc,
            allow_all_outbound=allow_all_outbound,
            description=description,
            disable_inline_rules=disable_inline_rules,
            security_group_name=security_group_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromLookupById") # type: ignore[misc]
    @builtins.classmethod
    def from_lookup_by_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        security_group_id: builtins.str,
    ) -> ISecurityGroup:
        '''Look up a security group by id.

        :param scope: -
        :param id: -
        :param security_group_id: -
        '''
        return typing.cast(ISecurityGroup, jsii.sinvoke(cls, "fromLookupById", [scope, id, security_group_id]))

    @jsii.member(jsii_name="fromLookupByName") # type: ignore[misc]
    @builtins.classmethod
    def from_lookup_by_name(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        security_group_name: builtins.str,
        vpc: IVpc,
    ) -> ISecurityGroup:
        '''Look up a security group by name.

        :param scope: -
        :param id: -
        :param security_group_name: -
        :param vpc: -
        '''
        return typing.cast(ISecurityGroup, jsii.sinvoke(cls, "fromLookupByName", [scope, id, security_group_name, vpc]))

    @jsii.member(jsii_name="fromSecurityGroupId") # type: ignore[misc]
    @builtins.classmethod
    def from_security_group_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        security_group_id: builtins.str,
        *,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        mutable: typing.Optional[builtins.bool] = None,
    ) -> ISecurityGroup:
        '''Import an existing security group into this app.

        This method will assume that the Security Group has a rule in it which allows
        all outbound traffic, and so will not add egress rules to the imported Security
        Group (only ingress rules).

        If your existing Security Group needs to have egress rules added, pass the
        ``allowAllOutbound: false`` option on import.

        :param scope: -
        :param id: -
        :param security_group_id: -
        :param allow_all_outbound: Mark the SecurityGroup as having been created allowing all outbound traffic. Only if this is set to false will egress rules be added to this security group. Be aware, this would undo any potential "all outbound traffic" default. Default: true
        :param mutable: If a SecurityGroup is mutable CDK can add rules to existing groups. Beware that making a SecurityGroup immutable might lead to issue due to missing ingress/egress rules for new resources. Default: true
        '''
        options = SecurityGroupImportOptions(
            allow_all_outbound=allow_all_outbound, mutable=mutable
        )

        return typing.cast(ISecurityGroup, jsii.sinvoke(cls, "fromSecurityGroupId", [scope, id, security_group_id, options]))

    @jsii.member(jsii_name="isSecurityGroup") # type: ignore[misc]
    @builtins.classmethod
    def is_security_group(cls, x: typing.Any) -> builtins.bool:
        '''Return whether the indicated object is a security group.

        :param x: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "isSecurityGroup", [x]))

    @jsii.member(jsii_name="addEgressRule")
    def add_egress_rule(
        self,
        peer: IPeer,
        connection: Port,
        description: typing.Optional[builtins.str] = None,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Add an egress rule for the current security group.

        ``remoteRule`` controls where the Rule object is created if the peer is also a
        securityGroup and they are in different stack. If false (default) the
        rule object is created under the current SecurityGroup object. If true and the
        peer is also a SecurityGroup, the rule object is created under the remote
        SecurityGroup object.

        :param peer: -
        :param connection: -
        :param description: -
        :param remote_rule: -
        '''
        return typing.cast(None, jsii.invoke(self, "addEgressRule", [peer, connection, description, remote_rule]))

    @jsii.member(jsii_name="addIngressRule")
    def add_ingress_rule(
        self,
        peer: IPeer,
        connection: Port,
        description: typing.Optional[builtins.str] = None,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Add an ingress rule for the current security group.

        ``remoteRule`` controls where the Rule object is created if the peer is also a
        securityGroup and they are in different stack. If false (default) the
        rule object is created under the current SecurityGroup object. If true and the
        peer is also a SecurityGroup, the rule object is created under the remote
        SecurityGroup object.

        :param peer: -
        :param connection: -
        :param description: -
        :param remote_rule: -
        '''
        return typing.cast(None, jsii.invoke(self, "addIngressRule", [peer, connection, description, remote_rule]))

    @jsii.member(jsii_name="determineRuleScope")
    def _determine_rule_scope(
        self,
        peer: IPeer,
        connection: Port,
        from_to: builtins.str,
        remote_rule: typing.Optional[builtins.bool] = None,
    ) -> typing.Mapping[typing.Any, typing.Any]:
        '''Determine where to parent a new ingress/egress rule.

        A SecurityGroup rule is parented under the group it's related to, UNLESS
        we're in a cross-stack scenario with another Security Group. In that case,
        we respect the 'remoteRule' flag and will parent under the other security
        group.

        This is necessary to avoid cyclic dependencies between stacks, since both
        ingress and egress rules will reference both security groups, and a naive
        parenting will lead to the following situation:

        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—         â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â•‘         â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
        â•‘  â”‚  GroupA   â”‚â—€â”€â”€â”€â”€â•¬â”€â”   â”Œâ”€â”€â”€â•¬â”€â”€â”€â–¶â”‚  GroupB   â”‚   â•‘
        â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â•‘ â”‚   â”‚   â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
        â•‘        â–²           â•‘ â”‚   â”‚   â•‘          â–²         â•‘
        â•‘        â”‚           â•‘ â”‚   â”‚   â•‘          â”‚         â•‘
        â•‘        â”‚           â•‘ â”‚   â”‚   â•‘          â”‚         â•‘
        â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â•‘ â””â”€â”€â”€â”¼â”€â”€â”€â•¬â”€â”€â”€â”€â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
        â•‘  â”‚  EgressA  â”‚â”€â”€â”€â”€â”€â•¬â”€â”€â”€â”€â”€â”˜   â•‘    â”‚ IngressB  â”‚   â•‘
        â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â•‘         â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
        â•‘                    â•‘         â•‘                    â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•         â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        By having the ability to switch the parent, we avoid the cyclic reference by
        keeping all rules in a single stack.

        If this happens, we also have to change the construct ID, because
        otherwise we might have two objects with the same ID if we have
        multiple reversed security group relationships.

        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â•‘
        â•‘â”‚  GroupB   â”‚                      â•‘
        â•‘â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â•‘
        â•‘      â–²                            â•‘
        â•‘      â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘
        â•‘      â”œâ”€â”€â”€â”€"from A"â”€â”€â”‚ IngressB  â”‚ â•‘
        â•‘      â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘
        â•‘      â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘
        â•‘      â”œâ”€â”€â”€â”€â”€"to B"â”€â”€â”€â”‚  EgressA  â”‚ â•‘
        â•‘      â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘
        â•‘      â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â•‘
        â•‘      â””â”€â”€â”€â”€â”€"to B"â”€â”€â”€â”‚  EgressC  â”‚ â•‘  <-- oops
        â•‘                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        :param peer: -
        :param connection: -
        :param from_to: -
        :param remote_rule: -
        '''
        return typing.cast(typing.Mapping[typing.Any, typing.Any], jsii.invoke(self, "determineRuleScope", [peer, connection, from_to, remote_rule]))

    @jsii.member(jsii_name="toEgressRuleConfig")
    def to_egress_rule_config(self) -> typing.Any:
        '''Produce the egress rule JSON for the given connection.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toEgressRuleConfig", []))

    @jsii.member(jsii_name="toIngressRuleConfig")
    def to_ingress_rule_config(self) -> typing.Any:
        '''Produce the ingress rule JSON for the given connection.'''
        return typing.cast(typing.Any, jsii.invoke(self, "toIngressRuleConfig", []))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allowAllOutbound")
    def allow_all_outbound(self) -> builtins.bool:
        '''Whether the SecurityGroup has been configured to allow all outbound traffic.'''
        return typing.cast(builtins.bool, jsii.get(self, "allowAllOutbound"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="canInlineRule")
    def can_inline_rule(self) -> builtins.bool:
        '''Whether the rule can be inlined into a SecurityGroup or not.'''
        return typing.cast(builtins.bool, jsii.get(self, "canInlineRule"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''The network connections associated with this resource.'''
        return typing.cast("Connections", jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupId")
    def security_group_id(self) -> builtins.str:
        '''The ID of the security group.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "securityGroupId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroupVpcId")
    def security_group_vpc_id(self) -> builtins.str:
        '''The VPC ID this security group is part of.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "securityGroupVpcId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="uniqueId")
    def unique_id(self) -> builtins.str:
        '''A unique identifier for this connection peer.'''
        return typing.cast(builtins.str, jsii.get(self, "uniqueId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultPort")
    def default_port(self) -> typing.Optional[Port]:
        return typing.cast(typing.Optional[Port], jsii.get(self, "defaultPort"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SecurityGroupImportOptions",
    jsii_struct_bases=[],
    name_mapping={"allow_all_outbound": "allowAllOutbound", "mutable": "mutable"},
)
class SecurityGroupImportOptions:
    def __init__(
        self,
        *,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        mutable: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Additional options for imported security groups.

        :param allow_all_outbound: Mark the SecurityGroup as having been created allowing all outbound traffic. Only if this is set to false will egress rules be added to this security group. Be aware, this would undo any potential "all outbound traffic" default. Default: true
        :param mutable: If a SecurityGroup is mutable CDK can add rules to existing groups. Beware that making a SecurityGroup immutable might lead to issue due to missing ingress/egress rules for new resources. Default: true

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            security_group = ec2.SecurityGroup.from_security_group_id(self, "SG", "sg-12345",
                mutable=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if allow_all_outbound is not None:
            self._values["allow_all_outbound"] = allow_all_outbound
        if mutable is not None:
            self._values["mutable"] = mutable

    @builtins.property
    def allow_all_outbound(self) -> typing.Optional[builtins.bool]:
        '''Mark the SecurityGroup as having been created allowing all outbound traffic.

        Only if this is set to false will egress rules be added to this security
        group. Be aware, this would undo any potential "all outbound traffic"
        default.

        :default: true
        '''
        result = self._values.get("allow_all_outbound")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def mutable(self) -> typing.Optional[builtins.bool]:
        '''If a SecurityGroup is mutable CDK can add rules to existing groups.

        Beware that making a SecurityGroup immutable might lead to issue
        due to missing ingress/egress rules for new resources.

        :default: true
        '''
        result = self._values.get("mutable")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityGroupImportOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SecurityGroupProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc": "vpc",
        "allow_all_outbound": "allowAllOutbound",
        "description": "description",
        "disable_inline_rules": "disableInlineRules",
        "security_group_name": "securityGroupName",
    },
)
class SecurityGroupProps:
    def __init__(
        self,
        *,
        vpc: IVpc,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        description: typing.Optional[builtins.str] = None,
        disable_inline_rules: typing.Optional[builtins.bool] = None,
        security_group_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param vpc: The VPC in which to create the security group.
        :param allow_all_outbound: Whether to allow all outbound traffic by default. If this is set to true, there will only be a single egress rule which allows all outbound traffic. If this is set to false, no outbound traffic will be allowed by default and all egress traffic must be explicitly authorized. Default: true
        :param description: A description of the security group. Default: The default name will be the construct's CDK path.
        :param disable_inline_rules: Whether to disable inline ingress and egress rule optimization. If this is set to true, ingress and egress rules will not be declared under the SecurityGroup in cloudformation, but will be separate elements. Inlining rules is an optimization for producing smaller stack templates. Sometimes this is not desirable, for example when security group access is managed via tags. The default value can be overriden globally by setting the context variable '@aws-cdk/aws-ec2.securityGroupDisableInlineRules'. Default: false
        :param security_group_name: The name of the security group. For valid values, see the GroupName parameter of the CreateSecurityGroup action in the Amazon EC2 API Reference. It is not recommended to use an explicit group name. Default: If you don't specify a GroupName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # vpc: ec2.Vpc
            
            
            template = ec2.LaunchTemplate(self, "LaunchTemplate",
                machine_image=ec2.MachineImage.latest_amazon_linux(),
                security_group=ec2.SecurityGroup(self, "LaunchTemplateSG",
                    vpc=vpc
                )
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc": vpc,
        }
        if allow_all_outbound is not None:
            self._values["allow_all_outbound"] = allow_all_outbound
        if description is not None:
            self._values["description"] = description
        if disable_inline_rules is not None:
            self._values["disable_inline_rules"] = disable_inline_rules
        if security_group_name is not None:
            self._values["security_group_name"] = security_group_name

    @builtins.property
    def vpc(self) -> IVpc:
        '''The VPC in which to create the security group.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(IVpc, result)

    @builtins.property
    def allow_all_outbound(self) -> typing.Optional[builtins.bool]:
        '''Whether to allow all outbound traffic by default.

        If this is set to true, there will only be a single egress rule which allows all
        outbound traffic. If this is set to false, no outbound traffic will be allowed by
        default and all egress traffic must be explicitly authorized.

        :default: true
        '''
        result = self._values.get("allow_all_outbound")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''A description of the security group.

        :default: The default name will be the construct's CDK path.
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disable_inline_rules(self) -> typing.Optional[builtins.bool]:
        '''Whether to disable inline ingress and egress rule optimization.

        If this is set to true, ingress and egress rules will not be declared under the
        SecurityGroup in cloudformation, but will be separate elements.

        Inlining rules is an optimization for producing smaller stack templates. Sometimes
        this is not desirable, for example when security group access is managed via tags.

        The default value can be overriden globally by setting the context variable
        '@aws-cdk/aws-ec2.securityGroupDisableInlineRules'.

        :default: false
        '''
        result = self._values.get("disable_inline_rules")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def security_group_name(self) -> typing.Optional[builtins.str]:
        '''The name of the security group.

        For valid values, see the GroupName
        parameter of the CreateSecurityGroup action in the Amazon EC2 API
        Reference.

        It is not recommended to use an explicit group name.

        :default:

        If you don't specify a GroupName, AWS CloudFormation generates a
        unique physical ID and uses that ID for the group name.
        '''
        result = self._values.get("security_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecurityGroupProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SelectedSubnets",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zones": "availabilityZones",
        "has_public": "hasPublic",
        "internet_connectivity_established": "internetConnectivityEstablished",
        "subnet_ids": "subnetIds",
        "subnets": "subnets",
        "is_pending_lookup": "isPendingLookup",
    },
)
class SelectedSubnets:
    def __init__(
        self,
        *,
        availability_zones: typing.Sequence[builtins.str],
        has_public: builtins.bool,
        internet_connectivity_established: constructs.IDependable,
        subnet_ids: typing.Sequence[builtins.str],
        subnets: typing.Sequence[ISubnet],
        is_pending_lookup: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Result of selecting a subset of subnets from a VPC.

        :param availability_zones: The respective AZs of each subnet.
        :param has_public: Whether any of the given subnets are from the VPC's public subnets.
        :param internet_connectivity_established: Dependency representing internet connectivity for these subnets.
        :param subnet_ids: The subnet IDs.
        :param subnets: Selected subnet objects.
        :param is_pending_lookup: The subnet selection is not actually real yet. If this value is true, don't validate anything about the subnets. The count or identities are not known yet, and the validation will most likely fail which will prevent a successful lookup. Default: false

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            vpc = ec2.Vpc(self, "TheVPC",
                cidr="10.0.0.0/16"
            )
            
            # Iterate the private subnets
            selection = vpc.select_subnets(
                subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
            )
            
            for subnet in selection.subnets:
                pass
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zones": availability_zones,
            "has_public": has_public,
            "internet_connectivity_established": internet_connectivity_established,
            "subnet_ids": subnet_ids,
            "subnets": subnets,
        }
        if is_pending_lookup is not None:
            self._values["is_pending_lookup"] = is_pending_lookup

    @builtins.property
    def availability_zones(self) -> typing.List[builtins.str]:
        '''The respective AZs of each subnet.'''
        result = self._values.get("availability_zones")
        assert result is not None, "Required property 'availability_zones' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def has_public(self) -> builtins.bool:
        '''Whether any of the given subnets are from the VPC's public subnets.'''
        result = self._values.get("has_public")
        assert result is not None, "Required property 'has_public' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependency representing internet connectivity for these subnets.'''
        result = self._values.get("internet_connectivity_established")
        assert result is not None, "Required property 'internet_connectivity_established' is missing"
        return typing.cast(constructs.IDependable, result)

    @builtins.property
    def subnet_ids(self) -> typing.List[builtins.str]:
        '''The subnet IDs.'''
        result = self._values.get("subnet_ids")
        assert result is not None, "Required property 'subnet_ids' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def subnets(self) -> typing.List[ISubnet]:
        '''Selected subnet objects.'''
        result = self._values.get("subnets")
        assert result is not None, "Required property 'subnets' is missing"
        return typing.cast(typing.List[ISubnet], result)

    @builtins.property
    def is_pending_lookup(self) -> typing.Optional[builtins.bool]:
        '''The subnet selection is not actually real yet.

        If this value is true, don't validate anything about the subnets. The count
        or identities are not known yet, and the validation will most likely fail
        which will prevent a successful lookup.

        :default: false
        '''
        result = self._values.get("is_pending_lookup")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SelectedSubnets(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.SpotInstanceInterruption")
class SpotInstanceInterruption(enum.Enum):
    '''Provides the options for the types of interruption for spot instances.'''

    STOP = "STOP"
    '''The instance will stop when interrupted.'''
    TERMINATE = "TERMINATE"
    '''The instance will be terminated when interrupted.'''
    HIBERNATE = "HIBERNATE"
    '''The instance will hibernate when interrupted.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.SpotRequestType")
class SpotRequestType(enum.Enum):
    '''The Spot Instance request type.

    :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-requests.html
    '''

    ONE_TIME = "ONE_TIME"
    '''A one-time Spot Instance request remains active until Amazon EC2 launches the Spot Instance, the request expires, or you cancel the request.

    If the Spot price exceeds your maximum price
    or capacity is not available, your Spot Instance is terminated and the Spot Instance request
    is closed.
    '''
    PERSISTENT = "PERSISTENT"
    '''A persistent Spot Instance request remains active until it expires or you cancel it, even if the request is fulfilled.

    If the Spot price exceeds your maximum price or capacity is not available,
    your Spot Instance is interrupted. After your instance is interrupted, when your maximum price exceeds
    the Spot price or capacity becomes available again, the Spot Instance is started if stopped or resumed
    if hibernated.
    '''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SsmParameterImageOptions",
    jsii_struct_bases=[],
    name_mapping={
        "cached_in_context": "cachedInContext",
        "os": "os",
        "user_data": "userData",
    },
)
class SsmParameterImageOptions:
    def __init__(
        self,
        *,
        cached_in_context: typing.Optional[builtins.bool] = None,
        os: typing.Optional[OperatingSystemType] = None,
        user_data: typing.Optional["UserData"] = None,
    ) -> None:
        '''Properties for GenericSsmParameterImage.

        :param cached_in_context: Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false
        :param os: Operating system. Default: OperatingSystemType.LINUX
        :param user_data: Custom UserData. Default: - UserData appropriate for the OS

        :exampleMetadata: lit=aws-ec2/test/example.images.lit.ts infused

        Example::

            # Pick the right Amazon Linux edition. All arguments shown are optional
            # and will default to these values when omitted.
            amzn_linux = ec2.MachineImage.latest_amazon_linux(
                generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
                edition=ec2.AmazonLinuxEdition.STANDARD,
                virtualization=ec2.AmazonLinuxVirt.HVM,
                storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE,
                cpu_type=ec2.AmazonLinuxCpuType.X86_64
            )
            
            # Pick a Windows edition to use
            windows = ec2.MachineImage.latest_windows(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
            
            # Read AMI id from SSM parameter store
            ssm = ec2.MachineImage.from_ssm_parameter("/my/ami", os=ec2.OperatingSystemType.LINUX)
            
            # Look up the most recent image matching a set of AMI filters.
            # In this case, look up the NAT instance AMI, by using a wildcard
            # in the 'name' field:
            nat_ami = ec2.MachineImage.lookup(
                name="amzn-ami-vpc-nat-*",
                owners=["amazon"]
            )
            
            # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
            # a map giving the AMI to in for each region:
            linux = ec2.MachineImage.generic_linux({
                "us-east-1": "ami-97785bed",
                "eu-west-1": "ami-12345678"
            })
            
            # For other custom (Windows) images, instantiate a `GenericWindowsImage` with
            # a map giving the AMI to in for each region:
            generic_windows = ec2.MachineImage.generic_windows({
                "us-east-1": "ami-97785bed",
                "eu-west-1": "ami-12345678"
            })
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if cached_in_context is not None:
            self._values["cached_in_context"] = cached_in_context
        if os is not None:
            self._values["os"] = os
        if user_data is not None:
            self._values["user_data"] = user_data

    @builtins.property
    def cached_in_context(self) -> typing.Optional[builtins.bool]:
        '''Whether the AMI ID is cached to be stable between deployments.

        By default, the newest image is used on each deployment. This will cause
        instances to be replaced whenever a new version is released, and may cause
        downtime if there aren't enough running instances in the AutoScalingGroup
        to reschedule the tasks on.

        If set to true, the AMI ID will be cached in ``cdk.context.json`` and the
        same value will be used on future runs. Your instances will not be replaced
        but your AMI version will grow old over time. To refresh the AMI lookup,
        you will have to evict the value from the cache using the ``cdk context``
        command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for
        more information.

        Can not be set to ``true`` in environment-agnostic stacks.

        :default: false
        '''
        result = self._values.get("cached_in_context")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def os(self) -> typing.Optional[OperatingSystemType]:
        '''Operating system.

        :default: OperatingSystemType.LINUX
        '''
        result = self._values.get("os")
        return typing.cast(typing.Optional[OperatingSystemType], result)

    @builtins.property
    def user_data(self) -> typing.Optional["UserData"]:
        '''Custom UserData.

        :default: - UserData appropriate for the OS
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional["UserData"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SsmParameterImageOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(ISubnet)
class Subnet(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.Subnet",
):
    '''Represents a new VPC subnet resource.

    :exampleMetadata: infused
    :resource: AWS::EC2::Subnet

    Example::

        # cluster: ecs.Cluster
        
        load_balanced_fargate_service = ecs_patterns.ApplicationLoadBalancedFargateService(self, "Service",
            cluster=cluster,
            memory_limit_mi_b=1024,
            desired_count=1,
            cpu=512,
            task_image_options=ecsPatterns.ApplicationLoadBalancedTaskImageOptions(
                image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")
            ),
            task_subnets=ec2.SubnetSelection(
                subnets=[ec2.Subnet.from_subnet_id(self, "subnet", "VpcISOLATEDSubnet1Subnet80F07FA0")]
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param availability_zone: The availability zone for the subnet.
        :param cidr_block: The CIDR notation for this subnet.
        :param vpc_id: The VPC which this subnet is part of.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        props = SubnetProps(
            availability_zone=availability_zone,
            cidr_block=cidr_block,
            vpc_id=vpc_id,
            map_public_ip_on_launch=map_public_ip_on_launch,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromSubnetAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_subnet_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_id: builtins.str,
        availability_zone: typing.Optional[builtins.str] = None,
        ipv4_cidr_block: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> ISubnet:
        '''
        :param scope: -
        :param id: -
        :param subnet_id: The subnetId for this particular subnet.
        :param availability_zone: The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features
        :param ipv4_cidr_block: The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features
        :param route_table_id: The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints
        '''
        attrs = SubnetAttributes(
            subnet_id=subnet_id,
            availability_zone=availability_zone,
            ipv4_cidr_block=ipv4_cidr_block,
            route_table_id=route_table_id,
        )

        return typing.cast(ISubnet, jsii.sinvoke(cls, "fromSubnetAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="fromSubnetId") # type: ignore[misc]
    @builtins.classmethod
    def from_subnet_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        subnet_id: builtins.str,
    ) -> ISubnet:
        '''Import existing subnet from id.

        :param scope: -
        :param id: -
        :param subnet_id: -
        '''
        return typing.cast(ISubnet, jsii.sinvoke(cls, "fromSubnetId", [scope, id, subnet_id]))

    @jsii.member(jsii_name="isVpcSubnet") # type: ignore[misc]
    @builtins.classmethod
    def is_vpc_subnet(cls, x: typing.Any) -> builtins.bool:
        '''
        :param x: -
        '''
        return typing.cast(builtins.bool, jsii.sinvoke(cls, "isVpcSubnet", [x]))

    @jsii.member(jsii_name="addDefaultInternetRoute")
    def add_default_internet_route(
        self,
        gateway_id: builtins.str,
        gateway_attachment: constructs.IDependable,
    ) -> None:
        '''Create a default route that points to a passed IGW, with a dependency on the IGW's attachment to the VPC.

        :param gateway_id: the logical ID (ref) of the gateway attached to your VPC.
        :param gateway_attachment: the gateway attachment construct to be added as a dependency.
        '''
        return typing.cast(None, jsii.invoke(self, "addDefaultInternetRoute", [gateway_id, gateway_attachment]))

    @jsii.member(jsii_name="addDefaultNatRoute")
    def add_default_nat_route(self, nat_gateway_id: builtins.str) -> None:
        '''Adds an entry to this subnets route table that points to the passed NATGatewayId.

        :param nat_gateway_id: The ID of the NAT gateway.
        '''
        return typing.cast(None, jsii.invoke(self, "addDefaultNatRoute", [nat_gateway_id]))

    @jsii.member(jsii_name="addRoute")
    def add_route(
        self,
        id: builtins.str,
        *,
        router_id: builtins.str,
        router_type: RouterType,
        destination_cidr_block: typing.Optional[builtins.str] = None,
        destination_ipv6_cidr_block: typing.Optional[builtins.str] = None,
        enables_internet_connectivity: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Adds an entry to this subnets route table.

        :param id: -
        :param router_id: The ID of the router. Can be an instance ID, gateway ID, etc, depending on the router type.
        :param router_type: What type of router to route this traffic to.
        :param destination_cidr_block: IPv4 range this route applies to. Default: '0.0.0.0/0'
        :param destination_ipv6_cidr_block: IPv6 range this route applies to. Default: - Uses IPv6
        :param enables_internet_connectivity: Whether this route will enable internet connectivity. If true, this route will be added before any AWS resources that depend on internet connectivity in the VPC will be created. Default: false
        '''
        options = AddRouteOptions(
            router_id=router_id,
            router_type=router_type,
            destination_cidr_block=destination_cidr_block,
            destination_ipv6_cidr_block=destination_ipv6_cidr_block,
            enables_internet_connectivity=enables_internet_connectivity,
        )

        return typing.cast(None, jsii.invoke(self, "addRoute", [id, options]))

    @jsii.member(jsii_name="associateNetworkAcl")
    def associate_network_acl(self, id: builtins.str, network_acl: INetworkAcl) -> None:
        '''Associate a Network ACL with this subnet.

        :param id: -
        :param network_acl: -
        '''
        return typing.cast(None, jsii.invoke(self, "associateNetworkAcl", [id, network_acl]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone the subnet is located in.'''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dependencyElements")
    def dependency_elements(self) -> typing.List[constructs.IDependable]:
        '''Parts of this VPC subnet.'''
        return typing.cast(typing.List[constructs.IDependable], jsii.get(self, "dependencyElements"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetConnectivityEstablished")
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force internet connectivity established on the VPC.'''
        return typing.cast(constructs.IDependable, jsii.get(self, "internetConnectivityEstablished"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="ipv4CidrBlock")
    def ipv4_cidr_block(self) -> builtins.str:
        '''The IPv4 CIDR block for this subnet.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "ipv4CidrBlock"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAcl")
    def network_acl(self) -> INetworkAcl:
        '''Network ACL associated with this Subnet.

        Upon creation, this is the default ACL which allows all traffic, except
        explicit DENY entries that you add.

        You can replace it with a custom ACL which denies all traffic except
        the explicit ALLOW entries that you add by creating a ``NetworkAcl``
        object and calling ``associateNetworkAcl()``.
        '''
        return typing.cast(INetworkAcl, jsii.get(self, "networkAcl"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="routeTable")
    def route_table(self) -> IRouteTable:
        '''The routeTableId attached to this subnet.'''
        return typing.cast(IRouteTable, jsii.get(self, "routeTable"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetAvailabilityZone")
    def subnet_availability_zone(self) -> builtins.str:
        '''
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetId")
    def subnet_id(self) -> builtins.str:
        '''The subnetId for this particular subnet.'''
        return typing.cast(builtins.str, jsii.get(self, "subnetId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetIpv6CidrBlocks")
    def subnet_ipv6_cidr_blocks(self) -> typing.List[builtins.str]:
        '''
        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "subnetIpv6CidrBlocks"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetNetworkAclAssociationId")
    def subnet_network_acl_association_id(self) -> builtins.str:
        '''
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetNetworkAclAssociationId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetOutpostArn")
    def subnet_outpost_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of the Outpost for this subnet (if one exists).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetOutpostArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetVpcId")
    def subnet_vpc_id(self) -> builtins.str:
        '''
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetVpcId"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SubnetAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "subnet_id": "subnetId",
        "availability_zone": "availabilityZone",
        "ipv4_cidr_block": "ipv4CidrBlock",
        "route_table_id": "routeTableId",
    },
)
class SubnetAttributes:
    def __init__(
        self,
        *,
        subnet_id: builtins.str,
        availability_zone: typing.Optional[builtins.str] = None,
        ipv4_cidr_block: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param subnet_id: The subnetId for this particular subnet.
        :param availability_zone: The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features
        :param ipv4_cidr_block: The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features
        :param route_table_id: The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # Supply all properties
            subnet1 = ec2.Subnet.from_subnet_attributes(self, "SubnetFromAttributes",
                subnet_id="s-1234",
                availability_zone="pub-az-4465",
                route_table_id="rt-145"
            )
            
            # Supply only subnet id
            subnet2 = ec2.Subnet.from_subnet_id(self, "SubnetFromId", "s-1234")
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_id": subnet_id,
        }
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if ipv4_cidr_block is not None:
            self._values["ipv4_cidr_block"] = ipv4_cidr_block
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The subnetId for this particular subnet.'''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone the subnet is located in.

        :default: - No AZ information, cannot use AZ selection features
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR block associated with the subnet.

        :default: - No CIDR information, cannot use CIDR filter features
        '''
        result = self._values.get("ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table for this particular subnet.

        :default: - No route table information, cannot create VPC endpoints
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SubnetConfiguration",
    jsii_struct_bases=[],
    name_mapping={
        "name": "name",
        "subnet_type": "subnetType",
        "cidr_mask": "cidrMask",
        "map_public_ip_on_launch": "mapPublicIpOnLaunch",
        "reserved": "reserved",
    },
)
class SubnetConfiguration:
    def __init__(
        self,
        *,
        name: builtins.str,
        subnet_type: "SubnetType",
        cidr_mask: typing.Optional[jsii.Number] = None,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
        reserved: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Specify configuration parameters for a single subnet group in a VPC.

        :param name: Logical name for the subnet group. This name can be used when selecting VPC subnets to distinguish between different subnet groups of the same type.
        :param subnet_type: The type of Subnet to configure. The Subnet type will control the ability to route and connect to the Internet.
        :param cidr_mask: The number of leading 1 bits in the routing mask. The number of available IP addresses in each subnet of this group will be equal to ``2^(32 - cidrMask) - 2``. Valid values are ``16--28``. Default: - Available IP space is evenly divided across subnets.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        :param reserved: Controls if subnet IP space needs to be reserved. When true, the IP space for the subnet is reserved but no actual resources are provisioned. This space is only dependent on the number of availability zones and on ``cidrMask`` - all other subnet properties are ignored. Default: false

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            subnet_configuration = ec2.SubnetConfiguration(
                name="name",
                subnet_type=ec2.SubnetType.PRIVATE_ISOLATED,
            
                # the properties below are optional
                cidr_mask=123,
                map_public_ip_on_launch=False,
                reserved=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "name": name,
            "subnet_type": subnet_type,
        }
        if cidr_mask is not None:
            self._values["cidr_mask"] = cidr_mask
        if map_public_ip_on_launch is not None:
            self._values["map_public_ip_on_launch"] = map_public_ip_on_launch
        if reserved is not None:
            self._values["reserved"] = reserved

    @builtins.property
    def name(self) -> builtins.str:
        '''Logical name for the subnet group.

        This name can be used when selecting VPC subnets to distinguish
        between different subnet groups of the same type.
        '''
        result = self._values.get("name")
        assert result is not None, "Required property 'name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_type(self) -> "SubnetType":
        '''The type of Subnet to configure.

        The Subnet type will control the ability to route and connect to the
        Internet.
        '''
        result = self._values.get("subnet_type")
        assert result is not None, "Required property 'subnet_type' is missing"
        return typing.cast("SubnetType", result)

    @builtins.property
    def cidr_mask(self) -> typing.Optional[jsii.Number]:
        '''The number of leading 1 bits in the routing mask.

        The number of available IP addresses in each subnet of this group
        will be equal to ``2^(32 - cidrMask) - 2``.

        Valid values are ``16--28``.

        :default: - Available IP space is evenly divided across subnets.
        '''
        result = self._values.get("cidr_mask")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def map_public_ip_on_launch(self) -> typing.Optional[builtins.bool]:
        '''Controls if a public IP is associated to an instance at launch.

        :default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        result = self._values.get("map_public_ip_on_launch")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def reserved(self) -> typing.Optional[builtins.bool]:
        '''Controls if subnet IP space needs to be reserved.

        When true, the IP space for the subnet is reserved but no actual
        resources are provisioned. This space is only dependent on the
        number of availability zones and on ``cidrMask`` - all other subnet
        properties are ignored.

        :default: false
        '''
        result = self._values.get("reserved")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetConfiguration(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SubnetFilter(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.SubnetFilter",
):
    '''Contains logic which chooses a set of subnets from a larger list, in conjunction with SubnetSelection, to determine where to place AWS resources such as VPC endpoints, EC2 instances, etc.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        subnet_filter = ec2.SubnetFilter.availability_zones(["availabilityZones"])
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="availabilityZones") # type: ignore[misc]
    @builtins.classmethod
    def availability_zones(
        cls,
        availability_zones: typing.Sequence[builtins.str],
    ) -> "SubnetFilter":
        '''Chooses subnets which are in one of the given availability zones.

        :param availability_zones: -
        '''
        return typing.cast("SubnetFilter", jsii.sinvoke(cls, "availabilityZones", [availability_zones]))

    @jsii.member(jsii_name="byCidrMask") # type: ignore[misc]
    @builtins.classmethod
    def by_cidr_mask(cls, mask: jsii.Number) -> "SubnetFilter":
        '''Chooses subnets which have the provided CIDR netmask.

        :param mask: -
        '''
        return typing.cast("SubnetFilter", jsii.sinvoke(cls, "byCidrMask", [mask]))

    @jsii.member(jsii_name="byIds") # type: ignore[misc]
    @builtins.classmethod
    def by_ids(cls, subnet_ids: typing.Sequence[builtins.str]) -> "SubnetFilter":
        '''Chooses subnets by id.

        :param subnet_ids: -
        '''
        return typing.cast("SubnetFilter", jsii.sinvoke(cls, "byIds", [subnet_ids]))

    @jsii.member(jsii_name="containsIpAddresses") # type: ignore[misc]
    @builtins.classmethod
    def contains_ip_addresses(
        cls,
        ipv4addrs: typing.Sequence[builtins.str],
    ) -> "SubnetFilter":
        '''Chooses subnets which contain any of the specified IP addresses.

        :param ipv4addrs: -
        '''
        return typing.cast("SubnetFilter", jsii.sinvoke(cls, "containsIpAddresses", [ipv4addrs]))

    @jsii.member(jsii_name="onePerAz") # type: ignore[misc]
    @builtins.classmethod
    def one_per_az(cls) -> "SubnetFilter":
        '''Chooses subnets such that there is at most one per availability zone.'''
        return typing.cast("SubnetFilter", jsii.sinvoke(cls, "onePerAz", []))

    @jsii.member(jsii_name="selectSubnets")
    def select_subnets(
        self,
        _subnets: typing.Sequence[ISubnet],
    ) -> typing.List[ISubnet]:
        '''Executes the subnet filtering logic, returning a filtered set of subnets.

        :param _subnets: -
        '''
        return typing.cast(typing.List[ISubnet], jsii.invoke(self, "selectSubnets", [_subnets]))


class _SubnetFilterProxy(SubnetFilter):
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, SubnetFilter).__jsii_proxy_class__ = lambda : _SubnetFilterProxy


@jsii.implements(ISubnetNetworkAclAssociation)
class SubnetNetworkAclAssociation(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.SubnetNetworkAclAssociation",
):
    '''
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # network_acl: ec2.NetworkAcl
        # subnet: ec2.Subnet
        
        subnet_network_acl_association = ec2.SubnetNetworkAclAssociation(self, "MySubnetNetworkAclAssociation",
            network_acl=network_acl,
            subnet=subnet,
        
            # the properties below are optional
            subnet_network_acl_association_name="subnetNetworkAclAssociationName"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        network_acl: INetworkAcl,
        subnet: ISubnet,
        subnet_network_acl_association_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param network_acl: The Network ACL this association is defined for.
        :param subnet: ID of the Subnet.
        :param subnet_network_acl_association_name: The name of the SubnetNetworkAclAssociation. It is not recommended to use an explicit name. Default: If you don't specify a SubnetNetworkAclAssociationName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        '''
        props = SubnetNetworkAclAssociationProps(
            network_acl=network_acl,
            subnet=subnet,
            subnet_network_acl_association_name=subnet_network_acl_association_name,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromSubnetNetworkAclAssociationAssociationId") # type: ignore[misc]
    @builtins.classmethod
    def from_subnet_network_acl_association_association_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        subnet_network_acl_association_association_id: builtins.str,
    ) -> ISubnetNetworkAclAssociation:
        '''
        :param scope: -
        :param id: -
        :param subnet_network_acl_association_association_id: -
        '''
        return typing.cast(ISubnetNetworkAclAssociation, jsii.sinvoke(cls, "fromSubnetNetworkAclAssociationAssociationId", [scope, id, subnet_network_acl_association_association_id]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="networkAcl")
    def network_acl(self) -> INetworkAcl:
        '''ID for the current Network ACL.

        :attribute: true
        '''
        return typing.cast(INetworkAcl, jsii.get(self, "networkAcl"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnet")
    def subnet(self) -> ISubnet:
        '''ID of the Subnet.

        :attribute: true
        '''
        return typing.cast(ISubnet, jsii.get(self, "subnet"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="subnetNetworkAclAssociationAssociationId")
    def subnet_network_acl_association_association_id(self) -> builtins.str:
        '''ID for the current SubnetNetworkAclAssociation.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "subnetNetworkAclAssociationAssociationId"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SubnetNetworkAclAssociationProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_acl": "networkAcl",
        "subnet": "subnet",
        "subnet_network_acl_association_name": "subnetNetworkAclAssociationName",
    },
)
class SubnetNetworkAclAssociationProps:
    def __init__(
        self,
        *,
        network_acl: INetworkAcl,
        subnet: ISubnet,
        subnet_network_acl_association_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties to create a SubnetNetworkAclAssociation.

        :param network_acl: The Network ACL this association is defined for.
        :param subnet: ID of the Subnet.
        :param subnet_network_acl_association_name: The name of the SubnetNetworkAclAssociation. It is not recommended to use an explicit name. Default: If you don't specify a SubnetNetworkAclAssociationName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # network_acl: ec2.NetworkAcl
            # subnet: ec2.Subnet
            
            subnet_network_acl_association_props = ec2.SubnetNetworkAclAssociationProps(
                network_acl=network_acl,
                subnet=subnet,
            
                # the properties below are optional
                subnet_network_acl_association_name="subnetNetworkAclAssociationName"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "network_acl": network_acl,
            "subnet": subnet,
        }
        if subnet_network_acl_association_name is not None:
            self._values["subnet_network_acl_association_name"] = subnet_network_acl_association_name

    @builtins.property
    def network_acl(self) -> INetworkAcl:
        '''The Network ACL this association is defined for.

        :attribute: true
        '''
        result = self._values.get("network_acl")
        assert result is not None, "Required property 'network_acl' is missing"
        return typing.cast(INetworkAcl, result)

    @builtins.property
    def subnet(self) -> ISubnet:
        '''ID of the Subnet.

        :attribute: true
        '''
        result = self._values.get("subnet")
        assert result is not None, "Required property 'subnet' is missing"
        return typing.cast(ISubnet, result)

    @builtins.property
    def subnet_network_acl_association_name(self) -> typing.Optional[builtins.str]:
        '''The name of the SubnetNetworkAclAssociation.

        It is not recommended to use an explicit name.

        :default:

        If you don't specify a SubnetNetworkAclAssociationName, AWS CloudFormation generates a
        unique physical ID and uses that ID for the group name.
        '''
        result = self._values.get("subnet_network_acl_association_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetNetworkAclAssociationProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SubnetProps",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "cidr_block": "cidrBlock",
        "vpc_id": "vpcId",
        "map_public_ip_on_launch": "mapPublicIpOnLaunch",
    },
)
class SubnetProps:
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Specify configuration parameters for a VPC subnet.

        :param availability_zone: The availability zone for the subnet.
        :param cidr_block: The CIDR notation for this subnet.
        :param vpc_id: The VPC which this subnet is part of.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            subnet_props = ec2.SubnetProps(
                availability_zone="availabilityZone",
                cidr_block="cidrBlock",
                vpc_id="vpcId",
            
                # the properties below are optional
                map_public_ip_on_launch=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
            "cidr_block": cidr_block,
            "vpc_id": vpc_id,
        }
        if map_public_ip_on_launch is not None:
            self._values["map_public_ip_on_launch"] = map_public_ip_on_launch

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The availability zone for the subnet.'''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidr_block(self) -> builtins.str:
        '''The CIDR notation for this subnet.'''
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The VPC which this subnet is part of.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def map_public_ip_on_launch(self) -> typing.Optional[builtins.bool]:
        '''Controls if a public IP is associated to an instance at launch.

        :default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        result = self._values.get("map_public_ip_on_launch")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.SubnetSelection",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zones": "availabilityZones",
        "one_per_az": "onePerAz",
        "subnet_filters": "subnetFilters",
        "subnet_group_name": "subnetGroupName",
        "subnets": "subnets",
        "subnet_type": "subnetType",
    },
)
class SubnetSelection:
    def __init__(
        self,
        *,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        one_per_az: typing.Optional[builtins.bool] = None,
        subnet_filters: typing.Optional[typing.Sequence[SubnetFilter]] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[ISubnet]] = None,
        subnet_type: typing.Optional["SubnetType"] = None,
    ) -> None:
        '''Customize subnets that are selected for placement of ENIs.

        Constructs that allow customization of VPC placement use parameters of this
        type to provide placement settings.

        By default, the instances are placed in the private subnets.

        :param availability_zones: Select subnets only in the given AZs. Default: no filtering on AZs is done
        :param one_per_az: If true, return at most one subnet per AZ. Default: false
        :param subnet_filters: List of provided subnet filters. Default: - none
        :param subnet_group_name: Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name
        :param subnets: Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)
        :param subnet_type: Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)

        :exampleMetadata: infused

        Example::

            # vpc: ec2.Vpc
            
            cluster = docdb.DatabaseCluster(self, "Database",
                master_user=docdb.Login(
                    username="myuser",  # NOTE: 'admin' is reserved by DocumentDB
                    exclude_characters="\"@/:",  # optional, defaults to the set "\"@/" and is also used for eventually created rotations
                    secret_name="/myapp/mydocdb/masteruser"
                ),
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.R5, ec2.InstanceSize.LARGE),
                vpc_subnets=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PUBLIC
                ),
                vpc=vpc
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if availability_zones is not None:
            self._values["availability_zones"] = availability_zones
        if one_per_az is not None:
            self._values["one_per_az"] = one_per_az
        if subnet_filters is not None:
            self._values["subnet_filters"] = subnet_filters
        if subnet_group_name is not None:
            self._values["subnet_group_name"] = subnet_group_name
        if subnets is not None:
            self._values["subnets"] = subnets
        if subnet_type is not None:
            self._values["subnet_type"] = subnet_type

    @builtins.property
    def availability_zones(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Select subnets only in the given AZs.

        :default: no filtering on AZs is done
        '''
        result = self._values.get("availability_zones")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def one_per_az(self) -> typing.Optional[builtins.bool]:
        '''If true, return at most one subnet per AZ.

        :default: false
        '''
        result = self._values.get("one_per_az")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def subnet_filters(self) -> typing.Optional[typing.List[SubnetFilter]]:
        '''List of provided subnet filters.

        :default: - none
        '''
        result = self._values.get("subnet_filters")
        return typing.cast(typing.Optional[typing.List[SubnetFilter]], result)

    @builtins.property
    def subnet_group_name(self) -> typing.Optional[builtins.str]:
        '''Select the subnet group with the given name.

        Select the subnet group with the given name. This only needs
        to be used if you have multiple subnet groups of the same type
        and you need to distinguish between them. Otherwise, prefer
        ``subnetType``.

        This field does not select individual subnets, it selects all subnets that
        share the given subnet group name. This is the name supplied in
        ``subnetConfiguration``.

        At most one of ``subnetType`` and ``subnetGroupName`` can be supplied.

        :default: - Selection by type instead of by name
        '''
        result = self._values.get("subnet_group_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnets(self) -> typing.Optional[typing.List[ISubnet]]:
        '''Explicitly select individual subnets.

        Use this if you don't want to automatically use all subnets in
        a group, but have a need to control selection down to
        individual subnets.

        Cannot be specified together with ``subnetType`` or ``subnetGroupName``.

        :default: - Use all subnets in a selected group (all private subnets by default)
        '''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[typing.List[ISubnet]], result)

    @builtins.property
    def subnet_type(self) -> typing.Optional["SubnetType"]:
        '''Select all subnets of the given type.

        At most one of ``subnetType`` and ``subnetGroupName`` can be supplied.

        :default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)
        '''
        result = self._values.get("subnet_type")
        return typing.cast(typing.Optional["SubnetType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SubnetSelection(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.SubnetType")
class SubnetType(enum.Enum):
    '''The type of Subnet.

    :exampleMetadata: infused

    Example::

        # vpc: ec2.Vpc
        
        cluster = docdb.DatabaseCluster(self, "Database",
            master_user=docdb.Login(
                username="myuser",  # NOTE: 'admin' is reserved by DocumentDB
                exclude_characters="\"@/:",  # optional, defaults to the set "\"@/" and is also used for eventually created rotations
                secret_name="/myapp/mydocdb/masteruser"
            ),
            instance_type=ec2.InstanceType.of(ec2.InstanceClass.R5, ec2.InstanceSize.LARGE),
            vpc_subnets=ec2.SubnetSelection(
                subnet_type=ec2.SubnetType.PUBLIC
            ),
            vpc=vpc
        )
    '''

    PRIVATE_ISOLATED = "PRIVATE_ISOLATED"
    '''Isolated Subnets do not route traffic to the Internet (in this VPC), and as such, do not require NAT gateways.

    Isolated subnets can only connect to or be connected to from other
    instances in the same VPC. A default VPC configuration will not include
    isolated subnets.

    This can be good for subnets with RDS or Elasticache instances,
    or which route Internet traffic through a peer VPC.
    '''
    PRIVATE_WITH_NAT = "PRIVATE_WITH_NAT"
    '''Subnet that routes to the internet (via a NAT gateway), but not vice versa.

    Instances in a private subnet can connect to the Internet, but will not
    allow connections to be initiated from the Internet. NAT Gateway(s) are
    required with this subnet type to route the Internet traffic through.
    If a NAT Gateway is not required or desired, use ``SubnetType.PRIVATE_ISOLATED`` instead.

    By default, a NAT gateway is created in every public subnet for maximum availability.
    Be aware that you will be charged for NAT gateways.

    Normally a Private subnet will use a NAT gateway in the same AZ, but
    if ``natGateways`` is used to reduce the number of NAT gateways, a NAT
    gateway from another AZ will be used instead.
    '''
    PUBLIC = "PUBLIC"
    '''Subnet connected to the Internet.

    Instances in a Public subnet can connect to the Internet and can be
    connected to from the Internet as long as they are launched with public
    IPs (controlled on the AutoScalingGroup or other constructs that launch
    instances).

    Public subnets route outbound traffic via an Internet Gateway.
    '''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.TrafficDirection")
class TrafficDirection(enum.Enum):
    '''Direction of traffic the AclEntry applies to.'''

    EGRESS = "EGRESS"
    '''Traffic leaving the subnet.'''
    INGRESS = "INGRESS"
    '''Traffic entering the subnet.'''


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.TransportProtocol")
class TransportProtocol(enum.Enum):
    '''Transport protocol for client VPN.'''

    TCP = "TCP"
    '''Transmission Control Protocol (TCP).'''
    UDP = "UDP"
    '''User Datagram Protocol (UDP).'''


class UserData(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.UserData",
):
    '''Instance User Data.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        multipart_user_data = ec2.MultipartUserData()
        commands_user_data = ec2.UserData.for_linux()
        multipart_user_data.add_user_data_part(commands_user_data, ec2.MultipartBody.SHELL_SCRIPT, True)
        
        # Adding commands to the multipartUserData adds them to commandsUserData, and vice-versa.
        multipart_user_data.add_commands("touch /root/multi.txt")
        commands_user_data.add_commands("touch /root/userdata.txt")
    '''

    def __init__(self) -> None:
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="custom") # type: ignore[misc]
    @builtins.classmethod
    def custom(cls, content: builtins.str) -> "UserData":
        '''Create a userdata object with custom content.

        :param content: -
        '''
        return typing.cast("UserData", jsii.sinvoke(cls, "custom", [content]))

    @jsii.member(jsii_name="forLinux") # type: ignore[misc]
    @builtins.classmethod
    def for_linux(cls, *, shebang: typing.Optional[builtins.str] = None) -> "UserData":
        '''Create a userdata object for Linux hosts.

        :param shebang: Shebang for the UserData script. Default: "#!/bin/bash"
        '''
        options = LinuxUserDataOptions(shebang=shebang)

        return typing.cast("UserData", jsii.sinvoke(cls, "forLinux", [options]))

    @jsii.member(jsii_name="forOperatingSystem") # type: ignore[misc]
    @builtins.classmethod
    def for_operating_system(cls, os: OperatingSystemType) -> "UserData":
        '''
        :param os: -
        '''
        return typing.cast("UserData", jsii.sinvoke(cls, "forOperatingSystem", [os]))

    @jsii.member(jsii_name="forWindows") # type: ignore[misc]
    @builtins.classmethod
    def for_windows(cls) -> "UserData":
        '''Create a userdata object for Windows hosts.'''
        return typing.cast("UserData", jsii.sinvoke(cls, "forWindows", []))

    @jsii.member(jsii_name="addCommands") # type: ignore[misc]
    @abc.abstractmethod
    def add_commands(self, *commands: builtins.str) -> None:
        '''Add one or more commands to the user data.

        :param commands: -
        '''
        ...

    @jsii.member(jsii_name="addExecuteFileCommand") # type: ignore[misc]
    @abc.abstractmethod
    def add_execute_file_command(
        self,
        *,
        file_path: builtins.str,
        arguments: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Adds commands to execute a file.

        :param file_path: The path to the file.
        :param arguments: The arguments to be passed to the file. Default: No arguments are passed to the file.
        '''
        ...

    @jsii.member(jsii_name="addOnExitCommands") # type: ignore[misc]
    @abc.abstractmethod
    def add_on_exit_commands(self, *commands: builtins.str) -> None:
        '''Add one or more commands to the user data that will run when the script exits.

        :param commands: -
        '''
        ...

    @jsii.member(jsii_name="addS3DownloadCommand") # type: ignore[misc]
    @abc.abstractmethod
    def add_s3_download_command(
        self,
        *,
        bucket: _IBucket_42e086fd,
        bucket_key: builtins.str,
        local_file: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''Adds commands to download a file from S3.

        :param bucket: Name of the S3 bucket to download from.
        :param bucket_key: The key of the file to download.
        :param local_file: The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey
        :param region: The region of the S3 Bucket (needed for access via VPC Gateway). Default: none

        :return: : The local path that the file will be downloaded to
        '''
        ...

    @jsii.member(jsii_name="addSignalOnExitCommand") # type: ignore[misc]
    @abc.abstractmethod
    def add_signal_on_exit_command(self, resource: _Resource_45bc6135) -> None:
        '''Adds a command which will send a cfn-signal when the user data script ends.

        :param resource: -
        '''
        ...

    @jsii.member(jsii_name="render") # type: ignore[misc]
    @abc.abstractmethod
    def render(self) -> builtins.str:
        '''Render the UserData for use in a construct.'''
        ...


class _UserDataProxy(UserData):
    @jsii.member(jsii_name="addCommands")
    def add_commands(self, *commands: builtins.str) -> None:
        '''Add one or more commands to the user data.

        :param commands: -
        '''
        return typing.cast(None, jsii.invoke(self, "addCommands", [*commands]))

    @jsii.member(jsii_name="addExecuteFileCommand")
    def add_execute_file_command(
        self,
        *,
        file_path: builtins.str,
        arguments: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Adds commands to execute a file.

        :param file_path: The path to the file.
        :param arguments: The arguments to be passed to the file. Default: No arguments are passed to the file.
        '''
        params = ExecuteFileOptions(file_path=file_path, arguments=arguments)

        return typing.cast(None, jsii.invoke(self, "addExecuteFileCommand", [params]))

    @jsii.member(jsii_name="addOnExitCommands")
    def add_on_exit_commands(self, *commands: builtins.str) -> None:
        '''Add one or more commands to the user data that will run when the script exits.

        :param commands: -
        '''
        return typing.cast(None, jsii.invoke(self, "addOnExitCommands", [*commands]))

    @jsii.member(jsii_name="addS3DownloadCommand")
    def add_s3_download_command(
        self,
        *,
        bucket: _IBucket_42e086fd,
        bucket_key: builtins.str,
        local_file: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''Adds commands to download a file from S3.

        :param bucket: Name of the S3 bucket to download from.
        :param bucket_key: The key of the file to download.
        :param local_file: The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey
        :param region: The region of the S3 Bucket (needed for access via VPC Gateway). Default: none

        :return: : The local path that the file will be downloaded to
        '''
        params = S3DownloadOptions(
            bucket=bucket, bucket_key=bucket_key, local_file=local_file, region=region
        )

        return typing.cast(builtins.str, jsii.invoke(self, "addS3DownloadCommand", [params]))

    @jsii.member(jsii_name="addSignalOnExitCommand")
    def add_signal_on_exit_command(self, resource: _Resource_45bc6135) -> None:
        '''Adds a command which will send a cfn-signal when the user data script ends.

        :param resource: -
        '''
        return typing.cast(None, jsii.invoke(self, "addSignalOnExitCommand", [resource]))

    @jsii.member(jsii_name="render")
    def render(self) -> builtins.str:
        '''Render the UserData for use in a construct.'''
        return typing.cast(builtins.str, jsii.invoke(self, "render", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, UserData).__jsii_proxy_class__ = lambda : _UserDataProxy


@jsii.implements(IVolume)
class Volume(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.Volume",
):
    '''Creates a new EBS Volume in AWS EC2.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # instance: ec2.Instance
        # role: iam.Role
        
        
        volume = ec2.Volume(self, "Volume",
            availability_zone="us-west-2a",
            size=Size.gibibytes(500),
            encrypted=True
        )
        
        volume.grant_attach_volume(role, [instance])
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        auto_enable_io: typing.Optional[builtins.bool] = None,
        enable_multi_attach: typing.Optional[builtins.bool] = None,
        encrypted: typing.Optional[builtins.bool] = None,
        encryption_key: typing.Optional[_IKey_5f11635f] = None,
        iops: typing.Optional[jsii.Number] = None,
        removal_policy: typing.Optional[_RemovalPolicy_9f93c814] = None,
        size: typing.Optional[_Size_7b441c34] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
        volume_type: typing.Optional[EbsDeviceVolumeType] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param availability_zone: The Availability Zone in which to create the volume.
        :param auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O. Default: false
        :param enable_multi_attach: Indicates whether Amazon EBS Multi-Attach is enabled. See {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html#considerations|Considerations and limitations} for the constraints of multi-attach. Default: false
        :param encrypted: Specifies whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default|Encryption by Default} in the Amazon Elastic Compute Cloud User Guide. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances|Supported Instance Types.} Default: false
        :param encryption_key: The customer-managed encryption key that is used to encrypt the Volume. The encrypted property must be true if this is provided. Note: If using an {@link aws-kms.IKey} created from a {@link aws-kms.Key.fromKeyArn()} here, then the KMS key **must** have the following in its Key policy; otherwise, the Volume will fail to create:: { "Effect": "Allow", "Principal": { "AWS": "<arn for your account-user> ex: arn:aws:iam::00000000000:root" }, "Resource": "*", "Action": [ "kms:DescribeKey", "kms:GenerateDataKeyWithoutPlainText", ], "Condition": { "StringEquals": { "kms:ViaService": "ec2.<Region>.amazonaws.com", (eg: ec2.us-east-1.amazonaws.com) "kms:CallerAccount": "0000000000" (your account ID) } } } Default: The default KMS key for the account, region, and EC2 service is used.
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. The maximum ratio is 50 IOPS/GiB for PROVISIONED_IOPS_SSD, and 500 IOPS/GiB for both PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3. See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html} for more information. This parameter is valid only for PROVISIONED_IOPS_SSD, PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3 volumes. Default: None -- Required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS if omitted.
        :param removal_policy: Policy to apply when the volume is removed from the stack. Default: RemovalPolicy.RETAIN
        :param size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html} for details on the allowable size for each type of volume. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        :param snapshot_id: The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size. Default: The EBS volume is not created from a snapshot.
        :param volume_name: The value of the physicalName property of this resource. Default: The physical name will be allocated by CloudFormation at deployment time
        :param volume_type: The type of the volume; what type of storage to use to form the EBS Volume. Default: {@link EbsDeviceVolumeType.GENERAL_PURPOSE_SSD}
        '''
        props = VolumeProps(
            availability_zone=availability_zone,
            auto_enable_io=auto_enable_io,
            enable_multi_attach=enable_multi_attach,
            encrypted=encrypted,
            encryption_key=encryption_key,
            iops=iops,
            removal_policy=removal_policy,
            size=size,
            snapshot_id=snapshot_id,
            volume_name=volume_name,
            volume_type=volume_type,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromVolumeAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_volume_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        volume_id: builtins.str,
        encryption_key: typing.Optional[_IKey_5f11635f] = None,
    ) -> IVolume:
        '''Import an existing EBS Volume into the Stack.

        :param scope: the scope of the import.
        :param id: the ID of the imported Volume in the construct tree.
        :param availability_zone: The availability zone that the EBS Volume is contained within (ex: us-west-2a).
        :param volume_id: The EBS Volume's ID.
        :param encryption_key: The customer-managed encryption key that is used to encrypt the Volume. Default: None -- The EBS Volume is not using a customer-managed KMS key for encryption.
        '''
        attrs = VolumeAttributes(
            availability_zone=availability_zone,
            volume_id=volume_id,
            encryption_key=encryption_key,
        )

        return typing.cast(IVolume, jsii.sinvoke(cls, "fromVolumeAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="grantAttachVolume")
    def grant_attach_volume(
        self,
        grantee: _IGrantable_71c4f5de,
        instances: typing.Optional[typing.Sequence[IInstance]] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to attach this Volume to an instance.

        CAUTION: Granting an instance permission to attach to itself using this method will lead to
        an unresolvable circular reference between the instance role and the instance.
        Use {@link IVolume.grantAttachVolumeToSelf} to grant an instance permission to attach this
        volume to itself.

        :param grantee: -
        :param instances: -
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantAttachVolume", [grantee, instances]))

    @jsii.member(jsii_name="grantAttachVolumeByResourceTag")
    def grant_attach_volume_by_resource_tag(
        self,
        grantee: _IGrantable_71c4f5de,
        constructs: typing.Sequence[constructs.Construct],
        tag_key_suffix: typing.Optional[builtins.str] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to attach the Volume by a ResourceTag condition.

        If you are looking to
        grant an Instance, AutoScalingGroup, EC2-Fleet, SpotFleet, ECS host, etc the ability to attach
        this volume to **itself** then this is the method you want to use.

        This is implemented by adding a Tag with key ``VolumeGrantAttach-<suffix>`` to the given
        constructs and this Volume, and then conditioning the Grant such that the grantee is only
        given the ability to AttachVolume if both the Volume and the destination Instance have that
        tag applied to them.

        :param grantee: -
        :param constructs: -
        :param tag_key_suffix: -
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantAttachVolumeByResourceTag", [grantee, constructs, tag_key_suffix]))

    @jsii.member(jsii_name="grantDetachVolume")
    def grant_detach_volume(
        self,
        grantee: _IGrantable_71c4f5de,
        instances: typing.Optional[typing.Sequence[IInstance]] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to detach this Volume from an instance CAUTION: Granting an instance permission to detach from itself using this method will lead to an unresolvable circular reference between the instance role and the instance.

        Use {@link IVolume.grantDetachVolumeFromSelf} to grant an instance permission to detach this
        volume from itself.

        :param grantee: -
        :param instances: -
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantDetachVolume", [grantee, instances]))

    @jsii.member(jsii_name="grantDetachVolumeByResourceTag")
    def grant_detach_volume_by_resource_tag(
        self,
        grantee: _IGrantable_71c4f5de,
        constructs: typing.Sequence[constructs.Construct],
        tag_key_suffix: typing.Optional[builtins.str] = None,
    ) -> _Grant_a7ae64f8:
        '''Grants permission to detach the Volume by a ResourceTag condition.

        This is implemented via the same mechanism as {@link IVolume.grantAttachVolumeByResourceTag},
        and is subject to the same conditions.

        :param grantee: -
        :param constructs: -
        :param tag_key_suffix: -
        '''
        return typing.cast(_Grant_a7ae64f8, jsii.invoke(self, "grantDetachVolumeByResourceTag", [grantee, constructs, tag_key_suffix]))

    @jsii.member(jsii_name="validateProps")
    def _validate_props(
        self,
        *,
        availability_zone: builtins.str,
        auto_enable_io: typing.Optional[builtins.bool] = None,
        enable_multi_attach: typing.Optional[builtins.bool] = None,
        encrypted: typing.Optional[builtins.bool] = None,
        encryption_key: typing.Optional[_IKey_5f11635f] = None,
        iops: typing.Optional[jsii.Number] = None,
        removal_policy: typing.Optional[_RemovalPolicy_9f93c814] = None,
        size: typing.Optional[_Size_7b441c34] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
        volume_type: typing.Optional[EbsDeviceVolumeType] = None,
    ) -> None:
        '''
        :param availability_zone: The Availability Zone in which to create the volume.
        :param auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O. Default: false
        :param enable_multi_attach: Indicates whether Amazon EBS Multi-Attach is enabled. See {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html#considerations|Considerations and limitations} for the constraints of multi-attach. Default: false
        :param encrypted: Specifies whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default|Encryption by Default} in the Amazon Elastic Compute Cloud User Guide. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances|Supported Instance Types.} Default: false
        :param encryption_key: The customer-managed encryption key that is used to encrypt the Volume. The encrypted property must be true if this is provided. Note: If using an {@link aws-kms.IKey} created from a {@link aws-kms.Key.fromKeyArn()} here, then the KMS key **must** have the following in its Key policy; otherwise, the Volume will fail to create:: { "Effect": "Allow", "Principal": { "AWS": "<arn for your account-user> ex: arn:aws:iam::00000000000:root" }, "Resource": "*", "Action": [ "kms:DescribeKey", "kms:GenerateDataKeyWithoutPlainText", ], "Condition": { "StringEquals": { "kms:ViaService": "ec2.<Region>.amazonaws.com", (eg: ec2.us-east-1.amazonaws.com) "kms:CallerAccount": "0000000000" (your account ID) } } } Default: The default KMS key for the account, region, and EC2 service is used.
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. The maximum ratio is 50 IOPS/GiB for PROVISIONED_IOPS_SSD, and 500 IOPS/GiB for both PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3. See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html} for more information. This parameter is valid only for PROVISIONED_IOPS_SSD, PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3 volumes. Default: None -- Required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS if omitted.
        :param removal_policy: Policy to apply when the volume is removed from the stack. Default: RemovalPolicy.RETAIN
        :param size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html} for details on the allowable size for each type of volume. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        :param snapshot_id: The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size. Default: The EBS volume is not created from a snapshot.
        :param volume_name: The value of the physicalName property of this resource. Default: The physical name will be allocated by CloudFormation at deployment time
        :param volume_type: The type of the volume; what type of storage to use to form the EBS Volume. Default: {@link EbsDeviceVolumeType.GENERAL_PURPOSE_SSD}
        '''
        props = VolumeProps(
            availability_zone=availability_zone,
            auto_enable_io=auto_enable_io,
            enable_multi_attach=enable_multi_attach,
            encrypted=encrypted,
            encryption_key=encryption_key,
            iops=iops,
            removal_policy=removal_policy,
            size=size,
            snapshot_id=snapshot_id,
            volume_name=volume_name,
            volume_type=volume_type,
        )

        return typing.cast(None, jsii.invoke(self, "validateProps", [props]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZone")
    def availability_zone(self) -> builtins.str:
        '''The availability zone that the EBS Volume is contained within (ex: us-west-2a).'''
        return typing.cast(builtins.str, jsii.get(self, "availabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="volumeId")
    def volume_id(self) -> builtins.str:
        '''The EBS Volume's ID.'''
        return typing.cast(builtins.str, jsii.get(self, "volumeId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="encryptionKey")
    def encryption_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The customer-managed encryption key that is used to encrypt the Volume.'''
        return typing.cast(typing.Optional[_IKey_5f11635f], jsii.get(self, "encryptionKey"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VolumeAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "volume_id": "volumeId",
        "encryption_key": "encryptionKey",
    },
)
class VolumeAttributes:
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        volume_id: builtins.str,
        encryption_key: typing.Optional[_IKey_5f11635f] = None,
    ) -> None:
        '''Attributes required to import an existing EBS Volume into the Stack.

        :param availability_zone: The availability zone that the EBS Volume is contained within (ex: us-west-2a).
        :param volume_id: The EBS Volume's ID.
        :param encryption_key: The customer-managed encryption key that is used to encrypt the Volume. Default: None -- The EBS Volume is not using a customer-managed KMS key for encryption.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_kms as kms
            
            # key: kms.Key
            
            volume_attributes = ec2.VolumeAttributes(
                availability_zone="availabilityZone",
                volume_id="volumeId",
            
                # the properties below are optional
                encryption_key=key
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
            "volume_id": volume_id,
        }
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The availability zone that the EBS Volume is contained within (ex: us-west-2a).'''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def volume_id(self) -> builtins.str:
        '''The EBS Volume's ID.'''
        result = self._values.get("volume_id")
        assert result is not None, "Required property 'volume_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The customer-managed encryption key that is used to encrypt the Volume.

        :default: None -- The EBS Volume is not using a customer-managed KMS key for encryption.
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_5f11635f], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VolumeAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VolumeProps",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zone": "availabilityZone",
        "auto_enable_io": "autoEnableIo",
        "enable_multi_attach": "enableMultiAttach",
        "encrypted": "encrypted",
        "encryption_key": "encryptionKey",
        "iops": "iops",
        "removal_policy": "removalPolicy",
        "size": "size",
        "snapshot_id": "snapshotId",
        "volume_name": "volumeName",
        "volume_type": "volumeType",
    },
)
class VolumeProps:
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        auto_enable_io: typing.Optional[builtins.bool] = None,
        enable_multi_attach: typing.Optional[builtins.bool] = None,
        encrypted: typing.Optional[builtins.bool] = None,
        encryption_key: typing.Optional[_IKey_5f11635f] = None,
        iops: typing.Optional[jsii.Number] = None,
        removal_policy: typing.Optional[_RemovalPolicy_9f93c814] = None,
        size: typing.Optional[_Size_7b441c34] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
        volume_name: typing.Optional[builtins.str] = None,
        volume_type: typing.Optional[EbsDeviceVolumeType] = None,
    ) -> None:
        '''Properties of an EBS Volume.

        :param availability_zone: The Availability Zone in which to create the volume.
        :param auto_enable_io: Indicates whether the volume is auto-enabled for I/O operations. By default, Amazon EBS disables I/O to the volume from attached EC2 instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O. Default: false
        :param enable_multi_attach: Indicates whether Amazon EBS Multi-Attach is enabled. See {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html#considerations|Considerations and limitations} for the constraints of multi-attach. Default: false
        :param encrypted: Specifies whether the volume should be encrypted. The effect of setting the encryption state to true depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default|Encryption by Default} in the Amazon Elastic Compute Cloud User Guide. Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances|Supported Instance Types.} Default: false
        :param encryption_key: The customer-managed encryption key that is used to encrypt the Volume. The encrypted property must be true if this is provided. Note: If using an {@link aws-kms.IKey} created from a {@link aws-kms.Key.fromKeyArn()} here, then the KMS key **must** have the following in its Key policy; otherwise, the Volume will fail to create:: { "Effect": "Allow", "Principal": { "AWS": "<arn for your account-user> ex: arn:aws:iam::00000000000:root" }, "Resource": "*", "Action": [ "kms:DescribeKey", "kms:GenerateDataKeyWithoutPlainText", ], "Condition": { "StringEquals": { "kms:ViaService": "ec2.<Region>.amazonaws.com", (eg: ec2.us-east-1.amazonaws.com) "kms:CallerAccount": "0000000000" (your account ID) } } } Default: The default KMS key for the account, region, and EC2 service is used.
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. The maximum ratio is 50 IOPS/GiB for PROVISIONED_IOPS_SSD, and 500 IOPS/GiB for both PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3. See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html} for more information. This parameter is valid only for PROVISIONED_IOPS_SSD, PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3 volumes. Default: None -- Required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS if omitted.
        :param removal_policy: Policy to apply when the volume is removed from the stack. Default: RemovalPolicy.RETAIN
        :param size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html} for details on the allowable size for each type of volume. Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        :param snapshot_id: The snapshot from which to create the volume. You must specify either a snapshot ID or a volume size. Default: The EBS volume is not created from a snapshot.
        :param volume_name: The value of the physicalName property of this resource. Default: The physical name will be allocated by CloudFormation at deployment time
        :param volume_type: The type of the volume; what type of storage to use to form the EBS Volume. Default: {@link EbsDeviceVolumeType.GENERAL_PURPOSE_SSD}

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # instance: ec2.Instance
            # role: iam.Role
            
            
            volume = ec2.Volume(self, "Volume",
                availability_zone="us-west-2a",
                size=Size.gibibytes(500),
                encrypted=True
            )
            
            volume.grant_attach_volume(role, [instance])
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
        }
        if auto_enable_io is not None:
            self._values["auto_enable_io"] = auto_enable_io
        if enable_multi_attach is not None:
            self._values["enable_multi_attach"] = enable_multi_attach
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if encryption_key is not None:
            self._values["encryption_key"] = encryption_key
        if iops is not None:
            self._values["iops"] = iops
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if size is not None:
            self._values["size"] = size
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id
        if volume_name is not None:
            self._values["volume_name"] = volume_name
        if volume_type is not None:
            self._values["volume_type"] = volume_type

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The Availability Zone in which to create the volume.'''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def auto_enable_io(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether the volume is auto-enabled for I/O operations.

        By default, Amazon EBS disables I/O to the volume from attached EC2
        instances when it determines that a volume's data is potentially inconsistent. If the consistency of the volume is not a concern, and
        you prefer that the volume be made available immediately if it's impaired, you can configure the volume to automatically enable I/O.

        :default: false
        '''
        result = self._values.get("auto_enable_io")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_multi_attach(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether Amazon EBS Multi-Attach is enabled.

        See {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volumes-multi.html#considerations|Considerations and limitations}
        for the constraints of multi-attach.

        :default: false
        '''
        result = self._values.get("enable_multi_attach")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def encrypted(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the volume should be encrypted.

        The effect of setting the encryption state to true depends on the volume origin
        (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information,
        see {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default|Encryption by Default}
        in the Amazon Elastic Compute Cloud User Guide.

        Encrypted Amazon EBS volumes must be attached to instances that support Amazon EBS encryption. For more information, see
        {@link https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances|Supported Instance Types.}

        :default: false
        '''
        result = self._values.get("encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def encryption_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The customer-managed encryption key that is used to encrypt the Volume.

        The encrypted property must
        be true if this is provided.

        Note: If using an {@link aws-kms.IKey} created from a {@link aws-kms.Key.fromKeyArn()} here,
        then the KMS key **must** have the following in its Key policy; otherwise, the Volume
        will fail to create::

            {
              "Effect": "Allow",
              "Principal": { "AWS": "<arn for your account-user> ex: arn:aws:iam::00000000000:root" },
              "Resource": "*",
              "Action": [
                "kms:DescribeKey",
                "kms:GenerateDataKeyWithoutPlainText",
              ],
              "Condition": {
                "StringEquals": {
                  "kms:ViaService": "ec2.<Region>.amazonaws.com", (eg: ec2.us-east-1.amazonaws.com)
                  "kms:CallerAccount": "0000000000" (your account ID)
                }
              }
            }

        :default: The default KMS key for the account, region, and EC2 service is used.
        '''
        result = self._values.get("encryption_key")
        return typing.cast(typing.Optional[_IKey_5f11635f], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) to provision for the volume.

        The maximum ratio is 50 IOPS/GiB for PROVISIONED_IOPS_SSD,
        and 500 IOPS/GiB for both PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3.
        See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html}
        for more information.

        This parameter is valid only for PROVISIONED_IOPS_SSD, PROVISIONED_IOPS_SSD_IO2 and GENERAL_PURPOSE_SSD_GP3 volumes.

        :default: None -- Required for io1 and io2 volumes. The default for gp3 volumes is 3,000 IOPS if omitted.
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_RemovalPolicy_9f93c814]:
        '''Policy to apply when the volume is removed from the stack.

        :default: RemovalPolicy.RETAIN
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_RemovalPolicy_9f93c814], result)

    @builtins.property
    def size(self) -> typing.Optional[_Size_7b441c34]:
        '''The size of the volume, in GiBs.

        You must specify either a snapshot ID or a volume size.
        See {@link https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html}
        for details on the allowable size for each type of volume.

        :default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.
        '''
        result = self._values.get("size")
        return typing.cast(typing.Optional[_Size_7b441c34], result)

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        '''The snapshot from which to create the volume.

        You must specify either a snapshot ID or a volume size.

        :default: The EBS volume is not created from a snapshot.
        '''
        result = self._values.get("snapshot_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_name(self) -> typing.Optional[builtins.str]:
        '''The value of the physicalName property of this resource.

        :default: The physical name will be allocated by CloudFormation at deployment time
        '''
        result = self._values.get("volume_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def volume_type(self) -> typing.Optional[EbsDeviceVolumeType]:
        '''The type of the volume;

        what type of storage to use to form the EBS Volume.

        :default: {@link EbsDeviceVolumeType.GENERAL_PURPOSE_SSD}
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional[EbsDeviceVolumeType], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VolumeProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IVpc)
class Vpc(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.Vpc",
):
    '''Define an AWS Virtual Private Cloud.

    See the package-level documentation of this package for an overview
    of the various dimensions in which you can configure your VPC.

    For example::

       # Example automatically generated from non-compiling source. May contain errors.
       vpc = ec2.Vpc(self, "TheVPC",
           cidr="10.0.0.0/16"
       )

       # Iterate the private subnets
       selection = vpc.select_subnets(
           subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
       )

       for subnet in selection.subnets:
           pass

    :exampleMetadata: infused
    :resource: AWS::EC2::VPC

    Example::

        vpc = ec2.Vpc(self, "Vpc", max_azs=1)
        cluster = ecs.Cluster(self, "EcsCluster", vpc=vpc)
        security_group = ec2.SecurityGroup(self, "SG", vpc=vpc)
        
        scheduled_fargate_task = ecs_patterns.ScheduledFargateTask(self, "ScheduledFargateTask",
            cluster=cluster,
            scheduled_fargate_task_image_options=ecsPatterns.ScheduledFargateTaskImageOptions(
                image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample"),
                memory_limit_mi_b=512
            ),
            schedule=appscaling.Schedule.expression("rate(1 minute)"),
            security_groups=[security_group]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        cidr: typing.Optional[builtins.str] = None,
        default_instance_tenancy: typing.Optional[DefaultInstanceTenancy] = None,
        enable_dns_hostnames: typing.Optional[builtins.bool] = None,
        enable_dns_support: typing.Optional[builtins.bool] = None,
        flow_logs: typing.Optional[typing.Mapping[builtins.str, FlowLogOptions]] = None,
        gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, GatewayVpcEndpointOptions]] = None,
        max_azs: typing.Optional[jsii.Number] = None,
        nat_gateway_provider: typing.Optional[NatProvider] = None,
        nat_gateways: typing.Optional[jsii.Number] = None,
        nat_gateway_subnets: typing.Optional[SubnetSelection] = None,
        subnet_configuration: typing.Optional[typing.Sequence[SubnetConfiguration]] = None,
        vpc_name: typing.Optional[builtins.str] = None,
        vpn_connections: typing.Optional[typing.Mapping[builtins.str, "VpnConnectionOptions"]] = None,
        vpn_gateway: typing.Optional[builtins.bool] = None,
        vpn_gateway_asn: typing.Optional[jsii.Number] = None,
        vpn_route_propagation: typing.Optional[typing.Sequence[SubnetSelection]] = None,
    ) -> None:
        '''Vpc creates a VPC that spans a whole region.

        It will automatically divide the provided VPC CIDR range, and create public and private subnets per Availability Zone.
        Network routing for the public subnets will be configured to allow outbound access directly via an Internet Gateway.
        Network routing for the private subnets will be configured to allow outbound access via a set of resilient NAT Gateways (one per AZ).

        :param scope: -
        :param id: -
        :param cidr: The CIDR range to use for the VPC, e.g. '10.0.0.0/16'. Should be a minimum of /28 and maximum size of /16. The range will be split across all subnets per Availability Zone. Default: Vpc.DEFAULT_CIDR_RANGE
        :param default_instance_tenancy: The default tenancy of instances launched into the VPC. By setting this to dedicated tenancy, instances will be launched on hardware dedicated to a single AWS customer, unless specifically specified at instance launch time. Please note, not all instance types are usable with Dedicated tenancy. Default: DefaultInstanceTenancy.Default (shared) tenancy
        :param enable_dns_hostnames: Indicates whether the instances launched in the VPC get public DNS hostnames. If this attribute is true, instances in the VPC get public DNS hostnames, but only if the enableDnsSupport attribute is also set to true. Default: true
        :param enable_dns_support: Indicates whether the DNS resolution is supported for the VPC. If this attribute is false, the Amazon-provided DNS server in the VPC that resolves public DNS hostnames to IP addresses is not enabled. If this attribute is true, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC IPv4 network range plus two will succeed. Default: true
        :param flow_logs: Flow logs to add to this VPC. Default: - No flow logs.
        :param gateway_endpoints: Gateway endpoints to add to this VPC. Default: - None.
        :param max_azs: Define the maximum number of AZs to use in this region. If the region has more AZs than you want to use (for example, because of EIP limits), pick a lower number here. The AZs will be sorted and picked from the start of the list. If you pick a higher number than the number of AZs in the region, all AZs in the region will be selected. To use "all AZs" available to your account, use a high number (such as 99). Be aware that environment-agnostic stacks will be created with access to only 2 AZs, so to use more than 2 AZs, be sure to specify the account and region on your stack. Default: 3
        :param nat_gateway_provider: What type of NAT provider to use. Select between NAT gateways or NAT instances. NAT gateways may not be available in all AWS regions. Default: NatProvider.gateway()
        :param nat_gateways: The number of NAT Gateways/Instances to create. The type of NAT gateway or instance will be determined by the ``natGatewayProvider`` parameter. You can set this number lower than the number of Availability Zones in your VPC in order to save on NAT cost. Be aware you may be charged for cross-AZ data traffic instead. Default: - One NAT gateway/instance per Availability Zone
        :param nat_gateway_subnets: Configures the subnets which will have NAT Gateways/Instances. You can pick a specific group of subnets by specifying the group name; the picked subnets must be public subnets. Only necessary if you have more than one public subnet group. Default: - All public subnets.
        :param subnet_configuration: Configure the subnets to build for each AZ. Each entry in this list configures a Subnet Group; each group will contain a subnet for each Availability Zone. For example, if you want 1 public subnet, 1 private subnet, and 1 isolated subnet in each AZ provide the following:: new ec2.Vpc(this, 'VPC', { subnetConfiguration: [ { cidrMask: 24, name: 'ingress', subnetType: ec2.SubnetType.PUBLIC, }, { cidrMask: 24, name: 'application', subnetType: ec2.SubnetType.PRIVATE_WITH_NAT, }, { cidrMask: 28, name: 'rds', subnetType: ec2.SubnetType.PRIVATE_ISOLATED, } ] }); Default: - The VPC CIDR will be evenly divided between 1 public and 1 private subnet per AZ.
        :param vpc_name: The VPC name. Since the VPC resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: this.node.path
        :param vpn_connections: VPN connections to this VPC. Default: - No connections.
        :param vpn_gateway: Indicates whether a VPN gateway should be created and attached to this VPC. Default: - true when vpnGatewayAsn or vpnConnections is specified
        :param vpn_gateway_asn: The private Autonomous System Number (ASN) for the VPN gateway. Default: - Amazon default ASN.
        :param vpn_route_propagation: Where to propagate VPN routes. Default: - On the route tables associated with private subnets. If no private subnets exists, isolated subnets are used. If no isolated subnets exists, public subnets are used.
        '''
        props = VpcProps(
            cidr=cidr,
            default_instance_tenancy=default_instance_tenancy,
            enable_dns_hostnames=enable_dns_hostnames,
            enable_dns_support=enable_dns_support,
            flow_logs=flow_logs,
            gateway_endpoints=gateway_endpoints,
            max_azs=max_azs,
            nat_gateway_provider=nat_gateway_provider,
            nat_gateways=nat_gateways,
            nat_gateway_subnets=nat_gateway_subnets,
            subnet_configuration=subnet_configuration,
            vpc_name=vpc_name,
            vpn_connections=vpn_connections,
            vpn_gateway=vpn_gateway,
            vpn_gateway_asn=vpn_gateway_asn,
            vpn_route_propagation=vpn_route_propagation,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromLookup") # type: ignore[misc]
    @builtins.classmethod
    def from_lookup(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        is_default: typing.Optional[builtins.bool] = None,
        region: typing.Optional[builtins.str] = None,
        subnet_group_name_tag: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpc_name: typing.Optional[builtins.str] = None,
    ) -> IVpc:
        '''Import an existing VPC from by querying the AWS environment this stack is deployed to.

        This function only needs to be used to use VPCs not defined in your CDK
        application. If you are looking to share a VPC between stacks, you can
        pass the ``Vpc`` object between stacks and use it as normal.

        Calling this method will lead to a lookup when the CDK CLI is executed.
        You can therefore not use any values that will only be available at
        CloudFormation execution time (i.e., Tokens).

        The VPC information will be cached in ``cdk.context.json`` and the same VPC
        will be used on future runs. To refresh the lookup, you will have to
        evict the value from the cache using the ``cdk context`` command. See
        https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information.

        :param scope: -
        :param id: -
        :param is_default: Whether to match the default VPC. Default: Don't care whether we return the default VPC
        :param region: Optional to override inferred region. Default: Current stack's environment region
        :param subnet_group_name_tag: Optional tag for subnet group name. If not provided, we'll look at the aws-cdk:subnet-name tag. If the subnet does not have the specified tag, we'll use its type as the name. Default: aws-cdk:subnet-name
        :param tags: Tags on the VPC. The VPC must have all of these tags Default: Don't filter on tags
        :param vpc_id: The ID of the VPC. If given, will import exactly this VPC. Default: Don't filter on vpcId
        :param vpc_name: The name of the VPC. If given, will import the VPC with this name. Default: Don't filter on vpcName
        '''
        options = VpcLookupOptions(
            is_default=is_default,
            region=region,
            subnet_group_name_tag=subnet_group_name_tag,
            tags=tags,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
        )

        return typing.cast(IVpc, jsii.sinvoke(cls, "fromLookup", [scope, id, options]))

    @jsii.member(jsii_name="fromVpcAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_vpc_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zones: typing.Sequence[builtins.str],
        vpc_id: builtins.str,
        isolated_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        isolated_subnet_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        isolated_subnet_route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_subnet_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_subnet_route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_subnet_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_subnet_route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpc_cidr_block: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
    ) -> IVpc:
        '''Import a VPC by supplying all attributes directly.

        NOTE: using ``fromVpcAttributes()`` with deploy-time parameters (like a ``Fn.importValue()`` or
        ``CfnParameter`` to represent a list of subnet IDs) sometimes accidentally works. It happens
        to work for constructs that need a list of subnets (like ``AutoScalingGroup`` and ``eks.Cluster``)
        but it does not work for constructs that need individual subnets (like
        ``Instance``). See https://github.com/aws/aws-cdk/issues/4118 for more
        information.

        Prefer to use ``Vpc.fromLookup()`` instead.

        :param scope: -
        :param id: -
        :param availability_zones: List of availability zones for the subnets in this VPC.
        :param vpc_id: VPC's identifier.
        :param isolated_subnet_ids: List of isolated subnet IDs. Must be undefined or match the availability zones in length and order.
        :param isolated_subnet_names: List of names for the isolated subnets. Must be undefined or have a name for every isolated subnet group.
        :param isolated_subnet_route_table_ids: List of IDs of routing tables for the isolated subnets. Must be undefined or have a name for every isolated subnet group.
        :param private_subnet_ids: List of private subnet IDs. Must be undefined or match the availability zones in length and order.
        :param private_subnet_names: List of names for the private subnets. Must be undefined or have a name for every private subnet group.
        :param private_subnet_route_table_ids: List of IDs of routing tables for the private subnets. Must be undefined or have a name for every private subnet group.
        :param public_subnet_ids: List of public subnet IDs. Must be undefined or match the availability zones in length and order.
        :param public_subnet_names: List of names for the public subnets. Must be undefined or have a name for every public subnet group.
        :param public_subnet_route_table_ids: List of IDs of routing tables for the public subnets. Must be undefined or have a name for every public subnet group.
        :param vpc_cidr_block: VPC's CIDR range. Default: - Retrieving the CIDR from the VPC will fail
        :param vpn_gateway_id: VPN gateway's identifier.
        '''
        attrs = VpcAttributes(
            availability_zones=availability_zones,
            vpc_id=vpc_id,
            isolated_subnet_ids=isolated_subnet_ids,
            isolated_subnet_names=isolated_subnet_names,
            isolated_subnet_route_table_ids=isolated_subnet_route_table_ids,
            private_subnet_ids=private_subnet_ids,
            private_subnet_names=private_subnet_names,
            private_subnet_route_table_ids=private_subnet_route_table_ids,
            public_subnet_ids=public_subnet_ids,
            public_subnet_names=public_subnet_names,
            public_subnet_route_table_ids=public_subnet_route_table_ids,
            vpc_cidr_block=vpc_cidr_block,
            vpn_gateway_id=vpn_gateway_id,
        )

        return typing.cast(IVpc, jsii.sinvoke(cls, "fromVpcAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="addClientVpnEndpoint")
    def add_client_vpn_endpoint(
        self,
        id: builtins.str,
        *,
        cidr: builtins.str,
        server_certificate_arn: builtins.str,
        authorize_all_users_to_vpc_cidr: typing.Optional[builtins.bool] = None,
        client_certificate_arn: typing.Optional[builtins.str] = None,
        client_connection_handler: typing.Optional[IClientVpnConnectionHandler] = None,
        client_login_banner: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        log_stream: typing.Optional[_ILogStream_dcfca8c2] = None,
        port: typing.Optional["VpnPort"] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        self_service_portal: typing.Optional[builtins.bool] = None,
        session_timeout: typing.Optional[ClientVpnSessionTimeout] = None,
        split_tunnel: typing.Optional[builtins.bool] = None,
        transport_protocol: typing.Optional[TransportProtocol] = None,
        user_based_authentication: typing.Optional[ClientVpnUserBasedAuthentication] = None,
        vpc_subnets: typing.Optional[SubnetSelection] = None,
    ) -> "ClientVpnEndpoint":
        '''Adds a new client VPN endpoint to this VPC.

        :param id: -
        :param cidr: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.
        :param server_certificate_arn: The ARN of the server certificate.
        :param authorize_all_users_to_vpc_cidr: Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true
        :param client_certificate_arn: The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication
        :param client_connection_handler: The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler
        :param client_login_banner: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client
        :param description: A brief description of the Client VPN endpoint. Default: - no description
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device
        :param logging: Whether to enable connections logging. Default: true
        :param log_group: A CloudWatch Logs log group for connection logging. Default: - a new group is created
        :param log_stream: A CloudWatch Logs log stream for connection logging. Default: - a new stream is created
        :param port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS
        :param security_groups: The security groups to apply to the target network. Default: - a new security group is created
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true
        :param session_timeout: The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false
        :param transport_protocol: The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP
        :param user_based_authentication: The type of user-based authentication to use. Default: - use mutual authentication
        :param vpc_subnets: Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy
        '''
        options = ClientVpnEndpointOptions(
            cidr=cidr,
            server_certificate_arn=server_certificate_arn,
            authorize_all_users_to_vpc_cidr=authorize_all_users_to_vpc_cidr,
            client_certificate_arn=client_certificate_arn,
            client_connection_handler=client_connection_handler,
            client_login_banner=client_login_banner,
            description=description,
            dns_servers=dns_servers,
            logging=logging,
            log_group=log_group,
            log_stream=log_stream,
            port=port,
            security_groups=security_groups,
            self_service_portal=self_service_portal,
            session_timeout=session_timeout,
            split_tunnel=split_tunnel,
            transport_protocol=transport_protocol,
            user_based_authentication=user_based_authentication,
            vpc_subnets=vpc_subnets,
        )

        return typing.cast("ClientVpnEndpoint", jsii.invoke(self, "addClientVpnEndpoint", [id, options]))

    @jsii.member(jsii_name="addFlowLog")
    def add_flow_log(
        self,
        id: builtins.str,
        *,
        destination: typing.Optional[FlowLogDestination] = None,
        traffic_type: typing.Optional[FlowLogTrafficType] = None,
    ) -> "FlowLog":
        '''Adds a new flow log to this VPC.

        :param id: -
        :param destination: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL
        '''
        options = FlowLogOptions(destination=destination, traffic_type=traffic_type)

        return typing.cast("FlowLog", jsii.invoke(self, "addFlowLog", [id, options]))

    @jsii.member(jsii_name="addGatewayEndpoint")
    def add_gateway_endpoint(
        self,
        id: builtins.str,
        *,
        service: IGatewayVpcEndpointService,
        subnets: typing.Optional[typing.Sequence[SubnetSelection]] = None,
    ) -> "GatewayVpcEndpoint":
        '''Adds a new gateway endpoint to this VPC.

        :param id: -
        :param service: The service to use for this gateway VPC endpoint.
        :param subnets: Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC
        '''
        options = GatewayVpcEndpointOptions(service=service, subnets=subnets)

        return typing.cast("GatewayVpcEndpoint", jsii.invoke(self, "addGatewayEndpoint", [id, options]))

    @jsii.member(jsii_name="addInterfaceEndpoint")
    def add_interface_endpoint(
        self,
        id: builtins.str,
        *,
        service: IInterfaceVpcEndpointService,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        subnets: typing.Optional[SubnetSelection] = None,
    ) -> "InterfaceVpcEndpoint":
        '''Adds a new interface endpoint to this VPC.

        :param id: -
        :param service: The service to use for this interface VPC endpoint.
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets
        '''
        options = InterfaceVpcEndpointOptions(
            service=service,
            lookup_supported_azs=lookup_supported_azs,
            open=open,
            private_dns_enabled=private_dns_enabled,
            security_groups=security_groups,
            subnets=subnets,
        )

        return typing.cast("InterfaceVpcEndpoint", jsii.invoke(self, "addInterfaceEndpoint", [id, options]))

    @jsii.member(jsii_name="addVpnConnection")
    def add_vpn_connection(
        self,
        id: builtins.str,
        *,
        ip: builtins.str,
        asn: typing.Optional[jsii.Number] = None,
        static_routes: typing.Optional[typing.Sequence[builtins.str]] = None,
        tunnel_options: typing.Optional[typing.Sequence["VpnTunnelOption"]] = None,
    ) -> "VpnConnection":
        '''Adds a new VPN connection to this VPC.

        :param id: -
        :param ip: The ip address of the customer gateway.
        :param asn: The ASN of the customer gateway. Default: 65000
        :param static_routes: The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)
        :param tunnel_options: The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options
        '''
        options = VpnConnectionOptions(
            ip=ip, asn=asn, static_routes=static_routes, tunnel_options=tunnel_options
        )

        return typing.cast("VpnConnection", jsii.invoke(self, "addVpnConnection", [id, options]))

    @jsii.member(jsii_name="enableVpnGateway")
    def enable_vpn_gateway(
        self,
        *,
        vpn_route_propagation: typing.Optional[typing.Sequence[SubnetSelection]] = None,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Adds a VPN Gateway to this VPC.

        :param vpn_route_propagation: Provide an array of subnets where the route propagation should be added. Default: noPropagation
        :param type: Default type ipsec.1.
        :param amazon_side_asn: Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000
        '''
        options = EnableVpnGatewayOptions(
            vpn_route_propagation=vpn_route_propagation,
            type=type,
            amazon_side_asn=amazon_side_asn,
        )

        return typing.cast(None, jsii.invoke(self, "enableVpnGateway", [options]))

    @jsii.member(jsii_name="selectSubnetObjects")
    def _select_subnet_objects(
        self,
        *,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        one_per_az: typing.Optional[builtins.bool] = None,
        subnet_filters: typing.Optional[typing.Sequence[SubnetFilter]] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[ISubnet]] = None,
        subnet_type: typing.Optional[SubnetType] = None,
    ) -> typing.List[ISubnet]:
        '''Return the subnets appropriate for the placement strategy.

        :param availability_zones: Select subnets only in the given AZs. Default: no filtering on AZs is done
        :param one_per_az: If true, return at most one subnet per AZ. Default: false
        :param subnet_filters: List of provided subnet filters. Default: - none
        :param subnet_group_name: Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name
        :param subnets: Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)
        :param subnet_type: Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)
        '''
        selection = SubnetSelection(
            availability_zones=availability_zones,
            one_per_az=one_per_az,
            subnet_filters=subnet_filters,
            subnet_group_name=subnet_group_name,
            subnets=subnets,
            subnet_type=subnet_type,
        )

        return typing.cast(typing.List[ISubnet], jsii.invoke(self, "selectSubnetObjects", [selection]))

    @jsii.member(jsii_name="selectSubnets")
    def select_subnets(
        self,
        *,
        availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        one_per_az: typing.Optional[builtins.bool] = None,
        subnet_filters: typing.Optional[typing.Sequence[SubnetFilter]] = None,
        subnet_group_name: typing.Optional[builtins.str] = None,
        subnets: typing.Optional[typing.Sequence[ISubnet]] = None,
        subnet_type: typing.Optional[SubnetType] = None,
    ) -> SelectedSubnets:
        '''Returns IDs of selected subnets.

        :param availability_zones: Select subnets only in the given AZs. Default: no filtering on AZs is done
        :param one_per_az: If true, return at most one subnet per AZ. Default: false
        :param subnet_filters: List of provided subnet filters. Default: - none
        :param subnet_group_name: Select the subnet group with the given name. Select the subnet group with the given name. This only needs to be used if you have multiple subnet groups of the same type and you need to distinguish between them. Otherwise, prefer ``subnetType``. This field does not select individual subnets, it selects all subnets that share the given subnet group name. This is the name supplied in ``subnetConfiguration``. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: - Selection by type instead of by name
        :param subnets: Explicitly select individual subnets. Use this if you don't want to automatically use all subnets in a group, but have a need to control selection down to individual subnets. Cannot be specified together with ``subnetType`` or ``subnetGroupName``. Default: - Use all subnets in a selected group (all private subnets by default)
        :param subnet_type: Select all subnets of the given type. At most one of ``subnetType`` and ``subnetGroupName`` can be supplied. Default: SubnetType.PRIVATE_WITH_NAT (or ISOLATED or PUBLIC if there are no PRIVATE_WITH_NAT subnets)
        '''
        selection = SubnetSelection(
            availability_zones=availability_zones,
            one_per_az=one_per_az,
            subnet_filters=subnet_filters,
            subnet_group_name=subnet_group_name,
            subnets=subnets,
            subnet_type=subnet_type,
        )

        return typing.cast(SelectedSubnets, jsii.invoke(self, "selectSubnets", [selection]))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="DEFAULT_CIDR_RANGE")
    def DEFAULT_CIDR_RANGE(cls) -> builtins.str:
        '''The default CIDR range used when creating VPCs.

        This can be overridden using VpcProps when creating a VPCNetwork resource.
        e.g. new VpcResource(this, { cidr: '192.168.0.0./16' })
        '''
        return typing.cast(builtins.str, jsii.sget(cls, "DEFAULT_CIDR_RANGE"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="DEFAULT_SUBNETS")
    def DEFAULT_SUBNETS(cls) -> typing.List[SubnetConfiguration]:
        '''The default subnet configuration.

        1 Public and 1 Private subnet per AZ evenly split
        '''
        return typing.cast(typing.List[SubnetConfiguration], jsii.sget(cls, "DEFAULT_SUBNETS"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="DEFAULT_SUBNETS_NO_NAT")
    def DEFAULT_SUBNETS_NO_NAT(cls) -> typing.List[SubnetConfiguration]:
        '''The default subnet configuration if natGateways specified to be 0.

        1 Public and 1 Isolated Subnet per AZ evenly split
        '''
        return typing.cast(typing.List[SubnetConfiguration], jsii.sget(cls, "DEFAULT_SUBNETS_NO_NAT"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="availabilityZones")
    def availability_zones(self) -> typing.List[builtins.str]:
        '''AZs for this VPC.'''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "availabilityZones"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dnsHostnamesEnabled")
    def dns_hostnames_enabled(self) -> builtins.bool:
        '''Indicates if instances launched in this VPC will have public DNS hostnames.'''
        return typing.cast(builtins.bool, jsii.get(self, "dnsHostnamesEnabled"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="dnsSupportEnabled")
    def dns_support_enabled(self) -> builtins.bool:
        '''Indicates if DNS support is enabled for this VPC.'''
        return typing.cast(builtins.bool, jsii.get(self, "dnsSupportEnabled"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetConnectivityEstablished")
    def internet_connectivity_established(self) -> constructs.IDependable:
        '''Dependencies for internet connectivity.'''
        return typing.cast(constructs.IDependable, jsii.get(self, "internetConnectivityEstablished"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="isolatedSubnets")
    def isolated_subnets(self) -> typing.List[ISubnet]:
        '''List of isolated subnets in this VPC.'''
        return typing.cast(typing.List[ISubnet], jsii.get(self, "isolatedSubnets"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="privateSubnets")
    def private_subnets(self) -> typing.List[ISubnet]:
        '''List of private subnets in this VPC.'''
        return typing.cast(typing.List[ISubnet], jsii.get(self, "privateSubnets"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="publicSubnets")
    def public_subnets(self) -> typing.List[ISubnet]:
        '''List of public subnets in this VPC.'''
        return typing.cast(typing.List[ISubnet], jsii.get(self, "publicSubnets"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcArn")
    def vpc_arn(self) -> builtins.str:
        '''Arn of this VPC.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcArn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcCidrBlock")
    def vpc_cidr_block(self) -> builtins.str:
        '''CIDR range for this VPC.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcCidrBlock"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcCidrBlockAssociations")
    def vpc_cidr_block_associations(self) -> typing.List[builtins.str]:
        '''
        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcCidrBlockAssociations"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcDefaultNetworkAcl")
    def vpc_default_network_acl(self) -> builtins.str:
        '''
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcDefaultNetworkAcl"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcDefaultSecurityGroup")
    def vpc_default_security_group(self) -> builtins.str:
        '''
        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcDefaultSecurityGroup"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcId")
    def vpc_id(self) -> builtins.str:
        '''Identifier for this VPC.'''
        return typing.cast(builtins.str, jsii.get(self, "vpcId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcIpv6CidrBlocks")
    def vpc_ipv6_cidr_blocks(self) -> typing.List[builtins.str]:
        '''
        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcIpv6CidrBlocks"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="internetGatewayId")
    def internet_gateway_id(self) -> typing.Optional[builtins.str]:
        '''Internet Gateway for the VPC.

        Note that in case the VPC is configured only
        with ISOLATED subnets, this attribute will be ``undefined``.
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "internetGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnGatewayId")
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''Returns the id of the VPN Gateway (if enabled).'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "vpnGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="incompleteSubnetDefinition")
    def _incomplete_subnet_definition(self) -> builtins.bool:
        '''If this is set to true, don't error out on trying to select subnets.'''
        return typing.cast(builtins.bool, jsii.get(self, "incompleteSubnetDefinition"))

    @_incomplete_subnet_definition.setter
    def _incomplete_subnet_definition(self, value: builtins.bool) -> None:
        jsii.set(self, "incompleteSubnetDefinition", value)


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpcAttributes",
    jsii_struct_bases=[],
    name_mapping={
        "availability_zones": "availabilityZones",
        "vpc_id": "vpcId",
        "isolated_subnet_ids": "isolatedSubnetIds",
        "isolated_subnet_names": "isolatedSubnetNames",
        "isolated_subnet_route_table_ids": "isolatedSubnetRouteTableIds",
        "private_subnet_ids": "privateSubnetIds",
        "private_subnet_names": "privateSubnetNames",
        "private_subnet_route_table_ids": "privateSubnetRouteTableIds",
        "public_subnet_ids": "publicSubnetIds",
        "public_subnet_names": "publicSubnetNames",
        "public_subnet_route_table_ids": "publicSubnetRouteTableIds",
        "vpc_cidr_block": "vpcCidrBlock",
        "vpn_gateway_id": "vpnGatewayId",
    },
)
class VpcAttributes:
    def __init__(
        self,
        *,
        availability_zones: typing.Sequence[builtins.str],
        vpc_id: builtins.str,
        isolated_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        isolated_subnet_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        isolated_subnet_route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_subnet_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        private_subnet_route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_subnet_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_subnet_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        public_subnet_route_table_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        vpc_cidr_block: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties that reference an external Vpc.

        :param availability_zones: List of availability zones for the subnets in this VPC.
        :param vpc_id: VPC's identifier.
        :param isolated_subnet_ids: List of isolated subnet IDs. Must be undefined or match the availability zones in length and order.
        :param isolated_subnet_names: List of names for the isolated subnets. Must be undefined or have a name for every isolated subnet group.
        :param isolated_subnet_route_table_ids: List of IDs of routing tables for the isolated subnets. Must be undefined or have a name for every isolated subnet group.
        :param private_subnet_ids: List of private subnet IDs. Must be undefined or match the availability zones in length and order.
        :param private_subnet_names: List of names for the private subnets. Must be undefined or have a name for every private subnet group.
        :param private_subnet_route_table_ids: List of IDs of routing tables for the private subnets. Must be undefined or have a name for every private subnet group.
        :param public_subnet_ids: List of public subnet IDs. Must be undefined or match the availability zones in length and order.
        :param public_subnet_names: List of names for the public subnets. Must be undefined or have a name for every public subnet group.
        :param public_subnet_route_table_ids: List of IDs of routing tables for the public subnets. Must be undefined or have a name for every public subnet group.
        :param vpc_cidr_block: VPC's CIDR range. Default: - Retrieving the CIDR from the VPC will fail
        :param vpn_gateway_id: VPN gateway's identifier.

        :exampleMetadata: infused

        Example::

            sg = ec2.SecurityGroup.from_security_group_id(self, "FsxSecurityGroup", "{SECURITY-GROUP-ID}")
            fs = fsx.LustreFileSystem.from_lustre_file_system_attributes(self, "FsxLustreFileSystem",
                dns_name="{FILE-SYSTEM-DNS-NAME}",
                file_system_id="{FILE-SYSTEM-ID}",
                security_group=sg
            )
            
            vpc = ec2.Vpc.from_vpc_attributes(self, "Vpc",
                availability_zones=["us-west-2a", "us-west-2b"],
                public_subnet_ids=["{US-WEST-2A-SUBNET-ID}", "{US-WEST-2B-SUBNET-ID}"],
                vpc_id="{VPC-ID}"
            )
            
            inst = ec2.Instance(self, "inst",
                instance_type=ec2.InstanceType.of(ec2.InstanceClass.T2, ec2.InstanceSize.LARGE),
                machine_image=ec2.AmazonLinuxImage(
                    generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2
                ),
                vpc=vpc,
                vpc_subnets=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PUBLIC
                )
            )
            
            fs.connections.allow_default_port_from(inst)
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zones": availability_zones,
            "vpc_id": vpc_id,
        }
        if isolated_subnet_ids is not None:
            self._values["isolated_subnet_ids"] = isolated_subnet_ids
        if isolated_subnet_names is not None:
            self._values["isolated_subnet_names"] = isolated_subnet_names
        if isolated_subnet_route_table_ids is not None:
            self._values["isolated_subnet_route_table_ids"] = isolated_subnet_route_table_ids
        if private_subnet_ids is not None:
            self._values["private_subnet_ids"] = private_subnet_ids
        if private_subnet_names is not None:
            self._values["private_subnet_names"] = private_subnet_names
        if private_subnet_route_table_ids is not None:
            self._values["private_subnet_route_table_ids"] = private_subnet_route_table_ids
        if public_subnet_ids is not None:
            self._values["public_subnet_ids"] = public_subnet_ids
        if public_subnet_names is not None:
            self._values["public_subnet_names"] = public_subnet_names
        if public_subnet_route_table_ids is not None:
            self._values["public_subnet_route_table_ids"] = public_subnet_route_table_ids
        if vpc_cidr_block is not None:
            self._values["vpc_cidr_block"] = vpc_cidr_block
        if vpn_gateway_id is not None:
            self._values["vpn_gateway_id"] = vpn_gateway_id

    @builtins.property
    def availability_zones(self) -> typing.List[builtins.str]:
        '''List of availability zones for the subnets in this VPC.'''
        result = self._values.get("availability_zones")
        assert result is not None, "Required property 'availability_zones' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''VPC's identifier.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def isolated_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of isolated subnet IDs.

        Must be undefined or match the availability zones in length and order.
        '''
        result = self._values.get("isolated_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def isolated_subnet_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of names for the isolated subnets.

        Must be undefined or have a name for every isolated subnet group.
        '''
        result = self._values.get("isolated_subnet_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def isolated_subnet_route_table_ids(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''List of IDs of routing tables for the isolated subnets.

        Must be undefined or have a name for every isolated subnet group.
        '''
        result = self._values.get("isolated_subnet_route_table_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def private_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of private subnet IDs.

        Must be undefined or match the availability zones in length and order.
        '''
        result = self._values.get("private_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def private_subnet_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of names for the private subnets.

        Must be undefined or have a name for every private subnet group.
        '''
        result = self._values.get("private_subnet_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def private_subnet_route_table_ids(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''List of IDs of routing tables for the private subnets.

        Must be undefined or have a name for every private subnet group.
        '''
        result = self._values.get("private_subnet_route_table_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def public_subnet_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of public subnet IDs.

        Must be undefined or match the availability zones in length and order.
        '''
        result = self._values.get("public_subnet_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def public_subnet_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''List of names for the public subnets.

        Must be undefined or have a name for every public subnet group.
        '''
        result = self._values.get("public_subnet_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def public_subnet_route_table_ids(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''List of IDs of routing tables for the public subnets.

        Must be undefined or have a name for every public subnet group.
        '''
        result = self._values.get("public_subnet_route_table_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def vpc_cidr_block(self) -> typing.Optional[builtins.str]:
        '''VPC's CIDR range.

        :default: - Retrieving the CIDR from the VPC will fail
        '''
        result = self._values.get("vpc_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_gateway_id(self) -> typing.Optional[builtins.str]:
        '''VPN gateway's identifier.'''
        result = self._values.get("vpn_gateway_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpcAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IVpcEndpoint)
class VpcEndpoint(
    _Resource_45bc6135,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="aws-cdk-lib.aws_ec2.VpcEndpoint",
):
    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        environment_from_arn: typing.Optional[builtins.str] = None,
        physical_name: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param account: The AWS account ID this resource belongs to. Default: - the resource is in the same account as the stack it belongs to
        :param environment_from_arn: ARN to deduce region and account from. The ARN is parsed and the account and region are taken from the ARN. This should be used for imported resources. Cannot be supplied together with either ``account`` or ``region``. Default: - take environment from ``account``, ``region`` parameters, or use Stack environment.
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param region: The AWS region this resource belongs to. Default: - the resource is in the same region as the stack it belongs to
        '''
        props = _ResourceProps_15a65b4e(
            account=account,
            environment_from_arn=environment_from_arn,
            physical_name=physical_name,
            region=region,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addToPolicy")
    def add_to_policy(self, statement: _PolicyStatement_0fe33853) -> None:
        '''Adds a statement to the policy document of the VPC endpoint. The statement must have a Principal.

        Not all interface VPC endpoints support policy. For more information
        see https://docs.aws.amazon.com/vpc/latest/userguide/vpce-interface.html

        :param statement: the IAM statement to add.
        '''
        return typing.cast(None, jsii.invoke(self, "addToPolicy", [statement]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    @abc.abstractmethod
    def vpc_endpoint_id(self) -> builtins.str:
        '''The VPC endpoint identifier.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="policyDocument")
    def _policy_document(self) -> typing.Optional[_PolicyDocument_3ac34393]:
        return typing.cast(typing.Optional[_PolicyDocument_3ac34393], jsii.get(self, "policyDocument"))

    @_policy_document.setter
    def _policy_document(
        self,
        value: typing.Optional[_PolicyDocument_3ac34393],
    ) -> None:
        jsii.set(self, "policyDocument", value)


class _VpcEndpointProxy(
    VpcEndpoint, jsii.proxy_for(_Resource_45bc6135) # type: ignore[misc]
):
    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> builtins.str:
        '''The VPC endpoint identifier.'''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointId"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, VpcEndpoint).__jsii_proxy_class__ = lambda : _VpcEndpointProxy


@jsii.implements(IVpcEndpointService)
class VpcEndpointService(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.VpcEndpointService",
):
    '''A VPC endpoint service.

    :exampleMetadata: infused
    :resource: AWS::EC2::VPCEndpointService

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # network_load_balancer1: elbv2.NetworkLoadBalancer
        # network_load_balancer2: elbv2.NetworkLoadBalancer
        
        
        ec2.VpcEndpointService(self, "EndpointService",
            vpc_endpoint_service_load_balancers=[network_load_balancer1, network_load_balancer2],
            acceptance_required=True,
            allowed_principals=[iam.ArnPrincipal("arn:aws:iam::123456789012:root")]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc_endpoint_service_load_balancers: typing.Sequence[IVpcEndpointServiceLoadBalancer],
        acceptance_required: typing.Optional[builtins.bool] = None,
        allowed_principals: typing.Optional[typing.Sequence[_ArnPrincipal_d31ca6bc]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc_endpoint_service_load_balancers: One or more load balancers to host the VPC Endpoint Service.
        :param acceptance_required: Whether requests from service consumers to connect to the service through an endpoint must be accepted. Default: true
        :param allowed_principals: IAM users, IAM roles, or AWS accounts to allow inbound connections from. These principals can connect to your service using VPC endpoints. Takes a list of one or more ArnPrincipal. Default: - no principals
        '''
        props = VpcEndpointServiceProps(
            vpc_endpoint_service_load_balancers=vpc_endpoint_service_load_balancers,
            acceptance_required=acceptance_required,
            allowed_principals=allowed_principals,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="acceptanceRequired")
    def acceptance_required(self) -> builtins.bool:
        '''Whether to require manual acceptance of new connections to the service.'''
        return typing.cast(builtins.bool, jsii.get(self, "acceptanceRequired"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="allowedPrincipals")
    def allowed_principals(self) -> typing.List[_ArnPrincipal_d31ca6bc]:
        '''One or more Principal ARNs to allow inbound connections to.'''
        return typing.cast(typing.List[_ArnPrincipal_d31ca6bc], jsii.get(self, "allowedPrincipals"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceId")
    def vpc_endpoint_service_id(self) -> builtins.str:
        '''The id of the VPC Endpoint Service, like vpce-svc-xxxxxxxxxxxxxxxx.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointServiceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceLoadBalancers")
    def vpc_endpoint_service_load_balancers(
        self,
    ) -> typing.List[IVpcEndpointServiceLoadBalancer]:
        '''One or more network load balancers to host the service.

        :attribute: true
        '''
        return typing.cast(typing.List[IVpcEndpointServiceLoadBalancer], jsii.get(self, "vpcEndpointServiceLoadBalancers"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointServiceName")
    def vpc_endpoint_service_name(self) -> builtins.str:
        '''The service name of the VPC Endpoint Service that clients use to connect to, like com.amazonaws.vpce..vpce-svc-xxxxxxxxxxxxxxxx.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointServiceName"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpcEndpointServiceProps",
    jsii_struct_bases=[],
    name_mapping={
        "vpc_endpoint_service_load_balancers": "vpcEndpointServiceLoadBalancers",
        "acceptance_required": "acceptanceRequired",
        "allowed_principals": "allowedPrincipals",
    },
)
class VpcEndpointServiceProps:
    def __init__(
        self,
        *,
        vpc_endpoint_service_load_balancers: typing.Sequence[IVpcEndpointServiceLoadBalancer],
        acceptance_required: typing.Optional[builtins.bool] = None,
        allowed_principals: typing.Optional[typing.Sequence[_ArnPrincipal_d31ca6bc]] = None,
    ) -> None:
        '''Construction properties for a VpcEndpointService.

        :param vpc_endpoint_service_load_balancers: One or more load balancers to host the VPC Endpoint Service.
        :param acceptance_required: Whether requests from service consumers to connect to the service through an endpoint must be accepted. Default: true
        :param allowed_principals: IAM users, IAM roles, or AWS accounts to allow inbound connections from. These principals can connect to your service using VPC endpoints. Takes a list of one or more ArnPrincipal. Default: - no principals

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            # network_load_balancer1: elbv2.NetworkLoadBalancer
            # network_load_balancer2: elbv2.NetworkLoadBalancer
            
            
            ec2.VpcEndpointService(self, "EndpointService",
                vpc_endpoint_service_load_balancers=[network_load_balancer1, network_load_balancer2],
                acceptance_required=True,
                allowed_principals=[iam.ArnPrincipal("arn:aws:iam::123456789012:root")]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "vpc_endpoint_service_load_balancers": vpc_endpoint_service_load_balancers,
        }
        if acceptance_required is not None:
            self._values["acceptance_required"] = acceptance_required
        if allowed_principals is not None:
            self._values["allowed_principals"] = allowed_principals

    @builtins.property
    def vpc_endpoint_service_load_balancers(
        self,
    ) -> typing.List[IVpcEndpointServiceLoadBalancer]:
        '''One or more load balancers to host the VPC Endpoint Service.'''
        result = self._values.get("vpc_endpoint_service_load_balancers")
        assert result is not None, "Required property 'vpc_endpoint_service_load_balancers' is missing"
        return typing.cast(typing.List[IVpcEndpointServiceLoadBalancer], result)

    @builtins.property
    def acceptance_required(self) -> typing.Optional[builtins.bool]:
        '''Whether requests from service consumers to connect to the service through an endpoint must be accepted.

        :default: true
        '''
        result = self._values.get("acceptance_required")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def allowed_principals(
        self,
    ) -> typing.Optional[typing.List[_ArnPrincipal_d31ca6bc]]:
        '''IAM users, IAM roles, or AWS accounts to allow inbound connections from.

        These principals can connect to your service using VPC endpoints. Takes a
        list of one or more ArnPrincipal.

        :default: - no principals
        '''
        result = self._values.get("allowed_principals")
        return typing.cast(typing.Optional[typing.List[_ArnPrincipal_d31ca6bc]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpcEndpointServiceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.VpcEndpointType")
class VpcEndpointType(enum.Enum):
    '''The type of VPC endpoint.'''

    INTERFACE = "INTERFACE"
    '''Interface.

    An interface endpoint is an elastic network interface with a private IP
    address that serves as an entry point for traffic destined to a supported
    service.
    '''
    GATEWAY = "GATEWAY"
    '''Gateway.

    A gateway endpoint is a gateway that is a target for a specified route in
    your route table, used for traffic destined to a supported AWS service.
    '''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpcLookupOptions",
    jsii_struct_bases=[],
    name_mapping={
        "is_default": "isDefault",
        "region": "region",
        "subnet_group_name_tag": "subnetGroupNameTag",
        "tags": "tags",
        "vpc_id": "vpcId",
        "vpc_name": "vpcName",
    },
)
class VpcLookupOptions:
    def __init__(
        self,
        *,
        is_default: typing.Optional[builtins.bool] = None,
        region: typing.Optional[builtins.str] = None,
        subnet_group_name_tag: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        vpc_id: typing.Optional[builtins.str] = None,
        vpc_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties for looking up an existing VPC.

        The combination of properties must specify filter down to exactly one
        non-default VPC, otherwise an error is raised.

        :param is_default: Whether to match the default VPC. Default: Don't care whether we return the default VPC
        :param region: Optional to override inferred region. Default: Current stack's environment region
        :param subnet_group_name_tag: Optional tag for subnet group name. If not provided, we'll look at the aws-cdk:subnet-name tag. If the subnet does not have the specified tag, we'll use its type as the name. Default: aws-cdk:subnet-name
        :param tags: Tags on the VPC. The VPC must have all of these tags Default: Don't filter on tags
        :param vpc_id: The ID of the VPC. If given, will import exactly this VPC. Default: Don't filter on vpcId
        :param vpc_name: The name of the VPC. If given, will import the VPC with this name. Default: Don't filter on vpcName

        :exampleMetadata: infused

        Example::

            # create a cloud9 ec2 environment in a new VPC
            vpc = ec2.Vpc(self, "VPC", max_azs=3)
            cloud9.Ec2Environment(self, "Cloud9Env", vpc=vpc)
            
            # or create the cloud9 environment in the default VPC with specific instanceType
            default_vpc = ec2.Vpc.from_lookup(self, "DefaultVPC", is_default=True)
            cloud9.Ec2Environment(self, "Cloud9Env2",
                vpc=default_vpc,
                instance_type=ec2.InstanceType("t3.large")
            )
            
            # or specify in a different subnetSelection
            c9env = cloud9.Ec2Environment(self, "Cloud9Env3",
                vpc=vpc,
                subnet_selection=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PRIVATE
                )
            )
            
            # print the Cloud9 IDE URL in the output
            CfnOutput(self, "URL", value=c9env.ide_url)
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if is_default is not None:
            self._values["is_default"] = is_default
        if region is not None:
            self._values["region"] = region
        if subnet_group_name_tag is not None:
            self._values["subnet_group_name_tag"] = subnet_group_name_tag
        if tags is not None:
            self._values["tags"] = tags
        if vpc_id is not None:
            self._values["vpc_id"] = vpc_id
        if vpc_name is not None:
            self._values["vpc_name"] = vpc_name

    @builtins.property
    def is_default(self) -> typing.Optional[builtins.bool]:
        '''Whether to match the default VPC.

        :default: Don't care whether we return the default VPC
        '''
        result = self._values.get("is_default")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''Optional to override inferred region.

        :default: Current stack's environment region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def subnet_group_name_tag(self) -> typing.Optional[builtins.str]:
        '''Optional tag for subnet group name.

        If not provided, we'll look at the aws-cdk:subnet-name tag.
        If the subnet does not have the specified tag,
        we'll use its type as the name.

        :default: aws-cdk:subnet-name
        '''
        result = self._values.get("subnet_group_name_tag")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''Tags on the VPC.

        The VPC must have all of these tags

        :default: Don't filter on tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def vpc_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the VPC.

        If given, will import exactly this VPC.

        :default: Don't filter on vpcId
        '''
        result = self._values.get("vpc_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc_name(self) -> typing.Optional[builtins.str]:
        '''The name of the VPC.

        If given, will import the VPC with this name.

        :default: Don't filter on vpcName
        '''
        result = self._values.get("vpc_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpcLookupOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpcProps",
    jsii_struct_bases=[],
    name_mapping={
        "cidr": "cidr",
        "default_instance_tenancy": "defaultInstanceTenancy",
        "enable_dns_hostnames": "enableDnsHostnames",
        "enable_dns_support": "enableDnsSupport",
        "flow_logs": "flowLogs",
        "gateway_endpoints": "gatewayEndpoints",
        "max_azs": "maxAzs",
        "nat_gateway_provider": "natGatewayProvider",
        "nat_gateways": "natGateways",
        "nat_gateway_subnets": "natGatewaySubnets",
        "subnet_configuration": "subnetConfiguration",
        "vpc_name": "vpcName",
        "vpn_connections": "vpnConnections",
        "vpn_gateway": "vpnGateway",
        "vpn_gateway_asn": "vpnGatewayAsn",
        "vpn_route_propagation": "vpnRoutePropagation",
    },
)
class VpcProps:
    def __init__(
        self,
        *,
        cidr: typing.Optional[builtins.str] = None,
        default_instance_tenancy: typing.Optional[DefaultInstanceTenancy] = None,
        enable_dns_hostnames: typing.Optional[builtins.bool] = None,
        enable_dns_support: typing.Optional[builtins.bool] = None,
        flow_logs: typing.Optional[typing.Mapping[builtins.str, FlowLogOptions]] = None,
        gateway_endpoints: typing.Optional[typing.Mapping[builtins.str, GatewayVpcEndpointOptions]] = None,
        max_azs: typing.Optional[jsii.Number] = None,
        nat_gateway_provider: typing.Optional[NatProvider] = None,
        nat_gateways: typing.Optional[jsii.Number] = None,
        nat_gateway_subnets: typing.Optional[SubnetSelection] = None,
        subnet_configuration: typing.Optional[typing.Sequence[SubnetConfiguration]] = None,
        vpc_name: typing.Optional[builtins.str] = None,
        vpn_connections: typing.Optional[typing.Mapping[builtins.str, "VpnConnectionOptions"]] = None,
        vpn_gateway: typing.Optional[builtins.bool] = None,
        vpn_gateway_asn: typing.Optional[jsii.Number] = None,
        vpn_route_propagation: typing.Optional[typing.Sequence[SubnetSelection]] = None,
    ) -> None:
        '''Configuration for Vpc.

        :param cidr: The CIDR range to use for the VPC, e.g. '10.0.0.0/16'. Should be a minimum of /28 and maximum size of /16. The range will be split across all subnets per Availability Zone. Default: Vpc.DEFAULT_CIDR_RANGE
        :param default_instance_tenancy: The default tenancy of instances launched into the VPC. By setting this to dedicated tenancy, instances will be launched on hardware dedicated to a single AWS customer, unless specifically specified at instance launch time. Please note, not all instance types are usable with Dedicated tenancy. Default: DefaultInstanceTenancy.Default (shared) tenancy
        :param enable_dns_hostnames: Indicates whether the instances launched in the VPC get public DNS hostnames. If this attribute is true, instances in the VPC get public DNS hostnames, but only if the enableDnsSupport attribute is also set to true. Default: true
        :param enable_dns_support: Indicates whether the DNS resolution is supported for the VPC. If this attribute is false, the Amazon-provided DNS server in the VPC that resolves public DNS hostnames to IP addresses is not enabled. If this attribute is true, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC IPv4 network range plus two will succeed. Default: true
        :param flow_logs: Flow logs to add to this VPC. Default: - No flow logs.
        :param gateway_endpoints: Gateway endpoints to add to this VPC. Default: - None.
        :param max_azs: Define the maximum number of AZs to use in this region. If the region has more AZs than you want to use (for example, because of EIP limits), pick a lower number here. The AZs will be sorted and picked from the start of the list. If you pick a higher number than the number of AZs in the region, all AZs in the region will be selected. To use "all AZs" available to your account, use a high number (such as 99). Be aware that environment-agnostic stacks will be created with access to only 2 AZs, so to use more than 2 AZs, be sure to specify the account and region on your stack. Default: 3
        :param nat_gateway_provider: What type of NAT provider to use. Select between NAT gateways or NAT instances. NAT gateways may not be available in all AWS regions. Default: NatProvider.gateway()
        :param nat_gateways: The number of NAT Gateways/Instances to create. The type of NAT gateway or instance will be determined by the ``natGatewayProvider`` parameter. You can set this number lower than the number of Availability Zones in your VPC in order to save on NAT cost. Be aware you may be charged for cross-AZ data traffic instead. Default: - One NAT gateway/instance per Availability Zone
        :param nat_gateway_subnets: Configures the subnets which will have NAT Gateways/Instances. You can pick a specific group of subnets by specifying the group name; the picked subnets must be public subnets. Only necessary if you have more than one public subnet group. Default: - All public subnets.
        :param subnet_configuration: Configure the subnets to build for each AZ. Each entry in this list configures a Subnet Group; each group will contain a subnet for each Availability Zone. For example, if you want 1 public subnet, 1 private subnet, and 1 isolated subnet in each AZ provide the following:: new ec2.Vpc(this, 'VPC', { subnetConfiguration: [ { cidrMask: 24, name: 'ingress', subnetType: ec2.SubnetType.PUBLIC, }, { cidrMask: 24, name: 'application', subnetType: ec2.SubnetType.PRIVATE_WITH_NAT, }, { cidrMask: 28, name: 'rds', subnetType: ec2.SubnetType.PRIVATE_ISOLATED, } ] }); Default: - The VPC CIDR will be evenly divided between 1 public and 1 private subnet per AZ.
        :param vpc_name: The VPC name. Since the VPC resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag Default: this.node.path
        :param vpn_connections: VPN connections to this VPC. Default: - No connections.
        :param vpn_gateway: Indicates whether a VPN gateway should be created and attached to this VPC. Default: - true when vpnGatewayAsn or vpnConnections is specified
        :param vpn_gateway_asn: The private Autonomous System Number (ASN) for the VPN gateway. Default: - Amazon default ASN.
        :param vpn_route_propagation: Where to propagate VPN routes. Default: - On the route tables associated with private subnets. If no private subnets exists, isolated subnets are used. If no isolated subnets exists, public subnets are used.

        :exampleMetadata: infused

        Example::

            # create a cloud9 ec2 environment in a new VPC
            vpc = ec2.Vpc(self, "VPC", max_azs=3)
            cloud9.Ec2Environment(self, "Cloud9Env", vpc=vpc)
            
            # or create the cloud9 environment in the default VPC with specific instanceType
            default_vpc = ec2.Vpc.from_lookup(self, "DefaultVPC", is_default=True)
            cloud9.Ec2Environment(self, "Cloud9Env2",
                vpc=default_vpc,
                instance_type=ec2.InstanceType("t3.large")
            )
            
            # or specify in a different subnetSelection
            c9env = cloud9.Ec2Environment(self, "Cloud9Env3",
                vpc=vpc,
                subnet_selection=ec2.SubnetSelection(
                    subnet_type=ec2.SubnetType.PRIVATE
                )
            )
            
            # print the Cloud9 IDE URL in the output
            CfnOutput(self, "URL", value=c9env.ide_url)
        '''
        if isinstance(nat_gateway_subnets, dict):
            nat_gateway_subnets = SubnetSelection(**nat_gateway_subnets)
        self._values: typing.Dict[str, typing.Any] = {}
        if cidr is not None:
            self._values["cidr"] = cidr
        if default_instance_tenancy is not None:
            self._values["default_instance_tenancy"] = default_instance_tenancy
        if enable_dns_hostnames is not None:
            self._values["enable_dns_hostnames"] = enable_dns_hostnames
        if enable_dns_support is not None:
            self._values["enable_dns_support"] = enable_dns_support
        if flow_logs is not None:
            self._values["flow_logs"] = flow_logs
        if gateway_endpoints is not None:
            self._values["gateway_endpoints"] = gateway_endpoints
        if max_azs is not None:
            self._values["max_azs"] = max_azs
        if nat_gateway_provider is not None:
            self._values["nat_gateway_provider"] = nat_gateway_provider
        if nat_gateways is not None:
            self._values["nat_gateways"] = nat_gateways
        if nat_gateway_subnets is not None:
            self._values["nat_gateway_subnets"] = nat_gateway_subnets
        if subnet_configuration is not None:
            self._values["subnet_configuration"] = subnet_configuration
        if vpc_name is not None:
            self._values["vpc_name"] = vpc_name
        if vpn_connections is not None:
            self._values["vpn_connections"] = vpn_connections
        if vpn_gateway is not None:
            self._values["vpn_gateway"] = vpn_gateway
        if vpn_gateway_asn is not None:
            self._values["vpn_gateway_asn"] = vpn_gateway_asn
        if vpn_route_propagation is not None:
            self._values["vpn_route_propagation"] = vpn_route_propagation

    @builtins.property
    def cidr(self) -> typing.Optional[builtins.str]:
        '''The CIDR range to use for the VPC, e.g. '10.0.0.0/16'.

        Should be a minimum of /28 and maximum size of /16. The range will be
        split across all subnets per Availability Zone.

        :default: Vpc.DEFAULT_CIDR_RANGE
        '''
        result = self._values.get("cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_instance_tenancy(self) -> typing.Optional[DefaultInstanceTenancy]:
        '''The default tenancy of instances launched into the VPC.

        By setting this to dedicated tenancy, instances will be launched on
        hardware dedicated to a single AWS customer, unless specifically specified
        at instance launch time. Please note, not all instance types are usable
        with Dedicated tenancy.

        :default: DefaultInstanceTenancy.Default (shared) tenancy
        '''
        result = self._values.get("default_instance_tenancy")
        return typing.cast(typing.Optional[DefaultInstanceTenancy], result)

    @builtins.property
    def enable_dns_hostnames(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether the instances launched in the VPC get public DNS hostnames.

        If this attribute is true, instances in the VPC get public DNS hostnames,
        but only if the enableDnsSupport attribute is also set to true.

        :default: true
        '''
        result = self._values.get("enable_dns_hostnames")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_dns_support(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether the DNS resolution is supported for the VPC.

        If this attribute is false, the Amazon-provided DNS server in the VPC that
        resolves public DNS hostnames to IP addresses is not enabled. If this
        attribute is true, queries to the Amazon provided DNS server at the
        169.254.169.253 IP address, or the reserved IP address at the base of the
        VPC IPv4 network range plus two will succeed.

        :default: true
        '''
        result = self._values.get("enable_dns_support")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def flow_logs(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, FlowLogOptions]]:
        '''Flow logs to add to this VPC.

        :default: - No flow logs.
        '''
        result = self._values.get("flow_logs")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, FlowLogOptions]], result)

    @builtins.property
    def gateway_endpoints(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, GatewayVpcEndpointOptions]]:
        '''Gateway endpoints to add to this VPC.

        :default: - None.
        '''
        result = self._values.get("gateway_endpoints")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, GatewayVpcEndpointOptions]], result)

    @builtins.property
    def max_azs(self) -> typing.Optional[jsii.Number]:
        '''Define the maximum number of AZs to use in this region.

        If the region has more AZs than you want to use (for example, because of
        EIP limits), pick a lower number here. The AZs will be sorted and picked
        from the start of the list.

        If you pick a higher number than the number of AZs in the region, all AZs
        in the region will be selected. To use "all AZs" available to your
        account, use a high number (such as 99).

        Be aware that environment-agnostic stacks will be created with access to
        only 2 AZs, so to use more than 2 AZs, be sure to specify the account and
        region on your stack.

        :default: 3
        '''
        result = self._values.get("max_azs")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def nat_gateway_provider(self) -> typing.Optional[NatProvider]:
        '''What type of NAT provider to use.

        Select between NAT gateways or NAT instances. NAT gateways
        may not be available in all AWS regions.

        :default: NatProvider.gateway()
        '''
        result = self._values.get("nat_gateway_provider")
        return typing.cast(typing.Optional[NatProvider], result)

    @builtins.property
    def nat_gateways(self) -> typing.Optional[jsii.Number]:
        '''The number of NAT Gateways/Instances to create.

        The type of NAT gateway or instance will be determined by the
        ``natGatewayProvider`` parameter.

        You can set this number lower than the number of Availability Zones in your
        VPC in order to save on NAT cost. Be aware you may be charged for
        cross-AZ data traffic instead.

        :default: - One NAT gateway/instance per Availability Zone
        '''
        result = self._values.get("nat_gateways")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def nat_gateway_subnets(self) -> typing.Optional[SubnetSelection]:
        '''Configures the subnets which will have NAT Gateways/Instances.

        You can pick a specific group of subnets by specifying the group name;
        the picked subnets must be public subnets.

        Only necessary if you have more than one public subnet group.

        :default: - All public subnets.
        '''
        result = self._values.get("nat_gateway_subnets")
        return typing.cast(typing.Optional[SubnetSelection], result)

    @builtins.property
    def subnet_configuration(self) -> typing.Optional[typing.List[SubnetConfiguration]]:
        '''Configure the subnets to build for each AZ.

        Each entry in this list configures a Subnet Group; each group will contain a
        subnet for each Availability Zone.

        For example, if you want 1 public subnet, 1 private subnet, and 1 isolated
        subnet in each AZ provide the following::

           # Example automatically generated from non-compiling source. May contain errors.
           ec2.Vpc(self, "VPC",
               subnet_configuration=[ec2.SubnetConfiguration(
                   cidr_mask=24,
                   name="ingress",
                   subnet_type=ec2.SubnetType.PUBLIC
               ), ec2.SubnetConfiguration(
                   cidr_mask=24,
                   name="application",
                   subnet_type=ec2.SubnetType.PRIVATE_WITH_NAT
               ), ec2.SubnetConfiguration(
                   cidr_mask=28,
                   name="rds",
                   subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
               )
               ]
           )

        :default:

        - The VPC CIDR will be evenly divided between 1 public and 1
        private subnet per AZ.
        '''
        result = self._values.get("subnet_configuration")
        return typing.cast(typing.Optional[typing.List[SubnetConfiguration]], result)

    @builtins.property
    def vpc_name(self) -> typing.Optional[builtins.str]:
        '''The VPC name.

        Since the VPC resource doesn't support providing a physical name, the value provided here will be recorded in the ``Name`` tag

        :default: this.node.path
        '''
        result = self._values.get("vpc_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpn_connections(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "VpnConnectionOptions"]]:
        '''VPN connections to this VPC.

        :default: - No connections.
        '''
        result = self._values.get("vpn_connections")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "VpnConnectionOptions"]], result)

    @builtins.property
    def vpn_gateway(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether a VPN gateway should be created and attached to this VPC.

        :default: - true when vpnGatewayAsn or vpnConnections is specified
        '''
        result = self._values.get("vpn_gateway")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def vpn_gateway_asn(self) -> typing.Optional[jsii.Number]:
        '''The private Autonomous System Number (ASN) for the VPN gateway.

        :default: - Amazon default ASN.
        '''
        result = self._values.get("vpn_gateway_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def vpn_route_propagation(self) -> typing.Optional[typing.List[SubnetSelection]]:
        '''Where to propagate VPN routes.

        :default:

        - On the route tables associated with private subnets. If no
        private subnets exists, isolated subnets are used. If no isolated subnets
        exists, public subnets are used.
        '''
        result = self._values.get("vpn_route_propagation")
        return typing.cast(typing.Optional[typing.List[SubnetSelection]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpcProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IVpnConnection)
class VpnConnection(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.VpnConnection",
):
    '''Define a VPN Connection.

    :exampleMetadata: fixture=with-vpc infused
    :resource: AWS::EC2::VPNConnection

    Example::

        # Across all tunnels in the account/region
        all_data_out = ec2.VpnConnection.metric_all_tunnel_data_out()
        
        # For a specific vpn connection
        vpn_connection = vpc.add_vpn_connection("Dynamic",
            ip="1.2.3.4"
        )
        state = vpn_connection.metric_tunnel_state()
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        ip: builtins.str,
        asn: typing.Optional[jsii.Number] = None,
        static_routes: typing.Optional[typing.Sequence[builtins.str]] = None,
        tunnel_options: typing.Optional[typing.Sequence["VpnTunnelOption"]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC to connect to.
        :param ip: The ip address of the customer gateway.
        :param asn: The ASN of the customer gateway. Default: 65000
        :param static_routes: The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)
        :param tunnel_options: The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options
        '''
        props = VpnConnectionProps(
            vpc=vpc,
            ip=ip,
            asn=asn,
            static_routes=static_routes,
            tunnel_options=tunnel_options,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="metricAll") # type: ignore[misc]
    @builtins.classmethod
    def metric_all(
        cls,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Return the given named metric for all VPN connections in the account/region.

        :param metric_name: -
        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.sinvoke(cls, "metricAll", [metric_name, props]))

    @jsii.member(jsii_name="metricAllTunnelDataIn") # type: ignore[misc]
    @builtins.classmethod
    def metric_all_tunnel_data_in(
        cls,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Metric for the tunnel data in of all VPN connections in the account/region.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: sum over 5 minutes
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.sinvoke(cls, "metricAllTunnelDataIn", [props]))

    @jsii.member(jsii_name="metricAllTunnelDataOut") # type: ignore[misc]
    @builtins.classmethod
    def metric_all_tunnel_data_out(
        cls,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Metric for the tunnel data out of all VPN connections.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: sum over 5 minutes
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.sinvoke(cls, "metricAllTunnelDataOut", [props]))

    @jsii.member(jsii_name="metricAllTunnelState") # type: ignore[misc]
    @builtins.classmethod
    def metric_all_tunnel_state(
        cls,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Metric for the tunnel state of all VPN connections in the account/region.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: average over 5 minutes
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.sinvoke(cls, "metricAllTunnelState", [props]))

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''Return the given named metric for this VPNConnection.

        :param metric_name: -
        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricTunnelDataIn")
    def metric_tunnel_data_in(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The bytes received through the VPN tunnel.

        Sum over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metricTunnelDataIn", [props]))

    @jsii.member(jsii_name="metricTunnelDataOut")
    def metric_tunnel_data_out(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The bytes sent through the VPN tunnel.

        Sum over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metricTunnelDataOut", [props]))

    @jsii.member(jsii_name="metricTunnelState")
    def metric_tunnel_state(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[_Duration_4839e8c3] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[_Unit_61bc6f70] = None,
    ) -> _Metric_e396a4dc:
        '''The state of the tunnel. 0 indicates DOWN and 1 indicates UP.

        Average over 5 minutes

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream
        '''
        props = _MetricOptions_1788b62f(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(_Metric_e396a4dc, jsii.invoke(self, "metricTunnelState", [props]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayAsn")
    def customer_gateway_asn(self) -> jsii.Number:
        '''The ASN of the customer gateway.'''
        return typing.cast(jsii.Number, jsii.get(self, "customerGatewayAsn"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayId")
    def customer_gateway_id(self) -> builtins.str:
        '''The id of the customer gateway.'''
        return typing.cast(builtins.str, jsii.get(self, "customerGatewayId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="customerGatewayIp")
    def customer_gateway_ip(self) -> builtins.str:
        '''The ip address of the customer gateway.'''
        return typing.cast(builtins.str, jsii.get(self, "customerGatewayIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpnId")
    def vpn_id(self) -> builtins.str:
        '''The id of the VPN connection.'''
        return typing.cast(builtins.str, jsii.get(self, "vpnId"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpnConnectionOptions",
    jsii_struct_bases=[],
    name_mapping={
        "ip": "ip",
        "asn": "asn",
        "static_routes": "staticRoutes",
        "tunnel_options": "tunnelOptions",
    },
)
class VpnConnectionOptions:
    def __init__(
        self,
        *,
        ip: builtins.str,
        asn: typing.Optional[jsii.Number] = None,
        static_routes: typing.Optional[typing.Sequence[builtins.str]] = None,
        tunnel_options: typing.Optional[typing.Sequence["VpnTunnelOption"]] = None,
    ) -> None:
        '''
        :param ip: The ip address of the customer gateway.
        :param asn: The ASN of the customer gateway. Default: 65000
        :param static_routes: The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)
        :param tunnel_options: The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options

        :exampleMetadata: infused

        Example::

            # Example automatically generated from non-compiling source. May contain errors.
            vpc = ec2.Vpc(self, "MyVpc",
                vpn_connections={
                    "dynamic": ec2.VpnConnectionOptions( # Dynamic routing (BGP)
                        ip="1.2.3.4"),
                    "static": ec2.VpnConnectionOptions( # Static routing
                        ip="4.5.6.7",
                        static_routes=["192.168.10.0/24", "192.168.20.0/24"
                        ])
                }
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "ip": ip,
        }
        if asn is not None:
            self._values["asn"] = asn
        if static_routes is not None:
            self._values["static_routes"] = static_routes
        if tunnel_options is not None:
            self._values["tunnel_options"] = tunnel_options

    @builtins.property
    def ip(self) -> builtins.str:
        '''The ip address of the customer gateway.'''
        result = self._values.get("ip")
        assert result is not None, "Required property 'ip' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def asn(self) -> typing.Optional[jsii.Number]:
        '''The ASN of the customer gateway.

        :default: 65000
        '''
        result = self._values.get("asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def static_routes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The static routes to be routed from the VPN gateway to the customer gateway.

        :default: Dynamic routing (BGP)
        '''
        result = self._values.get("static_routes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tunnel_options(self) -> typing.Optional[typing.List["VpnTunnelOption"]]:
        '''The tunnel options for the VPN connection.

        At most two elements (one per tunnel).
        Duplicates not allowed.

        :default: Amazon generated tunnel options
        '''
        result = self._values.get("tunnel_options")
        return typing.cast(typing.Optional[typing.List["VpnTunnelOption"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpnConnectionProps",
    jsii_struct_bases=[VpnConnectionOptions],
    name_mapping={
        "ip": "ip",
        "asn": "asn",
        "static_routes": "staticRoutes",
        "tunnel_options": "tunnelOptions",
        "vpc": "vpc",
    },
)
class VpnConnectionProps(VpnConnectionOptions):
    def __init__(
        self,
        *,
        ip: builtins.str,
        asn: typing.Optional[jsii.Number] = None,
        static_routes: typing.Optional[typing.Sequence[builtins.str]] = None,
        tunnel_options: typing.Optional[typing.Sequence["VpnTunnelOption"]] = None,
        vpc: IVpc,
    ) -> None:
        '''
        :param ip: The ip address of the customer gateway.
        :param asn: The ASN of the customer gateway. Default: 65000
        :param static_routes: The static routes to be routed from the VPN gateway to the customer gateway. Default: Dynamic routing (BGP)
        :param tunnel_options: The tunnel options for the VPN connection. At most two elements (one per tunnel). Duplicates not allowed. Default: Amazon generated tunnel options
        :param vpc: The VPC to connect to.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # vpc: ec2.Vpc
            
            vpn_connection_props = ec2.VpnConnectionProps(
                ip="ip",
                vpc=vpc,
            
                # the properties below are optional
                asn=123,
                static_routes=["staticRoutes"],
                tunnel_options=[ec2.VpnTunnelOption(
                    pre_shared_key="preSharedKey",
                    tunnel_inside_cidr="tunnelInsideCidr"
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "ip": ip,
            "vpc": vpc,
        }
        if asn is not None:
            self._values["asn"] = asn
        if static_routes is not None:
            self._values["static_routes"] = static_routes
        if tunnel_options is not None:
            self._values["tunnel_options"] = tunnel_options

    @builtins.property
    def ip(self) -> builtins.str:
        '''The ip address of the customer gateway.'''
        result = self._values.get("ip")
        assert result is not None, "Required property 'ip' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def asn(self) -> typing.Optional[jsii.Number]:
        '''The ASN of the customer gateway.

        :default: 65000
        '''
        result = self._values.get("asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def static_routes(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The static routes to be routed from the VPN gateway to the customer gateway.

        :default: Dynamic routing (BGP)
        '''
        result = self._values.get("static_routes")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def tunnel_options(self) -> typing.Optional[typing.List["VpnTunnelOption"]]:
        '''The tunnel options for the VPN connection.

        At most two elements (one per tunnel).
        Duplicates not allowed.

        :default: Amazon generated tunnel options
        '''
        result = self._values.get("tunnel_options")
        return typing.cast(typing.Optional[typing.List["VpnTunnelOption"]], result)

    @builtins.property
    def vpc(self) -> IVpc:
        '''The VPC to connect to.'''
        result = self._values.get("vpc")
        assert result is not None, "Required property 'vpc' is missing"
        return typing.cast(IVpc, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.VpnConnectionType")
class VpnConnectionType(enum.Enum):
    '''The VPN connection type.'''

    IPSEC_1 = "IPSEC_1"
    '''The IPsec 1 VPN connection type.'''
    DUMMY = "DUMMY"
    '''Dummy member TODO: remove once https://github.com/aws/jsii/issues/231 is fixed.'''


@jsii.implements(IVpnGateway)
class VpnGateway(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.VpnGateway",
):
    '''The VPN Gateway that shall be added to the VPC.

    :resource: AWS::EC2::VPNGateway
    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        vpn_gateway = ec2.VpnGateway(self, "MyVpnGateway",
            type="type",
        
            # the properties below are optional
            amazon_side_asn=123
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param type: Default type ipsec.1.
        :param amazon_side_asn: Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000
        '''
        props = VpnGatewayProps(type=type, amazon_side_asn=amazon_side_asn)

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="gatewayId")
    def gateway_id(self) -> builtins.str:
        '''The virtual private gateway Id.'''
        return typing.cast(builtins.str, jsii.get(self, "gatewayId"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpnGatewayProps",
    jsii_struct_bases=[],
    name_mapping={"type": "type", "amazon_side_asn": "amazonSideAsn"},
)
class VpnGatewayProps:
    def __init__(
        self,
        *,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The VpnGateway Properties.

        :param type: Default type ipsec.1.
        :param amazon_side_asn: Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            vpn_gateway_props = ec2.VpnGatewayProps(
                type="type",
            
                # the properties below are optional
                amazon_side_asn=123
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn

    @builtins.property
    def type(self) -> builtins.str:
        '''Default type ipsec.1.'''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''Explicitly specify an Asn or let aws pick an Asn for you.

        :default: 65000
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnGatewayProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.VpnPort")
class VpnPort(enum.Enum):
    '''Port for client VPN.'''

    HTTPS = "HTTPS"
    '''HTTPS.'''
    OPENVPN = "OPENVPN"
    '''OpenVPN.'''


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.VpnTunnelOption",
    jsii_struct_bases=[],
    name_mapping={
        "pre_shared_key": "preSharedKey",
        "tunnel_inside_cidr": "tunnelInsideCidr",
    },
)
class VpnTunnelOption:
    def __init__(
        self,
        *,
        pre_shared_key: typing.Optional[builtins.str] = None,
        tunnel_inside_cidr: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param pre_shared_key: The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway. Allowed characters are alphanumeric characters and ._. Must be between 8 and 64 characters in length and cannot start with zero (0). Default: an Amazon generated pre-shared key
        :param tunnel_inside_cidr: The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. A size /30 CIDR block from the 169.254.0.0/16 range. Default: an Amazon generated inside IP CIDR

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            vpn_tunnel_option = ec2.VpnTunnelOption(
                pre_shared_key="preSharedKey",
                tunnel_inside_cidr="tunnelInsideCidr"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if pre_shared_key is not None:
            self._values["pre_shared_key"] = pre_shared_key
        if tunnel_inside_cidr is not None:
            self._values["tunnel_inside_cidr"] = tunnel_inside_cidr

    @builtins.property
    def pre_shared_key(self) -> typing.Optional[builtins.str]:
        '''The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.

        Allowed characters are alphanumeric characters
        and ._. Must be between 8 and 64 characters in length and cannot start with zero (0).

        :default: an Amazon generated pre-shared key
        '''
        result = self._values.get("pre_shared_key")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tunnel_inside_cidr(self) -> typing.Optional[builtins.str]:
        '''The range of inside IP addresses for the tunnel.

        Any specified CIDR blocks must be
        unique across all VPN connections that use the same virtual private gateway.
        A size /30 CIDR block from the 169.254.0.0/16 range.

        :default: an Amazon generated inside IP CIDR
        '''
        result = self._values.get("tunnel_inside_cidr")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnTunnelOption(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.WindowsImageProps",
    jsii_struct_bases=[],
    name_mapping={"user_data": "userData"},
)
class WindowsImageProps:
    def __init__(self, *, user_data: typing.Optional[UserData] = None) -> None:
        '''Configuration options for WindowsImage.

        :param user_data: Initial user data. Default: - Empty UserData for Windows machines

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # user_data: ec2.UserData
            
            windows_image_props = ec2.WindowsImageProps(
                user_data=user_data
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if user_data is not None:
            self._values["user_data"] = user_data

    @builtins.property
    def user_data(self) -> typing.Optional[UserData]:
        '''Initial user data.

        :default: - Empty UserData for Windows machines
        '''
        result = self._values.get("user_data")
        return typing.cast(typing.Optional[UserData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WindowsImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="aws-cdk-lib.aws_ec2.WindowsVersion")
class WindowsVersion(enum.Enum):
    '''The Windows version to use for the WindowsImage.

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    WINDOWS_SERVER_2008_SP2_ENGLISH_64BIT_SQL_2008_SP4_EXPRESS = "WINDOWS_SERVER_2008_SP2_ENGLISH_64BIT_SQL_2008_SP4_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_CHINESE_SIMPLIFIED_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_CHINESE_SIMPLIFIED_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_CHINESE_TRADITIONAL_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_CHINESE_TRADITIONAL_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_DUTCH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_DUTCH_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_ENTERPRISE"
    WINDOWS_SERVER_2012_R2_RTM_HUNGARIAN_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_HUNGARIAN_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_CORE_CONTAINERS = "WINDOWS_SERVER_2016_ENGLISH_CORE_CONTAINERS"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_WEB = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_WEB"
    WINDOWS_SERVER_2016_GERMAN_FULL_BASE = "WINDOWS_SERVER_2016_GERMAN_FULL_BASE"
    WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_32BIT_BASE = "WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_32BIT_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2008_R2_SP3_WEB = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2008_R2_SP3_WEB"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_EXPRESS = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_EXPRESS"
    WINDOWS_SERVER_2012_R2_SP1_PORTUGUESE_BRAZIL_64BIT_CORE = "WINDOWS_SERVER_2012_R2_SP1_PORTUGUESE_BRAZIL_64BIT_CORE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP2_EXPRESS = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP2_EXPRESS"
    WINDOWS_SERVER_2012_RTM_ITALIAN_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_ITALIAN_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_EXPRESS = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_EXPRESS"
    WINDOWS_SERVER_2016_ENGLISH_DEEP_LEARNING = "WINDOWS_SERVER_2016_ENGLISH_DEEP_LEARNING"
    WINDOWS_SERVER_2019_ITALIAN_FULL_BASE = "WINDOWS_SERVER_2019_ITALIAN_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_KOREAN_64BIT_BASE = "WINDOWS_SERVER_2008_R2_SP1_KOREAN_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP2_WEB = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP2_WEB"
    WINDOWS_SERVER_2016_JAPANESE_FULL_FQL_2016_SP2_WEB = "WINDOWS_SERVER_2016_JAPANESE_FULL_FQL_2016_SP2_WEB"
    WINDOWS_SERVER_2016_KOREAN_FULL_BASE = "WINDOWS_SERVER_2016_KOREAN_FULL_BASE"
    WINDOWS_SERVER_2016_KOREAN_FULL_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2016_KOREAN_FULL_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2016_PORTUGUESE_PORTUGAL_FULL_BASE = "WINDOWS_SERVER_2016_PORTUGUESE_PORTUGAL_FULL_BASE"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_WEB = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_WEB"
    WINDOWS_SERVER_2019_FRENCH_FULL_BASE = "WINDOWS_SERVER_2019_FRENCH_FULL_BASE"
    WINDOWS_SERVER_2019_KOREAN_FULL_BASE = "WINDOWS_SERVER_2019_KOREAN_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_CHINESE_HONG_KONG_SAR_64BIT_BASE = "WINDOWS_SERVER_2008_R2_SP1_CHINESE_HONG_KONG_SAR_64BIT_BASE"
    WINDOWS_SERVER_2008_R2_SP1_CHINESE_PRC_64BIT_BASE = "WINDOWS_SERVER_2008_R2_SP1_CHINESE_PRC_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_FRENCH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_FRENCH_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_CONTAINERS = "WINDOWS_SERVER_2016_ENGLISH_FULL_CONTAINERS"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_STANDARD = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_STANDARD"
    WINDOWS_SERVER_2016_RUSSIAN_FULL_BASE = "WINDOWS_SERVER_2016_RUSSIAN_FULL_BASE"
    WINDOWS_SERVER_2019_CHINESE_SIMPLIFIED_FULL_BASE = "WINDOWS_SERVER_2019_CHINESE_SIMPLIFIED_FULL_BASE"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2019_HUNGARIAN_FULL_BASE = "WINDOWS_SERVER_2019_HUNGARIAN_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2008_R2_SP3_EXPRESS = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2008_R2_SP3_EXPRESS"
    WINDOWS_SERVER_2007_R2_SP1_LANGUAGE_PACKS_64BIT_BASE = "WINDOWS_SERVER_2007_R2_SP1_LANGUAGE_PACKS_64BIT_BASE"
    WINDOWS_SERVER_2008_SP2_ENGLISH_32BIT_BASE = "WINDOWS_SERVER_2008_SP2_ENGLISH_32BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2012_SP4_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2012_SP4_ENTERPRISE"
    WINDOWS_SERVER_2012_RTM_CHINESE_TRADITIONAL_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_CHINESE_TRADITIONAL_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2008_R2_SP3_EXPRESS = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2008_R2_SP3_EXPRESS"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP2_STANDARD = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP2_STANDARD"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP2_EXPRESS = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP2_EXPRESS"
    WINDOWS_SERVER_2016_POLISH_FULL_BASE = "WINDOWS_SERVER_2016_POLISH_FULL_BASE"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_WEB = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_WEB"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_DEEP_LEARNING = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_DEEP_LEARNING"
    WINDOWS_SERVER_2012_R2_RTM_GERMAN_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_GERMAN_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_RUSSIAN_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_RUSSIAN_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_CHINESE_TRADITIONAL_HONG_KONG_SAR_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_CHINESE_TRADITIONAL_HONG_KONG_SAR_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_HUNGARIAN_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_HUNGARIAN_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP3_STANDARD = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP3_STANDARD"
    WINDOWS_SERVER_2019_ENGLISH_FULL_HYPERV = "WINDOWS_SERVER_2019_ENGLISH_FULL_HYPERV"
    WINDOWS_SERVER_2003_R2_SP2_ENGLISH_64BIT_SQL_2005_SP4_EXPRESS = "WINDOWS_SERVER_2003_R2_SP2_ENGLISH_64BIT_SQL_2005_SP4_EXPRESS"
    WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2012_SP4_EXPRESS = "WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2012_SP4_EXPRESS"
    WINDOWS_SERVER_2012_RTM_GERMAN_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_GERMAN_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2008_R2_SP3_STANDARD = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2008_R2_SP3_STANDARD"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_EXPRESS = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_EXPRESS"
    WINDOWS_SERVER_2019_JAPANESE_FULL_BASE = "WINDOWS_SERVER_2019_JAPANESE_FULL_BASE"
    WINDOWS_SERVER_2019_RUSSIAN_FULL_BASE = "WINDOWS_SERVER_2019_RUSSIAN_FULL_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_ITALIAN_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_ITALIAN_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2008_R2_SP3_STANDARD = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2008_R2_SP3_STANDARD"
    WINDOWS_SERVER_2016_ENGLISH_FULL_HYPERV = "WINDOWS_SERVER_2016_ENGLISH_FULL_HYPERV"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_ENTERPRISE = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_ENTERPRISE"
    WINDOWS_SERVER_2019_CHINESE_TRADITIONAL_FULL_BASE = "WINDOWS_SERVER_2019_CHINESE_TRADITIONAL_FULL_BASE"
    WINDOWS_SERVER_2019_ENGLISH_CORE_BASE = "WINDOWS_SERVER_2019_ENGLISH_CORE_BASE"
    WINDOWS_SERVER_2019_ENGLISH_CORE_CONTAINERSLATEST = "WINDOWS_SERVER_2019_ENGLISH_CORE_CONTAINERSLATEST"
    WINDOWS_SERVER_2008_SP2_ENGLISH_64BIT_BASE = "WINDOWS_SERVER_2008_SP2_ENGLISH_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_FRENCH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_FRENCH_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_POLISH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_POLISH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2012_SP4_EXPRESS = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2012_SP4_EXPRESS"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP3_STANDARD = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP3_STANDARD"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_2012_SP4_STANDARD = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_2012_SP4_STANDARD"
    WINDOWS_SERVER_2016_ENGLISH_CORE_CONTAINERSLATEST = "WINDOWS_SERVER_2016_ENGLISH_CORE_CONTAINERSLATEST"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_EXPRESS = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_EXPRESS"
    WINDOWS_SERVER_2019_TURKISH_FULL_BASE = "WINDOWS_SERVER_2019_TURKISH_FULL_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_WEB = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_WEB"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_WEB = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_WEB"
    WINDOWS_SERVER_2012_R2_RTM_PORTUGUESE_BRAZIL_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_PORTUGUESE_BRAZIL_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_PORTUGUESE_PORTUGAL_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_PORTUGUESE_PORTUGAL_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_SWEDISH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_SWEDISH_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_EXPRESS = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_EXPRESS"
    WINDOWS_SERVER_2016_ITALIAN_FULL_BASE = "WINDOWS_SERVER_2016_ITALIAN_FULL_BASE"
    WINDOWS_SERVER_2016_SPANISH_FULL_BASE = "WINDOWS_SERVER_2016_SPANISH_FULL_BASE"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_STANDARD = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_STANDARD"
    WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_64BIT_SQL_2005_SP4_STANDARD = "WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_64BIT_SQL_2005_SP4_STANDARD"
    WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2008_R2_SP3_STANDARD = "WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2008_R2_SP3_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_STANDARD"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2007_R2_SP3_WEB = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2007_R2_SP3_WEB"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP2_WEB = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP2_WEB"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_ENTERPRISE = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_ENTERPRISE"
    WINDOWS_SERVER_2016_PORTUGUESE_BRAZIL_FULL_BASE = "WINDOWS_SERVER_2016_PORTUGUESE_BRAZIL_FULL_BASE"
    WINDOWS_SERVER_2019_ENGLISH_FULL_BASE = "WINDOWS_SERVER_2019_ENGLISH_FULL_BASE"
    WINDOWS_SERVER_2003_R2_SP2_ENGLISH_32BIT_BASE = "WINDOWS_SERVER_2003_R2_SP2_ENGLISH_32BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_CZECH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_CZECH_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP2_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP2_EXPRESS"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2012_SP4_STANDARD = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2012_SP4_STANDARD"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_ENTERPRISE = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_ENTERPRISE"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_WEB = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_WEB"
    WINDOWS_SERVER_2016_SWEDISH_FULL_BASE = "WINDOWS_SERVER_2016_SWEDISH_FULL_BASE"
    WINDOWS_SERVER_2016_TURKISH_FULL_BASE = "WINDOWS_SERVER_2016_TURKISH_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_CORE_SQL_2012_SP4_STANDARD = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_CORE_SQL_2012_SP4_STANDARD"
    WINDOWS_SERVER_2008_R2_SP1_LANGUAGE_PACKS_64BIT_SQL_2008_R2_SP3_STANDARD = "WINDOWS_SERVER_2008_R2_SP1_LANGUAGE_PACKS_64BIT_SQL_2008_R2_SP3_STANDARD"
    WINDOWS_SERVER_2012_RTM_CZECH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_CZECH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_TURKISH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_TURKISH_64BIT_BASE"
    WINDOWS_SERVER_2016_DUTCH_FULL_BASE = "WINDOWS_SERVER_2016_DUTCH_FULL_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_EXPRESS = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_EXPRESS"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_ENTERPRISE = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_ENTERPRISE"
    WINDOWS_SERVER_2016_HUNGARIAN_FULL_BASE = "WINDOWS_SERVER_2016_HUNGARIAN_FULL_BASE"
    WINDOWS_SERVER_2016_KOREAN_FULL_SQL_2016_SP1_STANDARD = "WINDOWS_SERVER_2016_KOREAN_FULL_SQL_2016_SP1_STANDARD"
    WINDOWS_SERVER_2019_SPANISH_FULL_BASE = "WINDOWS_SERVER_2019_SPANISH_FULL_BASE"
    WINDOWS_SERVER_2003_R2_SP2_ENGLISH_64BIT_BASE = "WINDOWS_SERVER_2003_R2_SP2_ENGLISH_64BIT_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_BASE = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_BASE"
    WINDOWS_SERVER_2008_R2_SP1_LANGUAGE_PACKS_64BIT_SQL_2008_R2_SP3_EXPRESS = "WINDOWS_SERVER_2008_R2_SP1_LANGUAGE_PACKS_64BIT_SQL_2008_R2_SP3_EXPRESS"
    WINDOWS_SERVER_2012_SP2_PORTUGUESE_BRAZIL_64BIT_BASE = "WINDOWS_SERVER_2012_SP2_PORTUGUESE_BRAZIL_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_WEB = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_WEB"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP3_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP3_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP2_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP2_ENTERPRISE"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_BASE"
    WINDOWS_SERVER_2019_ENGLISH_FULL_CONTAINERSLATEST = "WINDOWS_SERVER_2019_ENGLISH_FULL_CONTAINERSLATEST"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_ENTERPRISE = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2017_ENTERPRISE"
    WINDOWS_SERVER_1709_ENGLISH_CORE_CONTAINERSLATEST = "WINDOWS_SERVER_1709_ENGLISH_CORE_CONTAINERSLATEST"
    WINDOWS_SERVER_1803_ENGLISH_CORE_BASE = "WINDOWS_SERVER_1803_ENGLISH_CORE_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_WEB = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_WEB"
    WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_BASE = "WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_BASE"
    WINDOWS_SERVER_2008_SP2_ENGLISH_64BIT_SQL_2008_SP4_STANDARD = "WINDOWS_SERVER_2008_SP2_ENGLISH_64BIT_SQL_2008_SP4_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_PORTUGUESE_BRAZIL_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_PORTUGUESE_BRAZIL_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_WEB = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_WEB"
    WINDOWS_SERVER_2016_ENGLISH_P3 = "WINDOWS_SERVER_2016_ENGLISH_P3"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_ENTERPRISE = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_ENTERPRISE"
    WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_64BIT_BASE = "WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_CHINESE_TRADITIONAL_HONG_KONG_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_CHINESE_TRADITIONAL_HONG_KONG_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_EXPRESS = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_ENTERPRISE"
    WINDOWS_SERVER_2012_RTM_CHINESE_SIMPLIFIED_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_CHINESE_SIMPLIFIED_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2012_SP4_WEB = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2012_SP4_WEB"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP3_WEB = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP3_WEB"
    WINDOWS_SERVER_2016_JAPANESE_FULL_BASE = "WINDOWS_SERVER_2016_JAPANESE_FULL_BASE"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_EXPRESS = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_EXPRESS"
    WINDOWS_SERVER_1803_ENGLISH_CORE_CONTAINERSLATEST = "WINDOWS_SERVER_1803_ENGLISH_CORE_CONTAINERSLATEST"
    WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2012_SP4_STANDARD = "WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2012_SP4_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_CORE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_CORE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_WEB = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP2_WEB"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2014_SP3_ENTERPRISE"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_2014_SP3_WEB = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_2014_SP3_WEB"
    WINDOWS_SERVER_2012_RTM_SWEDISH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_SWEDISH_64BIT_BASE"
    WINDOWS_SERVER_2016_CHINESE_SIMPLIFIED_FULL_BASE = "WINDOWS_SERVER_2016_CHINESE_SIMPLIFIED_FULL_BASE"
    WINDOWS_SERVER_2019_POLISH_FULL_BASE = "WINDOWS_SERVER_2019_POLISH_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2008_R2_SP3_WEB = "WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2008_R2_SP3_WEB"
    WINDOWS_SERVER_2008_R2_SP1_PORTUGUESE_BRAZIL_64BIT_BASE = "WINDOWS_SERVER_2008_R2_SP1_PORTUGUESE_BRAZIL_64BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2016_SP1_ENTERPRISE"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2016_SP2_EXPRESS = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2016_SP2_EXPRESS"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP3_EXPRESS = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP3_EXPRESS"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP2_STANDARD = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP2_STANDARD"
    WINDOWS_SERVER_2016_ENGLISH_CORE_BASE = "WINDOWS_SERVER_2016_ENGLISH_CORE_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_BASE = "WINDOWS_SERVER_2016_ENGLISH_FULL_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_WEB = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_WEB"
    WINDOWS_SERVER_2019_GERMAN_FULL_BASE = "WINDOWS_SERVER_2019_GERMAN_FULL_BASE"
    WINDOWS_SERVER_2003_R2_SP2_ENGLISH_64BIT_SQL_2005_SP4_STANDARD = "WINDOWS_SERVER_2003_R2_SP2_ENGLISH_64BIT_SQL_2005_SP4_STANDARD"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_ENTERPRISE = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_ENTERPRISE"
    WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2008_R2_SP3_EXPRESS = "WINDOWS_SERVER_2008_R2_SP1_JAPANESE_64BIT_SQL_2008_R2_SP3_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_ENTERPRISE = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP1_ENTERPRISE"
    WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP2_WEB = "WINDOWS_SERVER_2012_RTM_ENGLISH_64BIT_SQL_2014_SP2_WEB"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2008_R2_SP3_EXPRESS = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2008_R2_SP3_EXPRESS"
    WINDOWS_SERVER_2016_FRENCH_FULL_BASE = "WINDOWS_SERVER_2016_FRENCH_FULL_BASE"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP2_ENTERPRISE = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP2_ENTERPRISE"
    WINDOWS_SERVER_2019_CZECH_FULL_BASE = "WINDOWS_SERVER_2019_CZECH_FULL_BASE"
    WINDOWS_SERVER_1809_ENGLISH_CORE_BASE = "WINDOWS_SERVER_1809_ENGLISH_CORE_BASE"
    WINDOWS_SERVER_1809_ENGLISH_CORE_CONTAINERSLATEST = "WINDOWS_SERVER_1809_ENGLISH_CORE_CONTAINERSLATEST"
    WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_64BIT_SQL_2005_SP4_EXPRESS = "WINDOWS_SERVER_2003_R2_SP2_LANGUAGE_PACKS_64BIT_SQL_2005_SP4_EXPRESS"
    WINDOWS_SERVER_2012_R2_RTM_TURKISH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_TURKISH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2012_SP4_WEB = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2012_SP4_WEB"
    WINDOWS_SERVER_2012_RTM_POLISH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_POLISH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_SPANISH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_SPANISH_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_ENTERPRISE = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP1_ENTERPRISE"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP2_EXPRESS = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP2_EXPRESS"
    WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_ENTERPRISE = "WINDOWS_SERVER_2019_ENGLISH_FULL_SQL_2016_SP2_ENTERPRISE"
    WINDOWS_SERVER_1709_ENGLISH_CORE_BASE = "WINDOWS_SERVER_1709_ENGLISH_CORE_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_61BIT_SQL_2012_RTM_SP2_ENTERPRISE = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_61BIT_SQL_2012_RTM_SP2_ENTERPRISE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_STANDARD = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2012_SP4_STANDARD"
    WINDOWS_SERVER_2008_SP2_PORTUGUESE_BRAZIL_32BIT_BASE = "WINDOWS_SERVER_2008_SP2_PORTUGUESE_BRAZIL_32BIT_BASE"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP2_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP2_STANDARD"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2012_SP4_EXPRESS = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2012_SP4_EXPRESS"
    WINDOWS_SERVER_2012_RTM_PORTUGUESE_PORTUGAL_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_PORTUGUESE_PORTUGAL_64BIT_BASE"
    WINDOWS_SERVER_2016_CZECH_FULL_BASE = "WINDOWS_SERVER_2016_CZECH_FULL_BASE"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_STANDARD = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP1_STANDARD"
    WINDOWS_SERVER_2019_DUTCH_FULL_BASE = "WINDOWS_SERVER_2019_DUTCH_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_CORE = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_CORE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_WEB = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_SQL_2016_SP2_WEB"
    WINDOWS_SERVER_2012_R2_RTM_KOREAN_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_KOREAN_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_DUTCH_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_DUTCH_64BIT_BASE"
    WINDOWS_SERVER_2016_ENGLISH_64BIT_SQL_2012_SP4_ENTERPRISE = "WINDOWS_SERVER_2016_ENGLISH_64BIT_SQL_2012_SP4_ENTERPRISE"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_STANDARD = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP1_STANDARD"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_EXPRESS = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_EXPRESS"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_WEB = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_WEB"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_STANDARD = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_STANDARD"
    WINDOWS_SERVER_2019_PORTUGUESE_BRAZIL_FULL_BASE = "WINDOWS_SERVER_2019_PORTUGUESE_BRAZIL_FULL_BASE"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2008_R2_SP3_STANDARD = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SQL_2008_R2_SP3_STANDARD"
    WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SHAREPOINT_2010_SP2_FOUNDATION = "WINDOWS_SERVER_2008_R2_SP1_ENGLISH_64BIT_SHAREPOINT_2010_SP2_FOUNDATION"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_P3 = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_P3"
    WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP3_STANDARD = "WINDOWS_SERVER_2012_R2_RTM_JAPANESE_64BIT_SQL_2014_SP3_STANDARD"
    WINDOWS_SERVER_2012_R2_RTM_SPANISH_64BIT_BASE = "WINDOWS_SERVER_2012_R2_RTM_SPANISH_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP3_EXPRESS = "WINDOWS_SERVER_2012_RTM_JAPANESE_64BIT_SQL_2014_SP3_EXPRESS"
    WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2016_ENGLISH_CORE_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP2_STANDARD = "WINDOWS_SERVER_2016_JAPANESE_FULL_SQL_2016_SP2_STANDARD"
    WINDOWS_SERVER_2019_PORTUGUESE_PORTUGAL_FULL_BASE = "WINDOWS_SERVER_2019_PORTUGUESE_PORTUGAL_FULL_BASE"
    WINDOWS_SERVER_2019_SWEDISH_FULL_BASE = "WINDOWS_SERVER_2019_SWEDISH_FULL_BASE"
    WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_HYPERV = "WINDOWS_SERVER_2012_R2_RTM_ENGLISH_64BIT_HYPERV"
    WINDOWS_SERVER_2012_RTM_KOREAN_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_KOREAN_64BIT_BASE"
    WINDOWS_SERVER_2012_RTM_RUSSIAN_64BIT_BASE = "WINDOWS_SERVER_2012_RTM_RUSSIAN_64BIT_BASE"
    WINDOWS_SERVER_2016_CHINESE_TRADITIONAL_FULL_BASE = "WINDOWS_SERVER_2016_CHINESE_TRADITIONAL_FULL_BASE"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_WEB = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2016_SP2_WEB"
    WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_EXPRESS = "WINDOWS_SERVER_2016_ENGLISH_FULL_SQL_2017_EXPRESS"
    WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2019_ENTERPRISE = "WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2019_ENTERPRISE"
    WINDOWS_SERVER_2022_PORTUGUESE_BRAZIL_FULL_BASE = "WINDOWS_SERVER_2022_PORTUGUESE_BRAZIL_FULL_BASE"
    WINDOWS_SERVER_2022_ITALIAN_FULL_BASE = "WINDOWS_SERVER_2022_ITALIAN_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_CONTAINERSLATEST = "WINDOWS_SERVER_2022_ENGLISH_FULL_CONTAINERSLATEST"
    WINDOWS_SERVER_2022_RUSSIAN_FULL_BASE = "WINDOWS_SERVER_2022_RUSSIAN_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_EXPRESS = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_EXPRESS"
    WINDOWS_SERVER_2022_POLISH_FULL_BASE = "WINDOWS_SERVER_2022_POLISH_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_CORE_BASE = "WINDOWS_SERVER_2022_ENGLISH_CORE_BASE"
    WINDOWS_SERVER_2022_HUNGARIAN_FULL_BASE = "WINDOWS_SERVER_2022_HUNGARIAN_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_EXPRESS = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_EXPRESS"
    WINDOWS_SERVER_2022_GERMAN_FULL_BASE = "WINDOWS_SERVER_2022_GERMAN_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_CORE_CONTAINERSLATEST = "WINDOWS_SERVER_2022_ENGLISH_CORE_CONTAINERSLATEST"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_STANDARD = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_STANDARD"
    WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2017_WEB = "WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2017_WEB"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_WEB = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_WEB"
    WINDOWS_SERVER_2022_JAPANESE_FULL_BASE = "WINDOWS_SERVER_2022_JAPANESE_FULL_BASE"
    WINDOWS_SERVER_2022_KOREAN_FULL_BASE = "WINDOWS_SERVER_2022_KOREAN_FULL_BASE"
    WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2017_ENTERPRISE = "WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2017_ENTERPRISE"
    WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2019_STANDARD = "WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2019_STANDARD"
    WINDOWS_SERVER_2022_CHINESE_SIMPLIFIED_FULL_BASE = "WINDOWS_SERVER_2022_CHINESE_SIMPLIFIED_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_WEB = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_WEB"
    WINDOWS_SERVER_2022_SPANISH_FULL_BASE = "WINDOWS_SERVER_2022_SPANISH_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_CORE_ECS_OPTIMIZED = "WINDOWS_SERVER_2022_ENGLISH_CORE_ECS_OPTIMIZED"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_STANDARD = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_STANDARD"
    WINDOWS_SERVER_2022_CHINESE_TRADITIONAL_FULL_BASE = "WINDOWS_SERVER_2022_CHINESE_TRADITIONAL_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_ENTERPRISE = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2019_ENTERPRISE"
    WINDOWS_SERVER_2022_FRENCH_FULL_BASE = "WINDOWS_SERVER_2022_FRENCH_FULL_BASE"
    WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2017_STANDARD = "WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2017_STANDARD"
    WINDOWS_SERVER_2022_ENGLISH_FULL_BASE = "WINDOWS_SERVER_2022_ENGLISH_FULL_BASE"
    WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2019_WEB = "WINDOWS_SERVER_2022_JAPANESE_FULL_SQL_2019_WEB"
    WINDOWS_SERVER_2022_TURKISH_FULL_BASE = "WINDOWS_SERVER_2022_TURKISH_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_ENTERPRISE = "WINDOWS_SERVER_2022_ENGLISH_FULL_SQL_2017_ENTERPRISE"
    WINDOWS_SERVER_2022_PORTUGUESE_PORTUGAL_FULL_BASE = "WINDOWS_SERVER_2022_PORTUGUESE_PORTUGAL_FULL_BASE"
    WINDOWS_SERVER_2022_CZECH_FULL_BASE = "WINDOWS_SERVER_2022_CZECH_FULL_BASE"
    WINDOWS_SERVER_2022_ENGLISH_FULL_ECS_OPTIMIZED = "WINDOWS_SERVER_2022_ENGLISH_FULL_ECS_OPTIMIZED"
    WINDOWS_SERVER_2022_DUTCH_FULL_BASE = "WINDOWS_SERVER_2022_DUTCH_FULL_BASE"
    WINDOWS_SERVER_2022_SWEDISH_FULL_BASE = "WINDOWS_SERVER_2022_SWEDISH_FULL_BASE"


@jsii.implements(IInstance)
class BastionHostLinux(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.BastionHostLinux",
):
    '''This creates a linux bastion host you can use to connect to other instances or services in your VPC.

    The recommended way to connect to the bastion host is by using AWS Systems Manager Session Manager.

    The operating system is Amazon Linux 2 with the latest SSM agent installed

    You can also configure this bastion host to allow connections via SSH

    :exampleMetadata: fixture=with-vpc infused
    :resource: AWS::EC2::Instance

    Example::

        host = ec2.BastionHostLinux(self, "BastionHost",
            vpc=vpc,
            block_devices=[ec2.BlockDevice(
                device_name="EBSBastionHost",
                volume=ec2.BlockDeviceVolume.ebs(10,
                    encrypted=True
                )
            )]
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        availability_zone: typing.Optional[builtins.str] = None,
        block_devices: typing.Optional[typing.Sequence[BlockDevice]] = None,
        init: typing.Optional[CloudFormationInit] = None,
        init_options: typing.Optional[ApplyCloudFormationInitOptions] = None,
        instance_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[InstanceType] = None,
        machine_image: typing.Optional[IMachineImage] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
        subnet_selection: typing.Optional[SubnetSelection] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: VPC to launch the instance in.
        :param availability_zone: In which AZ to place the instance within the VPC. Default: - Random zone.
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param init: Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init
        :param init_options: Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options
        :param instance_name: The name of the instance. Default: 'BastionHost'
        :param instance_type: Type of instance to launch. Default: 't3.nano'
        :param machine_image: The machine image to use, assumed to have SSM Agent preinstalled. Default: - An Amazon Linux 2 image which is kept up-to-date automatically (the instance may be replaced on every deployment) and already has SSM Agent installed.
        :param require_imdsv2: Whether IMDSv2 should be required on this instance. Default: - false
        :param security_group: Security Group to assign to this instance. Default: - create new security group with no inbound and all outbound traffic allowed
        :param subnet_selection: Select the subnets to run the bastion host in. Set this to PUBLIC if you need to connect to this instance via the internet and cannot use SSM. You have to allow port 22 manually by using the connections field Default: - private subnets of the supplied VPC
        '''
        props = BastionHostLinuxProps(
            vpc=vpc,
            availability_zone=availability_zone,
            block_devices=block_devices,
            init=init,
            init_options=init_options,
            instance_name=instance_name,
            instance_type=instance_type,
            machine_image=machine_image,
            require_imdsv2=require_imdsv2,
            security_group=security_group,
            subnet_selection=subnet_selection,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="allowSshAccessFrom")
    def allow_ssh_access_from(self, *peer: IPeer) -> None:
        '''Allow SSH access from the given peer or peers.

        Necessary if you want to connect to the instance using ssh. If not
        called, you should use SSM Session Manager to connect to the instance.

        :param peer: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowSshAccessFrom", [*peer]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''Allows specify security group connections for the instance.'''
        return typing.cast("Connections", jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="grantPrincipal")
    def grant_principal(self) -> _IPrincipal_539bb2fd:
        '''The principal to grant permissions to.'''
        return typing.cast(_IPrincipal_539bb2fd, jsii.get(self, "grantPrincipal"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instance")
    def instance(self) -> Instance:
        '''The underlying instance resource.'''
        return typing.cast(Instance, jsii.get(self, "instance"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceAvailabilityZone")
    def instance_availability_zone(self) -> builtins.str:
        '''The availability zone the instance was launched in.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceAvailabilityZone"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instanceId")
    def instance_id(self) -> builtins.str:
        '''The instance's ID.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instanceId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateDnsName")
    def instance_private_dns_name(self) -> builtins.str:
        '''Private DNS name for this instance.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePrivateDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePrivateIp")
    def instance_private_ip(self) -> builtins.str:
        '''Private IP for this instance.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePrivateIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicDnsName")
    def instance_public_dns_name(self) -> builtins.str:
        '''Publicly-routable DNS name for this instance.

        (May be an empty string if the instance does not have a public name).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePublicDnsName"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="instancePublicIp")
    def instance_public_ip(self) -> builtins.str:
        '''Publicly-routable IP  address for this instance.

        (May be an empty string if the instance does not have a public IP).

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "instancePublicIp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="role")
    def role(self) -> _IRole_235f5d8e:
        '''The IAM role assumed by the instance.'''
        return typing.cast(_IRole_235f5d8e, jsii.get(self, "role"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="stack")
    def stack(self) -> _Stack_2866e57f:
        '''The stack in which this resource is defined.'''
        return typing.cast(_Stack_2866e57f, jsii.get(self, "stack"))


@jsii.implements(IConnectable)
class Connections(metaclass=jsii.JSIIMeta, jsii_type="aws-cdk-lib.aws_ec2.Connections"):
    '''Manage the allowed network connections for constructs with Security Groups.

    Security Groups can be thought of as a firewall for network-connected
    devices. This class makes it easy to allow network connections to and
    from security groups, and between security groups individually. When
    establishing connectivity between security groups, it will automatically
    add rules in both security groups

    This object can manage one or more security groups.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # peer: ec2.IPeer
        # port: ec2.Port
        # security_group: ec2.SecurityGroup
        
        connections = ec2.Connections(
            default_port=port,
            peer=peer,
            security_groups=[security_group]
        )
    '''

    def __init__(
        self,
        *,
        default_port: typing.Optional[Port] = None,
        peer: typing.Optional[IPeer] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
    ) -> None:
        '''
        :param default_port: Default port range for initiating connections to and from this object. Default: - No default port
        :param peer: Class that represents the rule by which others can connect to this connectable. This object is required, but will be derived from securityGroup if that is passed. Default: Derived from securityGroup if set.
        :param security_groups: What securityGroup(s) this object is managing connections for. Default: No security groups
        '''
        props = ConnectionsProps(
            default_port=default_port, peer=peer, security_groups=security_groups
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="addSecurityGroup")
    def add_security_group(self, *security_groups: ISecurityGroup) -> None:
        '''Add a security group to the list of security groups managed by this object.

        :param security_groups: -
        '''
        return typing.cast(None, jsii.invoke(self, "addSecurityGroup", [*security_groups]))

    @jsii.member(jsii_name="allowDefaultPortFrom")
    def allow_default_port_from(
        self,
        other: IConnectable,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow connections from the peer on our default port.

        Even if the peer has a default port, we will always use our default port.

        :param other: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowDefaultPortFrom", [other, description]))

    @jsii.member(jsii_name="allowDefaultPortFromAnyIpv4")
    def allow_default_port_from_any_ipv4(
        self,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow default connections from all IPv4 ranges.

        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowDefaultPortFromAnyIpv4", [description]))

    @jsii.member(jsii_name="allowDefaultPortInternally")
    def allow_default_port_internally(
        self,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow hosts inside the security group to connect to each other.

        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowDefaultPortInternally", [description]))

    @jsii.member(jsii_name="allowDefaultPortTo")
    def allow_default_port_to(
        self,
        other: IConnectable,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow connections from the peer on our default port.

        Even if the peer has a default port, we will always use our default port.

        :param other: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowDefaultPortTo", [other, description]))

    @jsii.member(jsii_name="allowFrom")
    def allow_from(
        self,
        other: IConnectable,
        port_range: Port,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow connections from the peer on the given port.

        :param other: -
        :param port_range: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowFrom", [other, port_range, description]))

    @jsii.member(jsii_name="allowFromAnyIpv4")
    def allow_from_any_ipv4(
        self,
        port_range: Port,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow from any IPv4 ranges.

        :param port_range: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowFromAnyIpv4", [port_range, description]))

    @jsii.member(jsii_name="allowInternally")
    def allow_internally(
        self,
        port_range: Port,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow hosts inside the security group to connect to each other on the given port.

        :param port_range: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowInternally", [port_range, description]))

    @jsii.member(jsii_name="allowTo")
    def allow_to(
        self,
        other: IConnectable,
        port_range: Port,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow connections to the peer on the given port.

        :param other: -
        :param port_range: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowTo", [other, port_range, description]))

    @jsii.member(jsii_name="allowToAnyIpv4")
    def allow_to_any_ipv4(
        self,
        port_range: Port,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow to all IPv4 ranges.

        :param port_range: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowToAnyIpv4", [port_range, description]))

    @jsii.member(jsii_name="allowToDefaultPort")
    def allow_to_default_port(
        self,
        other: IConnectable,
        description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Allow connections to the security group on their default port.

        :param other: -
        :param description: -
        '''
        return typing.cast(None, jsii.invoke(self, "allowToDefaultPort", [other, description]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> "Connections":
        '''The network connections associated with this resource.'''
        return typing.cast("Connections", jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroups")
    def security_groups(self) -> typing.List[ISecurityGroup]:
        return typing.cast(typing.List[ISecurityGroup], jsii.get(self, "securityGroups"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="defaultPort")
    def default_port(self) -> typing.Optional[Port]:
        '''The default port configured for this connection peer, if available.'''
        return typing.cast(typing.Optional[Port], jsii.get(self, "defaultPort"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.EbsDeviceOptions",
    jsii_struct_bases=[EbsDeviceOptionsBase],
    name_mapping={
        "delete_on_termination": "deleteOnTermination",
        "iops": "iops",
        "volume_type": "volumeType",
        "encrypted": "encrypted",
        "kms_key": "kmsKey",
    },
)
class EbsDeviceOptions(EbsDeviceOptionsBase):
    def __init__(
        self,
        *,
        delete_on_termination: typing.Optional[builtins.bool] = None,
        iops: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional[EbsDeviceVolumeType] = None,
        encrypted: typing.Optional[builtins.bool] = None,
        kms_key: typing.Optional[_IKey_5f11635f] = None,
    ) -> None:
        '''Block device options for an EBS volume.

        :param delete_on_termination: Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1} The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for {@link EbsDeviceVolumeType.IO1}
        :param volume_type: The EBS volume type. Default: {@link EbsDeviceVolumeType.GP2}
        :param encrypted: Specifies whether the EBS volume is encrypted. Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption Default: false
        :param kms_key: The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption. You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances. Default: - If encrypted is true, the default aws/ebs KMS key will be used.

        :exampleMetadata: fixture=with-vpc infused

        Example::

            host = ec2.BastionHostLinux(self, "BastionHost",
                vpc=vpc,
                block_devices=[ec2.BlockDevice(
                    device_name="EBSBastionHost",
                    volume=ec2.BlockDeviceVolume.ebs(10,
                        encrypted=True
                    )
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if delete_on_termination is not None:
            self._values["delete_on_termination"] = delete_on_termination
        if iops is not None:
            self._values["iops"] = iops
        if volume_type is not None:
            self._values["volume_type"] = volume_type
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if kms_key is not None:
            self._values["kms_key"] = kms_key

    @builtins.property
    def delete_on_termination(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether to delete the volume when the instance is terminated.

        :default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        '''
        result = self._values.get("delete_on_termination")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) to provision for the volume.

        Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1}

        The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS,
        you need at least 100 GiB storage on the volume.

        :default: - none, required for {@link EbsDeviceVolumeType.IO1}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_type(self) -> typing.Optional[EbsDeviceVolumeType]:
        '''The EBS volume type.

        :default: {@link EbsDeviceVolumeType.GP2}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional[EbsDeviceVolumeType], result)

    @builtins.property
    def encrypted(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the EBS volume is encrypted.

        Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption

        :default: false

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances
        '''
        result = self._values.get("encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def kms_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption.

        You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances.

        :default: - If encrypted is true, the default aws/ebs KMS key will be used.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#ebs-encryption-requirements
        '''
        result = self._values.get("kms_key")
        return typing.cast(typing.Optional[_IKey_5f11635f], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EbsDeviceOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.EbsDeviceProps",
    jsii_struct_bases=[EbsDeviceSnapshotOptions, EbsDeviceOptions],
    name_mapping={
        "delete_on_termination": "deleteOnTermination",
        "iops": "iops",
        "volume_type": "volumeType",
        "volume_size": "volumeSize",
        "encrypted": "encrypted",
        "kms_key": "kmsKey",
        "snapshot_id": "snapshotId",
    },
)
class EbsDeviceProps(EbsDeviceSnapshotOptions, EbsDeviceOptions):
    def __init__(
        self,
        *,
        delete_on_termination: typing.Optional[builtins.bool] = None,
        iops: typing.Optional[jsii.Number] = None,
        volume_type: typing.Optional[EbsDeviceVolumeType] = None,
        volume_size: typing.Optional[jsii.Number] = None,
        encrypted: typing.Optional[builtins.bool] = None,
        kms_key: typing.Optional[_IKey_5f11635f] = None,
        snapshot_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Properties of an EBS block device.

        :param delete_on_termination: Indicates whether to delete the volume when the instance is terminated. Default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        :param iops: The number of I/O operations per second (IOPS) to provision for the volume. Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1} The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS, you need at least 100 GiB storage on the volume. Default: - none, required for {@link EbsDeviceVolumeType.IO1}
        :param volume_type: The EBS volume type. Default: {@link EbsDeviceVolumeType.GP2}
        :param volume_size: The volume size, in Gibibytes (GiB). If you specify volumeSize, it must be equal or greater than the size of the snapshot. Default: - The snapshot size
        :param encrypted: Specifies whether the EBS volume is encrypted. Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption Default: false
        :param kms_key: The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption. You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances. Default: - If encrypted is true, the default aws/ebs KMS key will be used.
        :param snapshot_id: The snapshot ID of the volume to use. Default: - No snapshot will be used

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_kms as kms
            
            # key: kms.Key
            
            ebs_device_props = ec2.EbsDeviceProps(
                delete_on_termination=False,
                encrypted=False,
                iops=123,
                kms_key=key,
                snapshot_id="snapshotId",
                volume_size=123,
                volume_type=ec2.EbsDeviceVolumeType.STANDARD
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {}
        if delete_on_termination is not None:
            self._values["delete_on_termination"] = delete_on_termination
        if iops is not None:
            self._values["iops"] = iops
        if volume_type is not None:
            self._values["volume_type"] = volume_type
        if volume_size is not None:
            self._values["volume_size"] = volume_size
        if encrypted is not None:
            self._values["encrypted"] = encrypted
        if kms_key is not None:
            self._values["kms_key"] = kms_key
        if snapshot_id is not None:
            self._values["snapshot_id"] = snapshot_id

    @builtins.property
    def delete_on_termination(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether to delete the volume when the instance is terminated.

        :default: - true for Amazon EC2 Auto Scaling, false otherwise (e.g. EBS)
        '''
        result = self._values.get("delete_on_termination")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def iops(self) -> typing.Optional[jsii.Number]:
        '''The number of I/O operations per second (IOPS) to provision for the volume.

        Must only be set for {@link volumeType}: {@link EbsDeviceVolumeType.IO1}

        The maximum ratio of IOPS to volume size (in GiB) is 50:1, so for 5,000 provisioned IOPS,
        you need at least 100 GiB storage on the volume.

        :default: - none, required for {@link EbsDeviceVolumeType.IO1}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("iops")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def volume_type(self) -> typing.Optional[EbsDeviceVolumeType]:
        '''The EBS volume type.

        :default: {@link EbsDeviceVolumeType.GP2}

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
        '''
        result = self._values.get("volume_type")
        return typing.cast(typing.Optional[EbsDeviceVolumeType], result)

    @builtins.property
    def volume_size(self) -> typing.Optional[jsii.Number]:
        '''The volume size, in Gibibytes (GiB).

        If you specify volumeSize, it must be equal or greater than the size of the snapshot.

        :default: - The snapshot size
        '''
        result = self._values.get("volume_size")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def encrypted(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the EBS volume is encrypted.

        Encrypted EBS volumes can only be attached to instances that support Amazon EBS encryption

        :default: false

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances
        '''
        result = self._values.get("encrypted")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def kms_key(self) -> typing.Optional[_IKey_5f11635f]:
        '''The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption.

        You have to ensure that the KMS CMK has the correct permissions to be used by the service launching the ec2 instances.

        :default: - If encrypted is true, the default aws/ebs KMS key will be used.

        :see: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#ebs-encryption-requirements
        '''
        result = self._values.get("kms_key")
        return typing.cast(typing.Optional[_IKey_5f11635f], result)

    @builtins.property
    def snapshot_id(self) -> typing.Optional[builtins.str]:
        '''The snapshot ID of the volume to use.

        :default: - No snapshot will be used
        '''
        result = self._values.get("snapshot_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EbsDeviceProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.EnableVpnGatewayOptions",
    jsii_struct_bases=[VpnGatewayProps],
    name_mapping={
        "type": "type",
        "amazon_side_asn": "amazonSideAsn",
        "vpn_route_propagation": "vpnRoutePropagation",
    },
)
class EnableVpnGatewayOptions(VpnGatewayProps):
    def __init__(
        self,
        *,
        type: builtins.str,
        amazon_side_asn: typing.Optional[jsii.Number] = None,
        vpn_route_propagation: typing.Optional[typing.Sequence[SubnetSelection]] = None,
    ) -> None:
        '''Options for the Vpc.enableVpnGateway() method.

        :param type: Default type ipsec.1.
        :param amazon_side_asn: Explicitly specify an Asn or let aws pick an Asn for you. Default: 65000
        :param vpn_route_propagation: Provide an array of subnets where the route propagation should be added. Default: noPropagation

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            # subnet: ec2.Subnet
            # subnet_filter: ec2.SubnetFilter
            
            enable_vpn_gateway_options = ec2.EnableVpnGatewayOptions(
                type="type",
            
                # the properties below are optional
                amazon_side_asn=123,
                vpn_route_propagation=[ec2.SubnetSelection(
                    availability_zones=["availabilityZones"],
                    one_per_az=False,
                    subnet_filters=[subnet_filter],
                    subnet_group_name="subnetGroupName",
                    subnets=[subnet],
                    subnet_type=ec2.SubnetType.PRIVATE_ISOLATED
                )]
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "type": type,
        }
        if amazon_side_asn is not None:
            self._values["amazon_side_asn"] = amazon_side_asn
        if vpn_route_propagation is not None:
            self._values["vpn_route_propagation"] = vpn_route_propagation

    @builtins.property
    def type(self) -> builtins.str:
        '''Default type ipsec.1.'''
        result = self._values.get("type")
        assert result is not None, "Required property 'type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def amazon_side_asn(self) -> typing.Optional[jsii.Number]:
        '''Explicitly specify an Asn or let aws pick an Asn for you.

        :default: 65000
        '''
        result = self._values.get("amazon_side_asn")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def vpn_route_propagation(self) -> typing.Optional[typing.List[SubnetSelection]]:
        '''Provide an array of subnets where the route propagation should be added.

        :default: noPropagation
        '''
        result = self._values.get("vpn_route_propagation")
        return typing.cast(typing.Optional[typing.List[SubnetSelection]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EnableVpnGatewayOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IFlowLog)
class FlowLog(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.FlowLog",
):
    '''A VPC flow log.

    :exampleMetadata: infused
    :resource: AWS::EC2::FlowLog

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        log_group = logs.LogGroup(self, "MyCustomLogGroup")
        
        role = iam.Role(self, "MyCustomRole",
            assumed_by=iam.ServicePrincipal("vpc-flow-logs.amazonaws.com")
        )
        
        ec2.FlowLog(self, "FlowLog",
            resource_type=ec2.FlowLogResourceType.from_vpc(vpc),
            destination=ec2.FlowLogDestination.to_cloud_watch_logs(log_group, role)
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        resource_type: FlowLogResourceType,
        flow_log_name: typing.Optional[builtins.str] = None,
        destination: typing.Optional[FlowLogDestination] = None,
        traffic_type: typing.Optional[FlowLogTrafficType] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param resource_type: The type of resource for which to create the flow log.
        :param flow_log_name: The name of the FlowLog. It is not recommended to use an explicit name. Default: If you don't specify a flowLogName, AWS CloudFormation generates a unique physical ID and uses that ID for the group name.
        :param destination: Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3 Default: FlowLogDestinationType.toCloudWatchLogs()
        :param traffic_type: The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic. Default: ALL
        '''
        props = FlowLogProps(
            resource_type=resource_type,
            flow_log_name=flow_log_name,
            destination=destination,
            traffic_type=traffic_type,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromFlowLogId") # type: ignore[misc]
    @builtins.classmethod
    def from_flow_log_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        flow_log_id: builtins.str,
    ) -> IFlowLog:
        '''Import a Flow Log by it's Id.

        :param scope: -
        :param id: -
        :param flow_log_id: -
        '''
        return typing.cast(IFlowLog, jsii.sinvoke(cls, "fromFlowLogId", [scope, id, flow_log_id]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="flowLogId")
    def flow_log_id(self) -> builtins.str:
        '''The Id of the VPC Flow Log.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "flowLogId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="bucket")
    def bucket(self) -> typing.Optional[_IBucket_42e086fd]:
        '''The S3 bucket to publish flow logs to.'''
        return typing.cast(typing.Optional[_IBucket_42e086fd], jsii.get(self, "bucket"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="iamRole")
    def iam_role(self) -> typing.Optional[_IRole_235f5d8e]:
        '''The iam role used to publish logs to CloudWatch.'''
        return typing.cast(typing.Optional[_IRole_235f5d8e], jsii.get(self, "iamRole"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="keyPrefix")
    def key_prefix(self) -> typing.Optional[builtins.str]:
        '''S3 bucket key prefix to publish the flow logs under.'''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "keyPrefix"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="logGroup")
    def log_group(self) -> typing.Optional[_ILogGroup_3c4fa718]:
        '''The CloudWatch Logs LogGroup to publish flow logs to.'''
        return typing.cast(typing.Optional[_ILogGroup_3c4fa718], jsii.get(self, "logGroup"))


@jsii.implements(IGatewayVpcEndpointService)
class GatewayVpcEndpointAwsService(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.GatewayVpcEndpointAwsService",
):
    '''An AWS service for a gateway VPC endpoint.

    :exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused

    Example::

        # Add gateway endpoints when creating the VPC
        vpc = ec2.Vpc(self, "MyVpc",
            gateway_endpoints={
                "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(
                    service=ec2.GatewayVpcEndpointAwsService.S3
                )
            }
        )
        
        # Alternatively gateway endpoints can be added on the VPC
        dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",
            service=ec2.GatewayVpcEndpointAwsService.DYNAMODB
        )
        
        # This allows to customize the endpoint policy
        dynamo_db_endpoint.add_to_policy(
            iam.PolicyStatement( # Restrict to listing and describing tables
                principals=[iam.AnyPrincipal()],
                actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],
                resources=["*"]))
        
        # Add an interface endpoint
        vpc.add_interface_endpoint("EcrDockerEndpoint",
            service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER
        )
    '''

    def __init__(
        self,
        name: builtins.str,
        prefix: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param name: -
        :param prefix: -
        '''
        jsii.create(self.__class__, self, [name, prefix])

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="DYNAMODB")
    def DYNAMODB(cls) -> "GatewayVpcEndpointAwsService":
        return typing.cast("GatewayVpcEndpointAwsService", jsii.sget(cls, "DYNAMODB"))

    @jsii.python.classproperty # type: ignore[misc]
    @jsii.member(jsii_name="S3")
    def S3(cls) -> "GatewayVpcEndpointAwsService":
        return typing.cast("GatewayVpcEndpointAwsService", jsii.sget(cls, "S3"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="name")
    def name(self) -> builtins.str:
        '''The name of the service.'''
        return typing.cast(builtins.str, jsii.get(self, "name"))


@jsii.implements(IMachineImage)
class GenericLinuxImage(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.GenericLinuxImage",
):
    '''Construct a Linux machine image from an AMI map.

    Linux images IDs are not published to SSM parameter store yet, so you'll have to
    manually specify an AMI map.

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    def __init__(
        self,
        ami_map: typing.Mapping[builtins.str, builtins.str],
        *,
        user_data: typing.Optional[UserData] = None,
    ) -> None:
        '''
        :param ami_map: -
        :param user_data: Initial user data. Default: - Empty UserData for Linux machines
        '''
        props = GenericLinuxImageProps(user_data=user_data)

        jsii.create(self.__class__, self, [ami_map, props])

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> MachineImageConfig:
        '''Return the image to use in the given context.

        :param scope: -
        '''
        return typing.cast(MachineImageConfig, jsii.invoke(self, "getImage", [scope]))


@jsii.implements(IMachineImage)
class GenericSSMParameterImage(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.GenericSSMParameterImage",
):
    '''Select the image based on a given SSM parameter.

    This Machine Image automatically updates to the latest version on every
    deployment. Be aware this will cause your instances to be replaced when a
    new version of the image becomes available. Do not store stateful information
    on the instance if you are using this image.

    The AMI ID is selected using the values published to the SSM parameter store.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # user_data: ec2.UserData
        
        generic_sSMParameter_image = ec2.GenericSSMParameterImage("parameterName", ec2.OperatingSystemType.LINUX, user_data)
    '''

    def __init__(
        self,
        parameter_name: builtins.str,
        os: OperatingSystemType,
        user_data: typing.Optional[UserData] = None,
    ) -> None:
        '''
        :param parameter_name: -
        :param os: -
        :param user_data: -
        '''
        jsii.create(self.__class__, self, [parameter_name, os, user_data])

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> MachineImageConfig:
        '''Return the image to use in the given context.

        :param scope: -
        '''
        return typing.cast(MachineImageConfig, jsii.invoke(self, "getImage", [scope]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="parameterName")
    def parameter_name(self) -> builtins.str:
        '''Name of the SSM parameter we're looking up.'''
        return typing.cast(builtins.str, jsii.get(self, "parameterName"))


@jsii.implements(IMachineImage)
class GenericWindowsImage(
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.GenericWindowsImage",
):
    '''Construct a Windows machine image from an AMI map.

    Allows you to create a generic Windows EC2 , manually specify an AMI map.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        # user_data: ec2.UserData
        
        generic_windows_image = ec2.GenericWindowsImage({
            "ami_map_key": "amiMap"
        },
            user_data=user_data
        )
    '''

    def __init__(
        self,
        ami_map: typing.Mapping[builtins.str, builtins.str],
        *,
        user_data: typing.Optional[UserData] = None,
    ) -> None:
        '''
        :param ami_map: -
        :param user_data: Initial user data. Default: - Empty UserData for Windows machines
        '''
        props = GenericWindowsImageProps(user_data=user_data)

        jsii.create(self.__class__, self, [ami_map, props])

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> MachineImageConfig:
        '''Return the image to use in the given context.

        :param scope: -
        '''
        return typing.cast(MachineImageConfig, jsii.invoke(self, "getImage", [scope]))


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IClientVpnEndpoint")
class IClientVpnEndpoint(_IResource_c80c4260, IConnectable, typing_extensions.Protocol):
    '''A client VPN endpoint.'''

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endpointId")
    def endpoint_id(self) -> builtins.str:
        '''The endpoint ID.'''
        ...

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="targetNetworksAssociated")
    def target_networks_associated(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force target networks associations.'''
        ...


class _IClientVpnEndpointProxy(
    jsii.proxy_for(_IResource_c80c4260), # type: ignore[misc]
    jsii.proxy_for(IConnectable), # type: ignore[misc]
):
    '''A client VPN endpoint.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IClientVpnEndpoint"

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endpointId")
    def endpoint_id(self) -> builtins.str:
        '''The endpoint ID.'''
        return typing.cast(builtins.str, jsii.get(self, "endpointId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="targetNetworksAssociated")
    def target_networks_associated(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force target networks associations.'''
        return typing.cast(constructs.IDependable, jsii.get(self, "targetNetworksAssociated"))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IClientVpnEndpoint).__jsii_proxy_class__ = lambda : _IClientVpnEndpointProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IGatewayVpcEndpoint")
class IGatewayVpcEndpoint(IVpcEndpoint, typing_extensions.Protocol):
    '''A gateway VPC endpoint.'''

    pass


class _IGatewayVpcEndpointProxy(
    jsii.proxy_for(IVpcEndpoint) # type: ignore[misc]
):
    '''A gateway VPC endpoint.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IGatewayVpcEndpoint"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IGatewayVpcEndpoint).__jsii_proxy_class__ = lambda : _IGatewayVpcEndpointProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IInterfaceVpcEndpoint")
class IInterfaceVpcEndpoint(IVpcEndpoint, IConnectable, typing_extensions.Protocol):
    '''An interface VPC endpoint.'''

    pass


class _IInterfaceVpcEndpointProxy(
    jsii.proxy_for(IVpcEndpoint), # type: ignore[misc]
    jsii.proxy_for(IConnectable), # type: ignore[misc]
):
    '''An interface VPC endpoint.'''

    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IInterfaceVpcEndpoint"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IInterfaceVpcEndpoint).__jsii_proxy_class__ = lambda : _IInterfaceVpcEndpointProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IPrivateSubnet")
class IPrivateSubnet(ISubnet, typing_extensions.Protocol):
    pass


class _IPrivateSubnetProxy(
    jsii.proxy_for(ISubnet) # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IPrivateSubnet"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPrivateSubnet).__jsii_proxy_class__ = lambda : _IPrivateSubnetProxy


@jsii.interface(jsii_type="aws-cdk-lib.aws_ec2.IPublicSubnet")
class IPublicSubnet(ISubnet, typing_extensions.Protocol):
    pass


class _IPublicSubnetProxy(
    jsii.proxy_for(ISubnet) # type: ignore[misc]
):
    __jsii_type__: typing.ClassVar[str] = "aws-cdk-lib.aws_ec2.IPublicSubnet"
    pass

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPublicSubnet).__jsii_proxy_class__ = lambda : _IPublicSubnetProxy


class InitCommand(
    InitElement,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InitCommand",
):
    '''Command to execute on the instance.

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        handle = ec2.InitServiceRestartHandle()
        ec2.CloudFormationInit.from_elements(
            ec2.InitCommand.shell_command("/usr/bin/custom-nginx-install.sh", service_restart_handles=[handle]),
            ec2.InitService.enable("nginx", service_restart_handle=handle))
    '''

    @jsii.member(jsii_name="argvCommand") # type: ignore[misc]
    @builtins.classmethod
    def argv_command(
        cls,
        argv: typing.Sequence[builtins.str],
        *,
        cwd: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_errors: typing.Optional[builtins.bool] = None,
        key: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
        test_cmd: typing.Optional[builtins.str] = None,
        wait_after_completion: typing.Optional[InitCommandWaitDuration] = None,
    ) -> "InitCommand":
        '''Run a command from an argv array.

        You do not need to escape space characters or enclose command parameters in quotes.

        :param argv: -
        :param cwd: The working directory. Default: - Use default working directory
        :param env: Sets environment variables for the command. This property overwrites, rather than appends, the existing environment. Default: - Use current environment
        :param ignore_errors: Continue running if this command fails. Default: false
        :param key: Identifier key for this command. Commands are executed in lexicographical order of their key names. Default: - Automatically generated based on index
        :param service_restart_handles: Restart the given service(s) after this command has run. Default: - Do not restart any service
        :param test_cmd: Command to determine whether this command should be run. If the test passes (exits with error code of 0), the command is run. Default: - Always run the command
        :param wait_after_completion: The duration to wait after a command has finished in case the command causes a reboot. Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command; ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete. For Windows systems only. Default: - 60 seconds
        '''
        options = InitCommandOptions(
            cwd=cwd,
            env=env,
            ignore_errors=ignore_errors,
            key=key,
            service_restart_handles=service_restart_handles,
            test_cmd=test_cmd,
            wait_after_completion=wait_after_completion,
        )

        return typing.cast("InitCommand", jsii.sinvoke(cls, "argvCommand", [argv, options]))

    @jsii.member(jsii_name="shellCommand") # type: ignore[misc]
    @builtins.classmethod
    def shell_command(
        cls,
        shell_command: builtins.str,
        *,
        cwd: typing.Optional[builtins.str] = None,
        env: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        ignore_errors: typing.Optional[builtins.bool] = None,
        key: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
        test_cmd: typing.Optional[builtins.str] = None,
        wait_after_completion: typing.Optional[InitCommandWaitDuration] = None,
    ) -> "InitCommand":
        '''Run a shell command.

        Remember that some characters like ``&``, ``|``, ``;``, ``>`` etc. have special meaning in a shell and
        need to be preceded by a ``\\`` if you want to treat them as part of a filename.

        :param shell_command: -
        :param cwd: The working directory. Default: - Use default working directory
        :param env: Sets environment variables for the command. This property overwrites, rather than appends, the existing environment. Default: - Use current environment
        :param ignore_errors: Continue running if this command fails. Default: false
        :param key: Identifier key for this command. Commands are executed in lexicographical order of their key names. Default: - Automatically generated based on index
        :param service_restart_handles: Restart the given service(s) after this command has run. Default: - Do not restart any service
        :param test_cmd: Command to determine whether this command should be run. If the test passes (exits with error code of 0), the command is run. Default: - Always run the command
        :param wait_after_completion: The duration to wait after a command has finished in case the command causes a reboot. Set this value to ``InitCommandWaitDuration.none()`` if you do not want to wait for every command; ``InitCommandWaitDuration.forever()`` directs cfn-init to exit and resume only after the reboot is complete. For Windows systems only. Default: - 60 seconds
        '''
        options = InitCommandOptions(
            cwd=cwd,
            env=env,
            ignore_errors=ignore_errors,
            key=key,
            service_restart_handles=service_restart_handles,
            test_cmd=test_cmd,
            wait_after_completion=wait_after_completion,
        )

        return typing.cast("InitCommand", jsii.sinvoke(cls, "shellCommand", [shell_command, options]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="elementType")
    def element_type(self) -> builtins.str:
        '''Returns the init element type for this element.'''
        return typing.cast(builtins.str, jsii.get(self, "elementType"))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitFileAssetOptions",
    jsii_struct_bases=[InitFileOptions, _AssetOptions_2aa69621],
    name_mapping={
        "base64_encoded": "base64Encoded",
        "group": "group",
        "mode": "mode",
        "owner": "owner",
        "service_restart_handles": "serviceRestartHandles",
        "asset_hash": "assetHash",
        "asset_hash_type": "assetHashType",
        "bundling": "bundling",
        "exclude": "exclude",
        "follow_symlinks": "followSymlinks",
        "ignore_mode": "ignoreMode",
        "readers": "readers",
    },
)
class InitFileAssetOptions(InitFileOptions, _AssetOptions_2aa69621):
    def __init__(
        self,
        *,
        base64_encoded: typing.Optional[builtins.bool] = None,
        group: typing.Optional[builtins.str] = None,
        mode: typing.Optional[builtins.str] = None,
        owner: typing.Optional[builtins.str] = None,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
        asset_hash: typing.Optional[builtins.str] = None,
        asset_hash_type: typing.Optional[_AssetHashType_05b67f2d] = None,
        bundling: typing.Optional[_BundlingOptions_588cc936] = None,
        exclude: typing.Optional[typing.Sequence[builtins.str]] = None,
        follow_symlinks: typing.Optional[_SymlinkFollowMode_047ec1f6] = None,
        ignore_mode: typing.Optional[_IgnoreMode_655a98e8] = None,
        readers: typing.Optional[typing.Sequence[_IGrantable_71c4f5de]] = None,
    ) -> None:
        '''Additional options for creating an InitFile from an asset.

        :param base64_encoded: True if the inlined content (from a string or file) should be treated as base64 encoded. Only applicable for inlined string and file content. Default: false
        :param group: The name of the owning group for this file. Not supported for Windows systems. Default: 'root'
        :param mode: A six-digit octal value representing the mode for this file. Use the first three digits for symlinks and the last three digits for setting permissions. To create a symlink, specify 120xxx, where xxx defines the permissions of the target file. To specify permissions for a file, use the last three digits, such as 000644. Not supported for Windows systems. Default: '000644'
        :param owner: The name of the owning user for this file. Not supported for Windows systems. Default: 'root'
        :param service_restart_handles: Restart the given service after this file has been written. Default: - Do not restart any service
        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
        :param exclude: Glob patterns to exclude from the copy. Default: - nothing is excluded
        :param follow_symlinks: A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER
        :param ignore_mode: The ignore behavior to use for exclude patterns. Default: IgnoreMode.GLOB
        :param readers: A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import aws_cdk as cdk
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_iam as iam
            
            # docker_image: cdk.DockerImage
            # grantable: iam.IGrantable
            # init_service_restart_handle: ec2.InitServiceRestartHandle
            # local_bundling: cdk.ILocalBundling
            
            init_file_asset_options = ec2.InitFileAssetOptions(
                asset_hash="assetHash",
                asset_hash_type=cdk.AssetHashType.SOURCE,
                base64_encoded=False,
                bundling=cdk.BundlingOptions(
                    image=docker_image,
            
                    # the properties below are optional
                    command=["command"],
                    entrypoint=["entrypoint"],
                    environment={
                        "environment_key": "environment"
                    },
                    local=local_bundling,
                    output_type=cdk.BundlingOutput.ARCHIVED,
                    security_opt="securityOpt",
                    user="user",
                    volumes=[cdk.DockerVolume(
                        container_path="containerPath",
                        host_path="hostPath",
            
                        # the properties below are optional
                        consistency=cdk.DockerVolumeConsistency.CONSISTENT
                    )],
                    working_directory="workingDirectory"
                ),
                exclude=["exclude"],
                follow_symlinks=cdk.SymlinkFollowMode.NEVER,
                group="group",
                ignore_mode=cdk.IgnoreMode.GLOB,
                mode="mode",
                owner="owner",
                readers=[grantable],
                service_restart_handles=[init_service_restart_handle]
            )
        '''
        if isinstance(bundling, dict):
            bundling = _BundlingOptions_588cc936(**bundling)
        self._values: typing.Dict[str, typing.Any] = {}
        if base64_encoded is not None:
            self._values["base64_encoded"] = base64_encoded
        if group is not None:
            self._values["group"] = group
        if mode is not None:
            self._values["mode"] = mode
        if owner is not None:
            self._values["owner"] = owner
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles
        if asset_hash is not None:
            self._values["asset_hash"] = asset_hash
        if asset_hash_type is not None:
            self._values["asset_hash_type"] = asset_hash_type
        if bundling is not None:
            self._values["bundling"] = bundling
        if exclude is not None:
            self._values["exclude"] = exclude
        if follow_symlinks is not None:
            self._values["follow_symlinks"] = follow_symlinks
        if ignore_mode is not None:
            self._values["ignore_mode"] = ignore_mode
        if readers is not None:
            self._values["readers"] = readers

    @builtins.property
    def base64_encoded(self) -> typing.Optional[builtins.bool]:
        '''True if the inlined content (from a string or file) should be treated as base64 encoded.

        Only applicable for inlined string and file content.

        :default: false
        '''
        result = self._values.get("base64_encoded")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def group(self) -> typing.Optional[builtins.str]:
        '''The name of the owning group for this file.

        Not supported for Windows systems.

        :default: 'root'
        '''
        result = self._values.get("group")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def mode(self) -> typing.Optional[builtins.str]:
        '''A six-digit octal value representing the mode for this file.

        Use the first three digits for symlinks and the last three digits for
        setting permissions. To create a symlink, specify 120xxx, where xxx
        defines the permissions of the target file. To specify permissions for a
        file, use the last three digits, such as 000644.

        Not supported for Windows systems.

        :default: '000644'
        '''
        result = self._values.get("mode")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def owner(self) -> typing.Optional[builtins.str]:
        '''The name of the owning user for this file.

        Not supported for Windows systems.

        :default: 'root'
        '''
        result = self._values.get("owner")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List[InitServiceRestartHandle]]:
        '''Restart the given service after this file has been written.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List[InitServiceRestartHandle]], result)

    @builtins.property
    def asset_hash(self) -> typing.Optional[builtins.str]:
        '''Specify a custom hash for this asset.

        If ``assetHashType`` is set it must
        be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will
        be SHA256 hashed and encoded as hex. The resulting hash will be the asset
        hash.

        NOTE: the hash is used in order to identify a specific revision of the asset, and
        used for optimizing and caching deployment activities related to this asset such as
        packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will
        need to make sure it is updated every time the asset changes, or otherwise it is
        possible that some deployments will not be invalidated.

        :default: - based on ``assetHashType``
        '''
        result = self._values.get("asset_hash")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def asset_hash_type(self) -> typing.Optional[_AssetHashType_05b67f2d]:
        '''Specifies the type of hash to calculate for this asset.

        If ``assetHash`` is configured, this option must be ``undefined`` or
        ``AssetHashType.CUSTOM``.

        :default:

        - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is
        explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
        '''
        result = self._values.get("asset_hash_type")
        return typing.cast(typing.Optional[_AssetHashType_05b67f2d], result)

    @builtins.property
    def bundling(self) -> typing.Optional[_BundlingOptions_588cc936]:
        '''Bundle the asset by executing a command in a Docker container or a custom bundling provider.

        The asset path will be mounted at ``/asset-input``. The Docker
        container is responsible for putting content at ``/asset-output``.
        The content at ``/asset-output`` will be zipped and used as the
        final asset.

        :default:

        - uploaded as-is to S3 if the asset is a regular file or a .zip file,
        archived into a .zip file and uploaded to S3 otherwise
        '''
        result = self._values.get("bundling")
        return typing.cast(typing.Optional[_BundlingOptions_588cc936], result)

    @builtins.property
    def exclude(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Glob patterns to exclude from the copy.

        :default: - nothing is excluded
        '''
        result = self._values.get("exclude")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def follow_symlinks(self) -> typing.Optional[_SymlinkFollowMode_047ec1f6]:
        '''A strategy for how to handle symlinks.

        :default: SymlinkFollowMode.NEVER
        '''
        result = self._values.get("follow_symlinks")
        return typing.cast(typing.Optional[_SymlinkFollowMode_047ec1f6], result)

    @builtins.property
    def ignore_mode(self) -> typing.Optional[_IgnoreMode_655a98e8]:
        '''The ignore behavior to use for exclude patterns.

        :default: IgnoreMode.GLOB
        '''
        result = self._values.get("ignore_mode")
        return typing.cast(typing.Optional[_IgnoreMode_655a98e8], result)

    @builtins.property
    def readers(self) -> typing.Optional[typing.List[_IGrantable_71c4f5de]]:
        '''A list of principals that should be able to read this asset from S3.

        You can use ``asset.grantRead(principal)`` to grant read permissions later.

        :default: - No principals that can read file asset.
        '''
        result = self._values.get("readers")
        return typing.cast(typing.Optional[typing.List[_IGrantable_71c4f5de]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitFileAssetOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.InitSourceAssetOptions",
    jsii_struct_bases=[InitSourceOptions, _AssetOptions_2aa69621],
    name_mapping={
        "service_restart_handles": "serviceRestartHandles",
        "asset_hash": "assetHash",
        "asset_hash_type": "assetHashType",
        "bundling": "bundling",
        "exclude": "exclude",
        "follow_symlinks": "followSymlinks",
        "ignore_mode": "ignoreMode",
        "readers": "readers",
    },
)
class InitSourceAssetOptions(InitSourceOptions, _AssetOptions_2aa69621):
    def __init__(
        self,
        *,
        service_restart_handles: typing.Optional[typing.Sequence[InitServiceRestartHandle]] = None,
        asset_hash: typing.Optional[builtins.str] = None,
        asset_hash_type: typing.Optional[_AssetHashType_05b67f2d] = None,
        bundling: typing.Optional[_BundlingOptions_588cc936] = None,
        exclude: typing.Optional[typing.Sequence[builtins.str]] = None,
        follow_symlinks: typing.Optional[_SymlinkFollowMode_047ec1f6] = None,
        ignore_mode: typing.Optional[_IgnoreMode_655a98e8] = None,
        readers: typing.Optional[typing.Sequence[_IGrantable_71c4f5de]] = None,
    ) -> None:
        '''Additional options for an InitSource that builds an asset from local files.

        :param service_restart_handles: Restart the given services after this archive has been extracted. Default: - Do not restart any service
        :param asset_hash: Specify a custom hash for this asset. If ``assetHashType`` is set it must be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will be SHA256 hashed and encoded as hex. The resulting hash will be the asset hash. NOTE: the hash is used in order to identify a specific revision of the asset, and used for optimizing and caching deployment activities related to this asset such as packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will need to make sure it is updated every time the asset changes, or otherwise it is possible that some deployments will not be invalidated. Default: - based on ``assetHashType``
        :param asset_hash_type: Specifies the type of hash to calculate for this asset. If ``assetHash`` is configured, this option must be ``undefined`` or ``AssetHashType.CUSTOM``. Default: - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
        :param bundling: Bundle the asset by executing a command in a Docker container or a custom bundling provider. The asset path will be mounted at ``/asset-input``. The Docker container is responsible for putting content at ``/asset-output``. The content at ``/asset-output`` will be zipped and used as the final asset. Default: - uploaded as-is to S3 if the asset is a regular file or a .zip file, archived into a .zip file and uploaded to S3 otherwise
        :param exclude: Glob patterns to exclude from the copy. Default: - nothing is excluded
        :param follow_symlinks: A strategy for how to handle symlinks. Default: SymlinkFollowMode.NEVER
        :param ignore_mode: The ignore behavior to use for exclude patterns. Default: IgnoreMode.GLOB
        :param readers: A list of principals that should be able to read this asset from S3. You can use ``asset.grantRead(principal)`` to grant read permissions later. Default: - No principals that can read file asset.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            import aws_cdk as cdk
            from aws_cdk import aws_ec2 as ec2
            from aws_cdk import aws_iam as iam
            
            # docker_image: cdk.DockerImage
            # grantable: iam.IGrantable
            # init_service_restart_handle: ec2.InitServiceRestartHandle
            # local_bundling: cdk.ILocalBundling
            
            init_source_asset_options = ec2.InitSourceAssetOptions(
                asset_hash="assetHash",
                asset_hash_type=cdk.AssetHashType.SOURCE,
                bundling=cdk.BundlingOptions(
                    image=docker_image,
            
                    # the properties below are optional
                    command=["command"],
                    entrypoint=["entrypoint"],
                    environment={
                        "environment_key": "environment"
                    },
                    local=local_bundling,
                    output_type=cdk.BundlingOutput.ARCHIVED,
                    security_opt="securityOpt",
                    user="user",
                    volumes=[cdk.DockerVolume(
                        container_path="containerPath",
                        host_path="hostPath",
            
                        # the properties below are optional
                        consistency=cdk.DockerVolumeConsistency.CONSISTENT
                    )],
                    working_directory="workingDirectory"
                ),
                exclude=["exclude"],
                follow_symlinks=cdk.SymlinkFollowMode.NEVER,
                ignore_mode=cdk.IgnoreMode.GLOB,
                readers=[grantable],
                service_restart_handles=[init_service_restart_handle]
            )
        '''
        if isinstance(bundling, dict):
            bundling = _BundlingOptions_588cc936(**bundling)
        self._values: typing.Dict[str, typing.Any] = {}
        if service_restart_handles is not None:
            self._values["service_restart_handles"] = service_restart_handles
        if asset_hash is not None:
            self._values["asset_hash"] = asset_hash
        if asset_hash_type is not None:
            self._values["asset_hash_type"] = asset_hash_type
        if bundling is not None:
            self._values["bundling"] = bundling
        if exclude is not None:
            self._values["exclude"] = exclude
        if follow_symlinks is not None:
            self._values["follow_symlinks"] = follow_symlinks
        if ignore_mode is not None:
            self._values["ignore_mode"] = ignore_mode
        if readers is not None:
            self._values["readers"] = readers

    @builtins.property
    def service_restart_handles(
        self,
    ) -> typing.Optional[typing.List[InitServiceRestartHandle]]:
        '''Restart the given services after this archive has been extracted.

        :default: - Do not restart any service
        '''
        result = self._values.get("service_restart_handles")
        return typing.cast(typing.Optional[typing.List[InitServiceRestartHandle]], result)

    @builtins.property
    def asset_hash(self) -> typing.Optional[builtins.str]:
        '''Specify a custom hash for this asset.

        If ``assetHashType`` is set it must
        be set to ``AssetHashType.CUSTOM``. For consistency, this custom hash will
        be SHA256 hashed and encoded as hex. The resulting hash will be the asset
        hash.

        NOTE: the hash is used in order to identify a specific revision of the asset, and
        used for optimizing and caching deployment activities related to this asset such as
        packaging, uploading to Amazon S3, etc. If you chose to customize the hash, you will
        need to make sure it is updated every time the asset changes, or otherwise it is
        possible that some deployments will not be invalidated.

        :default: - based on ``assetHashType``
        '''
        result = self._values.get("asset_hash")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def asset_hash_type(self) -> typing.Optional[_AssetHashType_05b67f2d]:
        '''Specifies the type of hash to calculate for this asset.

        If ``assetHash`` is configured, this option must be ``undefined`` or
        ``AssetHashType.CUSTOM``.

        :default:

        - the default is ``AssetHashType.SOURCE``, but if ``assetHash`` is
        explicitly specified this value defaults to ``AssetHashType.CUSTOM``.
        '''
        result = self._values.get("asset_hash_type")
        return typing.cast(typing.Optional[_AssetHashType_05b67f2d], result)

    @builtins.property
    def bundling(self) -> typing.Optional[_BundlingOptions_588cc936]:
        '''Bundle the asset by executing a command in a Docker container or a custom bundling provider.

        The asset path will be mounted at ``/asset-input``. The Docker
        container is responsible for putting content at ``/asset-output``.
        The content at ``/asset-output`` will be zipped and used as the
        final asset.

        :default:

        - uploaded as-is to S3 if the asset is a regular file or a .zip file,
        archived into a .zip file and uploaded to S3 otherwise
        '''
        result = self._values.get("bundling")
        return typing.cast(typing.Optional[_BundlingOptions_588cc936], result)

    @builtins.property
    def exclude(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Glob patterns to exclude from the copy.

        :default: - nothing is excluded
        '''
        result = self._values.get("exclude")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def follow_symlinks(self) -> typing.Optional[_SymlinkFollowMode_047ec1f6]:
        '''A strategy for how to handle symlinks.

        :default: SymlinkFollowMode.NEVER
        '''
        result = self._values.get("follow_symlinks")
        return typing.cast(typing.Optional[_SymlinkFollowMode_047ec1f6], result)

    @builtins.property
    def ignore_mode(self) -> typing.Optional[_IgnoreMode_655a98e8]:
        '''The ignore behavior to use for exclude patterns.

        :default: IgnoreMode.GLOB
        '''
        result = self._values.get("ignore_mode")
        return typing.cast(typing.Optional[_IgnoreMode_655a98e8], result)

    @builtins.property
    def readers(self) -> typing.Optional[typing.List[_IGrantable_71c4f5de]]:
        '''A list of principals that should be able to read this asset from S3.

        You can use ``asset.grantRead(principal)`` to grant read permissions later.

        :default: - No principals that can read file asset.
        '''
        result = self._values.get("readers")
        return typing.cast(typing.Optional[typing.List[_IGrantable_71c4f5de]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "InitSourceAssetOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IInterfaceVpcEndpoint)
class InterfaceVpcEndpoint(
    VpcEndpoint,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.InterfaceVpcEndpoint",
):
    '''A interface VPC endpoint.

    :exampleMetadata: infused
    :resource: AWS::EC2::VPCEndpoint

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        # vpc: ec2.Vpc
        
        
        ec2.InterfaceVpcEndpoint(self, "VPC Endpoint",
            vpc=vpc,
            service=ec2.InterfaceVpcEndpointService("com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc", 443),
            # Choose which availability zones to place the VPC endpoint in, based on
            # available AZs
            subnets=ec2.SubnetSelection(
                availability_zones=["us-east-1a", "us-east-1c"]
            )
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        service: IInterfaceVpcEndpointService,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        subnets: typing.Optional[SubnetSelection] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC network in which the interface endpoint will be used.
        :param service: The service to use for this interface VPC endpoint.
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets
        '''
        props = InterfaceVpcEndpointProps(
            vpc=vpc,
            service=service,
            lookup_supported_azs=lookup_supported_azs,
            open=open,
            private_dns_enabled=private_dns_enabled,
            security_groups=security_groups,
            subnets=subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromInterfaceVpcEndpointAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_interface_vpc_endpoint_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        port: jsii.Number,
        vpc_endpoint_id: builtins.str,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
    ) -> IInterfaceVpcEndpoint:
        '''Imports an existing interface VPC endpoint.

        :param scope: -
        :param id: -
        :param port: The port of the service of the interface VPC endpoint.
        :param vpc_endpoint_id: The interface VPC endpoint identifier.
        :param security_groups: The security groups associated with the interface VPC endpoint.
        '''
        attrs = InterfaceVpcEndpointAttributes(
            port=port, vpc_endpoint_id=vpc_endpoint_id, security_groups=security_groups
        )

        return typing.cast(IInterfaceVpcEndpoint, jsii.sinvoke(cls, "fromInterfaceVpcEndpointAttributes", [scope, id, attrs]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> Connections:
        '''Access to network connections.'''
        return typing.cast(Connections, jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointCreationTimestamp")
    def vpc_endpoint_creation_timestamp(self) -> builtins.str:
        '''The date and time the interface VPC endpoint was created.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointCreationTimestamp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointDnsEntries")
    def vpc_endpoint_dns_entries(self) -> typing.List[builtins.str]:
        '''The DNS entries for the interface VPC endpoint.

        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcEndpointDnsEntries"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> builtins.str:
        '''The interface VPC endpoint identifier.'''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointNetworkInterfaceIds")
    def vpc_endpoint_network_interface_ids(self) -> typing.List[builtins.str]:
        '''One or more network interfaces for the interface VPC endpoint.

        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcEndpointNetworkInterfaceIds"))


class MultipartUserData(
    UserData,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.MultipartUserData",
):
    '''Mime multipart user data.

    This class represents MIME multipart user data, as described in.
    `Specifying Multiple User Data Blocks Using a MIME Multi Part Archive <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/bootstrap_container_instance.html#multi-part_user_data>`_

    :exampleMetadata: infused

    Example::

        # Example automatically generated from non-compiling source. May contain errors.
        boot_hook_conf = ec2.UserData.for_linux()
        boot_hook_conf.add_commands("cloud-init-per once docker_options echo 'OPTIONS=\"${OPTIONS} --storage-opt dm.basesize=40G\"' >> /etc/sysconfig/docker")
        
        setup_commands = ec2.UserData.for_linux()
        setup_commands.add_commands("sudo yum install awscli && echo Packages installed ã‚‰ã¨ > /var/tmp/setup")
        
        multipart_user_data = ec2.MultipartUserData()
        # The docker has to be configured at early stage, so content type is overridden to boothook
        multipart_user_data.add_part(ec2.MultipartBody.from_user_data(boot_hook_conf, "text/cloud-boothook; charset=\"us-ascii\""))
        # Execute the rest of setup
        multipart_user_data.add_part(ec2.MultipartBody.from_user_data(setup_commands))
        
        ec2.LaunchTemplate(self, "",
            user_data=multipart_user_data,
            block_devices=[]
        )
    '''

    def __init__(
        self,
        *,
        parts_separator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param parts_separator: The string used to separate parts in multipart user data archive (it's like MIME boundary). This string should contain [a-zA-Z0-9()+,-./:=?] characters only, and should not be present in any part, or in text content of archive. Default: ``+AWS+CDK+User+Data+Separator==``
        '''
        opts = MultipartUserDataOptions(parts_separator=parts_separator)

        jsii.create(self.__class__, self, [opts])

    @jsii.member(jsii_name="addCommands")
    def add_commands(self, *commands: builtins.str) -> None:
        '''Add one or more commands to the user data.

        :param commands: -
        '''
        return typing.cast(None, jsii.invoke(self, "addCommands", [*commands]))

    @jsii.member(jsii_name="addExecuteFileCommand")
    def add_execute_file_command(
        self,
        *,
        file_path: builtins.str,
        arguments: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Adds commands to execute a file.

        :param file_path: The path to the file.
        :param arguments: The arguments to be passed to the file. Default: No arguments are passed to the file.
        '''
        params = ExecuteFileOptions(file_path=file_path, arguments=arguments)

        return typing.cast(None, jsii.invoke(self, "addExecuteFileCommand", [params]))

    @jsii.member(jsii_name="addOnExitCommands")
    def add_on_exit_commands(self, *commands: builtins.str) -> None:
        '''Add one or more commands to the user data that will run when the script exits.

        :param commands: -
        '''
        return typing.cast(None, jsii.invoke(self, "addOnExitCommands", [*commands]))

    @jsii.member(jsii_name="addPart")
    def add_part(self, part: MultipartBody) -> None:
        '''Adds a part to the list of parts.

        :param part: -
        '''
        return typing.cast(None, jsii.invoke(self, "addPart", [part]))

    @jsii.member(jsii_name="addS3DownloadCommand")
    def add_s3_download_command(
        self,
        *,
        bucket: _IBucket_42e086fd,
        bucket_key: builtins.str,
        local_file: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''Adds commands to download a file from S3.

        :param bucket: Name of the S3 bucket to download from.
        :param bucket_key: The key of the file to download.
        :param local_file: The name of the local file. Default: Linux - /tmp/bucketKey Windows - %TEMP%/bucketKey
        :param region: The region of the S3 Bucket (needed for access via VPC Gateway). Default: none
        '''
        params = S3DownloadOptions(
            bucket=bucket, bucket_key=bucket_key, local_file=local_file, region=region
        )

        return typing.cast(builtins.str, jsii.invoke(self, "addS3DownloadCommand", [params]))

    @jsii.member(jsii_name="addSignalOnExitCommand")
    def add_signal_on_exit_command(self, resource: _Resource_45bc6135) -> None:
        '''Adds a command which will send a cfn-signal when the user data script ends.

        :param resource: -
        '''
        return typing.cast(None, jsii.invoke(self, "addSignalOnExitCommand", [resource]))

    @jsii.member(jsii_name="addUserDataPart")
    def add_user_data_part(
        self,
        user_data: UserData,
        content_type: typing.Optional[builtins.str] = None,
        make_default: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''Adds a multipart part based on a UserData object.

        If ``makeDefault`` is true, then the UserData added by this method
        will also be the target of calls to the ``add*Command`` methods on
        this MultipartUserData object.

        If ``makeDefault`` is false, then this is the same as calling::

           # Example automatically generated from non-compiling source. May contain errors.
           # multi_part: ec2.MultipartUserData
           # user_data: ec2.UserData
           # content_type: str


           multi_part.add_part(ec2.MultipartBody.from_user_data(user_data, content_type))

        An undefined ``makeDefault`` defaults to either:

        - ``true`` if no default UserData has been set yet; or
        - ``false`` if there is no default UserData set.

        :param user_data: -
        :param content_type: -
        :param make_default: -
        '''
        return typing.cast(None, jsii.invoke(self, "addUserDataPart", [user_data, content_type, make_default]))

    @jsii.member(jsii_name="render")
    def render(self) -> builtins.str:
        '''Render the UserData for use in a construct.'''
        return typing.cast(builtins.str, jsii.invoke(self, "render", []))


@jsii.implements(IConnectable)
class NatInstanceProvider(
    NatProvider,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.NatInstanceProvider",
):
    '''NAT provider which uses NAT Instances.

    :exampleMetadata: lit=aws-ec2/test/integ.nat-instances.lit.ts infused

    Example::

        # Configure the `natGatewayProvider` when defining a Vpc
        nat_gateway_provider = ec2.NatProvider.instance(
            instance_type=ec2.InstanceType("t3.small")
        )
        
        vpc = ec2.Vpc(self, "MyVpc",
            nat_gateway_provider=nat_gateway_provider,
        
            # The 'natGateways' parameter now controls the number of NAT instances
            nat_gateways=2
        )
    '''

    def __init__(
        self,
        *,
        instance_type: InstanceType,
        default_allowed_traffic: typing.Optional[NatTrafficDirection] = None,
        key_name: typing.Optional[builtins.str] = None,
        machine_image: typing.Optional[IMachineImage] = None,
        security_group: typing.Optional[ISecurityGroup] = None,
    ) -> None:
        '''
        :param instance_type: Instance type of the NAT instance.
        :param default_allowed_traffic: Direction to allow all traffic through the NAT instance by default. By default, inbound and outbound traffic is allowed. If you set this to another value than INBOUND_AND_OUTBOUND, you must configure the NAT instance's security groups in another way, either by passing in a fully configured Security Group using the ``securityGroup`` property, or by configuring it using the ``.securityGroup`` or ``.connections`` members after passing the NAT Instance Provider to a Vpc. Default: NatTrafficDirection.INBOUND_AND_OUTBOUND
        :param key_name: Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param machine_image: The machine image (AMI) to use. By default, will do an AMI lookup for the latest NAT instance image. If you have a specific AMI ID you want to use, pass a ``GenericLinuxImage``. For example:: ec2.NatProvider.instance({ instanceType: new ec2.InstanceType('t3.micro'), machineImage: new ec2.GenericLinuxImage({ 'us-east-2': 'ami-0f9c61b5a562a16af' }) }) Default: - Latest NAT instance image
        :param security_group: Security Group for NAT instances. Default: - A new security group will be created
        '''
        props = NatInstanceProps(
            instance_type=instance_type,
            default_allowed_traffic=default_allowed_traffic,
            key_name=key_name,
            machine_image=machine_image,
            security_group=security_group,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="configureNat")
    def configure_nat(
        self,
        *,
        nat_subnets: typing.Sequence["PublicSubnet"],
        private_subnets: typing.Sequence["PrivateSubnet"],
        vpc: Vpc,
    ) -> None:
        '''Called by the VPC to configure NAT.

        Don't call this directly, the VPC will call it automatically.

        :param nat_subnets: The public subnets where the NAT providers need to be placed.
        :param private_subnets: The private subnets that need to route through the NAT providers. There may be more private subnets than public subnets with NAT providers.
        :param vpc: The VPC we're configuring NAT for.
        '''
        options = ConfigureNatOptions(
            nat_subnets=nat_subnets, private_subnets=private_subnets, vpc=vpc
        )

        return typing.cast(None, jsii.invoke(self, "configureNat", [options]))

    @jsii.member(jsii_name="configureSubnet")
    def configure_subnet(self, subnet: "PrivateSubnet") -> None:
        '''Configures subnet with the gateway.

        Don't call this directly, the VPC will call it automatically.

        :param subnet: -
        '''
        return typing.cast(None, jsii.invoke(self, "configureSubnet", [subnet]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="configuredGateways")
    def configured_gateways(self) -> typing.List[GatewayConfig]:
        '''Return list of gateways spawned by the provider.'''
        return typing.cast(typing.List[GatewayConfig], jsii.get(self, "configuredGateways"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> Connections:
        '''Manage the Security Groups associated with the NAT instances.'''
        return typing.cast(Connections, jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="securityGroup")
    def security_group(self) -> ISecurityGroup:
        '''The Security Group associated with the NAT instances.'''
        return typing.cast(ISecurityGroup, jsii.get(self, "securityGroup"))


@jsii.implements(IPrivateSubnet)
class PrivateSubnet(
    Subnet,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.PrivateSubnet",
):
    '''Represents a private VPC subnet resource.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        private_subnet = ec2.PrivateSubnet(self, "MyPrivateSubnet",
            availability_zone="availabilityZone",
            cidr_block="cidrBlock",
            vpc_id="vpcId",
        
            # the properties below are optional
            map_public_ip_on_launch=False
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param availability_zone: The availability zone for the subnet.
        :param cidr_block: The CIDR notation for this subnet.
        :param vpc_id: The VPC which this subnet is part of.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        props = PrivateSubnetProps(
            availability_zone=availability_zone,
            cidr_block=cidr_block,
            vpc_id=vpc_id,
            map_public_ip_on_launch=map_public_ip_on_launch,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromPrivateSubnetAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_private_subnet_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_id: builtins.str,
        availability_zone: typing.Optional[builtins.str] = None,
        ipv4_cidr_block: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> IPrivateSubnet:
        '''
        :param scope: -
        :param id: -
        :param subnet_id: The subnetId for this particular subnet.
        :param availability_zone: The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features
        :param ipv4_cidr_block: The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features
        :param route_table_id: The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints
        '''
        attrs = PrivateSubnetAttributes(
            subnet_id=subnet_id,
            availability_zone=availability_zone,
            ipv4_cidr_block=ipv4_cidr_block,
            route_table_id=route_table_id,
        )

        return typing.cast(IPrivateSubnet, jsii.sinvoke(cls, "fromPrivateSubnetAttributes", [scope, id, attrs]))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.PrivateSubnetAttributes",
    jsii_struct_bases=[SubnetAttributes],
    name_mapping={
        "subnet_id": "subnetId",
        "availability_zone": "availabilityZone",
        "ipv4_cidr_block": "ipv4CidrBlock",
        "route_table_id": "routeTableId",
    },
)
class PrivateSubnetAttributes(SubnetAttributes):
    def __init__(
        self,
        *,
        subnet_id: builtins.str,
        availability_zone: typing.Optional[builtins.str] = None,
        ipv4_cidr_block: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param subnet_id: The subnetId for this particular subnet.
        :param availability_zone: The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features
        :param ipv4_cidr_block: The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features
        :param route_table_id: The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            private_subnet_attributes = ec2.PrivateSubnetAttributes(
                subnet_id="subnetId",
            
                # the properties below are optional
                availability_zone="availabilityZone",
                ipv4_cidr_block="ipv4CidrBlock",
                route_table_id="routeTableId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_id": subnet_id,
        }
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if ipv4_cidr_block is not None:
            self._values["ipv4_cidr_block"] = ipv4_cidr_block
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The subnetId for this particular subnet.'''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone the subnet is located in.

        :default: - No AZ information, cannot use AZ selection features
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR block associated with the subnet.

        :default: - No CIDR information, cannot use CIDR filter features
        '''
        result = self._values.get("ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table for this particular subnet.

        :default: - No route table information, cannot create VPC endpoints
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateSubnetAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.PrivateSubnetProps",
    jsii_struct_bases=[SubnetProps],
    name_mapping={
        "availability_zone": "availabilityZone",
        "cidr_block": "cidrBlock",
        "vpc_id": "vpcId",
        "map_public_ip_on_launch": "mapPublicIpOnLaunch",
    },
)
class PrivateSubnetProps(SubnetProps):
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param availability_zone: The availability zone for the subnet.
        :param cidr_block: The CIDR notation for this subnet.
        :param vpc_id: The VPC which this subnet is part of.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            private_subnet_props = ec2.PrivateSubnetProps(
                availability_zone="availabilityZone",
                cidr_block="cidrBlock",
                vpc_id="vpcId",
            
                # the properties below are optional
                map_public_ip_on_launch=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
            "cidr_block": cidr_block,
            "vpc_id": vpc_id,
        }
        if map_public_ip_on_launch is not None:
            self._values["map_public_ip_on_launch"] = map_public_ip_on_launch

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The availability zone for the subnet.'''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidr_block(self) -> builtins.str:
        '''The CIDR notation for this subnet.'''
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The VPC which this subnet is part of.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def map_public_ip_on_launch(self) -> typing.Optional[builtins.bool]:
        '''Controls if a public IP is associated to an instance at launch.

        :default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        result = self._values.get("map_public_ip_on_launch")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateSubnetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IPublicSubnet)
class PublicSubnet(
    Subnet,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.PublicSubnet",
):
    '''Represents a public VPC subnet resource.

    :exampleMetadata: fixture=_generated

    Example::

        # The code below shows an example of how to instantiate this type.
        # The values are placeholders you should change.
        from aws_cdk import aws_ec2 as ec2
        
        public_subnet = ec2.PublicSubnet(self, "MyPublicSubnet",
            availability_zone="availabilityZone",
            cidr_block="cidrBlock",
            vpc_id="vpcId",
        
            # the properties below are optional
            map_public_ip_on_launch=False
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        availability_zone: builtins.str,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param availability_zone: The availability zone for the subnet.
        :param cidr_block: The CIDR notation for this subnet.
        :param vpc_id: The VPC which this subnet is part of.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        props = PublicSubnetProps(
            availability_zone=availability_zone,
            cidr_block=cidr_block,
            vpc_id=vpc_id,
            map_public_ip_on_launch=map_public_ip_on_launch,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromPublicSubnetAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_public_subnet_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        subnet_id: builtins.str,
        availability_zone: typing.Optional[builtins.str] = None,
        ipv4_cidr_block: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> IPublicSubnet:
        '''
        :param scope: -
        :param id: -
        :param subnet_id: The subnetId for this particular subnet.
        :param availability_zone: The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features
        :param ipv4_cidr_block: The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features
        :param route_table_id: The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints
        '''
        attrs = PublicSubnetAttributes(
            subnet_id=subnet_id,
            availability_zone=availability_zone,
            ipv4_cidr_block=ipv4_cidr_block,
            route_table_id=route_table_id,
        )

        return typing.cast(IPublicSubnet, jsii.sinvoke(cls, "fromPublicSubnetAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="addNatGateway")
    def add_nat_gateway(
        self,
        eip_allocation_id: typing.Optional[builtins.str] = None,
    ) -> CfnNatGateway:
        '''Creates a new managed NAT gateway attached to this public subnet.

        Also adds the EIP for the managed NAT.

        :param eip_allocation_id: -

        :return: A ref to the the NAT Gateway ID
        '''
        return typing.cast(CfnNatGateway, jsii.invoke(self, "addNatGateway", [eip_allocation_id]))


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.PublicSubnetAttributes",
    jsii_struct_bases=[SubnetAttributes],
    name_mapping={
        "subnet_id": "subnetId",
        "availability_zone": "availabilityZone",
        "ipv4_cidr_block": "ipv4CidrBlock",
        "route_table_id": "routeTableId",
    },
)
class PublicSubnetAttributes(SubnetAttributes):
    def __init__(
        self,
        *,
        subnet_id: builtins.str,
        availability_zone: typing.Optional[builtins.str] = None,
        ipv4_cidr_block: typing.Optional[builtins.str] = None,
        route_table_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param subnet_id: The subnetId for this particular subnet.
        :param availability_zone: The Availability Zone the subnet is located in. Default: - No AZ information, cannot use AZ selection features
        :param ipv4_cidr_block: The IPv4 CIDR block associated with the subnet. Default: - No CIDR information, cannot use CIDR filter features
        :param route_table_id: The ID of the route table for this particular subnet. Default: - No route table information, cannot create VPC endpoints

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            public_subnet_attributes = ec2.PublicSubnetAttributes(
                subnet_id="subnetId",
            
                # the properties below are optional
                availability_zone="availabilityZone",
                ipv4_cidr_block="ipv4CidrBlock",
                route_table_id="routeTableId"
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "subnet_id": subnet_id,
        }
        if availability_zone is not None:
            self._values["availability_zone"] = availability_zone
        if ipv4_cidr_block is not None:
            self._values["ipv4_cidr_block"] = ipv4_cidr_block
        if route_table_id is not None:
            self._values["route_table_id"] = route_table_id

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The subnetId for this particular subnet.'''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def availability_zone(self) -> typing.Optional[builtins.str]:
        '''The Availability Zone the subnet is located in.

        :default: - No AZ information, cannot use AZ selection features
        '''
        result = self._values.get("availability_zone")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ipv4_cidr_block(self) -> typing.Optional[builtins.str]:
        '''The IPv4 CIDR block associated with the subnet.

        :default: - No CIDR information, cannot use CIDR filter features
        '''
        result = self._values.get("ipv4_cidr_block")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def route_table_id(self) -> typing.Optional[builtins.str]:
        '''The ID of the route table for this particular subnet.

        :default: - No route table information, cannot create VPC endpoints
        '''
        result = self._values.get("route_table_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicSubnetAttributes(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="aws-cdk-lib.aws_ec2.PublicSubnetProps",
    jsii_struct_bases=[SubnetProps],
    name_mapping={
        "availability_zone": "availabilityZone",
        "cidr_block": "cidrBlock",
        "vpc_id": "vpcId",
        "map_public_ip_on_launch": "mapPublicIpOnLaunch",
    },
)
class PublicSubnetProps(SubnetProps):
    def __init__(
        self,
        *,
        availability_zone: builtins.str,
        cidr_block: builtins.str,
        vpc_id: builtins.str,
        map_public_ip_on_launch: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param availability_zone: The availability zone for the subnet.
        :param cidr_block: The CIDR notation for this subnet.
        :param vpc_id: The VPC which this subnet is part of.
        :param map_public_ip_on_launch: Controls if a public IP is associated to an instance at launch. Default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.

        :exampleMetadata: fixture=_generated

        Example::

            # The code below shows an example of how to instantiate this type.
            # The values are placeholders you should change.
            from aws_cdk import aws_ec2 as ec2
            
            public_subnet_props = ec2.PublicSubnetProps(
                availability_zone="availabilityZone",
                cidr_block="cidrBlock",
                vpc_id="vpcId",
            
                # the properties below are optional
                map_public_ip_on_launch=False
            )
        '''
        self._values: typing.Dict[str, typing.Any] = {
            "availability_zone": availability_zone,
            "cidr_block": cidr_block,
            "vpc_id": vpc_id,
        }
        if map_public_ip_on_launch is not None:
            self._values["map_public_ip_on_launch"] = map_public_ip_on_launch

    @builtins.property
    def availability_zone(self) -> builtins.str:
        '''The availability zone for the subnet.'''
        result = self._values.get("availability_zone")
        assert result is not None, "Required property 'availability_zone' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cidr_block(self) -> builtins.str:
        '''The CIDR notation for this subnet.'''
        result = self._values.get("cidr_block")
        assert result is not None, "Required property 'cidr_block' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The VPC which this subnet is part of.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def map_public_ip_on_launch(self) -> typing.Optional[builtins.bool]:
        '''Controls if a public IP is associated to an instance at launch.

        :default: true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.
        '''
        result = self._values.get("map_public_ip_on_launch")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PublicSubnetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class WindowsImage(
    GenericSSMParameterImage,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.WindowsImage",
):
    '''Select the latest version of the indicated Windows version.

    This Machine Image automatically updates to the latest version on every
    deployment. Be aware this will cause your instances to be replaced when a
    new version of the image becomes available. Do not store stateful information
    on the instance if you are using this image.

    The AMI ID is selected using the values published to the SSM parameter store.

    https://aws.amazon.com/blogs/mt/query-for-the-latest-windows-ami-using-systems-manager-parameter-store/

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    def __init__(
        self,
        version: WindowsVersion,
        *,
        user_data: typing.Optional[UserData] = None,
    ) -> None:
        '''
        :param version: -
        :param user_data: Initial user data. Default: - Empty UserData for Windows machines
        '''
        props = WindowsImageProps(user_data=user_data)

        jsii.create(self.__class__, self, [version, props])


class AmazonLinuxImage(
    GenericSSMParameterImage,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.AmazonLinuxImage",
):
    '''Selects the latest version of Amazon Linux.

    This Machine Image automatically updates to the latest version on every
    deployment. Be aware this will cause your instances to be replaced when a
    new version of the image becomes available. Do not store stateful information
    on the instance if you are using this image.

    The AMI ID is selected using the values published to the SSM parameter store.

    :exampleMetadata: lit=aws-autoscaling/test/example.images.lit.ts infused

    Example::

        # Pick a Windows edition to use
        windows = ec2.WindowsImage(ec2.WindowsVersion.WINDOWS_SERVER_2019_ENGLISH_FULL_BASE)
        
        # Pick the right Amazon Linux edition. All arguments shown are optional
        # and will default to these values when omitted.
        amzn_linux = ec2.AmazonLinuxImage(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
        )
        
        # For other custom (Linux) images, instantiate a `GenericLinuxImage` with
        # a map giving the AMI to in for each region:
        
        linux = ec2.GenericLinuxImage({
            "us-east-1": "ami-97785bed",
            "eu-west-1": "ami-12345678"
        })
    '''

    def __init__(
        self,
        *,
        cached_in_context: typing.Optional[builtins.bool] = None,
        cpu_type: typing.Optional[AmazonLinuxCpuType] = None,
        edition: typing.Optional[AmazonLinuxEdition] = None,
        generation: typing.Optional[AmazonLinuxGeneration] = None,
        kernel: typing.Optional[AmazonLinuxKernel] = None,
        storage: typing.Optional[AmazonLinuxStorage] = None,
        user_data: typing.Optional[UserData] = None,
        virtualization: typing.Optional[AmazonLinuxVirt] = None,
    ) -> None:
        '''
        :param cached_in_context: Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false
        :param cpu_type: CPU Type. Default: X86_64
        :param edition: What edition of Amazon Linux to use. Default: Standard
        :param generation: What generation of Amazon Linux to use. Default: AmazonLinux
        :param kernel: What kernel version of Amazon Linux to use. Default: -
        :param storage: What storage backed image to use. Default: GeneralPurpose
        :param user_data: Initial user data. Default: - Empty UserData for Linux machines
        :param virtualization: Virtualization type. Default: HVM
        '''
        props = AmazonLinuxImageProps(
            cached_in_context=cached_in_context,
            cpu_type=cpu_type,
            edition=edition,
            generation=generation,
            kernel=kernel,
            storage=storage,
            user_data=user_data,
            virtualization=virtualization,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="ssmParameterName") # type: ignore[misc]
    @builtins.classmethod
    def ssm_parameter_name(
        cls,
        *,
        cached_in_context: typing.Optional[builtins.bool] = None,
        cpu_type: typing.Optional[AmazonLinuxCpuType] = None,
        edition: typing.Optional[AmazonLinuxEdition] = None,
        generation: typing.Optional[AmazonLinuxGeneration] = None,
        kernel: typing.Optional[AmazonLinuxKernel] = None,
        storage: typing.Optional[AmazonLinuxStorage] = None,
        user_data: typing.Optional[UserData] = None,
        virtualization: typing.Optional[AmazonLinuxVirt] = None,
    ) -> builtins.str:
        '''Return the SSM parameter name that will contain the Amazon Linux image with the given attributes.

        :param cached_in_context: Whether the AMI ID is cached to be stable between deployments. By default, the newest image is used on each deployment. This will cause instances to be replaced whenever a new version is released, and may cause downtime if there aren't enough running instances in the AutoScalingGroup to reschedule the tasks on. If set to true, the AMI ID will be cached in ``cdk.context.json`` and the same value will be used on future runs. Your instances will not be replaced but your AMI version will grow old over time. To refresh the AMI lookup, you will have to evict the value from the cache using the ``cdk context`` command. See https://docs.aws.amazon.com/cdk/latest/guide/context.html for more information. Can not be set to ``true`` in environment-agnostic stacks. Default: false
        :param cpu_type: CPU Type. Default: X86_64
        :param edition: What edition of Amazon Linux to use. Default: Standard
        :param generation: What generation of Amazon Linux to use. Default: AmazonLinux
        :param kernel: What kernel version of Amazon Linux to use. Default: -
        :param storage: What storage backed image to use. Default: GeneralPurpose
        :param user_data: Initial user data. Default: - Empty UserData for Linux machines
        :param virtualization: Virtualization type. Default: HVM
        '''
        props = AmazonLinuxImageProps(
            cached_in_context=cached_in_context,
            cpu_type=cpu_type,
            edition=edition,
            generation=generation,
            kernel=kernel,
            storage=storage,
            user_data=user_data,
            virtualization=virtualization,
        )

        return typing.cast(builtins.str, jsii.sinvoke(cls, "ssmParameterName", [props]))

    @jsii.member(jsii_name="getImage")
    def get_image(self, scope: constructs.Construct) -> MachineImageConfig:
        '''Return the image to use in the given context.

        :param scope: -
        '''
        return typing.cast(MachineImageConfig, jsii.invoke(self, "getImage", [scope]))


@jsii.implements(IClientVpnEndpoint)
class ClientVpnEndpoint(
    _Resource_45bc6135,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.ClientVpnEndpoint",
):
    '''A client VPN connnection.

    :exampleMetadata: fixture=client-vpn infused

    Example::

        endpoint = vpc.add_client_vpn_endpoint("Endpoint",
            cidr="10.100.0.0/16",
            server_certificate_arn="arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id",
            user_based_authentication=ec2.ClientVpnUserBasedAuthentication.federated(saml_provider),
            authorize_all_users_to_vpc_cidr=False
        )
        
        endpoint.add_authorization_rule("Rule",
            cidr="10.0.10.0/32",
            group_id="group-id"
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        cidr: builtins.str,
        server_certificate_arn: builtins.str,
        authorize_all_users_to_vpc_cidr: typing.Optional[builtins.bool] = None,
        client_certificate_arn: typing.Optional[builtins.str] = None,
        client_connection_handler: typing.Optional[IClientVpnConnectionHandler] = None,
        client_login_banner: typing.Optional[builtins.str] = None,
        description: typing.Optional[builtins.str] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        logging: typing.Optional[builtins.bool] = None,
        log_group: typing.Optional[_ILogGroup_3c4fa718] = None,
        log_stream: typing.Optional[_ILogStream_dcfca8c2] = None,
        port: typing.Optional[VpnPort] = None,
        security_groups: typing.Optional[typing.Sequence[ISecurityGroup]] = None,
        self_service_portal: typing.Optional[builtins.bool] = None,
        session_timeout: typing.Optional[ClientVpnSessionTimeout] = None,
        split_tunnel: typing.Optional[builtins.bool] = None,
        transport_protocol: typing.Optional[TransportProtocol] = None,
        user_based_authentication: typing.Optional[ClientVpnUserBasedAuthentication] = None,
        vpc_subnets: typing.Optional[SubnetSelection] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC to connect to.
        :param cidr: The IPv4 address range, in CIDR notation, from which to assign client IP addresses. The address range cannot overlap with the local CIDR of the VPC in which the associated subnet is located, or the routes that you add manually. Changing the address range will replace the Client VPN endpoint. The CIDR block should be /22 or greater.
        :param server_certificate_arn: The ARN of the server certificate.
        :param authorize_all_users_to_vpc_cidr: Whether to authorize all users to the VPC CIDR. This automatically creates an authorization rule. Set this to ``false`` and use ``addAuthorizationRule()`` to create your own rules instead. Default: true
        :param client_certificate_arn: The ARN of the client certificate for mutual authentication. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM). Default: - use user-based authentication
        :param client_connection_handler: The AWS Lambda function used for connection authorization. The name of the Lambda function must begin with the ``AWSClientVPN-`` prefix Default: - no connection handler
        :param client_login_banner: Customizable text that will be displayed in a banner on AWS provided clients when a VPN session is established. UTF-8 encoded characters only. Maximum of 1400 characters. Default: - no banner is presented to the client
        :param description: A brief description of the Client VPN endpoint. Default: - no description
        :param dns_servers: Information about the DNS servers to be used for DNS resolution. A Client VPN endpoint can have up to two DNS servers. Default: - use the DNS address configured on the device
        :param logging: Whether to enable connections logging. Default: true
        :param log_group: A CloudWatch Logs log group for connection logging. Default: - a new group is created
        :param log_stream: A CloudWatch Logs log stream for connection logging. Default: - a new stream is created
        :param port: The port number to assign to the Client VPN endpoint for TCP and UDP traffic. Default: VpnPort.HTTPS
        :param security_groups: The security groups to apply to the target network. Default: - a new security group is created
        :param self_service_portal: Specify whether to enable the self-service portal for the Client VPN endpoint. Default: true
        :param session_timeout: The maximum VPN session duration time. Default: ClientVpnSessionTimeout.TWENTY_FOUR_HOURS
        :param split_tunnel: Indicates whether split-tunnel is enabled on the AWS Client VPN endpoint. Default: false
        :param transport_protocol: The transport protocol to be used by the VPN session. Default: TransportProtocol.UDP
        :param user_based_authentication: The type of user-based authentication to use. Default: - use mutual authentication
        :param vpc_subnets: Subnets to associate to the client VPN endpoint. Default: - the VPC default strategy
        '''
        props = ClientVpnEndpointProps(
            vpc=vpc,
            cidr=cidr,
            server_certificate_arn=server_certificate_arn,
            authorize_all_users_to_vpc_cidr=authorize_all_users_to_vpc_cidr,
            client_certificate_arn=client_certificate_arn,
            client_connection_handler=client_connection_handler,
            client_login_banner=client_login_banner,
            description=description,
            dns_servers=dns_servers,
            logging=logging,
            log_group=log_group,
            log_stream=log_stream,
            port=port,
            security_groups=security_groups,
            self_service_portal=self_service_portal,
            session_timeout=session_timeout,
            split_tunnel=split_tunnel,
            transport_protocol=transport_protocol,
            user_based_authentication=user_based_authentication,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromEndpointAttributes") # type: ignore[misc]
    @builtins.classmethod
    def from_endpoint_attributes(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        endpoint_id: builtins.str,
        security_groups: typing.Sequence[ISecurityGroup],
    ) -> IClientVpnEndpoint:
        '''Import an existing client VPN endpoint.

        :param scope: -
        :param id: -
        :param endpoint_id: The endpoint ID.
        :param security_groups: The security groups associated with the endpoint.
        '''
        attrs = ClientVpnEndpointAttributes(
            endpoint_id=endpoint_id, security_groups=security_groups
        )

        return typing.cast(IClientVpnEndpoint, jsii.sinvoke(cls, "fromEndpointAttributes", [scope, id, attrs]))

    @jsii.member(jsii_name="addAuthorizationRule")
    def add_authorization_rule(
        self,
        id: builtins.str,
        *,
        cidr: builtins.str,
        description: typing.Optional[builtins.str] = None,
        group_id: typing.Optional[builtins.str] = None,
    ) -> ClientVpnAuthorizationRule:
        '''Adds an authorization rule to this endpoint.

        :param id: -
        :param cidr: The IPv4 address range, in CIDR notation, of the network for which access is being authorized.
        :param description: A brief description of the authorization rule. Default: - no description
        :param group_id: The ID of the group to grant access to, for example, the Active Directory group or identity provider (IdP) group. Default: - authorize all groups
        '''
        props = ClientVpnAuthorizationRuleOptions(
            cidr=cidr, description=description, group_id=group_id
        )

        return typing.cast(ClientVpnAuthorizationRule, jsii.invoke(self, "addAuthorizationRule", [id, props]))

    @jsii.member(jsii_name="addRoute")
    def add_route(
        self,
        id: builtins.str,
        *,
        cidr: builtins.str,
        target: ClientVpnRouteTarget,
        description: typing.Optional[builtins.str] = None,
    ) -> ClientVpnRoute:
        '''Adds a route to this endpoint.

        :param id: -
        :param cidr: The IPv4 address range, in CIDR notation, of the route destination. For example: - To add a route for Internet access, enter 0.0.0.0/0 - To add a route for a peered VPC, enter the peered VPC's IPv4 CIDR range - To add a route for an on-premises network, enter the AWS Site-to-Site VPN connection's IPv4 CIDR range - To add a route for the local network, enter the client CIDR range
        :param target: The target for the route.
        :param description: A brief description of the authorization rule. Default: - no description
        '''
        props = ClientVpnRouteOptions(
            cidr=cidr, target=target, description=description
        )

        return typing.cast(ClientVpnRoute, jsii.invoke(self, "addRoute", [id, props]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="connections")
    def connections(self) -> Connections:
        '''Allows specify security group connections for the endpoint.'''
        return typing.cast(Connections, jsii.get(self, "connections"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="endpointId")
    def endpoint_id(self) -> builtins.str:
        '''The endpoint ID.'''
        return typing.cast(builtins.str, jsii.get(self, "endpointId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="targetNetworksAssociated")
    def target_networks_associated(self) -> constructs.IDependable:
        '''Dependable that can be depended upon to force target networks associations.'''
        return typing.cast(constructs.IDependable, jsii.get(self, "targetNetworksAssociated"))


@jsii.implements(IGatewayVpcEndpoint)
class GatewayVpcEndpoint(
    VpcEndpoint,
    metaclass=jsii.JSIIMeta,
    jsii_type="aws-cdk-lib.aws_ec2.GatewayVpcEndpoint",
):
    '''A gateway VPC endpoint.

    :exampleMetadata: lit=aws-ec2/test/integ.vpc-endpoint.lit.ts infused
    :resource: AWS::EC2::VPCEndpoint

    Example::

        # Add gateway endpoints when creating the VPC
        vpc = ec2.Vpc(self, "MyVpc",
            gateway_endpoints={
                "S3": cdk.aws_ec2.GatewayVpcEndpointOptions(
                    service=ec2.GatewayVpcEndpointAwsService.S3
                )
            }
        )
        
        # Alternatively gateway endpoints can be added on the VPC
        dynamo_db_endpoint = vpc.add_gateway_endpoint("DynamoDbEndpoint",
            service=ec2.GatewayVpcEndpointAwsService.DYNAMODB
        )
        
        # This allows to customize the endpoint policy
        dynamo_db_endpoint.add_to_policy(
            iam.PolicyStatement( # Restrict to listing and describing tables
                principals=[iam.AnyPrincipal()],
                actions=["dynamodb:DescribeTable", "dynamodb:ListTables"],
                resources=["*"]))
        
        # Add an interface endpoint
        vpc.add_interface_endpoint("EcrDockerEndpoint",
            service=ec2.InterfaceVpcEndpointAwsService.ECR_DOCKER
        )
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        vpc: IVpc,
        service: IGatewayVpcEndpointService,
        subnets: typing.Optional[typing.Sequence[SubnetSelection]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC network in which the gateway endpoint will be used.
        :param service: The service to use for this gateway VPC endpoint.
        :param subnets: Where to add endpoint routing. By default, this endpoint will be routable from all subnets in the VPC. Specify a list of subnet selection objects here to be more specific. Default: - All subnets in the VPC
        '''
        props = GatewayVpcEndpointProps(vpc=vpc, service=service, subnets=subnets)

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="fromGatewayVpcEndpointId") # type: ignore[misc]
    @builtins.classmethod
    def from_gateway_vpc_endpoint_id(
        cls,
        scope: constructs.Construct,
        id: builtins.str,
        gateway_vpc_endpoint_id: builtins.str,
    ) -> IGatewayVpcEndpoint:
        '''
        :param scope: -
        :param id: -
        :param gateway_vpc_endpoint_id: -
        '''
        return typing.cast(IGatewayVpcEndpoint, jsii.sinvoke(cls, "fromGatewayVpcEndpointId", [scope, id, gateway_vpc_endpoint_id]))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointCreationTimestamp")
    def vpc_endpoint_creation_timestamp(self) -> builtins.str:
        '''The date and time the gateway VPC endpoint was created.

        :attribute: true
        '''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointCreationTimestamp"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointDnsEntries")
    def vpc_endpoint_dns_entries(self) -> typing.List[builtins.str]:
        '''
        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcEndpointDnsEntries"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointId")
    def vpc_endpoint_id(self) -> builtins.str:
        '''The gateway VPC endpoint identifier.'''
        return typing.cast(builtins.str, jsii.get(self, "vpcEndpointId"))

    @builtins.property # type: ignore[misc]
    @jsii.member(jsii_name="vpcEndpointNetworkInterfaceIds")
    def vpc_endpoint_network_interface_ids(self) -> typing.List[builtins.str]:
        '''
        :attribute: true
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "vpcEndpointNetworkInterfaceIds"))


__all__ = [
    "AclCidr",
    "AclCidrConfig",
    "AclIcmp",
    "AclPortRange",
    "AclTraffic",
    "AclTrafficConfig",
    "Action",
    "AddRouteOptions",
    "AmazonLinuxCpuType",
    "AmazonLinuxEdition",
    "AmazonLinuxGeneration",
    "AmazonLinuxImage",
    "AmazonLinuxImageProps",
    "AmazonLinuxKernel",
    "AmazonLinuxStorage",
    "AmazonLinuxVirt",
    "ApplyCloudFormationInitOptions",
    "AttachInitOptions",
    "BastionHostLinux",
    "BastionHostLinuxProps",
    "BlockDevice",
    "BlockDeviceVolume",
    "CfnCapacityReservation",
    "CfnCapacityReservationFleet",
    "CfnCapacityReservationFleetProps",
    "CfnCapacityReservationProps",
    "CfnCarrierGateway",
    "CfnCarrierGatewayProps",
    "CfnClientVpnAuthorizationRule",
    "CfnClientVpnAuthorizationRuleProps",
    "CfnClientVpnEndpoint",
    "CfnClientVpnEndpointProps",
    "CfnClientVpnRoute",
    "CfnClientVpnRouteProps",
    "CfnClientVpnTargetNetworkAssociation",
    "CfnClientVpnTargetNetworkAssociationProps",
    "CfnCustomerGateway",
    "CfnCustomerGatewayProps",
    "CfnDHCPOptions",
    "CfnDHCPOptionsProps",
    "CfnEC2Fleet",
    "CfnEC2FleetProps",
    "CfnEIP",
    "CfnEIPAssociation",
    "CfnEIPAssociationProps",
    "CfnEIPProps",
    "CfnEgressOnlyInternetGateway",
    "CfnEgressOnlyInternetGatewayProps",
    "CfnEnclaveCertificateIamRoleAssociation",
    "CfnEnclaveCertificateIamRoleAssociationProps",
    "CfnFlowLog",
    "CfnFlowLogProps",
    "CfnGatewayRouteTableAssociation",
    "CfnGatewayRouteTableAssociationProps",
    "CfnHost",
    "CfnHostProps",
    "CfnIPAM",
    "CfnIPAMAllocation",
    "CfnIPAMAllocationProps",
    "CfnIPAMPool",
    "CfnIPAMPoolProps",
    "CfnIPAMProps",
    "CfnIPAMScope",
    "CfnIPAMScopeProps",
    "CfnInstance",
    "CfnInstanceProps",
    "CfnInternetGateway",
    "CfnInternetGatewayProps",
    "CfnLaunchTemplate",
    "CfnLaunchTemplateProps",
    "CfnLocalGatewayRoute",
    "CfnLocalGatewayRouteProps",
    "CfnLocalGatewayRouteTableVPCAssociation",
    "CfnLocalGatewayRouteTableVPCAssociationProps",
    "CfnNatGateway",
    "CfnNatGatewayProps",
    "CfnNetworkAcl",
    "CfnNetworkAclEntry",
    "CfnNetworkAclEntryProps",
    "CfnNetworkAclProps",
    "CfnNetworkInsightsAccessScope",
    "CfnNetworkInsightsAccessScopeAnalysis",
    "CfnNetworkInsightsAccessScopeAnalysisProps",
    "CfnNetworkInsightsAccessScopeProps",
    "CfnNetworkInsightsAnalysis",
    "CfnNetworkInsightsAnalysisProps",
    "CfnNetworkInsightsPath",
    "CfnNetworkInsightsPathProps",
    "CfnNetworkInterface",
    "CfnNetworkInterfaceAttachment",
    "CfnNetworkInterfaceAttachmentProps",
    "CfnNetworkInterfacePermission",
    "CfnNetworkInterfacePermissionProps",
    "CfnNetworkInterfaceProps",
    "CfnPlacementGroup",
    "CfnPlacementGroupProps",
    "CfnPrefixList",
    "CfnPrefixListProps",
    "CfnRoute",
    "CfnRouteProps",
    "CfnRouteTable",
    "CfnRouteTableProps",
    "CfnSecurityGroup",
    "CfnSecurityGroupEgress",
    "CfnSecurityGroupEgressProps",
    "CfnSecurityGroupIngress",
    "CfnSecurityGroupIngressProps",
    "CfnSecurityGroupProps",
    "CfnSpotFleet",
    "CfnSpotFleetProps",
    "CfnSubnet",
    "CfnSubnetCidrBlock",
    "CfnSubnetCidrBlockProps",
    "CfnSubnetNetworkAclAssociation",
    "CfnSubnetNetworkAclAssociationProps",
    "CfnSubnetProps",
    "CfnSubnetRouteTableAssociation",
    "CfnSubnetRouteTableAssociationProps",
    "CfnTrafficMirrorFilter",
    "CfnTrafficMirrorFilterProps",
    "CfnTrafficMirrorFilterRule",
    "CfnTrafficMirrorFilterRuleProps",
    "CfnTrafficMirrorSession",
    "CfnTrafficMirrorSessionProps",
    "CfnTrafficMirrorTarget",
    "CfnTrafficMirrorTargetProps",
    "CfnTransitGateway",
    "CfnTransitGatewayAttachment",
    "CfnTransitGatewayAttachmentProps",
    "CfnTransitGatewayConnect",
    "CfnTransitGatewayConnectProps",
    "CfnTransitGatewayMulticastDomain",
    "CfnTransitGatewayMulticastDomainAssociation",
    "CfnTransitGatewayMulticastDomainAssociationProps",
    "CfnTransitGatewayMulticastDomainProps",
    "CfnTransitGatewayMulticastGroupMember",
    "CfnTransitGatewayMulticastGroupMemberProps",
    "CfnTransitGatewayMulticastGroupSource",
    "CfnTransitGatewayMulticastGroupSourceProps",
    "CfnTransitGatewayPeeringAttachment",
    "CfnTransitGatewayPeeringAttachmentProps",
    "CfnTransitGatewayProps",
    "CfnTransitGatewayRoute",
    "CfnTransitGatewayRouteProps",
    "CfnTransitGatewayRouteTable",
    "CfnTransitGatewayRouteTableAssociation",
    "CfnTransitGatewayRouteTableAssociationProps",
    "CfnTransitGatewayRouteTablePropagation",
    "CfnTransitGatewayRouteTablePropagationProps",
    "CfnTransitGatewayRouteTableProps",
    "CfnTransitGatewayVpcAttachment",
    "CfnTransitGatewayVpcAttachmentProps",
    "CfnVPC",
    "CfnVPCCidrBlock",
    "CfnVPCCidrBlockProps",
    "CfnVPCDHCPOptionsAssociation",
    "CfnVPCDHCPOptionsAssociationProps",
    "CfnVPCEndpoint",
    "CfnVPCEndpointConnectionNotification",
    "CfnVPCEndpointConnectionNotificationProps",
    "CfnVPCEndpointProps",
    "CfnVPCEndpointService",
    "CfnVPCEndpointServicePermissions",
    "CfnVPCEndpointServicePermissionsProps",
    "CfnVPCEndpointServiceProps",
    "CfnVPCGatewayAttachment",
    "CfnVPCGatewayAttachmentProps",
    "CfnVPCPeeringConnection",
    "CfnVPCPeeringConnectionProps",
    "CfnVPCProps",
    "CfnVPNConnection",
    "CfnVPNConnectionProps",
    "CfnVPNConnectionRoute",
    "CfnVPNConnectionRouteProps",
    "CfnVPNGateway",
    "CfnVPNGatewayProps",
    "CfnVPNGatewayRoutePropagation",
    "CfnVPNGatewayRoutePropagationProps",
    "CfnVolume",
    "CfnVolumeAttachment",
    "CfnVolumeAttachmentProps",
    "CfnVolumeProps",
    "ClientVpnAuthorizationRule",
    "ClientVpnAuthorizationRuleOptions",
    "ClientVpnAuthorizationRuleProps",
    "ClientVpnEndpoint",
    "ClientVpnEndpointAttributes",
    "ClientVpnEndpointOptions",
    "ClientVpnEndpointProps",
    "ClientVpnRoute",
    "ClientVpnRouteOptions",
    "ClientVpnRouteProps",
    "ClientVpnRouteTarget",
    "ClientVpnSessionTimeout",
    "ClientVpnUserBasedAuthentication",
    "CloudFormationInit",
    "CommonNetworkAclEntryOptions",
    "ConfigSetProps",
    "ConfigureNatOptions",
    "ConnectionRule",
    "Connections",
    "ConnectionsProps",
    "CpuCredits",
    "DefaultInstanceTenancy",
    "EbsDeviceOptions",
    "EbsDeviceOptionsBase",
    "EbsDeviceProps",
    "EbsDeviceSnapshotOptions",
    "EbsDeviceVolumeType",
    "EnableVpnGatewayOptions",
    "ExecuteFileOptions",
    "FlowLog",
    "FlowLogDestination",
    "FlowLogDestinationConfig",
    "FlowLogDestinationType",
    "FlowLogOptions",
    "FlowLogProps",
    "FlowLogResourceType",
    "FlowLogTrafficType",
    "GatewayConfig",
    "GatewayVpcEndpoint",
    "GatewayVpcEndpointAwsService",
    "GatewayVpcEndpointOptions",
    "GatewayVpcEndpointProps",
    "GenericLinuxImage",
    "GenericLinuxImageProps",
    "GenericSSMParameterImage",
    "GenericWindowsImage",
    "GenericWindowsImageProps",
    "IClientVpnConnectionHandler",
    "IClientVpnEndpoint",
    "IConnectable",
    "IFlowLog",
    "IGatewayVpcEndpoint",
    "IGatewayVpcEndpointService",
    "IInstance",
    "IInterfaceVpcEndpoint",
    "IInterfaceVpcEndpointService",
    "ILaunchTemplate",
    "IMachineImage",
    "INetworkAcl",
    "INetworkAclEntry",
    "IPeer",
    "IPrivateSubnet",
    "IPublicSubnet",
    "IRouteTable",
    "ISecurityGroup",
    "ISubnet",
    "ISubnetNetworkAclAssociation",
    "IVolume",
    "IVpc",
    "IVpcEndpoint",
    "IVpcEndpointService",
    "IVpcEndpointServiceLoadBalancer",
    "IVpnConnection",
    "IVpnGateway",
    "InitCommand",
    "InitCommandOptions",
    "InitCommandWaitDuration",
    "InitConfig",
    "InitElement",
    "InitFile",
    "InitFileAssetOptions",
    "InitFileOptions",
    "InitGroup",
    "InitPackage",
    "InitService",
    "InitServiceOptions",
    "InitServiceRestartHandle",
    "InitSource",
    "InitSourceAssetOptions",
    "InitSourceOptions",
    "InitUser",
    "InitUserOptions",
    "Instance",
    "InstanceArchitecture",
    "InstanceClass",
    "InstanceInitiatedShutdownBehavior",
    "InstanceProps",
    "InstanceRequireImdsv2Aspect",
    "InstanceRequireImdsv2AspectProps",
    "InstanceSize",
    "InstanceType",
    "InterfaceVpcEndpoint",
    "InterfaceVpcEndpointAttributes",
    "InterfaceVpcEndpointAwsService",
    "InterfaceVpcEndpointOptions",
    "InterfaceVpcEndpointProps",
    "InterfaceVpcEndpointService",
    "LaunchTemplate",
    "LaunchTemplateAttributes",
    "LaunchTemplateProps",
    "LaunchTemplateRequireImdsv2Aspect",
    "LaunchTemplateRequireImdsv2AspectProps",
    "LaunchTemplateSpecialVersions",
    "LaunchTemplateSpotOptions",
    "LinuxUserDataOptions",
    "LocationPackageOptions",
    "LookupMachineImage",
    "LookupMachineImageProps",
    "MachineImage",
    "MachineImageConfig",
    "MultipartBody",
    "MultipartBodyOptions",
    "MultipartUserData",
    "MultipartUserDataOptions",
    "NamedPackageOptions",
    "NatGatewayProps",
    "NatInstanceImage",
    "NatInstanceProps",
    "NatInstanceProvider",
    "NatProvider",
    "NatTrafficDirection",
    "NetworkAcl",
    "NetworkAclEntry",
    "NetworkAclEntryProps",
    "NetworkAclProps",
    "OperatingSystemType",
    "Peer",
    "Port",
    "PortProps",
    "PrivateSubnet",
    "PrivateSubnetAttributes",
    "PrivateSubnetProps",
    "Protocol",
    "PublicSubnet",
    "PublicSubnetAttributes",
    "PublicSubnetProps",
    "RouterType",
    "S3DownloadOptions",
    "SecurityGroup",
    "SecurityGroupImportOptions",
    "SecurityGroupProps",
    "SelectedSubnets",
    "SpotInstanceInterruption",
    "SpotRequestType",
    "SsmParameterImageOptions",
    "Subnet",
    "SubnetAttributes",
    "SubnetConfiguration",
    "SubnetFilter",
    "SubnetNetworkAclAssociation",
    "SubnetNetworkAclAssociationProps",
    "SubnetProps",
    "SubnetSelection",
    "SubnetType",
    "TrafficDirection",
    "TransportProtocol",
    "UserData",
    "Volume",
    "VolumeAttributes",
    "VolumeProps",
    "Vpc",
    "VpcAttributes",
    "VpcEndpoint",
    "VpcEndpointService",
    "VpcEndpointServiceProps",
    "VpcEndpointType",
    "VpcLookupOptions",
    "VpcProps",
    "VpnConnection",
    "VpnConnectionOptions",
    "VpnConnectionProps",
    "VpnConnectionType",
    "VpnGateway",
    "VpnGatewayProps",
    "VpnPort",
    "VpnTunnelOption",
    "WindowsImage",
    "WindowsImageProps",
    "WindowsVersion",
]

publication.publish()
