# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

"""Models for security vulnerability findings."""

from typing import List, Optional, Dict, Annotated
import re
from pydantic import Field, field_validator
from automated_security_helper.models.core import BaseFinding
from automated_security_helper.schemas.data_interchange import SecurityReport


class SecurityVulnerability(BaseFinding):
    """Model representing a security vulnerability finding."""

    vulnerability_type: Annotated[
        str,
        Field(
            description="Type of vulnerability (e.g., secret_exposure, sql_injection)",
        ),
    ] = None
    cwe_id: Annotated[
        Optional[str],
        Field(description="Common Weakness Enumeration ID"),
    ] = None
    cwe_link: Annotated[
        Optional[str],
        Field(description="Link for the CWE description, if available"),
    ] = None
    cvss_score: Annotated[
        Optional[float],
        Field(description="Common Vulnerability Scoring System score"),
    ] = None
    remediation_steps: Annotated[
        List[str],
        Field(description="Steps to remediate the vulnerability"),
    ] = []
    references: Annotated[
        List[str],
        Field(description="Related documentation, articles, etc."),
    ] = []

    @field_validator("cwe_id")
    @classmethod
    def validate_cwe_id(cls, v: Optional[str]) -> Optional[str]:
        """Validate CWE ID format."""
        if v is not None and not re.match(r"^CWE-\d+$", v):
            raise ValueError("CWE ID must be in format 'CWE-<number>'")
        return v

    @field_validator("cvss_score")
    @classmethod
    def validate_cvss_score(cls, v: Optional[float]) -> Optional[float]:
        """Validate CVSS score range."""
        if v is not None and not (0.0 <= v <= 10.0):
            raise ValueError("CVSS score must be between 0.0 and 10.0")
        return v


class SecurityVulnerabilityReport(SecurityReport):
    """A report containing multiple security vulnerabilities."""

    findings: Annotated[
        List[SecurityVulnerability],
        Field(
            default_factory=list, description="List of security vulnerabilities found"
        ),
    ]
    scan_type: Annotated[str, Field(description="Type of security scan")] = (
        "vulnerability"
    )
    risk_metrics: Annotated[
        Dict[str, float],
        Field(
            default_factory=lambda: {
                "total_cvss": 0.0,
                "avg_cvss": 0.0,
                "max_cvss": 0.0,
            },
            description="Risk metrics calculated from vulnerability CVSS scores",
        ),
    ]

    def model_post_init(self, __context) -> None:
        """Post initialization validation and setup."""
        super().model_post_init(__context)
        if not hasattr(self, "name"):
            self.name = "Security Vulnerability Report"
        if not hasattr(self, "risk_metrics"):
            self.risk_metrics = {"total_cvss": 0.0, "avg_cvss": 0.0, "max_cvss": 0.0}
        self.calculate_risk_metrics()

    def calculate_risk_metrics(self) -> None:
        """Calculate risk metrics based on vulnerabilities."""
        if not self.findings:
            self.risk_metrics = {"total_cvss": 0.0, "avg_cvss": 0.0, "max_cvss": 0.0}
            return

        cvss_scores = [v.cvss_score for v in self.findings if v.cvss_score is not None]
        if not cvss_scores:
            self.risk_metrics = {"total_cvss": 0.0, "avg_cvss": 0.0, "max_cvss": 0.0}
            return

        total_cvss = sum(cvss_scores)
        avg_cvss = total_cvss / len(cvss_scores)
        max_cvss = max(cvss_scores)

        self.risk_metrics = {
            "total_cvss": round(total_cvss, 2),
            "avg_cvss": round(avg_cvss, 2),
            "max_cvss": round(max_cvss, 2),
        }

        # Update findings list for SecurityReport base class
        self.findings = self.findings.copy()

        # Update metadata summary stats
        if hasattr(self, "metadata") and hasattr(self.metadata, "summary_stats"):
            self.metadata.summary_stats.update(
                {
                    "total_vulnerabilities": len(self.findings),
                    "critical": len(
                        [v for v in self.findings if v.severity == "CRITICAL"]
                    ),
                    "high": len([v for v in self.findings if v.severity == "HIGH"]),
                    "medium": len([v for v in self.findings if v.severity == "MEDIUM"]),
                    "low": len([v for v in self.findings if v.severity == "LOW"]),
                    "info": len([v for v in self.findings if v.severity == "INFO"]),
                }
            )

    def add_vulnerability(self, vulnerability: SecurityVulnerability) -> None:
        """Add a vulnerability to the report."""
        self.findings.append(vulnerability)

    def get_vulnerabilities_by_severity(
        self, severity: str
    ) -> List[SecurityVulnerability]:
        """Get all vulnerabilities of a specific severity."""
        return [v for v in self.findings if v.severity == severity]

    def get_highest_cvss_score(self) -> Optional[float]:
        """Get the highest CVSS score among all vulnerabilities."""
        scores = [v.cvss_score for v in self.findings if v.cvss_score is not None]
        return max(scores) if scores else None

    def summary(self) -> dict:
        """Generate a summary of the vulnerability report."""
        severity_counts = {}
        total_cvss = 0
        cvss_count = 0

        for vuln in self.findings:
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
            if vuln.cvss_score is not None:
                total_cvss += vuln.cvss_score
                cvss_count += 1

        return {
            "total_vulnerabilities": len(self.findings),
            "severity_distribution": severity_counts,
            "average_cvss_score": total_cvss / cvss_count if cvss_count > 0 else 0,
            "scan_timestamp": self.timestamp,
            "project_name": self.project_name,
        }
